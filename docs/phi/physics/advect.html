<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>phi.physics.advect API documentation</title>
<meta name="description" content="Container for different advection schemes for grids and particles â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>phi.physics.advect</code></h1>
</header>
<section id="section-intro">
<p>Container for different advection schemes for grids and particles.</p>
<p>Examples:</p>
<ul>
<li>semi_lagrangian (grid)</li>
<li>mac_cormack (grid)</li>
<li>runge_kutta_4 (particle)</li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Container for different advection schemes for grids and particles.

Examples:

* semi_lagrangian (grid)
* mac_cormack (grid)
* runge_kutta_4 (particle)
&#34;&#34;&#34;

from phi import math
from phi.field import SampledField, ConstantField, StaggeredGrid, CenteredGrid, Field, PointCloud, extrapolate_valid, Grid
from phi.field._field_math import GridType


def advect(field: Field, velocity: Field, dt: float) -&gt; Field:
    &#34;&#34;&#34;
    Advect `field` along the `velocity` vectors using the default advection method.

    Args:
      field: any built-in Field
      velocity: any Field
      dt: time increment

    Returns:
      Advected field of same type as `field`
    &#34;&#34;&#34;
    if isinstance(field, PointCloud):
        if isinstance(velocity, PointCloud) and velocity.elements == field.elements:
            return points(field, velocity, dt)
        return runge_kutta_4(field, velocity, dt=dt)
    if isinstance(field, ConstantField):
        return field
    if isinstance(field, (CenteredGrid, StaggeredGrid)):
        return semi_lagrangian(field, velocity, dt=dt)
    raise NotImplementedError(field)


def semi_lagrangian(field: GridType, velocity: Field, dt) -&gt; GridType:
    &#34;&#34;&#34;
    Semi-Lagrangian advection with simple backward lookup.
    
    This method samples the `velocity` at the grid points of `field`
    to determine the lookup location for each grid point by walking backwards along the velocity vectors.
    The new values are then determined by sampling `field` at these lookup locations.

    Args:
      field: quantity to be advected, stored on a grid (CenteredGrid or StaggeredGrid)
      velocity: vector field, need not be compatible with with `field`.
      dt: time increment
      field: GridType: 
      velocity: Field: 

    Returns:
      Field with same sample points as `field`

    &#34;&#34;&#34;
    v = velocity.sample_in(field.elements)
    x = field.points - v * dt
    interpolated = field.sample_at(x, reduce_channels=x.shape.non_channel.without(field.shape).names)
    return field.with_(values=interpolated)


def mac_cormack(field: GridType, velocity: Field, dt: float, correction_strength=1.0) -&gt; GridType:
    &#34;&#34;&#34;
    MacCormack advection uses a forward and backward lookup to determine the first-order error of semi-Lagrangian advection.
    It then uses that error estimate to correct the field values.
    To avoid overshoots, the resulting value is bounded by the neighbouring grid cells of the backward lookup.

    Args:
      field: Field to be advected, one of `(CenteredGrid, StaggeredGrid)`
      velocity: Vector field, need not be sampled at same locations as `field`.
      dt: Time increment
      correction_strength: The estimated error is multiplied by this factor before being applied. The case correction_strength=0 equals semi-lagrangian advection. Set lower than 1.0 to avoid oscillations. (Default value = 1.0)

    Returns:
      Advected field of type `type(field)`

    &#34;&#34;&#34;
    v = velocity.sample_in(field.elements)
    x0 = field.points
    x_bwd = x0 - v * dt
    x_fwd = x0 + v * dt
    reduce = x0.shape.non_channel.without(field.shape).names
    # Semi-Lagrangian advection
    field_semi_la = field.with_(values=field.sample_at(x_bwd, reduce_channels=reduce))
    # Inverse semi-Lagrangian advection
    field_inv_semi_la = field.with_(values=field_semi_la.sample_at(x_fwd, reduce_channels=reduce))
    # correction
    new_field = field_semi_la + correction_strength * 0.5 * (field - field_inv_semi_la)
    # Address overshoots
    limits = field.closest_values(x_bwd, reduce_channels=reduce)
    lower_limit = math.min(limits, [f&#39;closest_{dim}&#39; for dim in field.shape.spatial.names])
    upper_limit = math.max(limits, [f&#39;closest_{dim}&#39; for dim in field.shape.spatial.names])
    values_clamped = math.clip(new_field.values, lower_limit, upper_limit)
    return new_field.with_(values=values_clamped)


def runge_kutta_4(cloud: SampledField, velocity: Field, dt: float, accessible: Field = None, occupied: Field = None):
    &#34;&#34;&#34; 
    Lagrangian advection of particles using a fourth-order runge-kutta scheme. If `accessible` and `occupied` are specified,
    the advection uses velocity-dependent extrapolation of `velocity`.
    
    Args:
        cloud: PointCloud holding the particle positions as elements
        velocity: velocity Grid which should get used for advection
        dt: Time step for runge-kutta
        accessible: Boundary conditions for restricting extrapolation to accessible positions
        occupied: Binary Grid indicating particle positions on the grid for extrapolation

    Returns:
        PointCloud with advected particle positions and their corresponding values.
    &#34;&#34;&#34;
    assert isinstance(velocity, Grid), &#39;runge_kutta advection with extrapolation works for Grids only.&#39;

    def extrapolation_helper(elements, t_shift, v_field, mask):
        shift = math.ceil(math.max(math.abs(elements.center - points.center))) - t_shift
        t_shift += shift
        v_field, mask = extrapolate_valid(v_field, mask, int(shift))
        v_field *= accessible
        return v_field, mask, t_shift

    points = cloud.elements
    total_shift = 0
    extrapolate = accessible is not None and occupied is not None

    # --- Sample velocity at intermediate points and adjust velocity-dependent
    # extrapolation to maximum shift of corresponding component ---
    if extrapolate:
        assert isinstance(occupied, type(velocity)), &#39;occupation mask must have same type as velocity.&#39;
        velocity, occupied = extrapolate_valid(velocity, occupied, 2)
        velocity *= accessible
    vel_k1 = velocity.sample_in(points)

    shifted_points = points.shifted(0.5 * dt * vel_k1)
    if extrapolate:
        velocity, occupied, total_shift = extrapolation_helper(shifted_points, total_shift, velocity, occupied)
    vel_k2 = velocity.sample_in(shifted_points)

    shifted_points = points.shifted(0.5 * dt * vel_k2)
    if extrapolate:
        velocity, occupied, total_shift = extrapolation_helper(shifted_points, total_shift, velocity, occupied)
    vel_k3 = velocity.sample_in(shifted_points)

    shifted_points = points.shifted(dt * vel_k3)
    if extrapolate:
        velocity, _, _ = extrapolation_helper(shifted_points, total_shift, velocity, occupied)
    vel_k4 = velocity.sample_in(shifted_points)

    # --- Combine points with RK4 scheme ---
    vel = (1/6.) * (vel_k1 + 2 * (vel_k2 + vel_k3) + vel_k4)
    new_points = points.shifted(dt * vel)
    return cloud.with_(elements=new_points)


def points(field: PointCloud, velocity: PointCloud, dt):
    &#34;&#34;&#34;
    Advects the sample points of a point cloud using a simple Euler step.
    Each point moves by an amount equal to the local velocity times `dt`.

    Args:
      field: point cloud to be advected
      velocity: velocity sampled at the same points as the point cloud
      dt: Euler step time increment
      field: PointCloud: 
      velocity: PointCloud: 

    Returns:
      advected point cloud

    &#34;&#34;&#34;
    assert field.elements == velocity.elements
    new_points = field.elements.shifted(dt * velocity.values)
    return field.with_(elements=new_points)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="phi.physics.advect.advect"><code class="name flex">
<span>def <span class="ident">advect</span></span>(<span>field:Â phi.field._field.Field, velocity:Â phi.field._field.Field, dt:Â float) â€‘>Â phi.field._field.Field</span>
</code></dt>
<dd>
<div class="desc"><p>Advect <code>field</code> along the <code>velocity</code> vectors using the default advection method.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>field</code></strong></dt>
<dd>any built-in Field</dd>
<dt><strong><code>velocity</code></strong></dt>
<dd>any Field</dd>
<dt><strong><code>dt</code></strong></dt>
<dd>time increment</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Advected field of same type as <code>field</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def advect(field: Field, velocity: Field, dt: float) -&gt; Field:
    &#34;&#34;&#34;
    Advect `field` along the `velocity` vectors using the default advection method.

    Args:
      field: any built-in Field
      velocity: any Field
      dt: time increment

    Returns:
      Advected field of same type as `field`
    &#34;&#34;&#34;
    if isinstance(field, PointCloud):
        if isinstance(velocity, PointCloud) and velocity.elements == field.elements:
            return points(field, velocity, dt)
        return runge_kutta_4(field, velocity, dt=dt)
    if isinstance(field, ConstantField):
        return field
    if isinstance(field, (CenteredGrid, StaggeredGrid)):
        return semi_lagrangian(field, velocity, dt=dt)
    raise NotImplementedError(field)</code></pre>
</details>
</dd>
<dt id="phi.physics.advect.mac_cormack"><code class="name flex">
<span>def <span class="ident">mac_cormack</span></span>(<span>field:Â ~GridType, velocity:Â phi.field._field.Field, dt:Â float, correction_strength=1.0) â€‘>Â ~GridType</span>
</code></dt>
<dd>
<div class="desc"><p>MacCormack advection uses a forward and backward lookup to determine the first-order error of semi-Lagrangian advection.
It then uses that error estimate to correct the field values.
To avoid overshoots, the resulting value is bounded by the neighbouring grid cells of the backward lookup.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>field</code></strong></dt>
<dd>Field to be advected, one of <code>(CenteredGrid, StaggeredGrid)</code></dd>
<dt><strong><code>velocity</code></strong></dt>
<dd>Vector field, need not be sampled at same locations as <code>field</code>.</dd>
<dt><strong><code>dt</code></strong></dt>
<dd>Time increment</dd>
<dt><strong><code>correction_strength</code></strong></dt>
<dd>The estimated error is multiplied by this factor before being applied. The case correction_strength=0 equals semi-lagrangian advection. Set lower than 1.0 to avoid oscillations. (Default value = 1.0)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Advected field of type <code>type(field)</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mac_cormack(field: GridType, velocity: Field, dt: float, correction_strength=1.0) -&gt; GridType:
    &#34;&#34;&#34;
    MacCormack advection uses a forward and backward lookup to determine the first-order error of semi-Lagrangian advection.
    It then uses that error estimate to correct the field values.
    To avoid overshoots, the resulting value is bounded by the neighbouring grid cells of the backward lookup.

    Args:
      field: Field to be advected, one of `(CenteredGrid, StaggeredGrid)`
      velocity: Vector field, need not be sampled at same locations as `field`.
      dt: Time increment
      correction_strength: The estimated error is multiplied by this factor before being applied. The case correction_strength=0 equals semi-lagrangian advection. Set lower than 1.0 to avoid oscillations. (Default value = 1.0)

    Returns:
      Advected field of type `type(field)`

    &#34;&#34;&#34;
    v = velocity.sample_in(field.elements)
    x0 = field.points
    x_bwd = x0 - v * dt
    x_fwd = x0 + v * dt
    reduce = x0.shape.non_channel.without(field.shape).names
    # Semi-Lagrangian advection
    field_semi_la = field.with_(values=field.sample_at(x_bwd, reduce_channels=reduce))
    # Inverse semi-Lagrangian advection
    field_inv_semi_la = field.with_(values=field_semi_la.sample_at(x_fwd, reduce_channels=reduce))
    # correction
    new_field = field_semi_la + correction_strength * 0.5 * (field - field_inv_semi_la)
    # Address overshoots
    limits = field.closest_values(x_bwd, reduce_channels=reduce)
    lower_limit = math.min(limits, [f&#39;closest_{dim}&#39; for dim in field.shape.spatial.names])
    upper_limit = math.max(limits, [f&#39;closest_{dim}&#39; for dim in field.shape.spatial.names])
    values_clamped = math.clip(new_field.values, lower_limit, upper_limit)
    return new_field.with_(values=values_clamped)</code></pre>
</details>
</dd>
<dt id="phi.physics.advect.points"><code class="name flex">
<span>def <span class="ident">points</span></span>(<span>field:Â phi.field._point_cloud.PointCloud, velocity:Â phi.field._point_cloud.PointCloud, dt)</span>
</code></dt>
<dd>
<div class="desc"><p>Advects the sample points of a point cloud using a simple Euler step.
Each point moves by an amount equal to the local velocity times <code>dt</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>field</code></strong></dt>
<dd>point cloud to be advected</dd>
<dt><strong><code>velocity</code></strong></dt>
<dd>velocity sampled at the same points as the point cloud</dd>
<dt><strong><code>dt</code></strong></dt>
<dd>Euler step time increment</dd>
<dt><strong><code>field</code></strong></dt>
<dd>PointCloud: </dd>
<dt><strong><code>velocity</code></strong></dt>
<dd>PointCloud: </dd>
</dl>
<h2 id="returns">Returns</h2>
<p>advected point cloud</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def points(field: PointCloud, velocity: PointCloud, dt):
    &#34;&#34;&#34;
    Advects the sample points of a point cloud using a simple Euler step.
    Each point moves by an amount equal to the local velocity times `dt`.

    Args:
      field: point cloud to be advected
      velocity: velocity sampled at the same points as the point cloud
      dt: Euler step time increment
      field: PointCloud: 
      velocity: PointCloud: 

    Returns:
      advected point cloud

    &#34;&#34;&#34;
    assert field.elements == velocity.elements
    new_points = field.elements.shifted(dt * velocity.values)
    return field.with_(elements=new_points)</code></pre>
</details>
</dd>
<dt id="phi.physics.advect.runge_kutta_4"><code class="name flex">
<span>def <span class="ident">runge_kutta_4</span></span>(<span>cloud:Â phi.field._field.SampledField, velocity:Â phi.field._field.Field, dt:Â float, accessible:Â phi.field._field.FieldÂ =Â None, occupied:Â phi.field._field.FieldÂ =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>Lagrangian advection of particles using a fourth-order runge-kutta scheme. If <code>accessible</code> and <code>occupied</code> are specified,
the advection uses velocity-dependent extrapolation of <code>velocity</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cloud</code></strong></dt>
<dd>PointCloud holding the particle positions as elements</dd>
<dt><strong><code>velocity</code></strong></dt>
<dd>velocity Grid which should get used for advection</dd>
<dt><strong><code>dt</code></strong></dt>
<dd>Time step for runge-kutta</dd>
<dt><strong><code>accessible</code></strong></dt>
<dd>Boundary conditions for restricting extrapolation to accessible positions</dd>
<dt><strong><code>occupied</code></strong></dt>
<dd>Binary Grid indicating particle positions on the grid for extrapolation</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>PointCloud with advected particle positions and their corresponding values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def runge_kutta_4(cloud: SampledField, velocity: Field, dt: float, accessible: Field = None, occupied: Field = None):
    &#34;&#34;&#34; 
    Lagrangian advection of particles using a fourth-order runge-kutta scheme. If `accessible` and `occupied` are specified,
    the advection uses velocity-dependent extrapolation of `velocity`.
    
    Args:
        cloud: PointCloud holding the particle positions as elements
        velocity: velocity Grid which should get used for advection
        dt: Time step for runge-kutta
        accessible: Boundary conditions for restricting extrapolation to accessible positions
        occupied: Binary Grid indicating particle positions on the grid for extrapolation

    Returns:
        PointCloud with advected particle positions and their corresponding values.
    &#34;&#34;&#34;
    assert isinstance(velocity, Grid), &#39;runge_kutta advection with extrapolation works for Grids only.&#39;

    def extrapolation_helper(elements, t_shift, v_field, mask):
        shift = math.ceil(math.max(math.abs(elements.center - points.center))) - t_shift
        t_shift += shift
        v_field, mask = extrapolate_valid(v_field, mask, int(shift))
        v_field *= accessible
        return v_field, mask, t_shift

    points = cloud.elements
    total_shift = 0
    extrapolate = accessible is not None and occupied is not None

    # --- Sample velocity at intermediate points and adjust velocity-dependent
    # extrapolation to maximum shift of corresponding component ---
    if extrapolate:
        assert isinstance(occupied, type(velocity)), &#39;occupation mask must have same type as velocity.&#39;
        velocity, occupied = extrapolate_valid(velocity, occupied, 2)
        velocity *= accessible
    vel_k1 = velocity.sample_in(points)

    shifted_points = points.shifted(0.5 * dt * vel_k1)
    if extrapolate:
        velocity, occupied, total_shift = extrapolation_helper(shifted_points, total_shift, velocity, occupied)
    vel_k2 = velocity.sample_in(shifted_points)

    shifted_points = points.shifted(0.5 * dt * vel_k2)
    if extrapolate:
        velocity, occupied, total_shift = extrapolation_helper(shifted_points, total_shift, velocity, occupied)
    vel_k3 = velocity.sample_in(shifted_points)

    shifted_points = points.shifted(dt * vel_k3)
    if extrapolate:
        velocity, _, _ = extrapolation_helper(shifted_points, total_shift, velocity, occupied)
    vel_k4 = velocity.sample_in(shifted_points)

    # --- Combine points with RK4 scheme ---
    vel = (1/6.) * (vel_k1 + 2 * (vel_k2 + vel_k3) + vel_k4)
    new_points = points.shifted(dt * vel)
    return cloud.with_(elements=new_points)</code></pre>
</details>
</dd>
<dt id="phi.physics.advect.semi_lagrangian"><code class="name flex">
<span>def <span class="ident">semi_lagrangian</span></span>(<span>field:Â ~GridType, velocity:Â phi.field._field.Field, dt) â€‘>Â ~GridType</span>
</code></dt>
<dd>
<div class="desc"><p>Semi-Lagrangian advection with simple backward lookup.</p>
<p>This method samples the <code>velocity</code> at the grid points of <code>field</code>
to determine the lookup location for each grid point by walking backwards along the velocity vectors.
The new values are then determined by sampling <code>field</code> at these lookup locations.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>field</code></strong></dt>
<dd>quantity to be advected, stored on a grid (CenteredGrid or StaggeredGrid)</dd>
<dt><strong><code>velocity</code></strong></dt>
<dd>vector field, need not be compatible with with <code>field</code>.</dd>
<dt><strong><code>dt</code></strong></dt>
<dd>time increment</dd>
<dt><strong><code>field</code></strong></dt>
<dd>GridType: </dd>
<dt><strong><code>velocity</code></strong></dt>
<dd>Field: </dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Field with same sample points as <code>field</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def semi_lagrangian(field: GridType, velocity: Field, dt) -&gt; GridType:
    &#34;&#34;&#34;
    Semi-Lagrangian advection with simple backward lookup.
    
    This method samples the `velocity` at the grid points of `field`
    to determine the lookup location for each grid point by walking backwards along the velocity vectors.
    The new values are then determined by sampling `field` at these lookup locations.

    Args:
      field: quantity to be advected, stored on a grid (CenteredGrid or StaggeredGrid)
      velocity: vector field, need not be compatible with with `field`.
      dt: time increment
      field: GridType: 
      velocity: Field: 

    Returns:
      Field with same sample points as `field`

    &#34;&#34;&#34;
    v = velocity.sample_in(field.elements)
    x = field.points - v * dt
    interpolated = field.sample_at(x, reduce_channels=x.shape.non_channel.without(field.shape).names)
    return field.with_(values=interpolated)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="phi.physics" href="index.html">phi.physics</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="phi.physics.advect.advect" href="#phi.physics.advect.advect">advect</a></code></li>
<li><code><a title="phi.physics.advect.mac_cormack" href="#phi.physics.advect.mac_cormack">mac_cormack</a></code></li>
<li><code><a title="phi.physics.advect.points" href="#phi.physics.advect.points">points</a></code></li>
<li><code><a title="phi.physics.advect.runge_kutta_4" href="#phi.physics.advect.runge_kutta_4">runge_kutta_4</a></code></li>
<li><code><a title="phi.physics.advect.semi_lagrangian" href="#phi.physics.advect.semi_lagrangian">semi_lagrangian</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>