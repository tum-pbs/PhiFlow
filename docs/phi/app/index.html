<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>phi.app API documentation</title>
<meta name="description" content="Interactive application development and web interface …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>phi.app</code></h1>
</header>
<section id="section-intro">
<p>Interactive application development and web interface.</p>
<p>See the user interface documentation at <a href="https://tum-pbs.github.io/PhiFlow/Web_Interface.html">https://tum-pbs.github.io/PhiFlow/Web_Interface.html</a></p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Interactive application development and web interface.

See the user interface documentation at https://tum-pbs.github.io/PhiFlow/Web_Interface.html
&#34;&#34;&#34;
from ._value import EditableValue, EditableFloat, EditableInt, EditableBool, EditableString
from ._app import App
from ._viewer import Viewer
from ._display import show, view
from ._matplotlib import plot, animate, plot_scalars

__all__ = [key for key in globals().keys() if not key.startswith(&#39;_&#39;)]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="phi.app.animate"><code class="name flex">
<span>def <span class="ident">animate</span></span>(<span>fields: phi.field._field.SampledField, colorbar=False, figsize=(8, 6), same_scale=True, repeat=True, interval=200, **plt_args) ‑> matplotlib.animation.Animation</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a Matplotlib animation from <code>fields</code>.
<code>fields</code> may be a sequence of frames or a single <code>SampledField</code> instances with a <code>frames</code> dimension.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>fields</code></strong></dt>
<dd><code>SampledField</code> with <code>frames</code> dimension or <code>tuple</code> or <code>list</code> of <code>SampledField</code>.</dd>
<dt><strong><code>colorbar</code></strong></dt>
<dd>Whether to show a color bar</dd>
<dt><strong><code>figsize</code></strong></dt>
<dd>Figure size</dd>
<dt><strong><code>same_scale</code></strong></dt>
<dd>Whether to use the same scale, both temporally and for all sub-figures.</dd>
<dt><strong><code>repeat</code></strong></dt>
<dd>Whether the video should loop.</dd>
<dt><strong><code>interval</code></strong></dt>
<dd>Frame time in milliseconds.</dd>
<dt><strong><code>**plt_args</code></strong></dt>
<dd>Further plotting arguments, see <code><a title="phi.app.plot" href="#phi.app.plot">plot()</a></code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Matplotlib <code>Animation</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def animate(fields: SampledField or tuple or list,
            colorbar=False, figsize=(8, 6), same_scale=True, repeat=True, interval=200, **plt_args) -&gt; animation.Animation:
    &#34;&#34;&#34;
    Creates a Matplotlib animation from `fields`.
    `fields` may be a sequence of frames or a single `SampledField` instances with a `frames` dimension.

    Args:
        fields: `SampledField` with `frames` dimension or `tuple` or `list` of `SampledField`.
        colorbar: Whether to show a color bar
        figsize: Figure size
        same_scale: Whether to use the same scale, both temporally and for all sub-figures.
        repeat: Whether the video should loop.
        interval: Frame time in milliseconds.
        **plt_args: Further plotting arguments, see `plot()`.

    Returns:
        Matplotlib `Animation`
    &#34;&#34;&#34;
    if isinstance(fields, SampledField):
        assert &#39;frames&#39; in fields.shape, &#34;When passing a single Field, it must have a dimension with name &#39;frames&#39;.&#34;
        fields = fields.unstack(&#39;frames&#39;)
    fields = list(fields)
    field = fields[0]
    batch_size, b_values = _batch(field)
    fig, axes = plt.subplots(1, batch_size, figsize=figsize)
    axes = axes if isinstance(axes, np.ndarray) else [axes]

    def func(frame: int):
        field = fields[frame]
        batch_size, b_values = _batch(field)
        for axis in axes:
            axis.clear()
        _plot(field, b_values, axes, batch_size, colorbar, same_scale, **plt_args)

    ani = animation.FuncAnimation(fig, func, init_func=lambda: axes, repeat=repeat, frames=len(fields), interval=interval)
    plt.close(fig)
    return ani</code></pre>
</details>
</dd>
<dt id="phi.app.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>field: phi.field._field.SampledField, title=False, colorbar=False, figsize=(12, 5), same_scale=True, **plt_args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(field: SampledField or tuple or list, title=False, colorbar=False, figsize=(12, 5), same_scale=True, **plt_args):
    if isinstance(field, (tuple, list)):
        field = batch_stack(*field, dim=&#39;fields&#39;)
    batch_size, b_values = _batch(field)
    fig, axes = plt.subplots(1, batch_size, figsize=figsize)
    axes = axes if isinstance(axes, np.ndarray) else [axes]
    if title:
        for b in range(batch_size):
            if isinstance(title, str):
                sub_title = title
            elif title is True:
                sub_title = f&#34;{b} of {field.shape.batch}&#34;
            elif isinstance(title, (tuple, list)):
                sub_title = title[b]
            else:
                sub_title = None
            if sub_title is not None:
                axes[b].set_title(sub_title)
    _plot(field, b_values, axes, batch_size, colorbar, same_scale, **plt_args)
    plt.tight_layout()
    return fig, axes</code></pre>
</details>
</dd>
<dt id="phi.app.plot_scalars"><code class="name flex">
<span>def <span class="ident">plot_scalars</span></span>(<span>scene: str, names: str = None, reduce: str = 'names', smooth=1, smooth_alpha=0.4, figsize=(8, 6), transform: Callable = None, tight_layout=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_scalars(scene: str or tuple or list or Scene or math.Tensor,
                 names: str or tuple or list or math.Tensor = None,
                 reduce: str or tuple or list or math.Shape = &#39;names&#39;,
                 smooth=1,
                 smooth_alpha=0.4,
                 figsize=(8, 6),
                 transform: Callable = None,
                 tight_layout=True):
    scene = Scene.at(scene)
    additional_reduce = ()
    if names is None:
        first_path = next(iter(math.flatten(scene.paths)))
        names = [_str(n) for n in os.listdir(first_path)]
        names = [n[4:-4] for n in names if n.endswith(&#39;.txt&#39;) and n.startswith(&#39;log_&#39;)]
        names = math.wrap(names, &#39;names&#39;)
        additional_reduce = [&#39;names&#39;]
    elif isinstance(names, str):
        names = math.wrap(names)
    elif isinstance(names, (tuple, list)):
        names = math.wrap(names, &#39;names&#39;)
    else:
        assert isinstance(names, math.Tensor), f&#34;Invalid argument &#39;names&#39;: {type(names)}&#34;

    shape = (scene.shape &amp; names.shape)
    batch = shape.without(reduce).without(additional_reduce)

    cycle = list(plt.rcParams[&#39;axes.prop_cycle&#39;].by_key()[&#39;color&#39;])
    fig, axes = plt.subplots(1, batch.volume, figsize=figsize)
    axes = axes if isinstance(axes, numpy.ndarray) else [axes]

    for b, axis in zip(batch.meshgrid(), axes):
        assert isinstance(axis, plt.Axes)
        names_equal = names[b].rank == 0
        paths_equal = scene.paths[b].rank == 0
        if names_equal:
            axis.set_title(display_name(str(names[b])))
        elif paths_equal:
            axis.set_title(os.path.basename(str(scene.paths[b])))

        def single_plot(name, path, i):
            curve = numpy.loadtxt(os.path.join(path, f&#34;log_{name}.txt&#34;))
            name = display_name(name)
            if transform:
                curve = transform(curve)
            if names_equal:
                label = os.path.basename(path)
            elif paths_equal:
                label = name
            else:
                label = f&#34;{os.path.basename(path)} - {name}&#34;
            axis.plot(curve, color=cycle[i], alpha=smooth_alpha, linewidth=1)
            axis.plot(*smooth_uniform_curve(curve, n=smooth), color=cycle[i], linewidth=2, label=label)
            return name

        math.map(single_plot, names[b], scene.paths[b], math.range_tensor(shape.after_gather(b)))
        axis.legend()
    # Final touches
    if tight_layout:
        plt.tight_layout()
    return fig</code></pre>
</details>
</dd>
<dt id="phi.app.show"><code class="name flex">
<span>def <span class="ident">show</span></span>(<span>app: phi.app._app.App = None, play=True, gui: phi.app._display.Gui = None, keep_alive=True, **config)</span>
</code></dt>
<dd>
<div class="desc"><p>Launch the registered user interface (web interface by default).</p>
<p>This method may block until the GUI is closed.</p>
<p>This method prepares the app before showing it. No more fields should be added to the app after this method is invoked.</p>
<p>Also see the user interface documentation at <a href="https://tum-pbs.github.io/PhiFlow/Web_Interface.html">https://tum-pbs.github.io/PhiFlow/Web_Interface.html</a></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>app</code></strong></dt>
<dd>App or None:
(Default value = None)</dd>
<dt><strong><code>play</code></strong></dt>
<dd>If true, invokes <code>App.play()</code>. The default value is False unless "autorun" is passed as a command line argument.</dd>
<dt><strong><code>app</code></strong></dt>
<dd>optional) the application to display. If unspecified, searches the calling script for a subclass of App and instantiates it.</dd>
<dt><strong><code>gui</code></strong></dt>
<dd>(optional) class of GUI to use</dd>
<dt><strong><code>config</code></strong></dt>
<dd>additional GUI configuration parameters.
For a full list of parameters, see <a href="https://tum-pbs.github.io/PhiFlow/Web_Interface.html">https://tum-pbs.github.io/PhiFlow/Web_Interface.html</a></dd>
<dt><strong><code>keep_alive</code></strong></dt>
<dd>Whether the GUI keeps the app alive. If <code>False</code>, the program will exit when the main script is finished.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show(app: App or None = None, play=True, gui: Gui or str = None, keep_alive=True, **config):
    &#34;&#34;&#34;
    Launch the registered user interface (web interface by default).
    
    This method may block until the GUI is closed.
    
    This method prepares the app before showing it. No more fields should be added to the app after this method is invoked.
    
    Also see the user interface documentation at https://tum-pbs.github.io/PhiFlow/Web_Interface.html

    Args:
      app: App or None:  (Default value = None)
      play: If true, invokes `App.play()`. The default value is False unless &#34;autorun&#34; is passed as a command line argument.
      app: optional) the application to display. If unspecified, searches the calling script for a subclass of App and instantiates it.
      gui: (optional) class of GUI to use
      config: additional GUI configuration parameters.
        For a full list of parameters, see https://tum-pbs.github.io/PhiFlow/Web_Interface.html
      keep_alive: Whether the GUI keeps the app alive. If `False`, the program will exit when the main script is finished.
    &#34;&#34;&#34;
    assert isinstance(app, App), f&#34;show() first argument must be an App instance but got {app}&#34;
    app.prepare()
    # --- Setup Gui ---
    gui = default_gui() if gui is None else get_gui(gui)
    gui.configure(config)
    gui.setup(app)
    if play:
        gui.auto_play()
    if gui.asynchronous:
        display_thread = Thread(target=lambda: gui.show(True), name=&#34;ModuleViewer_show&#34;, daemon=not keep_alive)
        display_thread.start()
    else:
        gui.show(True)  # may be blocking call</code></pre>
</details>
</dd>
<dt id="phi.app.view"><code class="name flex">
<span>def <span class="ident">view</span></span>(<span>*fields: str, play: bool = True, gui=None, name: str = None, description: str = None, scene: bool = None, controls=None, keep_alive=True, **config) ‑> phi.app._viewer.Viewer</span>
</code></dt>
<dd>
<div class="desc"><p>Show <code>fields</code> in a graphical user interface.</p>
<p><code>fields</code> may contain instances of <code>Field</code> or variable names of top-level variables (main module or Jupyter notebook).
During loops, e.g. <code><a title="phi.app.view" href="#phi.app.view">view()</a>.range()</code>, the variable status is tracked and the GUI is updated.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*fields</code></strong></dt>
<dd>(Optional) Contents to be displayed. Either variable names or values.
For field instances, all variables referencing the value will be shown.
If not provided, the user namespace is searched for Field variables.</dd>
<dt><strong><code>play</code></strong></dt>
<dd>Whether to immediately start executing loops.</dd>
<dt><strong><code>gui</code></strong></dt>
<dd>(Optional) Name of GUI as <code>str</code> or GUI class.</dd>
<dt><strong><code>name</code></strong></dt>
<dd>Name to display in GUI and use for the output directory if <code>scene=True</code></dd>
<dt><strong><code>framerate</code></strong></dt>
<dd>Target frame rate in Hz. Play will not step faster than the framerate. <code>None</code> for unlimited frame rate.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.app.Viewer" href="#phi.app.Viewer">Viewer</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def view(*fields: str or SampledField,
         play: bool = True,
         gui=None,
         name: str = None,
         description: str = None,
         scene: bool or Scene = None,
         controls=None,
         keep_alive=True,
         **config) -&gt; Viewer:
    &#34;&#34;&#34;
    Show `fields` in a graphical user interface.

    `fields` may contain instances of `Field` or variable names of top-level variables (main module or Jupyter notebook).
    During loops, e.g. `view().range()`, the variable status is tracked and the GUI is updated.

    Args:
        *fields: (Optional) Contents to be displayed. Either variable names or values.
            For field instances, all variables referencing the value will be shown.
            If not provided, the user namespace is searched for Field variables.
        play: Whether to immediately start executing loops.
        gui: (Optional) Name of GUI as `str` or GUI class.
        name: Name to display in GUI and use for the output directory if `scene=True`
        framerate: Target frame rate in Hz. Play will not step faster than the framerate. `None` for unlimited frame rate.

    Returns:
        `Viewer`
    &#34;&#34;&#34;
    user_namespace = default_user_namespace()
    variables = _default_field_variables(user_namespace, fields)
    if scene is None:
        scene = not (&#39;google.colab&#39; in sys.modules or &#39;ipykernel&#39; in sys.modules)
    if scene is False:
        scene = None
    elif scene is True:
        scene = Scene.create(os.path.join(&#34;~&#34;, &#34;phi&#34;, _slugify_filename(name or user_namespace.get_reference())))
    else:
        assert isinstance(scene, Scene)
    name = name or user_namespace.get_title()
    description = description or user_namespace.get_description()
    gui = default_gui() if gui is None else get_gui(gui)
    viewer = create_viewer(user_namespace, variables, name, description, scene, asynchronous=gui.asynchronous, controls=controls)
    show(viewer, play=play, gui=gui, keep_alive=keep_alive, **config)
    return viewer</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="phi.app.App"><code class="flex name class">
<span>class <span class="ident">App</span></span>
<span>(</span><span>name: str = None, subtitle: str = '', scene: phi.field._scene.Scene = None, log_performance=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Main class for defining an application that can be displayed in the user interface.</p>
<p>To display data, call App.add_field().
All fields need to be registered before the app is prepared or shown.</p>
<p>To launch the GUI, call show(app). This calls App.prepare() if the app was not prepared.</p>
<p>See the user interface documentation at <a href="https://tum-pbs.github.io/PhiFlow/Web_Interface.html">https://tum-pbs.github.io/PhiFlow/Web_Interface.html</a></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Display name of the app.</dd>
<dt><strong><code>subtitle</code></strong></dt>
<dd>Description.</dd>
<dt><strong><code>scene</code></strong></dt>
<dd>(Optional) Directory to which data is stored.</dd>
<dt><strong><code>log_performance</code></strong></dt>
<dd>Whether to log the time elapsed during each step as a scalar value.
The values will be written to the app's directory and shown in the user interface.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class App(object):

    def __init__(self,
                 name: str = None,
                 subtitle: str = &#34;&#34;,
                 scene: Scene = None,
                 log_performance=True):
        &#34;&#34;&#34;
        Main class for defining an application that can be displayed in the user interface.

        To display data, call App.add_field().
        All fields need to be registered before the app is prepared or shown.

        To launch the GUI, call show(app). This calls App.prepare() if the app was not prepared.

        See the user interface documentation at https://tum-pbs.github.io/PhiFlow/Web_Interface.html

        Args:
            name: Display name of the app.
            subtitle: Description.
            scene: (Optional) Directory to which data is stored.
            log_performance: Whether to log the time elapsed during each step as a scalar value.
                The values will be written to the app&#39;s directory and shown in the user interface.
        &#34;&#34;&#34;
        self.start_time = time.time()
        &#34;&#34;&#34; Time of creation (`App` constructor invocation) &#34;&#34;&#34;
        self.name = name if name is not None else self.__class__.__name__
        &#34;&#34;&#34; Human-readable name. &#34;&#34;&#34;
        self.subtitle = subtitle
        &#34;&#34;&#34; Description to be displayed. &#34;&#34;&#34;
        self.scene = scene
        &#34;&#34;&#34; Directory to which data and logging information should be written as `Scene` instance. &#34;&#34;&#34;
        self.uses_existing_scene = scene.exist_properties() if scene is not None else False
        self._field_names = []
        self._fields = {}
        self.message = None
        self.steps = 0
        &#34;&#34;&#34; Counts the number of times `step()` has been called. May be set by the user. &#34;&#34;&#34;
        self.time = 0
        &#34;&#34;&#34; Time variable for simulations. Can be set by the user. &#34;&#34;&#34;
        self._invalidation_counter = 0
        self._controls = []
        self._actions = []
        self.prepared = False
        &#34;&#34;&#34; Wheter `prepare()` has been called. &#34;&#34;&#34;
        self.current_action = None
        self._pause = False
        self.pre_step = []  # callback(app)
        self.post_step = []  # callback(app)
        self.world = world
        self.log_performance = log_performance
        self._elapsed = None
        # Message logging
        log_formatter = logging.Formatter(&#34;%(message)s (%(levelname)s), %(asctime)sn\n&#34;)
        root_logger = logging.getLogger()
        root_logger.setLevel(logging.WARNING)
        self.logger = logging.Logger(&#34;app&#34;, logging.DEBUG)
        console_handler = self.console_handler = logging.StreamHandler(sys.stdout)
        console_handler.setFormatter(log_formatter)
        console_handler.setLevel(logging.INFO)
        self.logger.addHandler(console_handler)
        if self.scene is not None:
            if not isfile(self.scene.subpath(&#34;info.log&#34;)):
                log_file = self.log_file = self.scene.subpath(&#34;info.log&#34;)
            else:
                index = 2
                while True:
                    log_file = self.scene.subpath(&#34;info_%d.log&#34; % index)
                    if not isfile(log_file):
                        break
                    else:
                        index += 1
            file_handler = self.file_handler = logging.FileHandler(log_file)
            file_handler.setFormatter(log_formatter)
            self.logger.addHandler(file_handler)
        # Data logging
        self._scalars = {}  # name -&gt; (frame, value)
        self._scalar_streams = {}
        # Initial log message
        if self.scene is not None:
            self.info(&#34;App created. Scene directory is %s&#34; % self.scene.path)

    @property
    def frame(self):
        &#34;&#34;&#34; Alias for `steps`. &#34;&#34;&#34;
        return self.steps

    @property
    def directory(self):
        &#34;&#34;&#34; This directory is automatically created upon `App` creation. Equal to `scene.path`. &#34;&#34;&#34;
        return self.scene.path

    def _progress(self):
        self._pre_step()
        self.step()
        self._post_step()

    def _pre_step(self):
        for obs in self.pre_step:
            obs(self)
        self._step_start_time = time.perf_counter()

    def _post_step(self):
        self._elapsed = time.perf_counter() - self._step_start_time
        if self.log_performance:
            self.log_scalar(&#39;step_time&#39;, self._elapsed)
        self.steps += 1
        self.invalidate()
        for obs in self.post_step:
            obs(self)

    def invalidate(self):
        &#34;&#34;&#34; Causes the user interface to update. &#34;&#34;&#34;
        self._invalidation_counter += 1

    def step(self):
        &#34;&#34;&#34;
        Performs a single step.
        You may override this method to specify what happens when the user presses the buttons `Step` or `Play`.
        
        If a step function has been passed to `App.set_state()`, the state is progressed using that function.
        
        Otherwise, `world.step()` is executed (for phiflow 1 style simulations).
        
        App.steps automatically counts how many steps have been completed.
        If this method is not overridden, `App.time` is additionally increased by `App.dt`.
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;step() must be overridden.&#34;)

    @property
    def fieldnames(self):
        &#34;&#34;&#34; Alphabetical list of field names. See `get_field()`. &#34;&#34;&#34;
        return self._field_names

    def get_field(self, name):
        &#34;&#34;&#34;
        Reads the current value of a field.
        Fields can be added using `add_field()`.

        If a generator function was registered as the field data, this method may invoke the function which may take some time to complete.
        &#34;&#34;&#34;
        if name not in self._fields:
            raise KeyError(f&#34;Field {name} not declared. Available fields are {self._fields.keys()}&#34;)
        return self._fields[name].get(self._invalidation_counter)

    def add_field(self, name: str, value):
        &#34;&#34;&#34;
        Expose data to be displayed in the user interface.
        This method must be called before the user interface is launched, i.e. before `show(app)` or `app.prepare()` are invoked.
        
        `value` must be one of the following
        
        * Field
        * tensor
        * function without arguments returning one of the former. This function will be called each time the interface is updated.

        Args:
          name: unique human-readable name
          value: data to display
        &#34;&#34;&#34;
        assert not self.prepared, &#34;Cannot add fields to a prepared model&#34;
        if isinstance(value, StateProxy):

            def current_state():
                return value.state

            generator = current_state
        elif callable(value):
            generator = value
        else:
            assert isinstance(
                value, (np.ndarray, Field, float, int, math.Tensor)
            ), &#39;Unsupported type for field &#34;%s&#34;: %s&#39; % (name, type(value))

            def get_constant():
                return value

            generator = get_constant
        self._field_names.append(name)
        self._fields[name] = TimeDependentField(name, generator)

    def log_scalar(self, name: str, value: float or math.Tensor):
        &#34;&#34;&#34;
        Adds `value` to the curve `name` at the current step.
        This can be used to log the evolution of scalar quantities or summaries.

        The values are stored in a text file within the scene directory.
        The curves may also be directly viewed in the user interface.

        Args:
            name: Name of the curve. If no such curve exists, a new one is created.
            value: Value to append to the curve, must be a number or `phi.math.Tensor`.
        &#34;&#34;&#34;
        assert isinstance(name, str)
        value = float(math.mean(value))
        if name not in self._scalars:
            self._scalars[name] = []
            if self.scene is not None:
                path = self.scene.subpath(f&#34;log_{name}.txt&#34;)
                self._scalar_streams[name] = open(path, &#34;w&#34;)
        self._scalars[name].append((self.frame, value))
        if self.scene is not None:
            self._scalar_streams[name].write(f&#34;{value}\n&#34;)
            self._scalar_streams[name].flush()

    def log_scalars(self, **values: float or math.Tensor):
        for name, value in values.items():
            self.log_scalar(name, value)

    def get_scalar_curve(self, name) -&gt; tuple:
        frames = np.array([item[0] for item in self._scalars[name]])
        values = np.array([item[1] for item in self._scalars[name]])
        return frames, values

    def get_logged_scalars(self):
        return self._scalars.keys()

    @property
    def actions(self):
        &#34;&#34;&#34;
        List of all custom actions that can be invoked at runtime by the user.
        Actions can be registered using `add_action()` or by defining a method with prefix `action_`.
        &#34;&#34;&#34;
        return self._actions

    def add_action(self, name, methodcall):
        self._actions.append(Action(name, methodcall, name))

    def run_action(self, action):
        message_before = self.message
        action.method()
        self.invalidate()
        message_after = self.message
        if message_before == message_after:
            if self.message is None or self.message == &#34;&#34;:
                self.message = display_name(action.name)
            else:
                self.message += &#34; | &#34; + display_name(action.name)

    @property
    def controls(self):
        return self._controls

    def prepare(self):
        &#34;&#34;&#34;
        Prepares the app to be displayed in a user interface.
        
        This method can only be called once.
        If not invoked manually, it is automatically called before the user interface is launched.
        
        Preparation includes:
        
        * Detecting editable values from member variables that start with &#39;value_&#39;
        * Detecting actions from member functions that start with &#39;action_&#39;
        * Initializing the scene directory with a JSON file and copying related Python source files

        Returns:
            `app`
        &#34;&#34;&#34;
        if self.prepared:
            return
        logging.info(&#34;Gathering model data...&#34;)
        # Controls
        for name in self.__dict__:
            val = getattr(self, name)
            editable_value = None
            if isinstance(val, EditableValue):
                editable_value = val
                setattr(
                    self, name, val.initial_value
                )  # Replace EditableValue with initial value
            elif name.startswith(&#34;value_&#34;):
                value_name = display_name(name[6:])
                dtype = type(val)
                if dtype == bool:
                    editable_value = EditableBool(value_name, val)
                elif isinstance(val, numbers.Integral):  # Int
                    editable_value = EditableInt(value_name, val)
                elif isinstance(val, numbers.Number):  # Float
                    editable_value = EditableFloat(value_name, val)
                elif isinstance(val, str):
                    editable_value = EditableString(value_name, val)
            if editable_value:
                self._controls.append(Control(self, name, editable_value))
        # Actions
        for method_name in dir(self):
            if method_name.startswith(&#34;action_&#34;) and callable(
                getattr(self, method_name)
            ):
                self._actions.append(
                    Action(
                        display_name(method_name[7:]),
                        getattr(self, method_name),
                        method_name,
                    )
                )
        # Scene
        if self.scene is not None:
            self._update_scene_properties()
            source_files_to_save = set()
            for object in [self.__class__]:
                try:
                    source_files_to_save.add(inspect.getabsfile(object))
                except TypeError:
                    pass
            for source_file in source_files_to_save:
                self.scene.copy_src(source_file)
        # End
        self.prepared = True
        return self

    def _update_scene_properties(self):
        if self.uses_existing_scene or self.scene is None:
            return
        try:
            app_name = os.path.basename(inspect.getfile(self.__class__))
            app_path = inspect.getabsfile(self.__class__)
        except TypeError:
            app_name = app_path = &#34;&#34;
        properties = {
            &#34;instigator&#34;: &#34;App&#34;,
            &#34;app&#34;: str(app_name),
            &#34;app_path&#34;: str(app_path),
            &#34;name&#34;: self.name,
            &#34;description&#34;: self.subtitle,
            &#34;all_fields&#34;: self.fieldnames,
            &#34;actions&#34;: [action.name for action in self.actions],
            &#34;controls&#34;: [{control.name: control.value} for control in self.controls],
            &#34;steps&#34;: self.steps,
            &#34;time&#34;: self.time,
            &#34;world&#34;: struct.properties_dict(self.world.state),
        }
        self.scene.properties = properties

    def settings_str(self):
        return &#34;&#34;.join([&#34; &#34; + str(control) for control in self.controls])

    def info(self, message: str):
        &#34;&#34;&#34;
        Update the status message.
        The status message is written to the console and the log file.
        Additionally, it may be displayed by the user interface.

        See `debug()`.

        Args:
            message: Message to display
        &#34;&#34;&#34;
        message = str(message)
        self.message = message
        self.logger.info(message)

    def debug(self, message):
        &#34;&#34;&#34;
        Prints a message to the log file but does not display it.

        See `info()`.

        Args:
            message: Message to log.
        &#34;&#34;&#34;
        logging.info(message)

    def show(self, **config):
        warnings.warn(&#34;Use show(model) instead.&#34;, DeprecationWarning, stacklevel=2)
        from ._display import show

        show(self, **config)

    @property
    def status(self):
        pausing = &#34;/Pausing&#34; if (self._pause and self.current_action) else &#34;&#34;
        action = self.current_action if self.current_action else &#34;Idle&#34;
        message = f&#34; - {self.message}&#34; if self.message else &#34;&#34;
        return f&#34;{action}{pausing} ({self.steps} steps){message}&#34;

    def run_step(self, framerate=None):
        self.current_action = &#34;Running&#34;
        starttime = time.time()
        try:
            self._progress()
            if framerate is not None:
                duration = time.time() - starttime
                rest = 1.0 / framerate - duration
                if rest &gt; 0:
                    self.current_action = &#34;Waiting&#34;
                    time.sleep(rest)
        except Exception as e:
            self.info(
                &#34;Error during %s.step() \n %s: %s&#34;
                % (type(self).__name__, type(e).__name__, e)
            )
            self.logger.exception(e)
        finally:
            self.current_action = None

    def pause(self):
        &#34;&#34;&#34; Causes the `play()` method to stop after finishing the current step. &#34;&#34;&#34;
        self._pause = True

    def is_paused(self):
        return self._pause

    @property
    def running(self):
        &#34;&#34;&#34; Whether `play()` is currently executing. &#34;&#34;&#34;
        return self.current_action is not None

    def benchmark(self, sequence_count):
        self._pause = False
        step_count = 0
        starttime = time.time()
        for i in range(sequence_count):
            self.run_step(framerate=np.inf)
            step_count += 1
            if self._pause:
                break
        time_elapsed = time.time() - starttime
        return step_count, time_elapsed</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li>phi.app._viewer.Viewer</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="phi.app.App.actions"><code class="name">var <span class="ident">actions</span></code></dt>
<dd>
<div class="desc"><p>List of all custom actions that can be invoked at runtime by the user.
Actions can be registered using <code>add_action()</code> or by defining a method with prefix <code>action_</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def actions(self):
    &#34;&#34;&#34;
    List of all custom actions that can be invoked at runtime by the user.
    Actions can be registered using `add_action()` or by defining a method with prefix `action_`.
    &#34;&#34;&#34;
    return self._actions</code></pre>
</details>
</dd>
<dt id="phi.app.App.controls"><code class="name">var <span class="ident">controls</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def controls(self):
    return self._controls</code></pre>
</details>
</dd>
<dt id="phi.app.App.directory"><code class="name">var <span class="ident">directory</span></code></dt>
<dd>
<div class="desc"><p>This directory is automatically created upon <code><a title="phi.app.App" href="#phi.app.App">App</a></code> creation. Equal to <code>scene.path</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def directory(self):
    &#34;&#34;&#34; This directory is automatically created upon `App` creation. Equal to `scene.path`. &#34;&#34;&#34;
    return self.scene.path</code></pre>
</details>
</dd>
<dt id="phi.app.App.fieldnames"><code class="name">var <span class="ident">fieldnames</span></code></dt>
<dd>
<div class="desc"><p>Alphabetical list of field names. See <code>get_field()</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def fieldnames(self):
    &#34;&#34;&#34; Alphabetical list of field names. See `get_field()`. &#34;&#34;&#34;
    return self._field_names</code></pre>
</details>
</dd>
<dt id="phi.app.App.frame"><code class="name">var <span class="ident">frame</span></code></dt>
<dd>
<div class="desc"><p>Alias for <code>steps</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def frame(self):
    &#34;&#34;&#34; Alias for `steps`. &#34;&#34;&#34;
    return self.steps</code></pre>
</details>
</dd>
<dt id="phi.app.App.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>Human-readable name.</p></div>
</dd>
<dt id="phi.app.App.prepared"><code class="name">var <span class="ident">prepared</span></code></dt>
<dd>
<div class="desc"><p>Wheter <code>prepare()</code> has been called.</p></div>
</dd>
<dt id="phi.app.App.running"><code class="name">var <span class="ident">running</span></code></dt>
<dd>
<div class="desc"><p>Whether <code>play()</code> is currently executing.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def running(self):
    &#34;&#34;&#34; Whether `play()` is currently executing. &#34;&#34;&#34;
    return self.current_action is not None</code></pre>
</details>
</dd>
<dt id="phi.app.App.scene"><code class="name">var <span class="ident">scene</span></code></dt>
<dd>
<div class="desc"><p>Directory to which data and logging information should be written as <code>Scene</code> instance.</p></div>
</dd>
<dt id="phi.app.App.start_time"><code class="name">var <span class="ident">start_time</span></code></dt>
<dd>
<div class="desc"><p>Time of creation (<code><a title="phi.app.App" href="#phi.app.App">App</a></code> constructor invocation)</p></div>
</dd>
<dt id="phi.app.App.status"><code class="name">var <span class="ident">status</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def status(self):
    pausing = &#34;/Pausing&#34; if (self._pause and self.current_action) else &#34;&#34;
    action = self.current_action if self.current_action else &#34;Idle&#34;
    message = f&#34; - {self.message}&#34; if self.message else &#34;&#34;
    return f&#34;{action}{pausing} ({self.steps} steps){message}&#34;</code></pre>
</details>
</dd>
<dt id="phi.app.App.steps"><code class="name">var <span class="ident">steps</span></code></dt>
<dd>
<div class="desc"><p>Counts the number of times <code>step()</code> has been called. May be set by the user.</p></div>
</dd>
<dt id="phi.app.App.subtitle"><code class="name">var <span class="ident">subtitle</span></code></dt>
<dd>
<div class="desc"><p>Description to be displayed.</p></div>
</dd>
<dt id="phi.app.App.time"><code class="name">var <span class="ident">time</span></code></dt>
<dd>
<div class="desc"><p>Time variable for simulations. Can be set by the user.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phi.app.App.add_action"><code class="name flex">
<span>def <span class="ident">add_action</span></span>(<span>self, name, methodcall)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_action(self, name, methodcall):
    self._actions.append(Action(name, methodcall, name))</code></pre>
</details>
</dd>
<dt id="phi.app.App.add_field"><code class="name flex">
<span>def <span class="ident">add_field</span></span>(<span>self, name: str, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Expose data to be displayed in the user interface.
This method must be called before the user interface is launched, i.e. before <code><a title="phi.app.show" href="#phi.app.show">show()</a>(app)</code> or <code>app.prepare()</code> are invoked.</p>
<p><code>value</code> must be one of the following</p>
<ul>
<li>Field</li>
<li>tensor</li>
<li>function without arguments returning one of the former. This function will be called each time the interface is updated.</li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>unique human-readable name</dd>
<dt><strong><code>value</code></strong></dt>
<dd>data to display</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_field(self, name: str, value):
    &#34;&#34;&#34;
    Expose data to be displayed in the user interface.
    This method must be called before the user interface is launched, i.e. before `show(app)` or `app.prepare()` are invoked.
    
    `value` must be one of the following
    
    * Field
    * tensor
    * function without arguments returning one of the former. This function will be called each time the interface is updated.

    Args:
      name: unique human-readable name
      value: data to display
    &#34;&#34;&#34;
    assert not self.prepared, &#34;Cannot add fields to a prepared model&#34;
    if isinstance(value, StateProxy):

        def current_state():
            return value.state

        generator = current_state
    elif callable(value):
        generator = value
    else:
        assert isinstance(
            value, (np.ndarray, Field, float, int, math.Tensor)
        ), &#39;Unsupported type for field &#34;%s&#34;: %s&#39; % (name, type(value))

        def get_constant():
            return value

        generator = get_constant
    self._field_names.append(name)
    self._fields[name] = TimeDependentField(name, generator)</code></pre>
</details>
</dd>
<dt id="phi.app.App.benchmark"><code class="name flex">
<span>def <span class="ident">benchmark</span></span>(<span>self, sequence_count)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def benchmark(self, sequence_count):
    self._pause = False
    step_count = 0
    starttime = time.time()
    for i in range(sequence_count):
        self.run_step(framerate=np.inf)
        step_count += 1
        if self._pause:
            break
    time_elapsed = time.time() - starttime
    return step_count, time_elapsed</code></pre>
</details>
</dd>
<dt id="phi.app.App.debug"><code class="name flex">
<span>def <span class="ident">debug</span></span>(<span>self, message)</span>
</code></dt>
<dd>
<div class="desc"><p>Prints a message to the log file but does not display it.</p>
<p>See <code>info()</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong></dt>
<dd>Message to log.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def debug(self, message):
    &#34;&#34;&#34;
    Prints a message to the log file but does not display it.

    See `info()`.

    Args:
        message: Message to log.
    &#34;&#34;&#34;
    logging.info(message)</code></pre>
</details>
</dd>
<dt id="phi.app.App.get_field"><code class="name flex">
<span>def <span class="ident">get_field</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Reads the current value of a field.
Fields can be added using <code>add_field()</code>.</p>
<p>If a generator function was registered as the field data, this method may invoke the function which may take some time to complete.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_field(self, name):
    &#34;&#34;&#34;
    Reads the current value of a field.
    Fields can be added using `add_field()`.

    If a generator function was registered as the field data, this method may invoke the function which may take some time to complete.
    &#34;&#34;&#34;
    if name not in self._fields:
        raise KeyError(f&#34;Field {name} not declared. Available fields are {self._fields.keys()}&#34;)
    return self._fields[name].get(self._invalidation_counter)</code></pre>
</details>
</dd>
<dt id="phi.app.App.get_logged_scalars"><code class="name flex">
<span>def <span class="ident">get_logged_scalars</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_logged_scalars(self):
    return self._scalars.keys()</code></pre>
</details>
</dd>
<dt id="phi.app.App.get_scalar_curve"><code class="name flex">
<span>def <span class="ident">get_scalar_curve</span></span>(<span>self, name) ‑> tuple</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_scalar_curve(self, name) -&gt; tuple:
    frames = np.array([item[0] for item in self._scalars[name]])
    values = np.array([item[1] for item in self._scalars[name]])
    return frames, values</code></pre>
</details>
</dd>
<dt id="phi.app.App.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self, message: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the status message.
The status message is written to the console and the log file.
Additionally, it may be displayed by the user interface.</p>
<p>See <code>debug()</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong></dt>
<dd>Message to display</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self, message: str):
    &#34;&#34;&#34;
    Update the status message.
    The status message is written to the console and the log file.
    Additionally, it may be displayed by the user interface.

    See `debug()`.

    Args:
        message: Message to display
    &#34;&#34;&#34;
    message = str(message)
    self.message = message
    self.logger.info(message)</code></pre>
</details>
</dd>
<dt id="phi.app.App.invalidate"><code class="name flex">
<span>def <span class="ident">invalidate</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Causes the user interface to update.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def invalidate(self):
    &#34;&#34;&#34; Causes the user interface to update. &#34;&#34;&#34;
    self._invalidation_counter += 1</code></pre>
</details>
</dd>
<dt id="phi.app.App.is_paused"><code class="name flex">
<span>def <span class="ident">is_paused</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_paused(self):
    return self._pause</code></pre>
</details>
</dd>
<dt id="phi.app.App.log_scalar"><code class="name flex">
<span>def <span class="ident">log_scalar</span></span>(<span>self, name: str, value: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds <code>value</code> to the curve <code>name</code> at the current step.
This can be used to log the evolution of scalar quantities or summaries.</p>
<p>The values are stored in a text file within the scene directory.
The curves may also be directly viewed in the user interface.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Name of the curve. If no such curve exists, a new one is created.</dd>
<dt><strong><code>value</code></strong></dt>
<dd>Value to append to the curve, must be a number or <code><a title="phi.math.Tensor" href="../math/index.html#phi.math.Tensor">Tensor</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log_scalar(self, name: str, value: float or math.Tensor):
    &#34;&#34;&#34;
    Adds `value` to the curve `name` at the current step.
    This can be used to log the evolution of scalar quantities or summaries.

    The values are stored in a text file within the scene directory.
    The curves may also be directly viewed in the user interface.

    Args:
        name: Name of the curve. If no such curve exists, a new one is created.
        value: Value to append to the curve, must be a number or `phi.math.Tensor`.
    &#34;&#34;&#34;
    assert isinstance(name, str)
    value = float(math.mean(value))
    if name not in self._scalars:
        self._scalars[name] = []
        if self.scene is not None:
            path = self.scene.subpath(f&#34;log_{name}.txt&#34;)
            self._scalar_streams[name] = open(path, &#34;w&#34;)
    self._scalars[name].append((self.frame, value))
    if self.scene is not None:
        self._scalar_streams[name].write(f&#34;{value}\n&#34;)
        self._scalar_streams[name].flush()</code></pre>
</details>
</dd>
<dt id="phi.app.App.log_scalars"><code class="name flex">
<span>def <span class="ident">log_scalars</span></span>(<span>self, **values: float)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log_scalars(self, **values: float or math.Tensor):
    for name, value in values.items():
        self.log_scalar(name, value)</code></pre>
</details>
</dd>
<dt id="phi.app.App.pause"><code class="name flex">
<span>def <span class="ident">pause</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Causes the <code>play()</code> method to stop after finishing the current step.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pause(self):
    &#34;&#34;&#34; Causes the `play()` method to stop after finishing the current step. &#34;&#34;&#34;
    self._pause = True</code></pre>
</details>
</dd>
<dt id="phi.app.App.prepare"><code class="name flex">
<span>def <span class="ident">prepare</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Prepares the app to be displayed in a user interface.</p>
<p>This method can only be called once.
If not invoked manually, it is automatically called before the user interface is launched.</p>
<p>Preparation includes:</p>
<ul>
<li>Detecting editable values from member variables that start with 'value_'</li>
<li>Detecting actions from member functions that start with 'action_'</li>
<li>Initializing the scene directory with a JSON file and copying related Python source files</li>
</ul>
<h2 id="returns">Returns</h2>
<p><code>app</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prepare(self):
    &#34;&#34;&#34;
    Prepares the app to be displayed in a user interface.
    
    This method can only be called once.
    If not invoked manually, it is automatically called before the user interface is launched.
    
    Preparation includes:
    
    * Detecting editable values from member variables that start with &#39;value_&#39;
    * Detecting actions from member functions that start with &#39;action_&#39;
    * Initializing the scene directory with a JSON file and copying related Python source files

    Returns:
        `app`
    &#34;&#34;&#34;
    if self.prepared:
        return
    logging.info(&#34;Gathering model data...&#34;)
    # Controls
    for name in self.__dict__:
        val = getattr(self, name)
        editable_value = None
        if isinstance(val, EditableValue):
            editable_value = val
            setattr(
                self, name, val.initial_value
            )  # Replace EditableValue with initial value
        elif name.startswith(&#34;value_&#34;):
            value_name = display_name(name[6:])
            dtype = type(val)
            if dtype == bool:
                editable_value = EditableBool(value_name, val)
            elif isinstance(val, numbers.Integral):  # Int
                editable_value = EditableInt(value_name, val)
            elif isinstance(val, numbers.Number):  # Float
                editable_value = EditableFloat(value_name, val)
            elif isinstance(val, str):
                editable_value = EditableString(value_name, val)
        if editable_value:
            self._controls.append(Control(self, name, editable_value))
    # Actions
    for method_name in dir(self):
        if method_name.startswith(&#34;action_&#34;) and callable(
            getattr(self, method_name)
        ):
            self._actions.append(
                Action(
                    display_name(method_name[7:]),
                    getattr(self, method_name),
                    method_name,
                )
            )
    # Scene
    if self.scene is not None:
        self._update_scene_properties()
        source_files_to_save = set()
        for object in [self.__class__]:
            try:
                source_files_to_save.add(inspect.getabsfile(object))
            except TypeError:
                pass
        for source_file in source_files_to_save:
            self.scene.copy_src(source_file)
    # End
    self.prepared = True
    return self</code></pre>
</details>
</dd>
<dt id="phi.app.App.run_action"><code class="name flex">
<span>def <span class="ident">run_action</span></span>(<span>self, action)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_action(self, action):
    message_before = self.message
    action.method()
    self.invalidate()
    message_after = self.message
    if message_before == message_after:
        if self.message is None or self.message == &#34;&#34;:
            self.message = display_name(action.name)
        else:
            self.message += &#34; | &#34; + display_name(action.name)</code></pre>
</details>
</dd>
<dt id="phi.app.App.run_step"><code class="name flex">
<span>def <span class="ident">run_step</span></span>(<span>self, framerate=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_step(self, framerate=None):
    self.current_action = &#34;Running&#34;
    starttime = time.time()
    try:
        self._progress()
        if framerate is not None:
            duration = time.time() - starttime
            rest = 1.0 / framerate - duration
            if rest &gt; 0:
                self.current_action = &#34;Waiting&#34;
                time.sleep(rest)
    except Exception as e:
        self.info(
            &#34;Error during %s.step() \n %s: %s&#34;
            % (type(self).__name__, type(e).__name__, e)
        )
        self.logger.exception(e)
    finally:
        self.current_action = None</code></pre>
</details>
</dd>
<dt id="phi.app.App.settings_str"><code class="name flex">
<span>def <span class="ident">settings_str</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def settings_str(self):
    return &#34;&#34;.join([&#34; &#34; + str(control) for control in self.controls])</code></pre>
</details>
</dd>
<dt id="phi.app.App.show"><code class="name flex">
<span>def <span class="ident">show</span></span>(<span>self, **config)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show(self, **config):
    warnings.warn(&#34;Use show(model) instead.&#34;, DeprecationWarning, stacklevel=2)
    from ._display import show

    show(self, **config)</code></pre>
</details>
</dd>
<dt id="phi.app.App.step"><code class="name flex">
<span>def <span class="ident">step</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Performs a single step.
You may override this method to specify what happens when the user presses the buttons <code>Step</code> or <code>Play</code>.</p>
<p>If a step function has been passed to <code>App.set_state()</code>, the state is progressed using that function.</p>
<p>Otherwise, <code>world.step()</code> is executed (for phiflow 1 style simulations).</p>
<p>App.steps automatically counts how many steps have been completed.
If this method is not overridden, <code><a title="phi.app.App.time" href="#phi.app.App.time">App.time</a></code> is additionally increased by <code>App.dt</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step(self):
    &#34;&#34;&#34;
    Performs a single step.
    You may override this method to specify what happens when the user presses the buttons `Step` or `Play`.
    
    If a step function has been passed to `App.set_state()`, the state is progressed using that function.
    
    Otherwise, `world.step()` is executed (for phiflow 1 style simulations).
    
    App.steps automatically counts how many steps have been completed.
    If this method is not overridden, `App.time` is additionally increased by `App.dt`.
    &#34;&#34;&#34;
    raise NotImplementedError(&#34;step() must be overridden.&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="phi.app.EditableBool"><code class="flex name class">
<span>class <span class="ident">EditableBool</span></span>
<span>(</span><span>name, initial_value, category=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Editable values are used to specify controls of an <code><a title="phi.app.App" href="#phi.app.App">App</a></code> that can be manipulated at runtime by the user.
EditableValues only specify the initial value of the control.
During <code><a title="phi.app.App.prepare" href="#phi.app.App.prepare">App.prepare()</a></code>, they are replaced by <code>Control</code> objects that hold the actual value.</p>
<p>This constructor should not be used directly. Instantiate a subclass instead.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Human-readable name to be displayed.</dd>
<dt><strong><code>type</code></strong></dt>
<dd>Type identifier</dd>
<dt>initial_value:</dt>
<dt><strong><code>category</code></strong></dt>
<dd>Used to sort values. Not currently used.</dd>
<dt><strong><code>minmax</code></strong></dt>
<dd>tuple (min, max). Determines the range of allowed values. Determines the maximum expected text length for text fields.</dd>
<dt><strong><code>is_linear</code></strong></dt>
<dd>Whether to use a linear slider where applicable.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EditableBool(EditableValue):

    def __init__(self, name, initial_value, category=None):
        EditableValue.__init__(self, name, &#39;bool&#39;, initial_value, category, (False, True), True)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.app._value.EditableValue</li>
</ul>
</dd>
<dt id="phi.app.EditableFloat"><code class="flex name class">
<span>class <span class="ident">EditableFloat</span></span>
<span>(</span><span>name, initial_value, minmax=None, category=None, log_scale=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Editable values are used to specify controls of an <code><a title="phi.app.App" href="#phi.app.App">App</a></code> that can be manipulated at runtime by the user.
EditableValues only specify the initial value of the control.
During <code><a title="phi.app.App.prepare" href="#phi.app.App.prepare">App.prepare()</a></code>, they are replaced by <code>Control</code> objects that hold the actual value.</p>
<p>This constructor should not be used directly. Instantiate a subclass instead.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Human-readable name to be displayed.</dd>
<dt><strong><code>type</code></strong></dt>
<dd>Type identifier</dd>
<dt>initial_value:</dt>
<dt><strong><code>category</code></strong></dt>
<dd>Used to sort values. Not currently used.</dd>
<dt><strong><code>minmax</code></strong></dt>
<dd>tuple (min, max). Determines the range of allowed values. Determines the maximum expected text length for text fields.</dd>
<dt><strong><code>is_linear</code></strong></dt>
<dd>Whether to use a linear slider where applicable.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EditableFloat(EditableValue):

    def __init__(self, name, initial_value, minmax=None, category=None, log_scale=None):
        if minmax is not None:
            assert len(minmax) == 2, &#39;minmax must be pair (min, max)&#39;

        if log_scale is None:
            if minmax is None:
                log_scale = True
            else:
                log_scale = minmax[1] / float(minmax[0]) &gt; 10

        if not minmax:
            if log_scale:
                magn = log10(initial_value)
                minmax = (10.0**(magn - 3.2), 10.0**(magn + 2.2))
            else:
                if initial_value == 0.0:
                    minmax = (-10.0, 10.0)
                elif initial_value &gt; 0:
                    minmax = (0., 4. * initial_value)
                else:
                    minmax = (2. * initial_value, -2. * initial_value)
        else:
            minmax = (float(minmax[0]), float(minmax[1]))
        EditableValue.__init__(self, name, &#39;float&#39;, initial_value, category, minmax, not log_scale)

    @property
    def use_log_scale(self):
        return not self.is_linear</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.app._value.EditableValue</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="phi.app.EditableFloat.use_log_scale"><code class="name">var <span class="ident">use_log_scale</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def use_log_scale(self):
    return not self.is_linear</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="phi.app.EditableInt"><code class="flex name class">
<span>class <span class="ident">EditableInt</span></span>
<span>(</span><span>name, initial_value, minmax=None, category=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Editable values are used to specify controls of an <code><a title="phi.app.App" href="#phi.app.App">App</a></code> that can be manipulated at runtime by the user.
EditableValues only specify the initial value of the control.
During <code><a title="phi.app.App.prepare" href="#phi.app.App.prepare">App.prepare()</a></code>, they are replaced by <code>Control</code> objects that hold the actual value.</p>
<p>This constructor should not be used directly. Instantiate a subclass instead.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Human-readable name to be displayed.</dd>
<dt><strong><code>type</code></strong></dt>
<dd>Type identifier</dd>
<dt>initial_value:</dt>
<dt><strong><code>category</code></strong></dt>
<dd>Used to sort values. Not currently used.</dd>
<dt><strong><code>minmax</code></strong></dt>
<dd>tuple (min, max). Determines the range of allowed values. Determines the maximum expected text length for text fields.</dd>
<dt><strong><code>is_linear</code></strong></dt>
<dd>Whether to use a linear slider where applicable.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EditableInt(EditableValue):

    def __init__(self, name, initial_value, minmax=None, category=None):
        if not minmax:
            if initial_value == 0:
                minmax = (-10, 10)
            elif initial_value &gt; 0:
                minmax = (0, 4 * initial_value)
            else:
                minmax = (2 * initial_value, -2 * initial_value)
        EditableValue.__init__(self, name, &#39;int&#39;, initial_value, category, minmax, True)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.app._value.EditableValue</li>
</ul>
</dd>
<dt id="phi.app.EditableString"><code class="flex name class">
<span>class <span class="ident">EditableString</span></span>
<span>(</span><span>name, initial_value, category=None, rows=20)</span>
</code></dt>
<dd>
<div class="desc"><p>Editable values are used to specify controls of an <code><a title="phi.app.App" href="#phi.app.App">App</a></code> that can be manipulated at runtime by the user.
EditableValues only specify the initial value of the control.
During <code><a title="phi.app.App.prepare" href="#phi.app.App.prepare">App.prepare()</a></code>, they are replaced by <code>Control</code> objects that hold the actual value.</p>
<p>This constructor should not be used directly. Instantiate a subclass instead.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Human-readable name to be displayed.</dd>
<dt><strong><code>type</code></strong></dt>
<dd>Type identifier</dd>
<dt>initial_value:</dt>
<dt><strong><code>category</code></strong></dt>
<dd>Used to sort values. Not currently used.</dd>
<dt><strong><code>minmax</code></strong></dt>
<dd>tuple (min, max). Determines the range of allowed values. Determines the maximum expected text length for text fields.</dd>
<dt><strong><code>is_linear</code></strong></dt>
<dd>Whether to use a linear slider where applicable.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EditableString(EditableValue):

    def __init__(self, name, initial_value, category=None, rows=20):
        EditableValue.__init__(self, name, &#39;text&#39;, initial_value, category, (&#39;&#39;, &#39;A&#39; * rows), True)

    @property
    def rows(self):
        return len(self.max_value)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.app._value.EditableValue</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="phi.app.EditableString.rows"><code class="name">var <span class="ident">rows</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def rows(self):
    return len(self.max_value)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="phi.app.EditableValue"><code class="flex name class">
<span>class <span class="ident">EditableValue</span></span>
<span>(</span><span>name: str, type: str, initial_value, category: str, minmax, is_linear)</span>
</code></dt>
<dd>
<div class="desc"><p>Editable values are used to specify controls of an <code><a title="phi.app.App" href="#phi.app.App">App</a></code> that can be manipulated at runtime by the user.
EditableValues only specify the initial value of the control.
During <code><a title="phi.app.App.prepare" href="#phi.app.App.prepare">App.prepare()</a></code>, they are replaced by <code>Control</code> objects that hold the actual value.</p>
<p>This constructor should not be used directly. Instantiate a subclass instead.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Human-readable name to be displayed.</dd>
<dt><strong><code>type</code></strong></dt>
<dd>Type identifier</dd>
<dt>initial_value:</dt>
<dt><strong><code>category</code></strong></dt>
<dd>Used to sort values. Not currently used.</dd>
<dt><strong><code>minmax</code></strong></dt>
<dd>tuple (min, max). Determines the range of allowed values. Determines the maximum expected text length for text fields.</dd>
<dt><strong><code>is_linear</code></strong></dt>
<dd>Whether to use a linear slider where applicable.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EditableValue(object):
    &#34;&#34;&#34;
    Editable values are used to specify controls of an `App` that can be manipulated at runtime by the user.
    EditableValues only specify the initial value of the control.
    During `App.prepare()`, they are replaced by `Control` objects that hold the actual value.
    &#34;&#34;&#34;

    def __init__(self, name: str, type: str, initial_value, category: str, minmax, is_linear):
        &#34;&#34;&#34;
        This constructor should not be used directly. Instantiate a subclass instead.

        Args:
            name: Human-readable name to be displayed.
            type: Type identifier
            initial_value:
            category: Used to sort values. Not currently used.
            minmax: tuple (min, max). Determines the range of allowed values. Determines the maximum expected text length for text fields.
            is_linear: Whether to use a linear slider where applicable.
        &#34;&#34;&#34;
        self.name = name
        &#34;&#34;&#34; Human-readable name to be displayed. &#34;&#34;&#34;
        self.type = type
        &#34;&#34;&#34; Type identifier: &#39;int&#39;, &#39;float&#39;, &#39;bool&#39;, &#39;text&#39;. &#34;&#34;&#34;
        self.initial_value = initial_value
        &#34;&#34;&#34; Set manually or value of the variable when `App.prepare()` was called. &#34;&#34;&#34;
        self.category = category
        &#34;&#34;&#34; Used to sort values. Not currently used. &#34;&#34;&#34;
        self.minmax = minmax
        self.is_linear = is_linear
        &#34;&#34;&#34; Whether to use a linear slider where applicable. &#34;&#34;&#34;

    @property
    def min_value(self):
        &#34;&#34;&#34; Determines the range of allowed values. &#34;&#34;&#34;
        return self.minmax[0]

    @property
    def max_value(self):
        &#34;&#34;&#34; Determines the range of allowed values. Determines the maximum expected text length for text fields. &#34;&#34;&#34;
        return self.minmax[1]

    @staticmethod
    def value(value_or_editable_value):
        &#34;&#34;&#34;
        Retrieves the initial value if the argument is an `EditableValue`, else returns the given value.
        This is useful for consistently accessing an `App` variable before and after `prepare()` is called.
        &#34;&#34;&#34;
        if isinstance(value_or_editable_value, EditableValue):
            return value_or_editable_value.initial_value
        else:
            return value_or_editable_value</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li>phi.app._value.EditableBool</li>
<li>phi.app._value.EditableFloat</li>
<li>phi.app._value.EditableInt</li>
<li>phi.app._value.EditableString</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="phi.app.EditableValue.value"><code class="name flex">
<span>def <span class="ident">value</span></span>(<span>value_or_editable_value)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves the initial value if the argument is an <code><a title="phi.app.EditableValue" href="#phi.app.EditableValue">EditableValue</a></code>, else returns the given value.
This is useful for consistently accessing an <code><a title="phi.app.App" href="#phi.app.App">App</a></code> variable before and after <code>prepare()</code> is called.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def value(value_or_editable_value):
    &#34;&#34;&#34;
    Retrieves the initial value if the argument is an `EditableValue`, else returns the given value.
    This is useful for consistently accessing an `App` variable before and after `prepare()` is called.
    &#34;&#34;&#34;
    if isinstance(value_or_editable_value, EditableValue):
        return value_or_editable_value.initial_value
    else:
        return value_or_editable_value</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="phi.app.EditableValue.category"><code class="name">var <span class="ident">category</span></code></dt>
<dd>
<div class="desc"><p>Used to sort values. Not currently used.</p></div>
</dd>
<dt id="phi.app.EditableValue.initial_value"><code class="name">var <span class="ident">initial_value</span></code></dt>
<dd>
<div class="desc"><p>Set manually or value of the variable when <code><a title="phi.app.App.prepare" href="#phi.app.App.prepare">App.prepare()</a></code> was called.</p></div>
</dd>
<dt id="phi.app.EditableValue.is_linear"><code class="name">var <span class="ident">is_linear</span></code></dt>
<dd>
<div class="desc"><p>Whether to use a linear slider where applicable.</p></div>
</dd>
<dt id="phi.app.EditableValue.max_value"><code class="name">var <span class="ident">max_value</span></code></dt>
<dd>
<div class="desc"><p>Determines the range of allowed values. Determines the maximum expected text length for text fields.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def max_value(self):
    &#34;&#34;&#34; Determines the range of allowed values. Determines the maximum expected text length for text fields. &#34;&#34;&#34;
    return self.minmax[1]</code></pre>
</details>
</dd>
<dt id="phi.app.EditableValue.min_value"><code class="name">var <span class="ident">min_value</span></code></dt>
<dd>
<div class="desc"><p>Determines the range of allowed values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def min_value(self):
    &#34;&#34;&#34; Determines the range of allowed values. &#34;&#34;&#34;
    return self.minmax[0]</code></pre>
</details>
</dd>
<dt id="phi.app.EditableValue.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>Human-readable name to be displayed.</p></div>
</dd>
<dt id="phi.app.EditableValue.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<div class="desc"><p>Type identifier: 'int', 'float', 'bool', 'text'.</p></div>
</dd>
</dl>
</dd>
<dt id="phi.app.Viewer"><code class="flex name class">
<span>class <span class="ident">Viewer</span></span>
<span>(</span><span>namespace: phi.app._user_namespace.UserNamespace, fields: dict, name: str, subtitle: str, scene: phi.field._scene.Scene, log_performance: bool)</span>
</code></dt>
<dd>
<div class="desc"><p>Launches the user interface to display the contents of the calling Python script or notebook.</p>
<p>Name and subtitle of the App may be specified in the module docstring (string before imports).
The first line is interpreted as the name, the rest as the subtitle.
If not specified, a generic name and description is chosen.</p>
<p>Use ModuleViewer.range() as a for-loop iteratable to control the loop execution from within the GUI.</p>
<p>Also see the user interface documentation at <a href="https://tum-pbs.github.io/PhiFlow/Web_Interface.html">https://tum-pbs.github.io/PhiFlow/Web_Interface.html</a></p>
<p>Main class for defining an application that can be displayed in the user interface.</p>
<p>To display data, call App.add_field().
All fields need to be registered before the app is prepared or shown.</p>
<p>To launch the GUI, call show(app). This calls App.prepare() if the app was not prepared.</p>
<p>See the user interface documentation at <a href="https://tum-pbs.github.io/PhiFlow/Web_Interface.html">https://tum-pbs.github.io/PhiFlow/Web_Interface.html</a></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Display name of the app.</dd>
<dt><strong><code>subtitle</code></strong></dt>
<dd>Description.</dd>
<dt><strong><code>scene</code></strong></dt>
<dd>(Optional) Directory to which data is stored.</dd>
<dt><strong><code>log_performance</code></strong></dt>
<dd>Whether to log the time elapsed during each step as a scalar value.
The values will be written to the app's directory and shown in the user interface.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Viewer(App):
    &#34;&#34;&#34;
    Launches the user interface to display the contents of the calling Python script or notebook.

    Name and subtitle of the App may be specified in the module docstring (string before imports).
    The first line is interpreted as the name, the rest as the subtitle.
    If not specified, a generic name and description is chosen.

    Use ModuleViewer.range() as a for-loop iteratable to control the loop execution from within the GUI.

    Also see the user interface documentation at https://tum-pbs.github.io/PhiFlow/Web_Interface.html
    &#34;&#34;&#34;

    def __init__(self,
                 namespace: UserNamespace,
                 fields: dict,
                 name: str,
                 subtitle: str,
                 scene: Scene,
                 log_performance: bool,
                 ):
        App.__init__(self, name, subtitle, scene=scene, log_performance=log_performance)
        self.initial_field_values = fields
        self.namespace = namespace
        self.on_loop_start = []
        self.on_loop_exit = []
        for name in fields.keys():
            self.add_field(name, lambda n=name: self.namespace.get_variable(n))
        self.add_action(&#34;Reset&#34;, lambda: self.reset())
        self.rec = None

    def range(self, *args, warmup=0, **rec_dim):
        &#34;&#34;&#34;
        Similarly to `range()`, returns a generator that can be used in a `for` loop.

        ```python
        for step in ModuleViewer().range(100):
            print(f&#39;Running step {step}&#39;)
        ```

        However, `Viewer.range()` enables controlling the flow via the user interface.
        Each element returned by the generator waits for `ModuleViewer.step()` to be invoked once.

        Note that `step` is always equal to `ModuleViewer.step`.

        This method can be invoked multiple times.
        However, do not call this method while one `range` is still active.

        Args:
            *args: No arguments for infinite loop,
                `(stop: int)` to set number of iterations,
                `(start: int, stop: int)` to additionally set initial value of `step`.
            warmup: Number of uncounted loop iterations to perform before `step()` is invoked for the first time.
            **rec_dim: Can be used instead of `*args` to record values along this batch dimension.
                The recorded values can be accessed as `Viewer.rec.&lt;name&gt;` or `Viewer.rec[&#39;&lt;name&gt;&#39;]`.

        Returns:
            generator yielding `ModuleViewer.step`
        &#34;&#34;&#34;
        for _ in range(warmup):
            yield self.steps
            self.invalidate()

        for obs in self.on_loop_start:
            obs(self)

        if rec_dim:
            assert len(rec_dim) == 1, f&#34;Only one rec_dim allowed but got {rec_dim}&#34;
            assert not args, f&#34;No positional arguments are allowed when a rec_dim is specified. {rec_dim}&#34;
            rec_dim_name = next(iter(rec_dim.keys()))
            size = rec_dim[rec_dim_name]
            assert isinstance(size, int)
            self.rec = Record(rec_dim_name)
            self.rec.append(self.initial_field_values, warn_missing=False)
            args = [size]

        if len(args) == 0:
            step_source = itertools.count(start=1)
        elif len(args) == 1:
            step_source = range(args[0])
        elif len(args) == 2:
            step_source = range(args[0], args[1])
        else:
            raise ValueError(args)

        try:
            for step in step_source:
                self.steps = step
                self._pre_step()
                yield step
                self._post_step()
                if rec_dim:
                    self.rec.append({name: self.get_field(name) for name in self.fieldnames})
        finally:
            for obs in self.on_loop_exit:
                obs(self)

    def step(self):
        &#34;&#34;&#34; Has no effect. The real step is a loop iteration. See `Viewer.range()`. &#34;&#34;&#34;
        pass

    def reset(self, reset_steps=True):
        for name, value in self.initial_field_values.items():
            self.namespace.set_variable(name, value)
        if reset_steps:
            self.steps = 0</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.app._app.App</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>phi.app._viewer.AsyncViewer</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="phi.app.Viewer.range"><code class="name flex">
<span>def <span class="ident">range</span></span>(<span>self, *args, warmup=0, **rec_dim)</span>
</code></dt>
<dd>
<div class="desc"><p>Similarly to <code>range()</code>, returns a generator that can be used in a <code>for</code> loop.</p>
<pre><code class="language-python">for step in ModuleViewer().range(100):
    print(f'Running step {step}')
</code></pre>
<p>However, <code><a title="phi.app.Viewer.range" href="#phi.app.Viewer.range">Viewer.range()</a></code> enables controlling the flow via the user interface.
Each element returned by the generator waits for <code>ModuleViewer.step()</code> to be invoked once.</p>
<p>Note that <code>step</code> is always equal to <code>ModuleViewer.step</code>.</p>
<p>This method can be invoked multiple times.
However, do not call this method while one <code>range</code> is still active.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*args</code></strong></dt>
<dd>No arguments for infinite loop,
<code>(stop: int)</code> to set number of iterations,
<code>(start: int, stop: int)</code> to additionally set initial value of <code>step</code>.</dd>
<dt><strong><code>warmup</code></strong></dt>
<dd>Number of uncounted loop iterations to perform before <code>step()</code> is invoked for the first time.</dd>
<dt><strong><code>**rec_dim</code></strong></dt>
<dd>Can be used instead of <code>*args</code> to record values along this batch dimension.
The recorded values can be accessed as <code>Viewer.rec.&lt;name&gt;</code> or <code>Viewer.rec['&lt;name&gt;']</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>generator yielding <code>ModuleViewer.step</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def range(self, *args, warmup=0, **rec_dim):
    &#34;&#34;&#34;
    Similarly to `range()`, returns a generator that can be used in a `for` loop.

    ```python
    for step in ModuleViewer().range(100):
        print(f&#39;Running step {step}&#39;)
    ```

    However, `Viewer.range()` enables controlling the flow via the user interface.
    Each element returned by the generator waits for `ModuleViewer.step()` to be invoked once.

    Note that `step` is always equal to `ModuleViewer.step`.

    This method can be invoked multiple times.
    However, do not call this method while one `range` is still active.

    Args:
        *args: No arguments for infinite loop,
            `(stop: int)` to set number of iterations,
            `(start: int, stop: int)` to additionally set initial value of `step`.
        warmup: Number of uncounted loop iterations to perform before `step()` is invoked for the first time.
        **rec_dim: Can be used instead of `*args` to record values along this batch dimension.
            The recorded values can be accessed as `Viewer.rec.&lt;name&gt;` or `Viewer.rec[&#39;&lt;name&gt;&#39;]`.

    Returns:
        generator yielding `ModuleViewer.step`
    &#34;&#34;&#34;
    for _ in range(warmup):
        yield self.steps
        self.invalidate()

    for obs in self.on_loop_start:
        obs(self)

    if rec_dim:
        assert len(rec_dim) == 1, f&#34;Only one rec_dim allowed but got {rec_dim}&#34;
        assert not args, f&#34;No positional arguments are allowed when a rec_dim is specified. {rec_dim}&#34;
        rec_dim_name = next(iter(rec_dim.keys()))
        size = rec_dim[rec_dim_name]
        assert isinstance(size, int)
        self.rec = Record(rec_dim_name)
        self.rec.append(self.initial_field_values, warn_missing=False)
        args = [size]

    if len(args) == 0:
        step_source = itertools.count(start=1)
    elif len(args) == 1:
        step_source = range(args[0])
    elif len(args) == 2:
        step_source = range(args[0], args[1])
    else:
        raise ValueError(args)

    try:
        for step in step_source:
            self.steps = step
            self._pre_step()
            yield step
            self._post_step()
            if rec_dim:
                self.rec.append({name: self.get_field(name) for name in self.fieldnames})
    finally:
        for obs in self.on_loop_exit:
            obs(self)</code></pre>
</details>
</dd>
<dt id="phi.app.Viewer.restore_initial_field_values"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self, reset_steps=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self, reset_steps=True):
    for name, value in self.initial_field_values.items():
        self.namespace.set_variable(name, value)
    if reset_steps:
        self.steps = 0</code></pre>
</details>
</dd>
<dt id="phi.app.Viewer.step"><code class="name flex">
<span>def <span class="ident">step</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Has no effect. The real step is a loop iteration. See <code><a title="phi.app.Viewer.range" href="#phi.app.Viewer.range">Viewer.range()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step(self):
    &#34;&#34;&#34; Has no effect. The real step is a loop iteration. See `Viewer.range()`. &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="phi" href="../index.html">phi</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="phi.app.animate" href="#phi.app.animate">animate</a></code></li>
<li><code><a title="phi.app.plot" href="#phi.app.plot">plot</a></code></li>
<li><code><a title="phi.app.plot_scalars" href="#phi.app.plot_scalars">plot_scalars</a></code></li>
<li><code><a title="phi.app.show" href="#phi.app.show">show</a></code></li>
<li><code><a title="phi.app.view" href="#phi.app.view">view</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="phi.app.App" href="#phi.app.App">App</a></code></h4>
<ul class="two-column">
<li><code><a title="phi.app.App.actions" href="#phi.app.App.actions">actions</a></code></li>
<li><code><a title="phi.app.App.add_action" href="#phi.app.App.add_action">add_action</a></code></li>
<li><code><a title="phi.app.App.add_field" href="#phi.app.App.add_field">add_field</a></code></li>
<li><code><a title="phi.app.App.benchmark" href="#phi.app.App.benchmark">benchmark</a></code></li>
<li><code><a title="phi.app.App.controls" href="#phi.app.App.controls">controls</a></code></li>
<li><code><a title="phi.app.App.debug" href="#phi.app.App.debug">debug</a></code></li>
<li><code><a title="phi.app.App.directory" href="#phi.app.App.directory">directory</a></code></li>
<li><code><a title="phi.app.App.fieldnames" href="#phi.app.App.fieldnames">fieldnames</a></code></li>
<li><code><a title="phi.app.App.frame" href="#phi.app.App.frame">frame</a></code></li>
<li><code><a title="phi.app.App.get_field" href="#phi.app.App.get_field">get_field</a></code></li>
<li><code><a title="phi.app.App.get_logged_scalars" href="#phi.app.App.get_logged_scalars">get_logged_scalars</a></code></li>
<li><code><a title="phi.app.App.get_scalar_curve" href="#phi.app.App.get_scalar_curve">get_scalar_curve</a></code></li>
<li><code><a title="phi.app.App.info" href="#phi.app.App.info">info</a></code></li>
<li><code><a title="phi.app.App.invalidate" href="#phi.app.App.invalidate">invalidate</a></code></li>
<li><code><a title="phi.app.App.is_paused" href="#phi.app.App.is_paused">is_paused</a></code></li>
<li><code><a title="phi.app.App.log_scalar" href="#phi.app.App.log_scalar">log_scalar</a></code></li>
<li><code><a title="phi.app.App.log_scalars" href="#phi.app.App.log_scalars">log_scalars</a></code></li>
<li><code><a title="phi.app.App.name" href="#phi.app.App.name">name</a></code></li>
<li><code><a title="phi.app.App.pause" href="#phi.app.App.pause">pause</a></code></li>
<li><code><a title="phi.app.App.prepare" href="#phi.app.App.prepare">prepare</a></code></li>
<li><code><a title="phi.app.App.prepared" href="#phi.app.App.prepared">prepared</a></code></li>
<li><code><a title="phi.app.App.run_action" href="#phi.app.App.run_action">run_action</a></code></li>
<li><code><a title="phi.app.App.run_step" href="#phi.app.App.run_step">run_step</a></code></li>
<li><code><a title="phi.app.App.running" href="#phi.app.App.running">running</a></code></li>
<li><code><a title="phi.app.App.scene" href="#phi.app.App.scene">scene</a></code></li>
<li><code><a title="phi.app.App.settings_str" href="#phi.app.App.settings_str">settings_str</a></code></li>
<li><code><a title="phi.app.App.show" href="#phi.app.App.show">show</a></code></li>
<li><code><a title="phi.app.App.start_time" href="#phi.app.App.start_time">start_time</a></code></li>
<li><code><a title="phi.app.App.status" href="#phi.app.App.status">status</a></code></li>
<li><code><a title="phi.app.App.step" href="#phi.app.App.step">step</a></code></li>
<li><code><a title="phi.app.App.steps" href="#phi.app.App.steps">steps</a></code></li>
<li><code><a title="phi.app.App.subtitle" href="#phi.app.App.subtitle">subtitle</a></code></li>
<li><code><a title="phi.app.App.time" href="#phi.app.App.time">time</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.app.EditableBool" href="#phi.app.EditableBool">EditableBool</a></code></h4>
</li>
<li>
<h4><code><a title="phi.app.EditableFloat" href="#phi.app.EditableFloat">EditableFloat</a></code></h4>
<ul class="">
<li><code><a title="phi.app.EditableFloat.use_log_scale" href="#phi.app.EditableFloat.use_log_scale">use_log_scale</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.app.EditableInt" href="#phi.app.EditableInt">EditableInt</a></code></h4>
</li>
<li>
<h4><code><a title="phi.app.EditableString" href="#phi.app.EditableString">EditableString</a></code></h4>
<ul class="">
<li><code><a title="phi.app.EditableString.rows" href="#phi.app.EditableString.rows">rows</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.app.EditableValue" href="#phi.app.EditableValue">EditableValue</a></code></h4>
<ul class="two-column">
<li><code><a title="phi.app.EditableValue.category" href="#phi.app.EditableValue.category">category</a></code></li>
<li><code><a title="phi.app.EditableValue.initial_value" href="#phi.app.EditableValue.initial_value">initial_value</a></code></li>
<li><code><a title="phi.app.EditableValue.is_linear" href="#phi.app.EditableValue.is_linear">is_linear</a></code></li>
<li><code><a title="phi.app.EditableValue.max_value" href="#phi.app.EditableValue.max_value">max_value</a></code></li>
<li><code><a title="phi.app.EditableValue.min_value" href="#phi.app.EditableValue.min_value">min_value</a></code></li>
<li><code><a title="phi.app.EditableValue.name" href="#phi.app.EditableValue.name">name</a></code></li>
<li><code><a title="phi.app.EditableValue.type" href="#phi.app.EditableValue.type">type</a></code></li>
<li><code><a title="phi.app.EditableValue.value" href="#phi.app.EditableValue.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.app.Viewer" href="#phi.app.Viewer">Viewer</a></code></h4>
<ul class="">
<li><code><a title="phi.app.Viewer.range" href="#phi.app.Viewer.range">range</a></code></li>
<li><code><a title="phi.app.Viewer.reset" href="#phi.app.Viewer.restore_initial_field_values">reset</a></code></li>
<li><code><a title="phi.app.Viewer.step" href="#phi.app.Viewer.step">step</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>