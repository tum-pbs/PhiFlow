<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>phi.field API documentation</title>
<meta name="description" content="The fields module provides a number of data structures and functions to represent continuous, spatially varying data â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>phi.field</code></h1>
</header>
<section id="section-intro">
<p>The fields module provides a number of data structures and functions to represent continuous, spatially varying data.</p>
<p>All fields are subclasses of <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> which provides abstract functions for sampling field values at physical locations.</p>
<p>The most important field types are:</p>
<ul>
<li><code><a title="phi.field.CenteredGrid" href="#phi.field.CenteredGrid">CenteredGrid</a></code> embeds a tensor in the physical space. Uses linear interpolation between grid points.</li>
<li><code><a title="phi.field.StaggeredGrid" href="#phi.field.StaggeredGrid">StaggeredGrid</a></code> samples the vector components at face centers instead of at cell centers.</li>
<li><code><a title="phi.field.Noise" href="#phi.field.Noise">Noise</a></code> is a function that produces a procedurally generated noise field</li>
</ul>
<p>Use <code><a title="phi.field.grid" href="#phi.field.grid">grid()</a></code> to create a <code><a title="phi.field.Grid" href="#phi.field.Grid">Grid</a></code> from data or by sampling another <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> or <code><a title="phi.geom.Geometry" href="../geom/index.html#phi.geom.Geometry">Geometry</a></code>.
Alternatively, the <code><a title="phi.physics.Domain" href="../physics/index.html#phi.physics.Domain">Domain</a></code> class provides convenience methods for grid creation.</p>
<p>All fields can be sampled at physical locations or volumes using <code><a title="phi.field.sample" href="#phi.field.sample">sample()</a></code> or <code><a title="phi.field.reduce_sample" href="#phi.field.reduce_sample">reduce_sample()</a></code>.</p>
<p>See the <code><a title="phi.field" href="#phi.field">phi.field</a></code> module documentation at <a href="https://tum-pbs.github.io/PhiFlow/Fields.html">https://tum-pbs.github.io/PhiFlow/Fields.html</a></p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
The fields module provides a number of data structures and functions to represent continuous, spatially varying data.

All fields are subclasses of `Field` which provides abstract functions for sampling field values at physical locations.

The most important field types are:

* `CenteredGrid` embeds a tensor in the physical space. Uses linear interpolation between grid points.
* `StaggeredGrid` samples the vector components at face centers instead of at cell centers.
* `Noise` is a function that produces a procedurally generated noise field

Use `grid()` to create a `Grid` from data or by sampling another `Field` or `phi.geom.Geometry`.
Alternatively, the `phi.physics.Domain` class provides convenience methods for grid creation.

All fields can be sampled at physical locations or volumes using `sample()` or `reduce_sample()`.

See the `phi.field` module documentation at https://tum-pbs.github.io/PhiFlow/Fields.html
&#34;&#34;&#34;

from ._field import Field, SampledField, unstack, sample, reduce_sample
from ._constant import ConstantField
from ._mask import HardGeometryMask, SoftGeometryMask as GeometryMask, SoftGeometryMask
from ._grid import Grid, CenteredGrid, StaggeredGrid, unstack_staggered_tensor, stack_staggered_components, grid
from ._point_cloud import PointCloud
from ._noise import Noise
from ._angular_velocity import AngularVelocity
from phi.math import (
    abs, sign, round, ceil, floor, sqrt, exp, isfinite, real, imag, sin, cos, cast, to_float, to_int32, to_int64,
    stop_gradient,
    jit_compile, jit_compile_linear, functional_gradient,
    solve_linear, solve_nonlinear, minimize,
    l2_loss, l1_loss, frequency_loss,
)
from ._field_math import (
    assert_close, convert,
    laplace, spatial_gradient, divergence, stagger, curl,  # spatial operators
    fourier_poisson, fourier_laplace,
    mean, pad, shift, normalize, center_of_mass,
    concat, batch_stack, channel_stack,
    where,
    vec_squared, vec_abs,
    downsample2x, upsample2x,
    extrapolate_valid,
    native_call,
)
from ._field_io import write, read
from ._scene import Scene

__all__ = [key for key in globals().keys() if not key.startswith(&#39;_&#39;)]

__pdoc__ = {
    &#39;Grid.__init__&#39;: False,
    &#39;Scene.__init__&#39;: False,
}</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="phi.field.abs"><code class="name flex">
<span>def <span class="ident">abs</span></span>(<span>x) â€‘>Â phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Computes <em>||x||<sub>1</sub></em>.
Complex <code>x</code> result in matching precision float values.</p>
<p><em>Note</em>: The gradient of this operation is undefined for <em>x=0</em>.
TensorFlow and PyTorch return 0 while Jax returns 1.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong></dt>
<dd><code>Tensor</code> or <code>TensorLike</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Absolute value of <code>x</code> of same type as <code>x</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def abs_(x) -&gt; Tensor:
    &#34;&#34;&#34;
    Computes *||x||&lt;sub&gt;1&lt;/sub&gt;*.
    Complex `x` result in matching precision float values.

    *Note*: The gradient of this operation is undefined for *x=0*.
    TensorFlow and PyTorch return 0 while Jax returns 1.

    Args:
        x: `Tensor` or `TensorLike`

    Returns:
        Absolute value of `x` of same type as `x`.
    &#34;&#34;&#34;
    return _backend_op1(x, Backend.abs)</code></pre>
</details>
</dd>
<dt id="phi.field.assert_close"><code class="name flex">
<span>def <span class="ident">assert_close</span></span>(<span>*fields:Â phi.field._field.SampledField, rel_tolerance:Â floatÂ =Â 1e-05, abs_tolerance:Â floatÂ =Â 0)</span>
</code></dt>
<dd>
<div class="desc"><p>Raises an AssertionError if the <code>values</code> of the given fields are not close. See <code><a title="phi.math.assert_close" href="../math/index.html#phi.math.assert_close">assert_close()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assert_close(*fields: SampledField or math.Tensor or Number,
                 rel_tolerance: float = 1e-5,
                 abs_tolerance: float = 0):
    &#34;&#34;&#34; Raises an AssertionError if the `values` of the given fields are not close. See `phi.math.assert_close()`. &#34;&#34;&#34;
    f0 = next(filter(lambda t: isinstance(t, SampledField), fields))
    values = [(f &gt;&gt; f0).values if isinstance(f, SampledField) else math.wrap(f) for f in fields]
    math.assert_close(*values, rel_tolerance=rel_tolerance, abs_tolerance=abs_tolerance)</code></pre>
</details>
</dd>
<dt id="phi.field.batch_stack"><code class="name flex">
<span>def <span class="ident">batch_stack</span></span>(<span>*fields, dim:Â str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def batch_stack(*fields, dim: str):
    assert all(isinstance(f, SampledField) for f in fields), f&#34;All fields must be SampledFields of the same type but got {fields}&#34;
    assert all(isinstance(f, type(fields[0])) for f in fields), f&#34;All fields must be SampledFields of the same type but got {fields}&#34;
    if any(f.extrapolation != fields[0].extrapolation for f in fields):
        raise NotImplementedError(&#34;Concatenating extrapolations not supported&#34;)
    if isinstance(fields[0], Grid):
        values = math.batch_stack([f.values for f in fields], dim)
        return fields[0].with_(values=values)
    elif isinstance(fields[0], PointCloud):
        elements = geom.stack(*[f.elements for f in fields], dim=dim)
        values = math.batch_stack([f.values for f in fields], dim=dim)
        colors = math.batch_stack([f.color for f in fields], dim=dim)
        return fields[0].with_(elements=elements, values=values, color=colors)
    raise NotImplementedError(type(fields[0]))</code></pre>
</details>
</dd>
<dt id="phi.field.cast"><code class="name flex">
<span>def <span class="ident">cast</span></span>(<span>x:Â phi.math._tensors.Tensor, dtype:Â phi.math.backend._dtype.DType) â€‘>Â phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cast(x: Tensor, dtype: DType) -&gt; Tensor:
    return x._op1(lambda native: choose_backend(native).cast(native, dtype=dtype))</code></pre>
</details>
</dd>
<dt id="phi.field.ceil"><code class="name flex">
<span>def <span class="ident">ceil</span></span>(<span>x) â€‘>Â phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ceil(x) -&gt; Tensor:
    return _backend_op1(x, Backend.ceil)</code></pre>
</details>
</dd>
<dt id="phi.field.center_of_mass"><code class="name flex">
<span>def <span class="ident">center_of_mass</span></span>(<span>density:Â phi.field._field.SampledField)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def center_of_mass(density: SampledField):
    assert &#39;vector&#39; not in density.shape
    return mean(density.points * density) / mean(density)</code></pre>
</details>
</dd>
<dt id="phi.field.channel_stack"><code class="name flex">
<span>def <span class="ident">channel_stack</span></span>(<span>*fields, dim:Â str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def channel_stack(*fields, dim: str):
    assert all(isinstance(f, SampledField) for f in fields), f&#34;All fields must be SampledFields of the same type but got {fields}&#34;
    assert all(isinstance(f, type(fields[0])) for f in fields), f&#34;All fields must be SampledFields of the same type but got {fields}&#34;
    if any(f.extrapolation != fields[0].extrapolation for f in fields):
        raise NotImplementedError(&#34;Concatenating extrapolations not supported&#34;)
    if isinstance(fields[0], Grid):
        values = math.channel_stack([f.values for f in fields], dim)
        return fields[0].with_(values=values)
    elif isinstance(fields[0], PointCloud):
        elements = geom.stack(*[f.elements for f in fields], dim=dim)
        values = math.channel_stack([f.values for f in fields], dim=dim)
        colors = math.channel_stack([f.color for f in fields], dim=dim)
        return fields[0].with_(elements=elements, values=values, color=colors)
    raise NotImplementedError(type(fields[0]))</code></pre>
</details>
</dd>
<dt id="phi.field.concat"><code class="name flex">
<span>def <span class="ident">concat</span></span>(<span>*fields:Â phi.field._field.SampledField, dim:Â str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def concat(*fields: SampledField, dim: str):
    assert all(isinstance(f, SampledField) for f in fields)
    assert all(isinstance(f, type(fields[0])) for f in fields)
    if any(f.extrapolation != fields[0].extrapolation for f in fields):
        raise NotImplementedError(&#34;Concatenating extrapolations not supported&#34;)
    if isinstance(fields[0], Grid):
        values = math.concat([f.values for f in fields], dim=dim)
        return fields[0].with_(values=values)
    elif isinstance(fields[0], PointCloud):
        elements = geom.concat([f.elements for f in fields], dim, sizes=[f.shape.get_size(dim) for f in fields])
        values = math.concat([math.expand(f.values, f.shape.only(dim)) for f in fields], dim)
        colors = math.concat([math.expand(f.color, f.shape.only(dim)) for f in fields], dim)
        return fields[0].with_(elements=elements, values=values, color=colors)
    raise NotImplementedError(type(fields[0]))</code></pre>
</details>
</dd>
<dt id="phi.field.convert"><code class="name flex">
<span>def <span class="ident">convert</span></span>(<span>field:Â phi.field._field.SampledField, backend:Â phi.math.backend._backend.BackendÂ =Â None, use_dlpack=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert(field: SampledField, backend: Backend = None, use_dlpack=True):
    if isinstance(field, Grid):
        return field.with_(values=math.convert(field.values, backend, use_dlpack=use_dlpack))
    elif isinstance(field, PointCloud):
        attrs = {a: getattr(field.elements, a) for a in variable_attributes(field.elements)}
        elements = copy_with(field.elements, **{a: math.convert(v, backend, use_dlpack=use_dlpack) for a, v in attrs.items()})
        return field.with_(elements=elements, values=math.convert(field.values, backend, use_dlpack=use_dlpack))
    else:
        raise ValueError(field)</code></pre>
</details>
</dd>
<dt id="phi.field.cos"><code class="name flex">
<span>def <span class="ident">cos</span></span>(<span>x) â€‘>Â phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cos(x) -&gt; Tensor:
    return _backend_op1(x, Backend.cos)</code></pre>
</details>
</dd>
<dt id="phi.field.curl"><code class="name flex">
<span>def <span class="ident">curl</span></span>(<span>field:Â phi.field._grid.Grid, type:Â typeÂ =Â phi.field._grid.CenteredGrid)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def curl(field: Grid, type: type = CenteredGrid):
    assert field.spatial_rank in (2, 3), &#34;curl is only defined in 2 and 3 spatial dimensions.&#34;
    if field.spatial_rank == 2 and type == StaggeredGrid:
        assert isinstance(field, CenteredGrid) and &#39;vector&#39; not in field.shape, f&#34;2D curl requires scalar field but got {field}&#34;
        grad = math.spatial_gradient(field.values, dx=field.dx, difference=&#39;forward&#39;, padding=None, stack_dim=&#39;vector&#39;)
        result = grad.vector.flip() * (1, -1)  # (d/dy, -d/dx)
        bounds = Box(field.bounds.lower + 0.5 * field.dx, field.bounds.upper - 0.5 * field.dx)  # lose 1 cell per dimension
        return StaggeredGrid(result, bounds, field.extrapolation.spatial_gradient())
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="phi.field.divergence"><code class="name flex">
<span>def <span class="ident">divergence</span></span>(<span>field:Â phi.field._grid.Grid) â€‘>Â phi.field._grid.CenteredGrid</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the divergence of a grid using finite differences.</p>
<p>This function can operate in two modes depending on the type of <code>field</code>:</p>
<ul>
<li><code><a title="phi.field.CenteredGrid" href="#phi.field.CenteredGrid">CenteredGrid</a></code> approximates the divergence at cell centers using central differences</li>
<li><code><a title="phi.field.StaggeredGrid" href="#phi.field.StaggeredGrid">StaggeredGrid</a></code> exactly computes the divergence at cell centers</li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>field</code></strong></dt>
<dd>vector field as <code><a title="phi.field.CenteredGrid" href="#phi.field.CenteredGrid">CenteredGrid</a></code> or <code><a title="phi.field.StaggeredGrid" href="#phi.field.StaggeredGrid">StaggeredGrid</a></code></dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Divergence field as <code><a title="phi.field.CenteredGrid" href="#phi.field.CenteredGrid">CenteredGrid</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def divergence(field: Grid) -&gt; CenteredGrid:
    &#34;&#34;&#34;
    Computes the divergence of a grid using finite differences.

    This function can operate in two modes depending on the type of `field`:

    * `CenteredGrid` approximates the divergence at cell centers using central differences
    * `StaggeredGrid` exactly computes the divergence at cell centers

    Args:
        field: vector field as `CenteredGrid` or `StaggeredGrid`

    Returns:
        Divergence field as `CenteredGrid`
    &#34;&#34;&#34;
    if isinstance(field, StaggeredGrid):
        components = []
        for i, dim in enumerate(field.shape.spatial.names):
            div_dim = math.spatial_gradient(field.values.vector[i], dx=field.dx[i], difference=&#39;forward&#39;, padding=None, dims=[dim]).gradient[0]
            components.append(div_dim)
        data = math.sum(components, 0)
        return CenteredGrid(data, field.box, field.extrapolation.spatial_gradient())
    elif isinstance(field, CenteredGrid):
        left, right = shift(field, (-1, 1), stack_dim=&#39;div_&#39;)
        grad = (right - left) / (field.dx * 2)
        components = [grad.vector[i].div_[i] for i in range(grad.div_.size)]
        result = sum(components)
        return result
    else:
        raise NotImplementedError(f&#34;{type(field)} not supported. Only StaggeredGrid allowed.&#34;)</code></pre>
</details>
</dd>
<dt id="phi.field.downsample2x"><code class="name flex">
<span>def <span class="ident">downsample2x</span></span>(<span>grid:Â phi.field._grid.Grid) â€‘>Â ~GridType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def downsample2x(grid: Grid) -&gt; GridType:
    if isinstance(grid, CenteredGrid):
        values = math.downsample2x(grid.values, grid.extrapolation)
        return CenteredGrid(values, grid.bounds, grid.extrapolation)
    elif isinstance(grid, StaggeredGrid):
        values = []
        for dim, centered_grid in zip(grid.shape.spatial.names, unstack(grid, &#39;vector&#39;)):
            odd_discarded = centered_grid.values[{dim: slice(None, None, 2)}]
            others_interpolated = math.downsample2x(odd_discarded, grid.extrapolation, dims=grid.shape.spatial.without(dim))
            values.append(others_interpolated)
        return StaggeredGrid(math.channel_stack(values, &#39;vector&#39;), grid.bounds, grid.extrapolation)
    else:
        raise ValueError(type(grid))</code></pre>
</details>
</dd>
<dt id="phi.field.exp"><code class="name flex">
<span>def <span class="ident">exp</span></span>(<span>x) â€‘>Â phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exp(x) -&gt; Tensor:
    return _backend_op1(x, Backend.exp)</code></pre>
</details>
</dd>
<dt id="phi.field.extrapolate_valid"><code class="name flex">
<span>def <span class="ident">extrapolate_valid</span></span>(<span>grid:Â ~GridType, valid:Â ~GridType, distance_cells=1) â€‘>Â tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Extrapolates values of <code><a title="phi.field.grid" href="#phi.field.grid">grid()</a></code> which are marked by nonzero values in <code>valid</code> using `phi.math.extrapolate_valid_values().
If <code>values</code> is a StaggeredGrid, its components get extrapolated independently.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>grid</code></strong></dt>
<dd>Grid holding the values for extrapolation</dd>
<dt><strong><code>valid</code></strong></dt>
<dd>Grid (same type as <code>values</code>) marking the positions for extrapolation with nonzero values</dd>
<dt><strong><code>distance_cells</code></strong></dt>
<dd>Number of extrapolation steps</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phi.field.grid" href="#phi.field.grid">grid()</a></code></dt>
<dd>Grid with extrapolated values.</dd>
<dt><code>valid</code></dt>
<dd>binary Grid marking all valid values after extrapolation.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extrapolate_valid(grid: GridType, valid: GridType, distance_cells=1) -&gt; tuple:
    &#34;&#34;&#34;
    Extrapolates values of `grid` which are marked by nonzero values in `valid` using `phi.math.extrapolate_valid_values().
    If `values` is a StaggeredGrid, its components get extrapolated independently.

    Args:
        grid: Grid holding the values for extrapolation
        valid: Grid (same type as `values`) marking the positions for extrapolation with nonzero values
        distance_cells: Number of extrapolation steps

    Returns:
        grid: Grid with extrapolated values.
        valid: binary Grid marking all valid values after extrapolation.
    &#34;&#34;&#34;
    assert isinstance(valid, type(grid)), &#39;Type of valid Grid must match type of grid.&#39;
    if isinstance(grid, CenteredGrid):
        new_values, new_valid = extrapolate_valid_values(grid.values, valid.values, distance_cells)
        return grid.with_(values=new_values), valid.with_(values=new_valid)
    elif isinstance(grid, StaggeredGrid):
        new_values = []
        new_valid = []
        for cgrid, cvalid in zip(unstack(grid, &#39;vector&#39;), unstack(valid, &#39;vector&#39;)):
            new_tensor, new_mask = extrapolate_valid(cgrid, valid=cvalid, distance_cells=distance_cells)
            new_values.append(new_tensor.values)
            new_valid.append(new_mask.values)
        return grid.with_(values=math.channel_stack(new_values, &#39;vector&#39;)), valid.with_(values=math.channel_stack(new_valid, &#39;vector&#39;))
    else:
        raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="phi.field.floor"><code class="name flex">
<span>def <span class="ident">floor</span></span>(<span>x) â€‘>Â phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def floor(x) -&gt; Tensor:
    return _backend_op1(x, Backend.floor)</code></pre>
</details>
</dd>
<dt id="phi.field.fourier_laplace"><code class="name flex">
<span>def <span class="ident">fourier_laplace</span></span>(<span>grid:Â ~GridType, times=1) â€‘>Â ~GridType</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="phi.math.fourier_laplace" href="../math/index.html#phi.math.fourier_laplace">fourier_laplace()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fourier_laplace(grid: GridType, times=1) -&gt; GridType:
    &#34;&#34;&#34; See `phi.math.fourier_laplace()` &#34;&#34;&#34;
    extrapolation = grid.extrapolation.spatial_gradient().spatial_gradient()
    return grid.with_(values=math.fourier_laplace(grid.values, dx=grid.dx, times=times), extrapolation=extrapolation)</code></pre>
</details>
</dd>
<dt id="phi.field.fourier_poisson"><code class="name flex">
<span>def <span class="ident">fourier_poisson</span></span>(<span>grid:Â ~GridType, extrapolation:Â <a title="phi.math.extrapolation.Extrapolation" href="../math/extrapolation.html#phi.math.extrapolation.Extrapolation">Extrapolation</a>Â =Â None, times=1) â€‘>Â ~GridType</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="phi.math.fourier_poisson" href="../math/index.html#phi.math.fourier_poisson">fourier_poisson()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fourier_poisson(grid: GridType, extrapolation: math.Extrapolation = None, times=1) -&gt; GridType:
    &#34;&#34;&#34; See `phi.math.fourier_poisson()` &#34;&#34;&#34;
    return grid.with_(values=math.fourier_poisson(grid.values, dx=grid.dx, times=times), extrapolation=extrapolation)</code></pre>
</details>
</dd>
<dt id="phi.field.frequency_loss"><code class="name flex">
<span>def <span class="ident">frequency_loss</span></span>(<span>x, n=2, frequency_falloff:Â floatÂ =Â 100, threshold=1e-05, batch_norm:Â boolÂ =Â True, ignore_mean=False) â€‘>Â phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Penalizes the squared <code>values</code> in frequency (Fourier) space.
Lower frequencies are weighted more strongly then higher frequencies, depending on <code>frequency_falloff</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>values</code></strong></dt>
<dd>Values to penalize, typically <code>actual - target</code></dd>
<dt><strong><code>n</code></strong></dt>
<dd>Loss type, see <code>l_n_loss()</code>.</dd>
<dt><strong><code>frequency_falloff</code></strong></dt>
<dd>Large values put more emphasis on lower frequencies, 1.0 weights all frequencies equally.
<em>Note</em>: The total loss is not normalized. Varying the value will result in losses of different magnitudes.</dd>
<dt><strong><code>threshold</code></strong></dt>
<dd>Frequency amplitudes below this value are ignored.
Setting this to zero may cause infinities or NaN values during backpropagation.</dd>
<dt><strong><code>batch_norm</code></strong></dt>
<dd>Either <code>bool</code> specifying whether to divide by the product of all batch sizes or specific dimensions.</dd>
<dt><strong><code>ignore_mean</code></strong></dt>
<dd>If <code>True</code>, does not penalize the mean value (frequency=0 component).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Scalar loss value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def frequency_loss(x,
                   n=2,
                   frequency_falloff: float = 100,
                   threshold=1e-5,
                   batch_norm: bool or str or tuple or list or Shape = True,
                   ignore_mean=False) -&gt; Tensor:
    &#34;&#34;&#34;
    Penalizes the squared `values` in frequency (Fourier) space.
    Lower frequencies are weighted more strongly then higher frequencies, depending on `frequency_falloff`.

    Args:
        values: Values to penalize, typically `actual - target`
        n: Loss type, see `l_n_loss()`.
        frequency_falloff: Large values put more emphasis on lower frequencies, 1.0 weights all frequencies equally.
            *Note*: The total loss is not normalized. Varying the value will result in losses of different magnitudes.
        threshold: Frequency amplitudes below this value are ignored.
            Setting this to zero may cause infinities or NaN values during backpropagation.
        batch_norm: Either `bool` specifying whether to divide by the product of all batch sizes or specific dimensions.
        ignore_mean: If `True`, does not penalize the mean value (frequency=0 component).

    Returns:
      Scalar loss value
    &#34;&#34;&#34;
    if ignore_mean:
        values -= math.mean(values, values.shape.non_batch)
    k_squared = vec_squared(math.fftfreq(values.shape.spatial))
    weights = math.exp(-0.5 * k_squared * frequency_falloff ** 2)
    diff_fft = abs_square(math.fft(values) * weights)
    diff_fft = math.sqrt(math.maximum(diff_fft, threshold))
    return l_n_loss(diff_fft, n=n, batch_norm=batch_norm)</code></pre>
</details>
</dd>
<dt id="phi.field.functional_gradient"><code class="name flex">
<span>def <span class="ident">functional_gradient</span></span>(<span>f:Â Callable, wrt:Â tupleÂ =Â (0,), get_output=True) â€‘>Â Callable</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a function which computes the spatial_gradient of <code>f</code>.</p>
<p>Example:</p>
<pre><code class="language-python">def loss_function(x, y):
    prediction = f(x)
    loss = math.l2_loss(prediction - y)
    return loss, prediction

dx, = functional_gradient(loss_function)(x, y)

loss, prediction, dx, dy = functional_gradient(loss_function, wrt=(0, 1),
                                             get_output=True)(x, y)
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>f</code></strong></dt>
<dd>Function to be differentiated.
<code>f</code> must return a floating point <code>Tensor</code> with rank zero.
It can return additional tensors which are treated as auxiliary data and will be returned by the spatial_gradient function if <code>return_values=True</code>.
All arguments for which the spatial_gradient is computed must be of dtype float or complex.</dd>
<dt><strong><code>get_output</code></strong></dt>
<dd>Whether the spatial_gradient function should also return the return values of <code>f</code>.</dd>
<dt><strong><code>wrt</code></strong></dt>
<dd>Arguments of <code>f</code> with respect to which the spatial_gradient should be computed.
Example: <code>wrt_indices=[0]</code> computes the spatial_gradient with respect to the first argument of <code>f</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Function with the same arguments as <code>f</code> that returns the value of <code>f</code>, auxiliary data and spatial_gradient of <code>f</code> if <code>get_output=True</code>, else just the spatial_gradient of <code>f</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def functional_gradient(f: Callable, wrt: tuple or list = (0,), get_output=True) -&gt; Callable:
    &#34;&#34;&#34;
    Creates a function which computes the spatial_gradient of `f`.

    Example:

    ```python
    def loss_function(x, y):
        prediction = f(x)
        loss = math.l2_loss(prediction - y)
        return loss, prediction

    dx, = functional_gradient(loss_function)(x, y)

    loss, prediction, dx, dy = functional_gradient(loss_function, wrt=(0, 1),
                                                 get_output=True)(x, y)
    ```

    Args:
        f: Function to be differentiated.
            `f` must return a floating point `Tensor` with rank zero.
            It can return additional tensors which are treated as auxiliary data and will be returned by the spatial_gradient function if `return_values=True`.
            All arguments for which the spatial_gradient is computed must be of dtype float or complex.
        get_output: Whether the spatial_gradient function should also return the return values of `f`.
        wrt: Arguments of `f` with respect to which the spatial_gradient should be computed.
            Example: `wrt_indices=[0]` computes the spatial_gradient with respect to the first argument of `f`.

    Returns:
        Function with the same arguments as `f` that returns the value of `f`, auxiliary data and spatial_gradient of `f` if `get_output=True`, else just the spatial_gradient of `f`.
    &#34;&#34;&#34;
    return GradientFunction(f, wrt, get_output)</code></pre>
</details>
</dd>
<dt id="phi.field.grid"><code class="name flex">
<span>def <span class="ident">grid</span></span>(<span>values:Â phi.geom._geom.Geometry, resolution:Â phi.math._shape.Shape, bounds:Â phi.geom._box.BoxÂ =Â None, extrapolation:Â <a title="phi.math.extrapolation.Extrapolation" href="../math/extrapolation.html#phi.math.extrapolation.Extrapolation">Extrapolation</a>Â =Â 0, type:Â typeÂ =Â phi.field._grid.CenteredGrid) â€‘>Â ~GridType</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a <code><a title="phi.field.CenteredGrid" href="#phi.field.CenteredGrid">CenteredGrid</a></code> or <code><a title="phi.field.StaggeredGrid" href="#phi.field.StaggeredGrid">StaggeredGrid</a></code> from <code>values</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>values</code></strong></dt>
<dd>
<p>Values to use for the grid.
Has to be one of the following:</p>
<ul>
<li><code><a title="phi.geom.Geometry" href="../geom/index.html#phi.geom.Geometry">Geometry</a></code>: sets inside values to 1, outside to 0</li>
<li><code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code>: resamples the Field to the staggered sample points</li>
<li><code>Number</code>: uses the value for all sample points</li>
<li><code>tuple</code> or <code>list</code>: interprets the sequence as vector, used for all sample points</li>
<li><code><a title="phi.math.Tensor" href="../math/index.html#phi.math.Tensor">Tensor</a></code> compatible with grid dims: uses tensor values as grid values</li>
<li>Function <code>values(x)</code> where <code>x</code> is a <code><a title="phi.math.Tensor" href="../math/index.html#phi.math.Tensor">Tensor</a></code> representing the physical location.</li>
</ul>
</dd>
<dt><strong><code>resolution</code></strong></dt>
<dd>Grid resolution as purely spatial <code><a title="phi.math.Shape" href="../math/index.html#phi.math.Shape">Shape</a></code>.</dd>
<dt><strong><code>bounds</code></strong></dt>
<dd>Physical grid bounds as <code><a title="phi.geom.Box" href="../geom/index.html#phi.geom.Box">Box</a></code>.</dd>
<dt><strong><code>extrapolation</code></strong></dt>
<dd>Grid extrapolation as <code><a title="phi.math.Extrapolation" href="../math/index.html#phi.math.Extrapolation">Extrapolation</a></code>.</dd>
<dt><strong><code>type</code></strong></dt>
<dd>Grid type, either <code><a title="phi.field.CenteredGrid" href="#phi.field.CenteredGrid">CenteredGrid</a></code> or <code><a title="phi.field.StaggeredGrid" href="#phi.field.StaggeredGrid">StaggeredGrid</a></code></dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.field.CenteredGrid" href="#phi.field.CenteredGrid">CenteredGrid</a></code> or <code><a title="phi.field.StaggeredGrid" href="#phi.field.StaggeredGrid">StaggeredGrid</a></code>, depending on <code>type</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def grid(values: Geometry or Field or Number or math.Tensor or Callable or tuple or list,
         resolution: Shape,
         bounds: Box = None,
         extrapolation: math.Extrapolation = math.extrapolation.ZERO,
         type: type = CenteredGrid) -&gt; GridType:
    &#34;&#34;&#34;
    Creates a `CenteredGrid` or `StaggeredGrid` from `values`.

    Args:
        values: Values to use for the grid.
            Has to be one of the following:

            * `phi.geom.Geometry`: sets inside values to 1, outside to 0
            * `Field`: resamples the Field to the staggered sample points
            * `Number`: uses the value for all sample points
            * `tuple` or `list`: interprets the sequence as vector, used for all sample points
            * `phi.math.Tensor` compatible with grid dims: uses tensor values as grid values
            * Function `values(x)` where `x` is a `phi.math.Tensor` representing the physical location.

        resolution: Grid resolution as purely spatial `phi.math.Shape`.
        bounds: Physical grid bounds as `phi.geom.Box`.
        extrapolation: Grid extrapolation as `phi.math.Extrapolation`.
        type: Grid type, either `CenteredGrid` or `StaggeredGrid`

    Returns:
        `CenteredGrid` or `StaggeredGrid`, depending on `type`.
    &#34;&#34;&#34;
    if bounds is None:
        bounds = Box(0, math.wrap(resolution, &#39;vector&#39;))
    assert resolution.spatial_rank == bounds.spatial_rank, f&#34;Resolution {resolution} does not match bounds {bounds}&#34;
    if isinstance(values, Geometry):
        values = HardGeometryMask(values)
    if isinstance(values, Field):
        ref_grid = grid(0, resolution=resolution, bounds=bounds, extrapolation=extrapolation, type=type)
        sampled_values = reduce_sample(values, ref_grid.elements)
        return ref_grid.with_(values=sampled_values)
    else:
        if callable(values):
            cells = GridCell(resolution, bounds)
            x = cells.center if type == CenteredGrid else cells.face_centers()
            values = values(x)
        if not isinstance(values, math.Tensor):
            values = math.tensor(values)
        if values.dtype.kind not in (float, complex):
            values = math.to_float(values)
        if type == CenteredGrid:
            values = math.expand(values, resolution)
            return CenteredGrid(values, bounds, extrapolation)
        else:
            assert type == StaggeredGrid, &#34;type must be CenteredGrid or StaggeredGrid&#34;
            components = values.vector.unstack(resolution.spatial_rank)
            tensors = []
            for dim, component in zip(resolution.spatial.names, components):
                comp_cells = GridCell(resolution, bounds).extend_symmetric(dim, 1)
                tensors.append(math.expand(component, comp_cells.resolution))
            return StaggeredGrid(math.channel_stack(tensors, &#39;vector&#39;), bounds, extrapolation)</code></pre>
</details>
</dd>
<dt id="phi.field.imag"><code class="name flex">
<span>def <span class="ident">imag</span></span>(<span>complex) â€‘>Â phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def imag(complex) -&gt; Tensor:
    return _backend_op1(complex, Backend.imag)</code></pre>
</details>
</dd>
<dt id="phi.field.isfinite"><code class="name flex">
<span>def <span class="ident">isfinite</span></span>(<span>x) â€‘>Â phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isfinite(x) -&gt; Tensor:
    return _backend_op1(x, Backend.isfinite)</code></pre>
</details>
</dd>
<dt id="phi.field.jit_compile"><code class="name flex">
<span>def <span class="ident">jit_compile</span></span>(<span>f:Â Callable) â€‘>Â Callable</span>
</code></dt>
<dd>
<div class="desc"><p>Compiles a graph based on the function <code>f</code>.
The graph compilation is performed just-in-time (jit) when the returned function is called for the first time.</p>
<p>The traced function will compute the same result as <code>f</code> but may run much faster.
Some checks may be disabled in the compiled function.</p>
<p>Can be used as a decorator:</p>
<pre><code class="language-python">@math.jit_compile
def my_function(x: math.Tensor) -&gt; math.Tensor:
</code></pre>
<p>Compilation is implemented for the following backends:</p>
<ul>
<li>PyTorch: <a href="https://pytorch.org/docs/stable/jit.html"><code>torch.jit.trace</code></a></li>
<li>TensorFlow: <a href="https://www.tensorflow.org/guide/function"><code>tf.function</code></a></li>
<li>Jax: <a href="https://jax.readthedocs.io/en/latest/notebooks/quickstart.html#using-jit-to-speed-up-functions"><code>jax.jit</code></a></li>
</ul>
<p>See Also:
<code><a title="phi.field.jit_compile_linear" href="#phi.field.jit_compile_linear">jit_compile_linear()</a></code></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>f</code></strong></dt>
<dd>Function to be traced.
All arguments must be of type <code>Tensor</code> returning a single <code>Tensor</code> or a <code>tuple</code> or <code>list</code> of tensors.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Function with similar signature and return values as <code>f</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def jit_compile(f: Callable) -&gt; Callable:
    &#34;&#34;&#34;
    Compiles a graph based on the function `f`.
    The graph compilation is performed just-in-time (jit) when the returned function is called for the first time.

    The traced function will compute the same result as `f` but may run much faster.
    Some checks may be disabled in the compiled function.

    Can be used as a decorator:
    ```python
    @math.jit_compile
    def my_function(x: math.Tensor) -&gt; math.Tensor:
    ```

    Compilation is implemented for the following backends:

    * PyTorch: [`torch.jit.trace`](https://pytorch.org/docs/stable/jit.html)
    * TensorFlow: [`tf.function`](https://www.tensorflow.org/guide/function)
    * Jax: [`jax.jit`](https://jax.readthedocs.io/en/latest/notebooks/quickstart.html#using-jit-to-speed-up-functions)

    See Also:
        `jit_compile_linear()`

    Args:
        f: Function to be traced.
            All arguments must be of type `Tensor` returning a single `Tensor` or a `tuple` or `list` of tensors.

    Returns:
        Function with similar signature and return values as `f`.
    &#34;&#34;&#34;
    return f if isinstance(f, (JitFunction, LinearFunction)) else JitFunction(f)</code></pre>
</details>
</dd>
<dt id="phi.field.jit_compile_linear"><code class="name flex">
<span>def <span class="ident">jit_compile_linear</span></span>(<span>f:Â Callable[[~X],Â ~Y]) â€‘>Â phi.math._functional.LinearFunction[~X,Â ~Y]</span>
</code></dt>
<dd>
<div class="desc"><p>Compile an optimized representation of the linear function <code>f</code>.</p>
<p>Can be used as a decorator:</p>
<pre><code class="language-python">@math.jit_compile_linear
def my_linear_function(x: math.Tensor) -&gt; math.Tensor:
</code></pre>
<p>See Also:
<code><a title="phi.field.jit_compile" href="#phi.field.jit_compile">jit_compile()</a></code></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>f</code></strong></dt>
<dd>Linear function with <code>Tensor</code> positional arguments and return value(s).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>LinearFunction</code> with similar signature and return values as <code>f</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def jit_compile_linear(f: Callable[[X], Y]) -&gt; &#39;LinearFunction[X, Y]&#39;:
    &#34;&#34;&#34;
    Compile an optimized representation of the linear function `f`.

    Can be used as a decorator:

    ```python
    @math.jit_compile_linear
    def my_linear_function(x: math.Tensor) -&gt; math.Tensor:
    ```

    See Also:
        `jit_compile()`

    Args:
        f: Linear function with `Tensor` positional arguments and return value(s).

    Returns:
        `LinearFunction` with similar signature and return values as `f`.
    &#34;&#34;&#34;
    if isinstance(f, JitFunction):
        f = f.f  # cannot trace linear function from jitted version
    return f if isinstance(f, LinearFunction) else LinearFunction(f)</code></pre>
</details>
</dd>
<dt id="phi.field.l1_loss"><code class="name flex">
<span>def <span class="ident">l1_loss</span></span>(<span>x) â€‘>Â phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Computes <em>âˆ‘<sub>i</sub> ||x<sub>i</sub>||<sub>1</sub></em>, summing over all non-batch dimensions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong></dt>
<dd><code>Tensor</code> or <code>TensorLike</code>.
For <code>TensorLike</code> objects, only value the sum over all value attributes is computed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>loss</code></dt>
<dd><code>Tensor</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def l1_loss(x) -&gt; Tensor:
    &#34;&#34;&#34;
    Computes *âˆ‘&lt;sub&gt;i&lt;/sub&gt; ||x&lt;sub&gt;i&lt;/sub&gt;||&lt;sub&gt;1&lt;/sub&gt;*, summing over all non-batch dimensions.

    Args:
        x: `Tensor` or `TensorLike`.
            For `TensorLike` objects, only value the sum over all value attributes is computed.

    Returns:
        loss: `Tensor`
    &#34;&#34;&#34;
    if isinstance(x, Tensor):
        return math.sum_(abs(x), x.shape.non_batch)
    elif isinstance(x, TensorLike):
        return sum([l1_loss(getattr(x, a)) for a in value_attributes(x)])
    else:
        raise ValueError(x)</code></pre>
</details>
</dd>
<dt id="phi.field.l2_loss"><code class="name flex">
<span>def <span class="ident">l2_loss</span></span>(<span>x) â€‘>Â phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Computes <em>âˆ‘<sub>i</sub> ||x<sub>i</sub>||<sub>2</sub><sup>2</sup> / 2</em>, summing over all non-batch dimensions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong></dt>
<dd><code>Tensor</code> or <code>TensorLike</code>.
For <code>TensorLike</code> objects, only value the sum over all value attributes is computed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>loss</code></dt>
<dd><code>Tensor</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def l2_loss(x) -&gt; Tensor:
    &#34;&#34;&#34;
    Computes *âˆ‘&lt;sub&gt;i&lt;/sub&gt; ||x&lt;sub&gt;i&lt;/sub&gt;||&lt;sub&gt;2&lt;/sub&gt;&lt;sup&gt;2&lt;/sup&gt; / 2*, summing over all non-batch dimensions.

    Args:
        x: `Tensor` or `TensorLike`.
            For `TensorLike` objects, only value the sum over all value attributes is computed.

    Returns:
        loss: `Tensor`
    &#34;&#34;&#34;
    if isinstance(x, Tensor):
        if x.dtype.kind == complex:
            x = abs(x)
        return math.sum_(x ** 2, x.shape.non_batch) * 0.5
    elif isinstance(x, TensorLike):
        return sum([l2_loss(getattr(x, a)) for a in value_attributes(x)])
    else:
        raise ValueError(x)</code></pre>
</details>
</dd>
<dt id="phi.field.laplace"><code class="name flex">
<span>def <span class="ident">laplace</span></span>(<span>field:Â ~GridType, axes=None) â€‘>Â ~GridType</span>
</code></dt>
<dd>
<div class="desc"><p>Finite-difference laplace operator for Grids. See <code><a title="phi.math.laplace" href="../math/index.html#phi.math.laplace">laplace()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def laplace(field: GridType, axes=None) -&gt; GridType:
    &#34;&#34;&#34; Finite-difference laplace operator for Grids. See `phi.math.laplace()`. &#34;&#34;&#34;
    result = field._op1(lambda tensor: math.laplace(tensor, dx=field.dx, padding=field.extrapolation, dims=axes))
    return result</code></pre>
</details>
</dd>
<dt id="phi.field.mean"><code class="name flex">
<span>def <span class="ident">mean</span></span>(<span>field:Â phi.field._field.SampledField)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mean(field: SampledField):
    return math.mean(field.values, field.shape.spatial)</code></pre>
</details>
</dd>
<dt id="phi.field.minimize"><code class="name flex">
<span>def <span class="ident">minimize</span></span>(<span>f:Â Callable[[~X],Â ~Y], solve:Â phi.math._functional.Solve[~X,Â ~Y]) â€‘>Â ~X</span>
</code></dt>
<dd>
<div class="desc"><p>Finds a minimum of the scalar function <em>f(x)</em>.
The <code>method</code> argument of <code>solve</code> determines which method is used.
All methods supported by <code>scipy.optimize.minimize</code> are supported,
see <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html</a> .</p>
<p>This method is limited to backends that support <code><a title="phi.field.functional_gradient" href="#phi.field.functional_gradient">functional_gradient()</a></code>, currently PyTorch, TensorFlow and Jax.</p>
<p>To obtain additional information about the performed solve, use a <code>SolveTape</code>.</p>
<p>See Also:
<code><a title="phi.field.solve_nonlinear" href="#phi.field.solve_nonlinear">solve_nonlinear()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>f</code></strong></dt>
<dd>Function whose output is subject to minimization.
All positional arguments of <code>f</code> are optimized and must be <code>Tensor</code> or <code>TensorLike</code>.
The first return value of <code>f</code> must be a scalar float <code>Tensor</code> or <code>TensorLike</code>.</dd>
<dt><strong><code>solve</code></strong></dt>
<dd><code>Solve</code> object to specify method type, parameters and initial guess for <code>x</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>x</code></dt>
<dd>solution, the minimum point <code>x</code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NotConverged</code></dt>
<dd>If the desired accuracy was not be reached within the maximum number of iterations.</dd>
<dt><code>Diverged</code></dt>
<dd>If the optimization failed prematurely.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def minimize(f: Callable[[X], Y], solve: Solve[X, Y]) -&gt; X:
    &#34;&#34;&#34;
    Finds a minimum of the scalar function *f(x)*.
    The `method` argument of `solve` determines which method is used.
    All methods supported by `scipy.optimize.minimize` are supported,
    see https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html .

    This method is limited to backends that support `functional_gradient()`, currently PyTorch, TensorFlow and Jax.

    To obtain additional information about the performed solve, use a `SolveTape`.

    See Also:
        `solve_nonlinear()`.

    Args:
        f: Function whose output is subject to minimization.
            All positional arguments of `f` are optimized and must be `Tensor` or `TensorLike`.
            The first return value of `f` must be a scalar float `Tensor` or `TensorLike`.
        solve: `Solve` object to specify method type, parameters and initial guess for `x`.

    Returns:
        x: solution, the minimum point `x`.

    Raises:
        NotConverged: If the desired accuracy was not be reached within the maximum number of iterations.
        Diverged: If the optimization failed prematurely.
    &#34;&#34;&#34;
    assert solve.relative_tolerance == 0, f&#34;relative_tolerance must be zero for minimize() but got {solve.relative_tolerance}&#34;
    x0_nest, x0_tensors = disassemble_nested(solve.x0)
    x0_tensors = [to_float(t) for t in x0_tensors]
    backend = choose_backend_t(*x0_tensors, prefer_default=True)
    batch = combine_safe(*[t.shape for t in x0_tensors]).batch
    x0_natives = []
    for t in x0_tensors:
        t._expand()
        assert t.shape.is_uniform
        x0_natives.append(reshaped_native(t, [batch, t.shape.non_batch], force_expand=True))
    x0_flat = backend.concat(x0_natives, -1)

    def unflatten_assemble(x_flat, additional_dims=()):
        i = 0
        x_tensors = []
        for x0_native, x0_tensor in zip(x0_natives, x0_tensors):
            vol = backend.shape(x0_native)[-1]
            flat_native = x_flat[..., i:i + vol]
            x_tensors.append(reshaped_tensor(flat_native, [*additional_dims, batch, x0_tensor.shape.non_batch]))
            i += vol
        x = assemble_nested(x0_nest, x_tensors)
        return x

    def native_function(x_flat):
        x = unflatten_assemble(x_flat)
        if isinstance(x, (tuple, list)):
            y = f(*x)
        else:
            y = f(x)
        _, y_tensors = disassemble_nested(y)
        return y_tensors[0].sum, y_tensors[0].native()

    atol = backend.to_float(reshaped_native(solve.absolute_tolerance, [batch], force_expand=True))
    maxi = backend.to_int32(reshaped_native(solve.max_iterations, [batch], force_expand=True))
    trj = _SOLVE_TAPES and any(t.record_trajectories for t in _SOLVE_TAPES)
    ret = backend.minimize(solve.method, native_function, x0_flat, atol, maxi, trj)
    if not trj:
        assert isinstance(ret, SolveResult)
        converged = reshaped_tensor(ret.converged, [batch])
        diverged = reshaped_tensor(ret.diverged, [batch])
        x = unflatten_assemble(ret.x)
        iterations = reshaped_tensor(ret.iterations, [batch])
        function_evaluations = reshaped_tensor(ret.function_evaluations, [batch])
        residual = reshaped_tensor(ret.residual, [batch])
        result = SolveInfo(solve, x, residual, iterations, function_evaluations, converged, diverged, ret.method, ret.message)
    else:  # trajectory
        assert isinstance(ret, (tuple, list)) and all(isinstance(r, SolveResult) for r in ret)
        converged = reshaped_tensor(ret[-1].converged, [batch])
        diverged = reshaped_tensor(ret[-1].diverged, [batch])
        x = unflatten_assemble(ret[-1].x)
        x_ = unflatten_assemble(backend.stack([r.x for r in ret]), additional_dims=(&#39;trajectory&#39;,))
        residual = batch_stack([reshaped_tensor(r.residual, [batch]) for r in ret], &#39;trajectory&#39;)
        iterations = reshaped_tensor(ret[-1].iterations, [batch])
        function_evaluations = batch_stack([reshaped_tensor(r.function_evaluations, [batch]) for r in ret], &#39;trajectory&#39;)
        result = SolveInfo(solve, x_, residual, iterations, function_evaluations, converged, diverged, ret[-1].method, ret[-1].message)
    for tape in _SOLVE_TAPES:
        tape._add(solve, trj, result)
    result.convergence_check(False)  # raises ConvergenceException
    return x</code></pre>
</details>
</dd>
<dt id="phi.field.native_call"><code class="name flex">
<span>def <span class="ident">native_call</span></span>(<span>f, *inputs, channels_last=None, channel_dim='vector', extrapolation=None) â€‘>Â phi.field._field.SampledField</span>
</code></dt>
<dd>
<div class="desc"><p>Similar to <code><a title="phi.math.native_call" href="../math/index.html#phi.math.native_call">native_call()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>f</code></strong></dt>
<dd>Function to be called on native tensors of <code>inputs.values</code>.
The function output must have the same dimension layout as the inputs and the batch size must be identical.</dd>
<dt><strong><code>*inputs</code></strong></dt>
<dd><code><a title="phi.field.SampledField" href="#phi.field.SampledField">SampledField</a></code> or <code><a title="phi.math.Tensor" href="../math/index.html#phi.math.Tensor">Tensor</a></code> instances.</dd>
<dt><strong><code>extrapolation</code></strong></dt>
<dd>(Optional) Extrapolation of the output field. If <code>None</code>, uses the extrapolation of the first input field.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.field.SampledField" href="#phi.field.SampledField">SampledField</a></code> matching the first <code><a title="phi.field.SampledField" href="#phi.field.SampledField">SampledField</a></code> in <code>inputs</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def native_call(f, *inputs, channels_last=None, channel_dim=&#39;vector&#39;, extrapolation=None) -&gt; SampledField or math.Tensor:
    &#34;&#34;&#34;
    Similar to `phi.math.native_call()`.

    Args:
        f: Function to be called on native tensors of `inputs.values`.
            The function output must have the same dimension layout as the inputs and the batch size must be identical.
        *inputs: `SampledField` or `phi.math.Tensor` instances.
        extrapolation: (Optional) Extrapolation of the output field. If `None`, uses the extrapolation of the first input field.

    Returns:
        `SampledField` matching the first `SampledField` in `inputs`.
    &#34;&#34;&#34;
    input_tensors = [i.values if isinstance(i, SampledField) else math.tensor(i) for i in inputs]
    result = math.native_call(f, *input_tensors, channels_last=channels_last, channel_dim=channel_dim)
    for i in inputs:
        if isinstance(i, SampledField):
            return i.with_(values=result, extrapolation=extrapolation)
    return result</code></pre>
</details>
</dd>
<dt id="phi.field.normalize"><code class="name flex">
<span>def <span class="ident">normalize</span></span>(<span>field:Â phi.field._field.SampledField, norm:Â phi.field._field.SampledField, epsilon=1e-05)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalize(field: SampledField, norm: SampledField, epsilon=1e-5):
    data = math.normalize_to(field.values, norm.values, epsilon)
    return field.with_(values=data)</code></pre>
</details>
</dd>
<dt id="phi.field.pad"><code class="name flex">
<span>def <span class="ident">pad</span></span>(<span>grid:Â phi.field._grid.Grid, widths:Â int)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pad(grid: Grid, widths: int or tuple or list or dict):
    if isinstance(widths, int):
        widths = {axis: (widths, widths) for axis in grid.shape.spatial.names}
    elif isinstance(widths, (tuple, list)):
        widths = {axis: (width if isinstance(width, (tuple, list)) else (width, width)) for axis, width in zip(grid.shape.spatial.names, widths)}
    else:
        assert isinstance(widths, dict)
    widths_list = [widths[axis] for axis in grid.shape.spatial.names]
    if isinstance(grid, Grid):
        data = math.pad(grid.values, widths, grid.extrapolation)
        w_lower = math.wrap([w[0] for w in widths_list])
        w_upper = math.wrap([w[1] for w in widths_list])
        box = Box(grid.box.lower - w_lower * grid.dx, grid.box.upper + w_upper * grid.dx)
        return type(grid)(data, box, grid.extrapolation)
    raise NotImplementedError(f&#34;{type(grid)} not supported. Only Grid instances allowed.&#34;)</code></pre>
</details>
</dd>
<dt id="phi.field.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>file:Â str, convert_to_backend=True) â€‘>Â phi.field._field.SampledField</span>
</code></dt>
<dd>
<div class="desc"><p>Loads a previously saved <code><a title="phi.field.SampledField" href="#phi.field.SampledField">SampledField</a></code> from disc.</p>
<p>See Also:
<code><a title="phi.field.write" href="#phi.field.write">write()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file</code></strong></dt>
<dd>Single file as <code>str</code> or <code>Tensor</code> of string type.
If <code>file</code> is a tensor, all contained files are loaded an stacked according to the dimensions of <code>file</code>.</dd>
<dt><strong><code>convert_to_backend</code></strong></dt>
<dd>Whether to convert the read data to the data format of the default backend, e.g. TensorFlow tensors.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Loaded <code><a title="phi.field.SampledField" href="#phi.field.SampledField">SampledField</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(file: str or math.Tensor, convert_to_backend=True) -&gt; SampledField:
    &#34;&#34;&#34;
    Loads a previously saved `SampledField` from disc.

    See Also:
        `write()`.

    Args:
        file: Single file as `str` or `Tensor` of string type.
            If `file` is a tensor, all contained files are loaded an stacked according to the dimensions of `file`.
        convert_to_backend: Whether to convert the read data to the data format of the default backend, e.g. TensorFlow tensors.

    Returns:
        Loaded `SampledField`.
    &#34;&#34;&#34;
    if isinstance(file, str):
        return read_single_field(file, convert_to_backend=convert_to_backend)
    if isinstance(file, math.Tensor):
        if file.rank == 0:
            return read_single_field(file.native(), convert_to_backend=convert_to_backend)
        else:
            dim = file.shape.names[0]
            files = file.unstack(dim)
            fields = [read(file_, convert_to_backend=convert_to_backend) for file_ in files]
            return batch_stack(*fields, dim=dim)
    else:
        raise ValueError(file)</code></pre>
</details>
</dd>
<dt id="phi.field.real"><code class="name flex">
<span>def <span class="ident">real</span></span>(<span>complex) â€‘>Â phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def real(complex) -&gt; Tensor:
    return _backend_op1(complex, Backend.real)</code></pre>
</details>
</dd>
<dt id="phi.field.reduce_sample"><code class="name flex">
<span>def <span class="ident">reduce_sample</span></span>(<span>field:Â phi.field._field.Field, geometry:Â phi.geom._geom.Geometry) â€‘>Â phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Similar to <code><a title="phi.field.sample" href="#phi.field.sample">sample()</a></code>, but matches an optional <code>vector_</code> dimension of <code>geometry</code> with the <code>vector</code> dimension of this field.</p>
<p>See Also:
<code><a title="phi.field.sample" href="#phi.field.sample">sample()</a></code>, <code><a title="phi.field.Field.at" href="#phi.field.Field.at">Field.at()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>field</code></strong></dt>
<dd>Source <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> to sample.</dd>
<dt><strong><code>geometry</code></strong></dt>
<dd>Single or batched <code><a title="phi.geom.Geometry" href="../geom/index.html#phi.geom.Geometry">Geometry</a></code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Sampled values as a <code><a title="phi.math.Tensor" href="../math/index.html#phi.math.Tensor">Tensor</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reduce_sample(field: Field, geometry: Geometry) -&gt; math.Tensor:
    &#34;&#34;&#34;
    Similar to `sample()`, but matches an optional `vector_` dimension of `geometry` with the `vector` dimension of this field.

    See Also:
        `sample()`, `Field.at()`.

    Args:
        field: Source `Field` to sample.
        geometry: Single or batched `phi.geom.Geometry`.

    Returns:
        Sampled values as a `phi.math.Tensor`
    &#34;&#34;&#34;
    if isinstance(field, SampledField) and field.elements.shallow_equals(geometry):
        return field.values
    assert &#39;vector&#39; not in geometry.shape
    if &#39;vector_&#39; in geometry.shape:
        components = unstack(field, &#39;vector&#39;) if &#39;vector&#39; in field.shape else (field,) * geometry.shape.get_size(&#39;vector_&#39;)
        sampled = [c._sample(p) for c, p in zip(components, geometry.unstack(&#39;vector_&#39;))]
        return math.channel_stack(sampled, &#39;vector&#39;)
    else:
        return field._sample(geometry)</code></pre>
</details>
</dd>
<dt id="phi.field.round"><code class="name flex">
<span>def <span class="ident">round</span></span>(<span>x) â€‘>Â phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def round_(x) -&gt; Tensor:
    return _backend_op1(x, Backend.round)</code></pre>
</details>
</dd>
<dt id="phi.field.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>field:Â phi.field._field.Field, geometry:Â phi.geom._geom.Geometry) â€‘>Â phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the field value inside the volume of the (batched) <code>geometry</code>.</p>
<p>The field value may be determined by integrating over the volume, sampling the central value or any other way.</p>
<p>The batch dimensions of <code>geometry</code> are matched with this field.
The <code>geometry</code> must not share any channel dimensions with this field.
Spatial dimensions of <code>geometry</code> can be used to sample a grid of geometries.</p>
<p>See Also:
<code><a title="phi.field.reduce_sample" href="#phi.field.reduce_sample">reduce_sample()</a></code>, <code><a title="phi.field.Field.at" href="#phi.field.Field.at">Field.at()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>field</code></strong></dt>
<dd>Source <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> to sample.</dd>
<dt><strong><code>geometry</code></strong></dt>
<dd>Single or batched <code><a title="phi.geom.Geometry" href="../geom/index.html#phi.geom.Geometry">Geometry</a></code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Sampled values as a <code><a title="phi.math.Tensor" href="../math/index.html#phi.math.Tensor">Tensor</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample(field: Field, geometry: Geometry) -&gt; math.Tensor:
    &#34;&#34;&#34;
    Computes the field value inside the volume of the (batched) `geometry`.

    The field value may be determined by integrating over the volume, sampling the central value or any other way.

    The batch dimensions of `geometry` are matched with this field.
    The `geometry` must not share any channel dimensions with this field.
    Spatial dimensions of `geometry` can be used to sample a grid of geometries.

    See Also:
        `reduce_sample()`, `Field.at()`.

    Args:
        field: Source `Field` to sample.
        geometry: Single or batched `phi.geom.Geometry`.

    Returns:
        Sampled values as a `phi.math.Tensor`
    &#34;&#34;&#34;
    assert all(dim not in field.shape for dim in geometry.shape.channel)
    if isinstance(field, SampledField) and field.elements.shallow_equals(geometry) and &#39;vector_&#39; not in geometry.shape:
        return field.values
    assert &#39;vector&#39; not in geometry.shape
    if &#39;vector_&#39; in geometry.shape:
        sampled = [field._sample(p) for p in geometry.unstack(&#39;vector_&#39;)]
        return math.channel_stack(sampled, &#39;vector_&#39;)
    else:
        return field._sample(geometry)</code></pre>
</details>
</dd>
<dt id="phi.field.shift"><code class="name flex">
<span>def <span class="ident">shift</span></span>(<span>grid:Â phi.field._grid.CenteredGrid, offsets:Â tuple, stack_dim='shift')</span>
</code></dt>
<dd>
<div class="desc"><p>Wraps :func:<code>math.shift</code> for CenteredGrid.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>grid</code></strong></dt>
<dd>CenteredGrid: </dd>
<dt><strong><code>offsets</code></strong></dt>
<dd>tuple: </dd>
<dt><strong><code>stack_dim</code></strong></dt>
<dd>(Default value = 'shift')</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shift(grid: CenteredGrid, offsets: tuple, stack_dim=&#39;shift&#39;):
    &#34;&#34;&#34;
    Wraps :func:`math.shift` for CenteredGrid.

    Args:
      grid: CenteredGrid: 
      offsets: tuple: 
      stack_dim:  (Default value = &#39;shift&#39;)

    Returns:

    &#34;&#34;&#34;
    data = math.shift(grid.values, offsets, padding=grid.extrapolation, stack_dim=stack_dim)
    return [CenteredGrid(data[i], grid.box, grid.extrapolation) for i in range(len(offsets))]</code></pre>
</details>
</dd>
<dt id="phi.field.sign"><code class="name flex">
<span>def <span class="ident">sign</span></span>(<span>x) â€‘>Â phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sign(x) -&gt; Tensor:
    return _backend_op1(x, Backend.sign)</code></pre>
</details>
</dd>
<dt id="phi.field.sin"><code class="name flex">
<span>def <span class="ident">sin</span></span>(<span>x) â€‘>Â phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sin(x) -&gt; Tensor:
    return _backend_op1(x, Backend.sin)</code></pre>
</details>
</dd>
<dt id="phi.field.solve_linear"><code class="name flex">
<span>def <span class="ident">solve_linear</span></span>(<span>f:Â Callable[[~X],Â ~Y], y:Â ~Y, solve:Â phi.math._functional.Solve[~X,Â ~Y]) â€‘>Â ~X</span>
</code></dt>
<dd>
<div class="desc"><p>Solves the system of linear equations <em>f(x) = y</em> and returns <em>x</em>.
For maximum performance, compile <code>f</code> using <code><a title="phi.field.jit_compile_linear" href="#phi.field.jit_compile_linear">jit_compile_linear()</a></code> beforehand.
This will use a matrix representation of <code>f</code> to solve the linear system.</p>
<p>To obtain additional information about the performed solve, use a <code>SolveTape</code>.</p>
<p>The gradient of this operation will perform another linear solve with the parameters specified by <code>Solve.gradient_solve</code>.</p>
<p>See Also:
<code><a title="phi.field.solve_nonlinear" href="#phi.field.solve_nonlinear">solve_nonlinear()</a></code>, <code><a title="phi.field.jit_compile_linear" href="#phi.field.jit_compile_linear">jit_compile_linear()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>f</code></strong></dt>
<dd>Linear function with single <code>Tensor</code> or <code>TensorLike</code> positional argument and return value.</dd>
<dt><strong><code>y</code></strong></dt>
<dd>Desired output of <code>f(x)</code> as <code>Tensor</code> or <code>TensorLike</code>.</dd>
<dt><strong><code>solve</code></strong></dt>
<dd><code>Solve</code> object specifying optimization method, parameters and initial guess for <code>x</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>x</code></dt>
<dd>solution of the linear system of equations <code>f(x) = y</code> as <code>Tensor</code> or <code>TensorLike</code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NotConverged</code></dt>
<dd>If the desired accuracy was not be reached within the maximum number of iterations.</dd>
<dt><code>Diverged</code></dt>
<dd>If the solve failed prematurely.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def solve_linear(f: Callable[[X], Y], y: Y, solve: Solve[X, Y]) -&gt; X:
    &#34;&#34;&#34;
    Solves the system of linear equations *f(x) = y* and returns *x*.
    For maximum performance, compile `f` using `jit_compile_linear()` beforehand.
    This will use a matrix representation of `f` to solve the linear system.

    To obtain additional information about the performed solve, use a `SolveTape`.

    The gradient of this operation will perform another linear solve with the parameters specified by `Solve.gradient_solve`.

    See Also:
        `solve_nonlinear()`, `jit_compile_linear()`.

    Args:
        f: Linear function with single `Tensor` or `TensorLike` positional argument and return value.
        y: Desired output of `f(x)` as `Tensor` or `TensorLike`.
        solve: `Solve` object specifying optimization method, parameters and initial guess for `x`.

    Returns:
        x: solution of the linear system of equations `f(x) = y` as `Tensor` or `TensorLike`.

    Raises:
        NotConverged: If the desired accuracy was not be reached within the maximum number of iterations.
        Diverged: If the solve failed prematurely.
    &#34;&#34;&#34;
    y_nest, y_tensors = disassemble_nested(y)
    x0_nest, x0_tensors = disassemble_nested(solve.x0)
    assert len(x0_tensors) == len(y_tensors) == 1, &#34;Only single-tensor linear solves are currently supported&#34;
    backend = choose_backend_t(*y_tensors, *x0_tensors)

    if not all_available(*y_tensors, *x0_tensors):  # jit mode
        f = jit_compile_linear(f) if backend.supports(Backend.sparse_tensor) else jit_compile(f)

    if isinstance(f, LinearFunction) and backend.supports(Backend.sparse_tensor):
        matrix = f.sparse_coordinate_matrix(solve.x0)
        return _matrix_solve(y, solve, matrix, backend=backend)  # custom_gradient
    else:
        return _function_solve(y, solve, f=f, backend=backend)  # custom_gradient</code></pre>
</details>
</dd>
<dt id="phi.field.solve_nonlinear"><code class="name flex">
<span>def <span class="ident">solve_nonlinear</span></span>(<span>f:Â Callable, y, solve:Â phi.math._functional.Solve) â€‘>Â phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Solves the non-linear equation <em>f(x) = y</em> by minimizing the norm of the residual.</p>
<p>This method is limited to backends that support <code><a title="phi.field.functional_gradient" href="#phi.field.functional_gradient">functional_gradient()</a></code>, currently PyTorch, TensorFlow and Jax.</p>
<p>To obtain additional information about the performed solve, use a <code>SolveTape</code>.</p>
<p>See Also:
<code><a title="phi.field.minimize" href="#phi.field.minimize">minimize()</a></code>, <code><a title="phi.field.solve_linear" href="#phi.field.solve_linear">solve_linear()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>f</code></strong></dt>
<dd>Function whose output is optimized to match <code>y</code>.
All positional arguments of <code>f</code> are optimized and must be <code>Tensor</code> or <code>TensorLike</code>.
The output of <code>f</code> must match <code>y</code>.</dd>
<dt><strong><code>y</code></strong></dt>
<dd>Desired output of <code>f(x)</code> as <code>Tensor</code> or <code>TensorLike</code>.</dd>
<dt><strong><code>solve</code></strong></dt>
<dd><code>Solve</code> object specifying optimization method, parameters and initial guess for <code>x</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>x</code></dt>
<dd>Solution fulfilling <code>f(x) = y</code> within specified tolerance as <code>Tensor</code> or <code>TensorLike</code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NotConverged</code></dt>
<dd>If the desired accuracy was not be reached within the maximum number of iterations.</dd>
<dt><code>Diverged</code></dt>
<dd>If the solve failed prematurely.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def solve_nonlinear(f: Callable, y, solve: Solve) -&gt; Tensor:
    &#34;&#34;&#34;
    Solves the non-linear equation *f(x) = y* by minimizing the norm of the residual.

    This method is limited to backends that support `functional_gradient()`, currently PyTorch, TensorFlow and Jax.

    To obtain additional information about the performed solve, use a `SolveTape`.

    See Also:
        `minimize()`, `solve_linear()`.

    Args:
        f: Function whose output is optimized to match `y`.
            All positional arguments of `f` are optimized and must be `Tensor` or `TensorLike`.
            The output of `f` must match `y`.
        y: Desired output of `f(x)` as `Tensor` or `TensorLike`.
        solve: `Solve` object specifying optimization method, parameters and initial guess for `x`.

    Returns:
        x: Solution fulfilling `f(x) = y` within specified tolerance as `Tensor` or `TensorLike`.

    Raises:
        NotConverged: If the desired accuracy was not be reached within the maximum number of iterations.
        Diverged: If the solve failed prematurely.
    &#34;&#34;&#34;
    from ._nd import l2_loss

    def min_func(x):
        diff = f(x) - y
        l2 = l2_loss(diff)
        return l2

    rel_tol_to_abs = solve.relative_tolerance * l2_loss(y, batch_norm=True)
    solve.absolute_tolerance = rel_tol_to_abs
    solve.relative_tolerance = 0
    return minimize(min_func, solve)</code></pre>
</details>
</dd>
<dt id="phi.field.spatial_gradient"><code class="name flex">
<span>def <span class="ident">spatial_gradient</span></span>(<span>field:Â phi.field._grid.CenteredGrid, type:Â typeÂ =Â phi.field._grid.CenteredGrid, stack_dim='vector')</span>
</code></dt>
<dd>
<div class="desc"><p>Finite difference spatial_gradient.</p>
<p>This function can operate in two modes:</p>
<ul>
<li><code>type=CenteredGrid</code> approximates the spatial_gradient at cell centers using central differences</li>
<li><code>type=StaggeredGrid</code> computes the spatial_gradient at face centers of neighbouring cells</li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>field</code></strong></dt>
<dd>centered grid of any number of dimensions (scalar field, vector field, tensor field)</dd>
<dt><strong><code>type</code></strong></dt>
<dd>either <code><a title="phi.field.CenteredGrid" href="#phi.field.CenteredGrid">CenteredGrid</a></code> or <code><a title="phi.field.StaggeredGrid" href="#phi.field.StaggeredGrid">StaggeredGrid</a></code></dd>
<dt><strong><code>stack_dim</code></strong></dt>
<dd>name of dimension to be added. This dimension lists the spatial_gradient w.r.t. the spatial dimensions.
The <code>field</code> must not have a dimension of the same name.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>spatial_gradient field of type <code>type</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def spatial_gradient(field: CenteredGrid, type: type = CenteredGrid, stack_dim=&#39;vector&#39;):
    &#34;&#34;&#34;
    Finite difference spatial_gradient.

    This function can operate in two modes:

    * `type=CenteredGrid` approximates the spatial_gradient at cell centers using central differences
    * `type=StaggeredGrid` computes the spatial_gradient at face centers of neighbouring cells

    Args:
        field: centered grid of any number of dimensions (scalar field, vector field, tensor field)
        type: either `CenteredGrid` or `StaggeredGrid`
        stack_dim: name of dimension to be added. This dimension lists the spatial_gradient w.r.t. the spatial dimensions.
            The `field` must not have a dimension of the same name.

    Returns:
        spatial_gradient field of type `type`.

    &#34;&#34;&#34;
    assert isinstance(field, Grid)
    if type == CenteredGrid:
        values = math.spatial_gradient(field.values, field.dx.vector.as_channel(name=stack_dim), difference=&#39;central&#39;, padding=field.extrapolation, stack_dim=stack_dim)
        return CenteredGrid(values, field.bounds, field.extrapolation.spatial_gradient())
    elif type == StaggeredGrid:
        assert stack_dim == &#39;vector&#39;
        return stagger(field, lambda lower, upper: (upper - lower) / field.dx, field.extrapolation.spatial_gradient())
    raise NotImplementedError(f&#34;{type(field)} not supported. Only CenteredGrid and StaggeredGrid allowed.&#34;)</code></pre>
</details>
</dd>
<dt id="phi.field.sqrt"><code class="name flex">
<span>def <span class="ident">sqrt</span></span>(<span>x) â€‘>Â phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sqrt(x) -&gt; Tensor:
    return _backend_op1(x, Backend.sqrt)</code></pre>
</details>
</dd>
<dt id="phi.field.stack_staggered_components"><code class="name flex">
<span>def <span class="ident">stack_staggered_components</span></span>(<span>data:Â phi.math._tensors.Tensor) â€‘>Â phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stack_staggered_components(data: Tensor) -&gt; Tensor:
    padded = []
    for dim, component in zip(data.shape.spatial.names, data.unstack(&#39;vector&#39;)):
        padded.append(math.pad(component, {d: (0, 1) for d in data.shape.spatial.without(dim).names}, mode=math.extrapolation.ZERO))
    return math.channel_stack(padded, &#39;vector&#39;)</code></pre>
</details>
</dd>
<dt id="phi.field.stagger"><code class="name flex">
<span>def <span class="ident">stagger</span></span>(<span>field:Â phi.field._grid.CenteredGrid, face_function:Â Callable, extrapolation:Â <a title="phi.math.extrapolation.Extrapolation" href="../math/extrapolation.html#phi.math.extrapolation.Extrapolation">Extrapolation</a>, type:Â typeÂ =Â phi.field._grid.StaggeredGrid)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new grid by evaluating <code>face_function</code> given two neighbouring cells.
One layer of missing cells is inferred from the extrapolation.</p>
<p>This method returns a Field of type <code>type</code> which must be either StaggeredGrid or CenteredGrid.
When returning a StaggeredGrid, the new values are sampled at the faces of neighbouring cells.
When returning a CenteredGrid, the new grid has the same resolution as <code>field</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>field</code></strong></dt>
<dd>centered grid</dd>
<dt><strong><code>face_function</code></strong></dt>
<dd>function mapping (value1: Tensor, value2: Tensor) -&gt; center_value: Tensor</dd>
<dt><strong><code>extrapolation</code></strong></dt>
<dd>extrapolation mode of the returned grid. Has no effect on the values.</dd>
<dt><strong><code>type</code></strong></dt>
<dd>one of (StaggeredGrid, CenteredGrid)</dd>
<dt><strong><code>field</code></strong></dt>
<dd>CenteredGrid: </dd>
<dt><strong><code>face_function</code></strong></dt>
<dd>Callable:</dd>
<dt><strong><code>extrapolation</code></strong></dt>
<dd>math.extrapolation.Extrapolation: </dd>
<dt><strong><code>type</code></strong></dt>
<dd>type:
(Default value = StaggeredGrid)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>grid of type matching the <code>type</code> argument</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stagger(field: CenteredGrid,
            face_function: Callable,
            extrapolation: math.extrapolation.Extrapolation,
            type: type = StaggeredGrid):
    &#34;&#34;&#34;
    Creates a new grid by evaluating `face_function` given two neighbouring cells.
    One layer of missing cells is inferred from the extrapolation.
    
    This method returns a Field of type `type` which must be either StaggeredGrid or CenteredGrid.
    When returning a StaggeredGrid, the new values are sampled at the faces of neighbouring cells.
    When returning a CenteredGrid, the new grid has the same resolution as `field`.

    Args:
      field: centered grid
      face_function: function mapping (value1: Tensor, value2: Tensor) -&gt; center_value: Tensor
      extrapolation: extrapolation mode of the returned grid. Has no effect on the values.
      type: one of (StaggeredGrid, CenteredGrid)
      field: CenteredGrid: 
      face_function: Callable:
      extrapolation: math.extrapolation.Extrapolation: 
      type: type:  (Default value = StaggeredGrid)

    Returns:
      grid of type matching the `type` argument

    &#34;&#34;&#34;
    all_lower = []
    all_upper = []
    if type == StaggeredGrid:
        for dim in field.shape.spatial.names:
            all_upper.append(math.pad(field.values, {dim: (0, 1)}, field.extrapolation))
            all_lower.append(math.pad(field.values, {dim: (1, 0)}, field.extrapolation))
        all_upper = math.channel_stack(all_upper, &#39;vector&#39;)
        all_lower = math.channel_stack(all_lower, &#39;vector&#39;)
        values = face_function(all_lower, all_upper)
        return StaggeredGrid(values, field.bounds, extrapolation)
    elif type == CenteredGrid:
        left, right = math.shift(field.values, (-1, 1), padding=field.extrapolation, stack_dim=&#39;vector&#39;)
        values = face_function(left, right)
        return CenteredGrid(values, field.bounds, extrapolation)
    else:
        raise ValueError(type)</code></pre>
</details>
</dd>
<dt id="phi.field.stop_gradient"><code class="name flex">
<span>def <span class="ident">stop_gradient</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"><p>Disables gradients for the given tensor.
This may switch off the gradients for <code>value</code> itself or create a copy of <code>value</code> with disabled gradients.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong></dt>
<dd><code>Tensor</code> or <code>TensorLike</code> for which gradients should be disabled.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Copy of <code>x</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop_gradient(x):
    &#34;&#34;&#34;
    Disables gradients for the given tensor.
    This may switch off the gradients for `value` itself or create a copy of `value` with disabled gradients.

    Args:
        x: `Tensor` or `TensorLike` for which gradients should be disabled.

    Returns:
        Copy of `x`.
    &#34;&#34;&#34;
    if isinstance(x, Tensor):
        return x._op1(lambda native: choose_backend(native).stop_gradient(native))
    elif isinstance(x, TensorLike):
        nest, values = disassemble_nested(x)
        new_values = [stop_gradient(v) for v in values]
        return assemble_nested(nest, new_values)
    else:
        return wrap(choose_backend(x).stop_gradient(x))</code></pre>
</details>
</dd>
<dt id="phi.field.to_float"><code class="name flex">
<span>def <span class="ident">to_float</span></span>(<span>x) â€‘>Â phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Converts the given tensor to floating point format with the currently specified precision.</p>
<p>The precision can be set globally using <code>math.set_global_precision()</code> and locally using <code>with math.precision()</code>.</p>
<p>See the <code><a title="phi.math" href="../math/index.html">phi.math</a></code> module documentation at <a href="https://tum-pbs.github.io/PhiFlow/Math.html">https://tum-pbs.github.io/PhiFlow/Math.html</a></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong></dt>
<dd>values to convert</dd>
<dt><strong><code>x</code></strong></dt>
<dd>Tensor: </dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Tensor of same shape as <code>x</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_float(x) -&gt; Tensor:
    &#34;&#34;&#34;
    Converts the given tensor to floating point format with the currently specified precision.
    
    The precision can be set globally using `math.set_global_precision()` and locally using `with math.precision()`.
    
    See the `phi.math` module documentation at https://tum-pbs.github.io/PhiFlow/Math.html

    Args:
      x: values to convert
      x: Tensor: 

    Returns:
      Tensor of same shape as `x`

    &#34;&#34;&#34;
    return _backend_op1(x, Backend.to_float)</code></pre>
</details>
</dd>
<dt id="phi.field.to_int32"><code class="name flex">
<span>def <span class="ident">to_int32</span></span>(<span>x) â€‘>Â phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_int32(x) -&gt; Tensor:
    return _backend_op1(x, Backend.to_int32)</code></pre>
</details>
</dd>
<dt id="phi.field.to_int64"><code class="name flex">
<span>def <span class="ident">to_int64</span></span>(<span>x) â€‘>Â phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_int64(x) -&gt; Tensor:
    return _backend_op1(x, Backend.to_int64)</code></pre>
</details>
</dd>
<dt id="phi.field.unstack"><code class="name flex">
<span>def <span class="ident">unstack</span></span>(<span>field:Â phi.field._field.Field, dim:Â str) â€‘>Â tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Unstack <code>field</code> along one of its dimensions.
The dimension can be batch, spatial or channel.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>field</code></strong></dt>
<dd><code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> to unstack.</dd>
<dt><strong><code>dim</code></strong></dt>
<dd>name of the dimension to unstack, must be part of <code>self.shape</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>tuple</code> of <code>Fields</code>. The returned fields may be of different types than <code>field</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unstack(field: Field, dim: str) -&gt; tuple:
    &#34;&#34;&#34;
    Unstack `field` along one of its dimensions.
    The dimension can be batch, spatial or channel.

    Args:
        field: `Field` to unstack.
        dim: name of the dimension to unstack, must be part of `self.shape`

    Returns:
        `tuple` of `Fields`. The returned fields may be of different types than `field`.
    &#34;&#34;&#34;
    size = field.shape.get_size(dim)
    if isinstance(size, Tensor):
        size = math.min(size)  # unstack StaggeredGrid along x or y
    return tuple(field[{dim: i}] for i in range(size))</code></pre>
</details>
</dd>
<dt id="phi.field.unstack_staggered_tensor"><code class="name flex">
<span>def <span class="ident">unstack_staggered_tensor</span></span>(<span>data:Â phi.math._tensors.Tensor) â€‘>Â phi.math._tensors.TensorStack</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unstack_staggered_tensor(data: Tensor) -&gt; TensorStack:
    sliced = []
    for dim, component in zip(data.shape.spatial.names, data.unstack(&#39;vector&#39;)):
        sliced.append(component[{d: slice(None, -1) for d in data.shape.spatial.without(dim).names}])
    return math.channel_stack(sliced, &#39;vector&#39;)</code></pre>
</details>
</dd>
<dt id="phi.field.upsample2x"><code class="name flex">
<span>def <span class="ident">upsample2x</span></span>(<span>grid:Â ~GridType) â€‘>Â ~GridType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def upsample2x(grid: GridType) -&gt; GridType:
    if isinstance(grid, CenteredGrid):
        values = math.upsample2x(grid.values, grid.extrapolation)
        return CenteredGrid(values, grid.bounds, grid.extrapolation)
    elif isinstance(grid, StaggeredGrid):
        raise NotImplementedError()
    else:
        raise ValueError(type(grid))</code></pre>
</details>
</dd>
<dt id="phi.field.vec_abs"><code class="name flex">
<span>def <span class="ident">vec_abs</span></span>(<span>field:Â phi.field._field.SampledField)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="phi.math.vec_abs" href="../math/index.html#phi.math.vec_abs">vec_abs()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vec_abs(field: SampledField):
    &#34;&#34;&#34; See `phi.math.vec_abs()` &#34;&#34;&#34;
    if isinstance(field, StaggeredGrid):
        field = field.at_centers()
    return field.with_(values=math.vec_abs(field.values))</code></pre>
</details>
</dd>
<dt id="phi.field.vec_squared"><code class="name flex">
<span>def <span class="ident">vec_squared</span></span>(<span>field:Â phi.field._field.SampledField)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="phi.math.vec_squared" href="../math/index.html#phi.math.vec_squared">vec_squared()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vec_squared(field: SampledField):
    &#34;&#34;&#34; See `phi.math.vec_squared()` &#34;&#34;&#34;
    if isinstance(field, StaggeredGrid):
        field = field.at_centers()
    return field.with_(values=math.vec_squared(field.values))</code></pre>
</details>
</dd>
<dt id="phi.field.where"><code class="name flex">
<span>def <span class="ident">where</span></span>(<span>mask:Â phi.field._field.Field, field_true:Â phi.field._field.Field, field_false:Â phi.field._field.Field)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def where(mask: Field or Geometry, field_true: Field, field_false: Field):
    if isinstance(mask, Geometry):
        mask = HardGeometryMask(mask)
    elif isinstance(mask, SampledField):
        field_true = field_true.at(mask)
        field_false = field_false.at(mask)
    elif isinstance(field_true, SampledField):
        mask = mask.at(field_true)
        field_false = field_false.at(field_true)
    elif isinstance(field_false, SampledField):
        mask = mask.at(field_true)
        field_true = field_true.at(mask)
    else:
        raise NotImplementedError(&#39;At least one argument must be a SampledField&#39;)
    values = mask.values * field_true.values + (1 - mask.values) * field_false.values
    # values = math.where(mask.values, field_true.values, field_false.values)
    return field_true.with_(values=values)</code></pre>
</details>
</dd>
<dt id="phi.field.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>field:Â phi.field._field.SampledField, file:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>Writes a field to disc using a NumPy file format.
Depending on <code>file</code>, the data may be split up into multiple files.</p>
<p>All characteristics of the field are serialized so that it can be fully restored using <code><a title="phi.field.read" href="#phi.field.read">read()</a></code>.</p>
<p>See Also:
<code><a title="phi.field.read" href="#phi.field.read">read()</a></code></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>field</code></strong></dt>
<dd>Field to be saved.</dd>
<dt><strong><code>file</code></strong></dt>
<dd>Single file as <code>str</code> or <code>Tensor</code> of string type.
If <code>file</code> is a tensor, the dimensions of <code>field</code> are matched to the dimensions of <code>file</code>.
Dimensions of <code>file</code> that are missing in <code>field</code> result in data duplication.
Dimensions of <code>field</code> that are missing in <code>file</code> result in larger files.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(field: SampledField, file: str or math.Tensor):
    &#34;&#34;&#34;
    Writes a field to disc using a NumPy file format.
    Depending on `file`, the data may be split up into multiple files.

    All characteristics of the field are serialized so that it can be fully restored using `read()`.

    See Also:
        `read()`

    Args:
        field: Field to be saved.
        file: Single file as `str` or `Tensor` of string type.
            If `file` is a tensor, the dimensions of `field` are matched to the dimensions of `file`.
            Dimensions of `file` that are missing in `field` result in data duplication.
            Dimensions of `field` that are missing in `file` result in larger files.
    &#34;&#34;&#34;
    if isinstance(file, str):
        write_single_field(field, file)
    elif isinstance(file, math.Tensor):
        if file.rank == 0:
            write_single_field(field, file.native())
        else:
            dim = file.shape.names[0]
            files = file.unstack(dim)
            fields = field.dimension(dim).unstack(file.shape.get_size(dim))
            for field_, file_ in zip(fields, files):
                write(field_, file_)
    else:
        raise ValueError(file)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="phi.field.AngularVelocity"><code class="flex name class">
<span>class <span class="ident">AngularVelocity</span></span>
<span>(</span><span>location, strength=1.0, falloff:Â collections.abc.CallableÂ =Â None, component:Â strÂ =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for all fields.</p>
<p>Important implementations:</p>
<ul>
<li>CenteredGrid</li>
<li>StaggeredGrid</li>
<li>PointCloud</li>
<li>Noise</li>
</ul>
<p>See the <code><a title="phi.field" href="#phi.field">phi.field</a></code> module documentation at <a href="https://tum-pbs.github.io/PhiFlow/Fields.html">https://tum-pbs.github.io/PhiFlow/Fields.html</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AngularVelocity(Field):

    def __init__(self, location, strength=1.0, falloff: Callable = None, component: str = None):
        location = math.wrap(location)
        assert location.shape.channel.names == (&#39;vector&#39;,), &#34;location must have a single channel dimension called &#39;vector&#39;&#34;
        assert location.shape.spatial.is_empty, &#34;location tensor cannot have any spatial dimensions&#34;
        self.location = location
        self.strength = strength
        self.falloff = falloff
        self.component = component
        spatial_names = [GLOBAL_AXIS_ORDER.axis_name(i, location.vector.size) for i in range(location.vector.size)]
        self._shape = location.shape.combined(math.spatial_shape([1] * location.vector.size, spatial_names))

    def _sample(self, geometry: Geometry) -&gt; math.Tensor:
        points = geometry.center
        distances = points - self.location
        strength = self.strength if self.falloff is None else self.strength * self.falloff(distances)
        velocity = math.cross_product(strength, distances)
        velocity = math.sum(velocity, self.location.shape.batch.without(points.shape))
        if self.component:
            velocity = velocity.vector[self.component]
        return velocity

    @property
    def shape(self) -&gt; Shape:
        return self._shape

    def __getitem__(self, item: dict):
        assert all(dim == &#39;vector&#39; for dim in item), f&#34;Cannot slice AngularVelocity with {item}&#34;
        if &#39;vector&#39; in item:
            assert item[&#39;vector&#39;] == 0 or self.component is None
            component = self.shape.spatial.names[item[&#39;vector&#39;]]
            return AngularVelocity(location=self.location, strength=self.strength, falloff=self.falloff, component=component)
        else:
            return self</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.field._field.Field</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="phi.field.AngularVelocity.shape"><code class="name">var <span class="ident">shape</span> :Â phi.math._shape.Shape</code></dt>
<dd>
<div class="desc"><p>Returns a shape with the following properties</p>
<ul>
<li>The spatial dimension names match the dimensions of this Field</li>
<li>The batch dimensions match the batch dimensions of this Field</li>
<li>The channel dimensions match the channels of this Field</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape(self) -&gt; Shape:
    return self._shape</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="phi.field.CenteredGrid"><code class="flex name class">
<span>class <span class="ident">CenteredGrid</span></span>
<span>(</span><span>values:Â phi.math._tensors.Tensor, bounds:Â phi.geom._box.Box, extrapolation:Â <a title="phi.math.extrapolation.Extrapolation" href="../math/extrapolation.html#phi.math.extrapolation.Extrapolation">Extrapolation</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>N-dimensional grid with values sampled at the cell centers.
A centered grid is defined through its data tensor, its bounds describing the physical size, and its extrapolation.</p>
<p>Centered grids support arbitrary batch, spatial and channel dimensions.</p>
<p>Use <code><a title="phi.field.grid" href="#phi.field.grid">grid()</a></code> with <code>type=CenteredGrid</code> (default) to create a centered grid.
Alternatively, the <code><a title="phi.physics.Domain" href="../physics/index.html#phi.physics.Domain">Domain</a></code> class provides convenience methods for grid creation.</p>
<p>See the <code><a title="phi.field" href="#phi.field">phi.field</a></code> module documentation at <a href="https://tum-pbs.github.io/PhiFlow/Fields.html">https://tum-pbs.github.io/PhiFlow/Fields.html</a></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>values</code></strong></dt>
<dd><code><a title="phi.math.Tensor" href="../math/index.html#phi.math.Tensor">Tensor</a></code> containing all dimensions of this grid.</dd>
<dt><strong><code>bounds</code></strong></dt>
<dd>Physical size and location of the grid.</dd>
<dt><strong><code>extrapolation</code></strong></dt>
<dd>The grid extrapolation determines the value outside the <code>values</code> tensor.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CenteredGrid(Grid):
    &#34;&#34;&#34;
    N-dimensional grid with values sampled at the cell centers.
    A centered grid is defined through its data tensor, its bounds describing the physical size, and its extrapolation.
    
    Centered grids support arbitrary batch, spatial and channel dimensions.

    Use `grid()` with `type=CenteredGrid` (default) to create a centered grid.
    Alternatively, the `phi.physics.Domain` class provides convenience methods for grid creation.
    
    See the `phi.field` module documentation at https://tum-pbs.github.io/PhiFlow/Fields.html
    &#34;&#34;&#34;

    def __init__(self, values: math.Tensor, bounds: Box, extrapolation: math.Extrapolation):
        &#34;&#34;&#34;
        Args:
            values: `phi.math.Tensor` containing all dimensions of this grid.
            bounds: Physical size and location of the grid.
            extrapolation: The grid extrapolation determines the value outside the `values` tensor.
        &#34;&#34;&#34;
        Grid.__init__(self, GridCell(values.shape.spatial, bounds), values, extrapolation, values.shape.spatial, bounds)

    def with_(self,
              elements: Geometry or None = None,
              values: Tensor = None,
              extrapolation: math.Extrapolation = None,
              **other_attributes) -&gt; &#39;CenteredGrid&#39;:
        assert elements is None
        assert not other_attributes, f&#34;Invalid attributes for type {type(self)}: {other_attributes}&#34;
        values = values if values is not None else self.values
        extrapolation = extrapolation if extrapolation is not None else self._extrapolation
        return CenteredGrid(values, self.bounds, extrapolation)

    def __getitem__(self, item: dict):
        values = self._values[{dim: slice(sel, sel + 1) if isinstance(sel, int) and dim in self.shape.spatial else sel for dim, sel in item.items()}]
        extrapolation = self._extrapolation[item]
        bounds = self.elements[item].bounds
        return CenteredGrid(values, bounds, extrapolation)

    def _sample(self, geometry: Geometry) -&gt; Tensor:
        if isinstance(geometry, GeometryStack):
            sampled = [self.sample(g) for g in geometry.geometries]
            return math.batch_stack(sampled, geometry.stack_dim_name)
        if isinstance(geometry, GridCell):
            if self.elements == geometry:
                return self.values
            elif math.close(self.dx, geometry.size):
                fast_resampled = self._shift_resample(geometry.resolution, geometry.bounds)
                if fast_resampled is not NotImplemented:
                    return fast_resampled
        points = geometry.center
        local_points = self.box.global_to_local(points) * self.resolution - 0.5
        return math.grid_sample(self.values, local_points, self.extrapolation)

    def _shift_resample(self, resolution: Shape, bounds: Box, threshold=1e-5, max_padding=20):
        assert math.all_available(bounds.lower, bounds.upper), &#34;Shift resampling requires &#39;bounds&#39; to be available.&#34;
        lower = math.to_int32(math.ceil(math.maximum(0, self.box.lower - bounds.lower) / self.dx - threshold))
        upper = math.to_int32(math.ceil(math.maximum(0, bounds.upper - self.box.upper) / self.dx - threshold))
        total_padding = (math.sum(lower) + math.sum(upper)).numpy()
        if total_padding &gt; max_padding:
            return NotImplemented
        elif total_padding &gt; 0:
            from phi.field import pad
            padded = pad(self, {dim: (int(lower[i]), int(upper[i])) for i, dim in enumerate(self.shape.spatial.names)})
            grid_box, grid_resolution, grid_values = padded.box, padded.resolution, padded.values
        else:
            grid_box, grid_resolution, grid_values = self.box, self.resolution, self.values
        origin_in_local = grid_box.global_to_local(bounds.lower) * grid_resolution
        data = math.sample_subgrid(grid_values, origin_in_local, resolution)
        return data

    def closest_values(self, points: Geometry):
        assert &#39;vector&#39; not in points.shape
        local_points = self.box.global_to_local(points.center) * self.resolution - 0.5
        return math.closest_grid_values(self.values, local_points, self.extrapolation)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.field._grid.Grid</li>
<li>phi.field._field.SampledField</li>
<li>phi.field._field.Field</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="phi.field.CenteredGrid.closest_values"><code class="name flex">
<span>def <span class="ident">closest_values</span></span>(<span>self, points:Â phi.geom._geom.Geometry)</span>
</code></dt>
<dd>
<div class="desc"><p>Sample the closest grid point values of this field at the world-space locations (in physical units) given by <code>points</code>.
Points must have a single channel dimension named <code>vector</code>.
It may additionally contain any number of batch and spatial dimensions, all treated as batch dimensions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>points</code></strong></dt>
<dd>world-space locations</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Closest grid point values as a <code>Tensor</code>.
For each dimension, the grid points immediately left and right of the sample points are evaluated.
For each point in <code>points</code>, a <em>2^d</em> cube of points is determined where <em>d</em> is the number of spatial dimensions of this field.
These values are stacked along the new dimensions <code>'closest_&lt;dim&gt;'</code> where <code>&lt;dim&gt;</code> refers to the name of a spatial dimension.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def closest_values(self, points: Geometry):
    assert &#39;vector&#39; not in points.shape
    local_points = self.box.global_to_local(points.center) * self.resolution - 0.5
    return math.closest_grid_values(self.values, local_points, self.extrapolation)</code></pre>
</details>
</dd>
<dt id="phi.field.CenteredGrid.with_"><code class="name flex">
<span>def <span class="ident">with_</span></span>(<span>self, elements:Â phi.geom._geom.GeometryÂ =Â None, values:Â phi.math._tensors.TensorÂ =Â None, extrapolation:Â <a title="phi.math.extrapolation.Extrapolation" href="../math/extrapolation.html#phi.math.extrapolation.Extrapolation">Extrapolation</a>Â =Â None, **other_attributes) â€‘>Â phi.field._grid.CenteredGrid</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a copy of this field with one or more properties changed. <code>None</code> keeps the current value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_(self,
          elements: Geometry or None = None,
          values: Tensor = None,
          extrapolation: math.Extrapolation = None,
          **other_attributes) -&gt; &#39;CenteredGrid&#39;:
    assert elements is None
    assert not other_attributes, f&#34;Invalid attributes for type {type(self)}: {other_attributes}&#34;
    values = values if values is not None else self.values
    extrapolation = extrapolation if extrapolation is not None else self._extrapolation
    return CenteredGrid(values, self.bounds, extrapolation)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="phi.field.ConstantField"><code class="flex name class">
<span>class <span class="ident">ConstantField</span></span>
<span>(</span><span>value=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for all fields.</p>
<p>Important implementations:</p>
<ul>
<li>CenteredGrid</li>
<li>StaggeredGrid</li>
<li>PointCloud</li>
<li>Noise</li>
</ul>
<p>See the <code><a title="phi.field" href="#phi.field">phi.field</a></code> module documentation at <a href="https://tum-pbs.github.io/PhiFlow/Fields.html">https://tum-pbs.github.io/PhiFlow/Fields.html</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConstantField(Field):

    def __init__(self, value=1.0):
        warnings.warn(&#34;ConstantField is deprecated. Use numbers or tuples instead.&#34;, DeprecationWarning)
        self.value = math.wrap(value)

    @property
    def shape(self) -&gt; Shape:
        return self.value.shape

    def _op1(self, operator) -&gt; Field:
        return ConstantField(operator(self.value))

    def _op2(self, other, operator) -&gt; Field:
        return ConstantField(operator(self.value, other))

    def _sample(self, geometry: Geometry) -&gt; math.Tensor:
        return self.value

    def __getitem__(self, item):
        return ConstantField(self.value[item])

    def unstack(self, dimension: str):
        warnings.warn(&#34;ConstantField.unstack() is deprecated. Use field.unstack(ConstantField) instead.&#34;, DeprecationWarning)
        return tuple(ConstantField(v) for v in self.value.unstack(dimension))

    def __repr__(self):
        return repr(self.value)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.field._field.Field</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="phi.field.ConstantField.shape"><code class="name">var <span class="ident">shape</span> :Â phi.math._shape.Shape</code></dt>
<dd>
<div class="desc"><p>Returns a shape with the following properties</p>
<ul>
<li>The spatial dimension names match the dimensions of this Field</li>
<li>The batch dimensions match the batch dimensions of this Field</li>
<li>The channel dimensions match the channels of this Field</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape(self) -&gt; Shape:
    return self.value.shape</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phi.field.ConstantField.unstack"><code class="name flex">
<span>def <span class="ident">unstack</span></span>(<span>self, dimension:Â str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unstack(self, dimension: str):
    warnings.warn(&#34;ConstantField.unstack() is deprecated. Use field.unstack(ConstantField) instead.&#34;, DeprecationWarning)
    return tuple(ConstantField(v) for v in self.value.unstack(dimension))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="phi.field.Field"><code class="flex name class">
<span>class <span class="ident">Field</span></span>
</code></dt>
<dd>
<div class="desc"><p>Base class for all fields.</p>
<p>Important implementations:</p>
<ul>
<li>CenteredGrid</li>
<li>StaggeredGrid</li>
<li>PointCloud</li>
<li>Noise</li>
</ul>
<p>See the <code><a title="phi.field" href="#phi.field">phi.field</a></code> module documentation at <a href="https://tum-pbs.github.io/PhiFlow/Fields.html">https://tum-pbs.github.io/PhiFlow/Fields.html</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Field:
    &#34;&#34;&#34;
    Base class for all fields.
    
    Important implementations:
    
    * CenteredGrid
    * StaggeredGrid
    * PointCloud
    * Noise
    
    See the `phi.field` module documentation at https://tum-pbs.github.io/PhiFlow/Fields.html
    &#34;&#34;&#34;

    @property
    def shape(self) -&gt; Shape:
        &#34;&#34;&#34;
        Returns a shape with the following properties
        
        * The spatial dimension names match the dimensions of this Field
        * The batch dimensions match the batch dimensions of this Field
        * The channel dimensions match the channels of this Field
        &#34;&#34;&#34;
        raise NotImplementedError()

    @property
    def spatial_rank(self) -&gt; int:
        &#34;&#34;&#34;
        Spatial rank of the field (1 for 1D, 2 for 2D, 3 for 3D).
        This is equal to the spatial rank of the `data`.
        &#34;&#34;&#34;
        return self.shape.spatial.rank

    def _sample(self, geometry: Geometry) -&gt; math.Tensor:
        &#34;&#34;&#34; For internal use only. Use `sample()` instead. &#34;&#34;&#34;
        raise NotImplementedError(self)

    def at(self, representation: &#39;SampledField&#39;) -&gt; &#39;SampledField&#39;:
        &#34;&#34;&#34;
        Samples this field at the sample points of `representation`.
        The result will approximate the values of this field on the data structure of `representation`.
        
        Unlike `Field.sample()`, this method returns a `Field` object, not a `Tensor`.

        Equal to `self &gt;&gt; representation`.

        Args:
          representation: Field object defining the sample points. The values of `representation` are ignored.
          representation: SampledField: 

        Returns:
          Field object of same type as `representation`

        &#34;&#34;&#34;
        resampled = reduce_sample(self, representation.elements)
        extrap = self.extrapolation if isinstance(self, SampledField) else representation.extrapolation
        return representation._op1(lambda old: extrap if isinstance(old, math.extrapolation.Extrapolation) else resampled)

    def __rshift__(self, other: &#39;SampledField&#39;):
        &#34;&#34;&#34;
        Resampling operator.

        Args:
            other: instance of SampledField

        Returns:
            Copy of other with values and extrapolation from this Field.
        &#34;&#34;&#34;
        return self.at(other)

    def __getitem__(self, item: dict) -&gt; &#39;Field&#39;:
        &#34;&#34;&#34;
        Access a slice of the Field.
        The returned `Field` may be of a different type than `self`.

        Args:
            item: `dict` mapping dimensions (`str`) to selections (`int` or `slice`)

        Returns:
            Sliced `Field`.
        &#34;&#34;&#34;
        raise NotImplementedError(self)

    def dimension(self, name: str):
        &#34;&#34;&#34;
        Returns a reference to one of the dimensions of this field.

        The dimension reference can be used the same way as a `Tensor` dimension reference.
        Notable properties and methods of a dimension reference are:
        indexing using `[index]`, `unstack()`, `size`, `exists`, `is_batch`, `is_spatial`, `is_channel`.

        A shortcut to calling this function is the syntax `field.&lt;dim_name&gt;` which calls `field.dimension(&lt;dim_name&gt;)`.

        Args:
            name: dimension name

        Returns:
            dimension reference

        &#34;&#34;&#34;
        return _FieldDim(self, name)

    def __getattr__(self, name: str) -&gt; &#39;_FieldDim&#39;:
        if name.startswith(&#39;_&#39;):
            raise AttributeError(f&#34;&#39;{type(self)}&#39; object has no attribute &#39;{name}&#39;&#34;)
        if hasattr(self.__class__, name):
            raise RuntimeError(f&#34;Failed to get attribute &#39;{name}&#39; of {self.__class__}&#34;)
        return _FieldDim(self, name)

    def __repr__(self):
        return f&#34;{self.__class__.__name__} {self.shape}&#34;</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li>phi.field._angular_velocity.AngularVelocity</li>
<li>phi.field._constant.ConstantField</li>
<li>phi.field._field.SampledField</li>
<li>phi.field._mask.HardGeometryMask</li>
<li>phi.field._noise.Noise</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="phi.field.Field.shape"><code class="name">var <span class="ident">shape</span> :Â phi.math._shape.Shape</code></dt>
<dd>
<div class="desc"><p>Returns a shape with the following properties</p>
<ul>
<li>The spatial dimension names match the dimensions of this Field</li>
<li>The batch dimensions match the batch dimensions of this Field</li>
<li>The channel dimensions match the channels of this Field</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape(self) -&gt; Shape:
    &#34;&#34;&#34;
    Returns a shape with the following properties
    
    * The spatial dimension names match the dimensions of this Field
    * The batch dimensions match the batch dimensions of this Field
    * The channel dimensions match the channels of this Field
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="phi.field.Field.spatial_rank"><code class="name">var <span class="ident">spatial_rank</span> :Â int</code></dt>
<dd>
<div class="desc"><p>Spatial rank of the field (1 for 1D, 2 for 2D, 3 for 3D).
This is equal to the spatial rank of the <code>data</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def spatial_rank(self) -&gt; int:
    &#34;&#34;&#34;
    Spatial rank of the field (1 for 1D, 2 for 2D, 3 for 3D).
    This is equal to the spatial rank of the `data`.
    &#34;&#34;&#34;
    return self.shape.spatial.rank</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phi.field.Field.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>self, representation:Â <a title="phi.field.SampledField" href="#phi.field.SampledField">SampledField</a>) â€‘>Â phi.field._field.SampledField</span>
</code></dt>
<dd>
<div class="desc"><p>Samples this field at the sample points of <code>representation</code>.
The result will approximate the values of this field on the data structure of <code>representation</code>.</p>
<p>Unlike <code>Field.sample()</code>, this method returns a <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> object, not a <code>Tensor</code>.</p>
<p>Equal to <code>self &gt;&gt; representation</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>representation</code></strong></dt>
<dd>Field object defining the sample points. The values of <code>representation</code> are ignored.</dd>
<dt><strong><code>representation</code></strong></dt>
<dd>SampledField: </dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Field object of same type as <code>representation</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def at(self, representation: &#39;SampledField&#39;) -&gt; &#39;SampledField&#39;:
    &#34;&#34;&#34;
    Samples this field at the sample points of `representation`.
    The result will approximate the values of this field on the data structure of `representation`.
    
    Unlike `Field.sample()`, this method returns a `Field` object, not a `Tensor`.

    Equal to `self &gt;&gt; representation`.

    Args:
      representation: Field object defining the sample points. The values of `representation` are ignored.
      representation: SampledField: 

    Returns:
      Field object of same type as `representation`

    &#34;&#34;&#34;
    resampled = reduce_sample(self, representation.elements)
    extrap = self.extrapolation if isinstance(self, SampledField) else representation.extrapolation
    return representation._op1(lambda old: extrap if isinstance(old, math.extrapolation.Extrapolation) else resampled)</code></pre>
</details>
</dd>
<dt id="phi.field.Field.dimension"><code class="name flex">
<span>def <span class="ident">dimension</span></span>(<span>self, name:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a reference to one of the dimensions of this field.</p>
<p>The dimension reference can be used the same way as a <code>Tensor</code> dimension reference.
Notable properties and methods of a dimension reference are:
indexing using <code>[index]</code>, <code><a title="phi.field.unstack" href="#phi.field.unstack">unstack()</a></code>, <code>size</code>, <code>exists</code>, <code>is_batch</code>, <code>is_spatial</code>, <code>is_channel</code>.</p>
<p>A shortcut to calling this function is the syntax <code>field.&lt;dim_name&gt;</code> which calls <code>field.dimension(&lt;dim_name&gt;)</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>dimension name</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>dimension reference</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dimension(self, name: str):
    &#34;&#34;&#34;
    Returns a reference to one of the dimensions of this field.

    The dimension reference can be used the same way as a `Tensor` dimension reference.
    Notable properties and methods of a dimension reference are:
    indexing using `[index]`, `unstack()`, `size`, `exists`, `is_batch`, `is_spatial`, `is_channel`.

    A shortcut to calling this function is the syntax `field.&lt;dim_name&gt;` which calls `field.dimension(&lt;dim_name&gt;)`.

    Args:
        name: dimension name

    Returns:
        dimension reference

    &#34;&#34;&#34;
    return _FieldDim(self, name)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="phi.field.Grid"><code class="flex name class">
<span>class <span class="ident">Grid</span></span>
</code></dt>
<dd>
<div class="desc"><p>Base class for <code><a title="phi.field.CenteredGrid" href="#phi.field.CenteredGrid">CenteredGrid</a></code> and <code><a title="phi.field.StaggeredGrid" href="#phi.field.StaggeredGrid">StaggeredGrid</a></code>.</p>
<p>Use <code><a title="phi.field.grid" href="#phi.field.grid">grid()</a></code> to create a grid.
Alternatively, the <code><a title="phi.physics.Domain" href="../physics/index.html#phi.physics.Domain">Domain</a></code> class provides convenience methods for grid creation.</p>
<p>Base class for fields that are sampled at specific locations such as grids or point clouds.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>elements</code></strong></dt>
<dd>Geometry object specifying the sample points and sizes</dd>
<dt><strong><code>values</code></strong></dt>
<dd>values corresponding to elements</dd>
<dt><strong><code>extrapolation</code></strong></dt>
<dd>values outside elements</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Grid(SampledField):
    &#34;&#34;&#34;
    Base class for `CenteredGrid` and `StaggeredGrid`.

    Use `grid()` to create a grid.
    Alternatively, the `phi.physics.Domain` class provides convenience methods for grid creation.
    &#34;&#34;&#34;

    def __init__(self, elements: Geometry, values: Tensor, extrapolation: math.Extrapolation, resolution: Shape, bounds: Box):
        SampledField.__init__(self, elements, values, extrapolation)
        assert values.shape.spatial_rank == elements.spatial_rank, f&#34;Spatial dimensions of values ({values.shape}) do not match elements {elements}&#34;
        assert values.shape.spatial_rank == bounds.spatial_rank, f&#34;Spatial dimensions of values ({values.shape}) do not match elements {elements}&#34;
        self._bounds = bounds
        self._resolution = resolution

    def closest_values(self, points: Geometry):
        &#34;&#34;&#34;
        Sample the closest grid point values of this field at the world-space locations (in physical units) given by `points`.
        Points must have a single channel dimension named `vector`.
        It may additionally contain any number of batch and spatial dimensions, all treated as batch dimensions.

        Args:
            points: world-space locations

        Returns:
            Closest grid point values as a `Tensor`.
            For each dimension, the grid points immediately left and right of the sample points are evaluated.
            For each point in `points`, a *2^d* cube of points is determined where *d* is the number of spatial dimensions of this field.
            These values are stacked along the new dimensions `&#39;closest_&lt;dim&gt;&#39;` where `&lt;dim&gt;` refers to the name of a spatial dimension.
        &#34;&#34;&#34;
        raise NotImplementedError(self)

    def _sample(self, geometry: Geometry) -&gt; math.Tensor:
        raise NotImplementedError(self)

    def with_(self, elements: Geometry or None = None, values: Tensor = None, extrapolation: math.Extrapolation = None, **other_attributes) -&gt; &#39;Grid&#39;:
        raise NotImplementedError(self)

    def __value_attrs__(self):
        return &#39;_values&#39;, &#39;_extrapolation&#39;

    def __variable_attrs__(self):
        return &#39;_values&#39;,

    def __getitem__(self, item: dict) -&gt; &#39;Grid&#39;:
        raise NotImplementedError(self)

    @property
    def shape(self):
        return self._resolution &amp; self._values.shape.non_spatial

    @property
    def bounds(self) -&gt; Box:
        return self._bounds

    @property
    def box(self) -&gt; Box:
        return self._bounds

    @property
    def resolution(self) -&gt; Shape:
        return self._resolution

    @property
    def dx(self) -&gt; Tensor:
        return self.box.size / self.resolution

    def __repr__(self):
        return f&#34;{self.__class__.__name__}[{self.shape.non_spatial &amp; self.resolution}, size={self.box.size}, extrapolation={self._extrapolation}]&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.field._field.SampledField</li>
<li>phi.field._field.Field</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>phi.field._grid.CenteredGrid</li>
<li>phi.field._grid.StaggeredGrid</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="phi.field.Grid.bounds"><code class="name">var <span class="ident">bounds</span> :Â phi.geom._box.Box</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bounds(self) -&gt; Box:
    return self._bounds</code></pre>
</details>
</dd>
<dt id="phi.field.Grid.box"><code class="name">var <span class="ident">box</span> :Â phi.geom._box.Box</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def box(self) -&gt; Box:
    return self._bounds</code></pre>
</details>
</dd>
<dt id="phi.field.Grid.dx"><code class="name">var <span class="ident">dx</span> :Â phi.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def dx(self) -&gt; Tensor:
    return self.box.size / self.resolution</code></pre>
</details>
</dd>
<dt id="phi.field.Grid.resolution"><code class="name">var <span class="ident">resolution</span> :Â phi.math._shape.Shape</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def resolution(self) -&gt; Shape:
    return self._resolution</code></pre>
</details>
</dd>
<dt id="phi.field.Grid.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<div class="desc"><p>Returns a shape with the following properties</p>
<ul>
<li>The spatial dimension names match the dimensions of this Field</li>
<li>The batch dimensions match the batch dimensions of this Field</li>
<li>The channel dimensions match the channels of this Field</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape(self):
    return self._resolution &amp; self._values.shape.non_spatial</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phi.field.Grid.closest_values"><code class="name flex">
<span>def <span class="ident">closest_values</span></span>(<span>self, points:Â phi.geom._geom.Geometry)</span>
</code></dt>
<dd>
<div class="desc"><p>Sample the closest grid point values of this field at the world-space locations (in physical units) given by <code>points</code>.
Points must have a single channel dimension named <code>vector</code>.
It may additionally contain any number of batch and spatial dimensions, all treated as batch dimensions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>points</code></strong></dt>
<dd>world-space locations</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Closest grid point values as a <code>Tensor</code>.
For each dimension, the grid points immediately left and right of the sample points are evaluated.
For each point in <code>points</code>, a <em>2^d</em> cube of points is determined where <em>d</em> is the number of spatial dimensions of this field.
These values are stacked along the new dimensions <code>'closest_&lt;dim&gt;'</code> where <code>&lt;dim&gt;</code> refers to the name of a spatial dimension.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def closest_values(self, points: Geometry):
    &#34;&#34;&#34;
    Sample the closest grid point values of this field at the world-space locations (in physical units) given by `points`.
    Points must have a single channel dimension named `vector`.
    It may additionally contain any number of batch and spatial dimensions, all treated as batch dimensions.

    Args:
        points: world-space locations

    Returns:
        Closest grid point values as a `Tensor`.
        For each dimension, the grid points immediately left and right of the sample points are evaluated.
        For each point in `points`, a *2^d* cube of points is determined where *d* is the number of spatial dimensions of this field.
        These values are stacked along the new dimensions `&#39;closest_&lt;dim&gt;&#39;` where `&lt;dim&gt;` refers to the name of a spatial dimension.
    &#34;&#34;&#34;
    raise NotImplementedError(self)</code></pre>
</details>
</dd>
<dt id="phi.field.Grid.with_"><code class="name flex">
<span>def <span class="ident">with_</span></span>(<span>self, elements:Â phi.geom._geom.GeometryÂ =Â None, values:Â phi.math._tensors.TensorÂ =Â None, extrapolation:Â <a title="phi.math.extrapolation.Extrapolation" href="../math/extrapolation.html#phi.math.extrapolation.Extrapolation">Extrapolation</a>Â =Â None, **other_attributes) â€‘>Â phi.field._grid.Grid</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a copy of this field with one or more properties changed. <code>None</code> keeps the current value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_(self, elements: Geometry or None = None, values: Tensor = None, extrapolation: math.Extrapolation = None, **other_attributes) -&gt; &#39;Grid&#39;:
    raise NotImplementedError(self)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="phi.field.HardGeometryMask"><code class="flex name class">
<span>class <span class="ident">HardGeometryMask</span></span>
<span>(</span><span>geometry:Â phi.geom._geom.Geometry)</span>
</code></dt>
<dd>
<div class="desc"><p>Field that takes the value 1 inside a Geometry object and 0 outside.
For volume sampling, performs sampling at the center points.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HardGeometryMask(Field):
    &#34;&#34;&#34;
    Field that takes the value 1 inside a Geometry object and 0 outside.
    For volume sampling, performs sampling at the center points.
    &#34;&#34;&#34;

    def __init__(self, geometry: Geometry):
        assert isinstance(geometry, Geometry)
        self.geometry = geometry

    @property
    def shape(self):
        return self.geometry.shape.non_channel

    def _sample(self, geometry: Geometry) -&gt; Tensor:
        return math.to_float(self.geometry.lies_inside(geometry.center))

    def __getitem__(self, item: dict):
        return HardGeometryMask(self.geometry[item])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.field._field.Field</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>phi.field._mask.SoftGeometryMask</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="phi.field.HardGeometryMask.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<div class="desc"><p>Returns a shape with the following properties</p>
<ul>
<li>The spatial dimension names match the dimensions of this Field</li>
<li>The batch dimensions match the batch dimensions of this Field</li>
<li>The channel dimensions match the channels of this Field</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape(self):
    return self.geometry.shape.non_channel</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="phi.field.Noise"><code class="flex name class">
<span>class <span class="ident">Noise</span></span>
<span>(</span><span>shape=(), scale=10, smoothness=1.0, **dims)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates random noise fluctuations which can be configured in physical size and smoothness.
Each time values are sampled from a Noise field, a new noise field is generated.</p>
<p>Noise is typically used as an initializer for CenteredGrids or StaggeredGrids.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>shape</code></strong></dt>
<dd>Batch and channel dimensions. Spatial dimensions will be added automatically once sampled on a grid.</dd>
<dt><strong><code>scale</code></strong></dt>
<dd>Size of noise fluctuations in physical units.</dd>
<dt><strong><code>smoothness</code></strong></dt>
<dd>Determines how quickly high frequencies die out.</dd>
<dt><strong><code>**dims</code></strong></dt>
<dd>Additional dimensions, added to <code>shape</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Noise(Field):
    &#34;&#34;&#34;
    Generates random noise fluctuations which can be configured in physical size and smoothness.
    Each time values are sampled from a Noise field, a new noise field is generated.

    Noise is typically used as an initializer for CenteredGrids or StaggeredGrids.
    &#34;&#34;&#34;

    def __init__(self, shape=math.EMPTY_SHAPE, scale=10, smoothness=1.0, **dims):
        &#34;&#34;&#34;
        Args:
          shape: Batch and channel dimensions. Spatial dimensions will be added automatically once sampled on a grid.
          scale: Size of noise fluctuations in physical units.
          smoothness: Determines how quickly high frequencies die out.
          **dims: Additional dimensions, added to `shape`.
        &#34;&#34;&#34;
        self.scale = scale
        self.smoothness = smoothness
        self._shape = shape &amp; math.shape(**dims)

    @property
    def shape(self):
        return self._shape

    def _sample(self, geometry: Geometry) -&gt; Tensor:
        if isinstance(geometry, GridCell):
            return self.grid_sample(geometry.resolution, geometry.grid_size)
        raise NotImplementedError(f&#34;{type(geometry)} not supported. Only GridCell allowed.&#34;)

    def grid_sample(self, resolution: math.Shape, size, shape: math.Shape = None):
        shape = (self._shape if shape is None else shape).combined(resolution)
        rndj = math.to_complex(random_normal(shape)) + 1j * math.to_complex(random_normal(shape))  # Note: there is no complex32
        with math.NUMPY_BACKEND:
            k = math.fftfreq(resolution) * resolution / size * self.scale  # in physical units
            k = math.vec_squared(k)
        lowest_frequency = 0.1
        weight_mask = math.to_float(k &gt; lowest_frequency)
        # --- Compute 1/k ---
        k.native()[(0,) * len(k.shape)] = np.inf
        inv_k = 1 / k
        inv_k.native()[(0,) * len(k.shape)] = 0
        # --- Compute result ---
        fft = rndj * inv_k ** self.smoothness * weight_mask
        array = math.real(math.ifft(fft))
        array /= math.std(array, dim=array.shape.non_batch)
        array -= math.mean(array, dim=array.shape.non_batch)
        array = math.to_float(array)
        return array

    def __getitem__(self, item: dict):
        new_shape = self.shape.after_gather(item)
        return Noise(new_shape, self.scale, self.smoothness)

    def __repr__(self):
        return &#34;%s, scale=%f, smoothness=%f&#34; % (self._shape, self.scale, self.smoothness)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.field._field.Field</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="phi.field.Noise.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<div class="desc"><p>Returns a shape with the following properties</p>
<ul>
<li>The spatial dimension names match the dimensions of this Field</li>
<li>The batch dimensions match the batch dimensions of this Field</li>
<li>The channel dimensions match the channels of this Field</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape(self):
    return self._shape</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phi.field.Noise.grid_sample"><code class="name flex">
<span>def <span class="ident">grid_sample</span></span>(<span>self, resolution:Â phi.math._shape.Shape, size, shape:Â phi.math._shape.ShapeÂ =Â None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def grid_sample(self, resolution: math.Shape, size, shape: math.Shape = None):
    shape = (self._shape if shape is None else shape).combined(resolution)
    rndj = math.to_complex(random_normal(shape)) + 1j * math.to_complex(random_normal(shape))  # Note: there is no complex32
    with math.NUMPY_BACKEND:
        k = math.fftfreq(resolution) * resolution / size * self.scale  # in physical units
        k = math.vec_squared(k)
    lowest_frequency = 0.1
    weight_mask = math.to_float(k &gt; lowest_frequency)
    # --- Compute 1/k ---
    k.native()[(0,) * len(k.shape)] = np.inf
    inv_k = 1 / k
    inv_k.native()[(0,) * len(k.shape)] = 0
    # --- Compute result ---
    fft = rndj * inv_k ** self.smoothness * weight_mask
    array = math.real(math.ifft(fft))
    array /= math.std(array, dim=array.shape.non_batch)
    array -= math.mean(array, dim=array.shape.non_batch)
    array = math.to_float(array)
    return array</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="phi.field.PointCloud"><code class="flex name class">
<span>class <span class="ident">PointCloud</span></span>
<span>(</span><span>elements:Â phi.geom._geom.Geometry, values:Â AnyÂ =Â 1, extrapolation=0, add_overlapping=False, bounds:Â phi.geom._box.BoxÂ =Â None, color:Â strÂ =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for all fields.</p>
<p>Important implementations:</p>
<ul>
<li>CenteredGrid</li>
<li>StaggeredGrid</li>
<li>PointCloud</li>
<li>Noise</li>
</ul>
<p>See the <code><a title="phi.field" href="#phi.field">phi.field</a></code> module documentation at <a href="https://tum-pbs.github.io/PhiFlow/Fields.html">https://tum-pbs.github.io/PhiFlow/Fields.html</a></p>
<p>A point cloud consists of elements at arbitrary locations.
A value or vector is associated with each element.</p>
<p>Outside of elements, the value of the field is determined by the extrapolation.</p>
<p>All points belonging to one example must be listed in the 'points' dimension.</p>
<p>Unlike with GeometryMask, the elements of a PointCloud are assumed to be small.
When sampling this field on a grid, scatter functions may be used.</p>
<p>See the <code><a title="phi.field" href="#phi.field">phi.field</a></code> module documentation at <a href="https://tum-pbs.github.io/PhiFlow/Fields.html">https://tum-pbs.github.io/PhiFlow/Fields.html</a></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>elements</code></strong></dt>
<dd>Geometry object specifying the sample points and sizes</dd>
<dt><strong><code>values</code></strong></dt>
<dd>values corresponding to elements</dd>
<dt><strong><code>extrapolation</code></strong></dt>
<dd>values outside elements</dd>
<dt><strong><code>add_overlapping</code></strong></dt>
<dd>True: values of overlapping geometries are summed. False: values between overlapping geometries are interpolated</dd>
<dt><strong><code>bounds</code></strong></dt>
<dd>(optional) size of the fixed domain in which the points should get visualized. None results in max and min coordinates of points.</dd>
<dt><strong><code>color</code></strong></dt>
<dd>(optional) hex code for color or tensor of colors (same length as elements) in which points should get plotted.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PointCloud(SampledField):

    def __init__(self,
                 elements: Geometry,
                 values: Any = 1,
                 extrapolation=math.extrapolation.ZERO,
                 add_overlapping=False,
                 bounds: Box = None,
                 color: str or Tensor or tuple or list or None = None):
        &#34;&#34;&#34;
        A point cloud consists of elements at arbitrary locations.
        A value or vector is associated with each element.

        Outside of elements, the value of the field is determined by the extrapolation.

        All points belonging to one example must be listed in the &#39;points&#39; dimension.

        Unlike with GeometryMask, the elements of a PointCloud are assumed to be small.
        When sampling this field on a grid, scatter functions may be used.

        See the `phi.field` module documentation at https://tum-pbs.github.io/PhiFlow/Fields.html

        Args:
          elements: Geometry object specifying the sample points and sizes
          values: values corresponding to elements
          extrapolation: values outside elements
          add_overlapping: True: values of overlapping geometries are summed. False: values between overlapping geometries are interpolated
          bounds: (optional) size of the fixed domain in which the points should get visualized. None results in max and min coordinates of points.
          color: (optional) hex code for color or tensor of colors (same length as elements) in which points should get plotted.
        &#34;&#34;&#34;
        SampledField.__init__(self, elements, values, extrapolation)
        self._add_overlapping = add_overlapping
        assert bounds is None or isinstance(bounds, Box), &#39;Invalid bounds.&#39;
        self._bounds = bounds
        assert &#39;points&#39; in self.shape, &#34;Cannot create PointCloud without &#39;points&#39; dimension. Add it either to elements or to values as batch dimension.&#34;
        if color is None:
            color = &#39;#0060ff&#39;
        self._color = math.wrap(color, names=&#39;points&#39;) if isinstance(color, (tuple, list)) else math.wrap(color)

    @property
    def shape(self):
        return self._elements.shape &amp; self._values.shape.non_spatial

    def __getitem__(self, item: dict):
        elements = self.elements[item]
        values = self._values[item]
        color = self._color[item]
        extrapolation = self._extrapolation[item]
        return PointCloud(elements, values, extrapolation, self._add_overlapping, self._bounds, color)

    def with_(self,
              elements: Geometry or None = None,
              values: Tensor = None,
              extrapolation: math.Extrapolation = None,
              add_overlapping: bool or None = None,
              bounds: Box = None,
              color: str or Tensor or tuple or list or None = None,
              **other_attributes) -&gt; &#39;PointCloud&#39;:
        assert not other_attributes, f&#34;Invalid attributes for type {type(self)}: {other_attributes}&#34;
        return PointCloud(elements if elements is not None else self.elements,
                          values if values is not None else self.values,
                          extrapolation if extrapolation is not None else self.extrapolation,
                          add_overlapping if add_overlapping is not None else self._add_overlapping,
                          bounds if bounds is not None else self._bounds,
                          color if color is not None else self._color)

    def __value_attrs__(self):
        return &#39;_values&#39;, &#39;_extrapolation&#39;

    def __variable_attrs__(self):
        return &#39;_values&#39;, &#39;_elements&#39;

    @property
    def bounds(self) -&gt; Box:
        return self._bounds

    @property
    def color(self) -&gt; Tensor:
        return self._color

    def _sample(self, geometry: Geometry) -&gt; Tensor:
        if geometry == self.elements:
            return self.values
        elif isinstance(geometry, GridCell):
            return self._grid_scatter(geometry.bounds, geometry.resolution)
        elif isinstance(geometry, GeometryStack):
            sampled = [self._sample(g) for g in geometry.geometries]
            return math.batch_stack(sampled, geometry.stack_dim_name)
        else:
            raise NotImplementedError()

    def _grid_scatter(self, box: Box, resolution: math.Shape):
        &#34;&#34;&#34;
        Approximately samples this field on a regular grid using math.scatter().

        Args:
          box: physical dimensions of the grid
          resolution: grid resolution
          box: Box: 
          resolution: math.Shape: 

        Returns:
          CenteredGrid

        &#34;&#34;&#34;
        closest_index = box.global_to_local(self.points) * resolution - 0.5
        mode = &#39;add&#39; if self._add_overlapping else &#39;mean&#39;
        base = math.zeros(resolution)
        if isinstance(self.extrapolation, math.extrapolation.ConstantExtrapolation):
            base += self.extrapolation.value
        scattered = math.scatter(base, closest_index, self.values, scatter_dims=(&#39;points&#39;,), mode=mode, outside_handling=&#39;discard&#39;)
        return scattered

    def __repr__(self):
        return &#34;PointCloud[%s]&#34; % (self.shape,)

    def __and__(self, other):
        assert isinstance(other, PointCloud)
        from ._field_math import concat
        return concat(self, other, dim=&#39;points&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.field._field.SampledField</li>
<li>phi.field._field.Field</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="phi.field.PointCloud.bounds"><code class="name">var <span class="ident">bounds</span> :Â phi.geom._box.Box</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bounds(self) -&gt; Box:
    return self._bounds</code></pre>
</details>
</dd>
<dt id="phi.field.PointCloud.color"><code class="name">var <span class="ident">color</span> :Â phi.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def color(self) -&gt; Tensor:
    return self._color</code></pre>
</details>
</dd>
<dt id="phi.field.PointCloud.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<div class="desc"><p>Returns a shape with the following properties</p>
<ul>
<li>The spatial dimension names match the dimensions of this Field</li>
<li>The batch dimensions match the batch dimensions of this Field</li>
<li>The channel dimensions match the channels of this Field</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape(self):
    return self._elements.shape &amp; self._values.shape.non_spatial</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phi.field.PointCloud.with_"><code class="name flex">
<span>def <span class="ident">with_</span></span>(<span>self, elements:Â phi.geom._geom.GeometryÂ =Â None, values:Â phi.math._tensors.TensorÂ =Â None, extrapolation:Â <a title="phi.math.extrapolation.Extrapolation" href="../math/extrapolation.html#phi.math.extrapolation.Extrapolation">Extrapolation</a>Â =Â None, add_overlapping:Â boolÂ =Â None, bounds:Â phi.geom._box.BoxÂ =Â None, color:Â strÂ =Â None, **other_attributes) â€‘>Â phi.field._point_cloud.PointCloud</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a copy of this field with one or more properties changed. <code>None</code> keeps the current value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_(self,
          elements: Geometry or None = None,
          values: Tensor = None,
          extrapolation: math.Extrapolation = None,
          add_overlapping: bool or None = None,
          bounds: Box = None,
          color: str or Tensor or tuple or list or None = None,
          **other_attributes) -&gt; &#39;PointCloud&#39;:
    assert not other_attributes, f&#34;Invalid attributes for type {type(self)}: {other_attributes}&#34;
    return PointCloud(elements if elements is not None else self.elements,
                      values if values is not None else self.values,
                      extrapolation if extrapolation is not None else self.extrapolation,
                      add_overlapping if add_overlapping is not None else self._add_overlapping,
                      bounds if bounds is not None else self._bounds,
                      color if color is not None else self._color)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="phi.field.SampledField"><code class="flex name class">
<span>class <span class="ident">SampledField</span></span>
<span>(</span><span>elements:Â phi.geom._geom.Geometry, values:Â phi.math._tensors.Tensor, extrapolation:Â <a title="phi.math.extrapolation.Extrapolation" href="../math/extrapolation.html#phi.math.extrapolation.Extrapolation">Extrapolation</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for all fields.</p>
<p>Important implementations:</p>
<ul>
<li>CenteredGrid</li>
<li>StaggeredGrid</li>
<li>PointCloud</li>
<li>Noise</li>
</ul>
<p>See the <code><a title="phi.field" href="#phi.field">phi.field</a></code> module documentation at <a href="https://tum-pbs.github.io/PhiFlow/Fields.html">https://tum-pbs.github.io/PhiFlow/Fields.html</a></p>
<p>Base class for fields that are sampled at specific locations such as grids or point clouds.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>elements</code></strong></dt>
<dd>Geometry object specifying the sample points and sizes</dd>
<dt><strong><code>values</code></strong></dt>
<dd>values corresponding to elements</dd>
<dt><strong><code>extrapolation</code></strong></dt>
<dd>values outside elements</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SampledField(Field):

    def __init__(self, elements: Geometry, values: Tensor or float or int, extrapolation: math.Extrapolation):
        &#34;&#34;&#34;
        Base class for fields that are sampled at specific locations such as grids or point clouds.

        Args:
          elements: Geometry object specifying the sample points and sizes
          values: values corresponding to elements
          extrapolation: values outside elements
        &#34;&#34;&#34;
        assert isinstance(extrapolation, (Extrapolation, tuple, list)), extrapolation
        assert isinstance(elements, Geometry), elements
        self._elements = elements
        self._values = math.wrap(values)
        self._extrapolation = extrapolation

    def with_(self,
              elements: Geometry or None = None,
              values: Tensor = None,
              extrapolation: math.Extrapolation = None,
              **other_attributes) -&gt; &#39;SampledFieldType&#39;:
        &#34;&#34;&#34; Creates a copy of this field with one or more properties changed. `None` keeps the current value. &#34;&#34;&#34;
        raise NotImplementedError(self)

    @property
    def shape(self):
        raise NotImplementedError()

    def __getitem__(self, item: dict) -&gt; &#39;Field&#39;:
        raise NotImplementedError(self)

    @property
    def elements(self) -&gt; Geometry:
        &#34;&#34;&#34;
        Returns a geometrical representation of the discretized volume elements.
        The result is a tuple of Geometry objects, each of which can have additional spatial (but not batch) dimensions.
        
        For grids, the geometries are boxes while particle fields may be represented as spheres.
        
        If this Field has no discrete points, this method returns an empty geometry.
        &#34;&#34;&#34;
        return self._elements

    @property
    def points(self) -&gt; Tensor:
        return self.elements.center

    @property
    def values(self) -&gt; Tensor:
        return self._values

    data = values

    @property
    def extrapolation(self) -&gt; Extrapolation:
        return self._extrapolation

    @property
    def shape(self) -&gt; Shape:
        return self._shape

    def __mul__(self, other):
        return self._op2(other, lambda d1, d2: d1 * d2)

    __rmul__ = __mul__

    def __truediv__(self, other):
        return self._op2(other, lambda d1, d2: d1 / d2)

    def __rtruediv__(self, other):
        return self._op2(other, lambda d1, d2: d2 / d1)

    def __sub__(self, other):
        return self._op2(other, lambda d1, d2: d1 - d2)

    def __rsub__(self, other):
        return self._op2(other, lambda d1, d2: d2 - d1)

    def __add__(self, other):
        return self._op2(other, lambda d1, d2: d1 + d2)

    __radd__ = __add__

    def __pow__(self, power, modulo=None):
        return self._op2(power, lambda f, p: f ** p)

    def __neg__(self):
        return self._op1(lambda x: -x)

    def __gt__(self, other):
        return self._op2(other, lambda x, y: x &gt; y)

    def __ge__(self, other):
        return self._op2(other, lambda x, y: x &gt;= y)

    def __lt__(self, other):
        return self._op2(other, lambda x, y: x &lt; y)

    def __le__(self, other):
        return self._op2(other, lambda x, y: x &lt;= y)

    def __abs__(self):
        return self._op1(lambda x: abs(x))

    def _op1(self: &#39;SampledFieldType&#39;, operator: Callable) -&gt; &#39;SampledFieldType&#39;:
        &#34;&#34;&#34;
        Perform an operation on the data of this field.

        Args:
          operator: function that accepts tensors and extrapolations and returns objects of the same type and dimensions

        Returns:
          Field of same type
        &#34;&#34;&#34;
        values = operator(self.values)
        extrapolation_ = operator(self._extrapolation)
        return self.with_(values=values, extrapolation=extrapolation_)

    def _op2(self, other, operator) -&gt; &#39;SampledField&#39;:
        if isinstance(other, Field):
            other_values = reduce_sample(other, self._elements)
            values = operator(self._values, other_values)
            extrapolation_ = operator(self._extrapolation, other.extrapolation)
            return self.with_(values=values, extrapolation=extrapolation_)
        else:
            other = math.tensor(other)
            values = operator(self._values, other)
            return self.with_(values=values)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.field._field.Field</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>phi.field._grid.Grid</li>
<li>phi.field._point_cloud.PointCloud</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="phi.field.SampledField.data"><code class="name">var <span class="ident">data</span> :Â phi.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def values(self) -&gt; Tensor:
    return self._values</code></pre>
</details>
</dd>
<dt id="phi.field.SampledField.elements"><code class="name">var <span class="ident">elements</span> :Â phi.geom._geom.Geometry</code></dt>
<dd>
<div class="desc"><p>Returns a geometrical representation of the discretized volume elements.
The result is a tuple of Geometry objects, each of which can have additional spatial (but not batch) dimensions.</p>
<p>For grids, the geometries are boxes while particle fields may be represented as spheres.</p>
<p>If this Field has no discrete points, this method returns an empty geometry.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def elements(self) -&gt; Geometry:
    &#34;&#34;&#34;
    Returns a geometrical representation of the discretized volume elements.
    The result is a tuple of Geometry objects, each of which can have additional spatial (but not batch) dimensions.
    
    For grids, the geometries are boxes while particle fields may be represented as spheres.
    
    If this Field has no discrete points, this method returns an empty geometry.
    &#34;&#34;&#34;
    return self._elements</code></pre>
</details>
</dd>
<dt id="phi.field.SampledField.extrapolation"><code class="name">var <span class="ident">extrapolation</span> :Â <a title="phi.math.extrapolation.Extrapolation" href="../math/extrapolation.html#phi.math.extrapolation.Extrapolation">Extrapolation</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def extrapolation(self) -&gt; Extrapolation:
    return self._extrapolation</code></pre>
</details>
</dd>
<dt id="phi.field.SampledField.points"><code class="name">var <span class="ident">points</span> :Â phi.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def points(self) -&gt; Tensor:
    return self.elements.center</code></pre>
</details>
</dd>
<dt id="phi.field.SampledField.shape"><code class="name">var <span class="ident">shape</span> :Â phi.math._shape.Shape</code></dt>
<dd>
<div class="desc"><p>Returns a shape with the following properties</p>
<ul>
<li>The spatial dimension names match the dimensions of this Field</li>
<li>The batch dimensions match the batch dimensions of this Field</li>
<li>The channel dimensions match the channels of this Field</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape(self) -&gt; Shape:
    return self._shape</code></pre>
</details>
</dd>
<dt id="phi.field.SampledField.values"><code class="name">var <span class="ident">values</span> :Â phi.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def values(self) -&gt; Tensor:
    return self._values</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phi.field.SampledField.with_"><code class="name flex">
<span>def <span class="ident">with_</span></span>(<span>self, elements:Â phi.geom._geom.GeometryÂ =Â None, values:Â phi.math._tensors.TensorÂ =Â None, extrapolation:Â <a title="phi.math.extrapolation.Extrapolation" href="../math/extrapolation.html#phi.math.extrapolation.Extrapolation">Extrapolation</a>Â =Â None, **other_attributes) â€‘>Â ~SampledFieldType</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a copy of this field with one or more properties changed. <code>None</code> keeps the current value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_(self,
          elements: Geometry or None = None,
          values: Tensor = None,
          extrapolation: math.Extrapolation = None,
          **other_attributes) -&gt; &#39;SampledFieldType&#39;:
    &#34;&#34;&#34; Creates a copy of this field with one or more properties changed. `None` keeps the current value. &#34;&#34;&#34;
    raise NotImplementedError(self)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="phi.field.Scene"><code class="flex name class">
<span>class <span class="ident">Scene</span></span>
</code></dt>
<dd>
<div class="desc"><p>Provides methods for reading and writing simulation data.</p>
<p>See the format documentation at <a href="https://tum-pbs.github.io/PhiFlow/Scene_Format_Specification.html">https://tum-pbs.github.io/PhiFlow/Scene_Format_Specification.html</a> .</p>
<p>All data of a <code><a title="phi.field.Scene" href="#phi.field.Scene">Scene</a></code> is located inside a single directory with name <code>sim_xxxxxx</code> where <code>xxxxxx</code> is the <code>id</code>.
The data of the scene is organized into NumPy files by <em>name</em> and <em>frame</em>.</p>
<p>To create a new scene, use <code><a title="phi.field.Scene.create" href="#phi.field.Scene.create">Scene.create()</a></code>.
To reference an existing scene, use <code><a title="phi.field.Scene.at" href="#phi.field.Scene.at">Scene.at()</a></code>.
To list all scenes within a directory, use <code><a title="phi.field.Scene.list" href="#phi.field.Scene.list">Scene.list()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Scene(object):
    &#34;&#34;&#34;
    Provides methods for reading and writing simulation data.

    See the format documentation at https://tum-pbs.github.io/PhiFlow/Scene_Format_Specification.html .

    All data of a `Scene` is located inside a single directory with name `sim_xxxxxx` where `xxxxxx` is the `id`.
    The data of the scene is organized into NumPy files by *name* and *frame*.

    To create a new scene, use `Scene.create()`.
    To reference an existing scene, use `Scene.at()`.
    To list all scenes within a directory, use `Scene.list()`.
    &#34;&#34;&#34;

    def __init__(self, paths: str or math.Tensor):
        self._paths = math.wrap(paths)
        self._properties: dict or None = None

    @property
    def shape(self):
        return self._paths.shape

    @property
    def is_batch(self):
        return self._paths.rank &gt; 0

    @property
    def path(self) -&gt; str:
        &#34;&#34;&#34;
        Relative path of the scene directory.
        This property only exists for single scenes, not scene batches.
        &#34;&#34;&#34;
        assert not self.is_batch, &#34;Scene.path is not defined for scene batches.&#34;
        return self._paths.native()

    @property
    def paths(self) -&gt; math.Tensor:
        return self._paths

    @staticmethod
    def batch_stack(*scenes: &#39;Scene&#39;, dim: str = &#39;batch&#39;) -&gt; &#39;Scene&#39;:
        return Scene(math.batch_stack([s._paths for s in scenes], dim))

    @staticmethod
    def create(parent_directory: str,
               shape: math.Shape = math.EMPTY_SHAPE,
               copy_calling_script=True,
               **dimensions) -&gt; &#39;Scene&#39;:
        &#34;&#34;&#34;
        Creates a new `Scene` or a batch of new scenes inside `parent_directory`.

        See Also:
            `Scene.at()`, `Scene.list()`.

        Args:
            parent_directory: Directory to hold the new `Scene`. If it doesn&#39;t exist, it will be created.
            shape: Determines number of scenes to create. Multiple scenes will be represented by a `Scene` with `is_batch=True`.
            copy_calling_script: Whether to copy the Python file that invoked this method into the `src` folder of all created scenes.
                See `Scene.copy_calling_script()`.
            dimensions: Additional batch dimensions

        Returns:
            Single `Scene` object representing the new scene(s).
        &#34;&#34;&#34;
        shape = (shape &amp; math.shape(**dimensions)).to_batch()
        parent_directory = expanduser(parent_directory)
        abs_dir = abspath(parent_directory)
        if not isdir(abs_dir):
            os.makedirs(abs_dir)
            next_id = 0
        else:
            indices = [int(name[4:]) for name in os.listdir(abs_dir) if name.startswith(&#34;sim_&#34;)]
            next_id = max([-1] + indices) + 1
        ids = math.wrap(tuple(range(next_id, next_id + shape.volume))).vector.split(shape)
        paths = math.map(lambda id_: join(parent_directory, f&#34;sim_{id_:06d}&#34;), ids)
        scene = Scene(paths)
        scene.mkdir()
        if copy_calling_script:
            try:
                scene.copy_calling_script()
            except IOError as err:
                warnings.warn(f&#34;Failed to copy calling script to scene during Scene.create(): {err}&#34;)
        return scene

    @staticmethod
    def list(parent_directory: str,
             include_other: bool = False,
             dim: str or None = None) -&gt; &#39;Scene&#39; or tuple:
        &#34;&#34;&#34;
        Lists all scenes inside the given directory.

        See Also:
            `Scene.at()`, `Scene.create()`.

        Args:
            parent_directory: Directory that contains scene folders.
            include_other: Whether folders that do not match the scene format should also be treated as scenes.
            dim: Stack dimension. If None, returns tuple of `Scene` objects. Otherwise, returns a scene batch with this dimension.

        Returns:
            `tuple` of scenes.
        &#34;&#34;&#34;
        parent_directory = expanduser(parent_directory)
        abs_dir = abspath(parent_directory)
        if not isdir(abs_dir):
            return ()
        names = [sim for sim in os.listdir(abs_dir) if sim.startswith(&#34;sim_&#34;) or (include_other and isdir(join(abs_dir, sim)))]
        if dim is None:
            return tuple(Scene(join(parent_directory, name)) for name in names)
        else:
            paths = math.wrap([join(parent_directory, name) for name in names], dim)
            return Scene(paths)

    @staticmethod
    def at(directory: str or tuple or list or math.Tensor or &#39;Scene&#39;, id: int or math.Tensor or None = None) -&gt; &#39;Scene&#39;:
        &#34;&#34;&#34;
        Creates a `Scene` for an existing directory.

        See Also:
            `Scene.create()`, `Scene.list()`.

        Args:
            directory: Either directory containing scene folder if `id` is given, or scene path if `id=None`.
            id: (Optional) Scene `id`, will be determined from `directory` if not specified.

        Returns:
            `Scene` object for existing scene.
        &#34;&#34;&#34;
        if isinstance(directory, Scene):
            assert id is None, f&#34;Got id={id} but directory is already a Scene.&#34;
            return directory
        if isinstance(directory, (tuple, list)):
            directory = math.wrap(directory, &#39;scenes&#39;)
        directory = math.map(lambda d: expanduser(d), math.wrap(directory))
        if id is None:
            paths = directory
        else:
            id = math.wrap(id)
            paths = math.map(lambda d, i: join(d, f&#34;sim_{i:06d}&#34;), directory, id)
        # test all exist
        for path in math.flatten(paths):
            if not isdir(path):
                raise IOError(f&#34;There is no scene at &#39;{path}&#39;&#34;)
        return Scene(paths)

    def subpath(self, name: str, create: bool = False) -&gt; str or tuple:
        &#34;&#34;&#34;
        Resolves the relative path `name` with this `Scene` as the root folder.

        Args:
            name: Relative path with this `Scene` as the root folder.
            create: Whether to create a directory of that name.

        Returns:
            Relative path including the path to this `Scene`.
            In batch mode, returns a `tuple`, else a `str`.
        &#34;&#34;&#34;
        def single_subpath(path):
            path = join(path, name)
            if create and not isdir(path):
                os.mkdir(path)
            return path

        result = math.map(single_subpath, self._paths)
        if result.rank == 0:
            return result.native()
        else:
            return result

    def _init_properties(self):
        if self._properties is not None:
            return
        json_file = join(next(iter(math.flatten(self._paths))), &#34;description.json&#34;)
        if isfile(json_file):
            with open(json_file) as stream:
                self._properties = json.load(stream)
        else:
            self._properties = {}

    def exist_properties(self):
        &#34;&#34;&#34;
        Checks whether the file `description.json` exists or has existed.
        &#34;&#34;&#34;
        if self._properties is not None:
            return True  # must have been written or read
        else:
            json_file = join(next(iter(math.flatten(self._paths))), &#34;description.json&#34;)
            return isfile(json_file)

    def exists_config(self):
        &#34;&#34;&#34; Tests if the configuration file *description.json* exists. In batch mode, tests if any configuration exists. &#34;&#34;&#34;
        if isinstance(self.path, str):
            return isfile(join(self.path, &#34;description.json&#34;))
        else:
            return any(isfile(join(p, &#34;description.json&#34;)) for p in self.path)

    @property
    def properties(self):
        self._init_properties()
        return self._properties

    @properties.setter
    def properties(self, dict):
        self._properties = dict
        with open(join(self.path, &#34;description.json&#34;), &#34;w&#34;) as out:
            json.dump(self._properties, out, indent=2)

    def put_property(self, key, value):
        &#34;&#34;&#34; See `Scene.put_properties()`. &#34;&#34;&#34;
        self._init_properties()
        self._properties[key] = value
        self._write_properties()

    def put_properties(self, update: dict = None, **kw_updates):
        &#34;&#34;&#34;
        Updates the properties dictionary and stores it in `description.json` of all scene folders.

        Args:
            update: new values, must be JSON serializable.
            kw_updates: additional update as keyword arguments. This overrides `update`.
        &#34;&#34;&#34;
        self._init_properties()
        if update:
            self._properties.update(update)
        self._properties.update(kw_updates)
        self._write_properties()

    def _write_properties(self):
        for path in math.flatten(self.paths):
            with open(join(path, &#34;description.json&#34;), &#34;w&#34;) as out:
                json.dump(self._properties, out, indent=2)

    def write_sim_frame(self, arrays, fieldnames, frame):
        write_sim_frame(self._paths, arrays, names=fieldnames, frame=frame)

    def write(self, data: dict = None, frame=0, **kw_data):
        &#34;&#34;&#34;
        Writes fields to this scene.
        One NumPy file will be created for each `phi.field.Field`

        See Also:
            `Scene.read()`.

        Args:
            data: `dict` mapping field names to `Field` objects that can be written using `phi.field.write()`.
            kw_data: Additional data, overrides elements in `data`.
            frame: Frame number.
        &#34;&#34;&#34;
        data = dict(data) if data else {}
        data.update(kw_data)
        write_sim_frame(self._paths, data, names=None, frame=frame)

    def read_array(self, field_name, frame):
        return read_sim_frame(self._paths, field_name, frame=frame)

    # def read_sim_frames(self, fieldnames=None, frames=None):
    #     return read_sim_frames(self.path, fieldnames=fieldnames, frames=frames, batch_dim=self.batch_dim)

    def read(self, *names: str, frame=0, convert_to_backend=True):
        &#34;&#34;&#34;
        Reads one or multiple fields from disc.

        See Also:
            `Scene.write()`.

        Args:
            names: Single field name or sequence of field names.
            frame: Frame number.
            convert_to_backend: Whether to convert the read data to the data format of the default backend, e.g. TensorFlow tensors.

        Returns:
            Single `phi.field.Field` or sequence of fields, depending on the type of `names`.
        &#34;&#34;&#34;
        result = read_sim_frame(self._paths, names, frame=frame, convert_to_backend=convert_to_backend)
        return result[0] if len(names) == 1 else result

    @property
    def fieldnames(self) -&gt; tuple:
        &#34;&#34;&#34; Determines all field names present in this `Scene`, independent of frame. &#34;&#34;&#34;
        return get_fieldnames(self.path)

    @property
    def frames(self):
        &#34;&#34;&#34; Determines all frame numbers present in this `Scene`, independent of field names. See `Scene.complete_frames`. &#34;&#34;&#34;
        return get_frames(self.path, mode=set.union)

    @property
    def complete_frames(self):
        &#34;&#34;&#34;
        Determines all frame number for which all existing fields are available.
        If there are multiple fields stored within this scene, a frame is considered complete only if an entry exists for all fields.

        See Also:
            `Scene.frames`
        &#34;&#34;&#34;
        return get_frames(self.path, mode=set.intersection)

    def __repr__(self):
        return repr(self.paths)

    def __eq__(self, other):
        return isinstance(other, Scene) and math.all(other._paths == self._paths)

    def copy_calling_script(self, full_trace=False, include_context_information=True):
        &#34;&#34;&#34;
        Copies the Python file that called this method into the `src` folder of this `Scene`.

        In batch mode, the script is copied to all scenes.

        Args:
            full_trace: Whether to include scripts that indirectly called this method.
            include_context_information: If True, writes the phiflow version and `sys.argv` into `context.json`.
        &#34;&#34;&#34;
        script_paths = [frame.filename for frame in inspect.stack()]
        script_paths = list(filter(lambda path: not _is_phi_file(path), script_paths))
        script_paths = set(script_paths) if full_trace else [script_paths[0]]
        self.subpath(&#39;src&#39;, create=True)
        for script_path in script_paths:
            if script_path.endswith(&#39;.py&#39;):
                self.copy_src(script_path, only_external=False)
            elif &#39;ipython&#39; in script_path:
                from IPython import get_ipython
                cells = get_ipython().user_ns[&#39;In&#39;]
                blocks = [f&#34;#%% In[{i}]\n{cell}&#34; for i, cell in enumerate(cells)]
                text = &#34;\n\n&#34;.join(blocks)
                self.copy_src_text(&#39;ipython.py&#39;, text)
        if include_context_information:
            for path in math.flatten(self._paths):
                with open(join(path, &#39;src&#39;, &#39;context.json&#39;), &#39;w&#39;) as context_file:
                    json.dump({
                        &#39;phi_version&#39;: phi_version,
                        &#39;argv&#39;: sys.argv
                    }, context_file)

    def copy_src(self, script_path, only_external=True):
        for path in math.flatten(self._paths):
            if not only_external or not _is_phi_file(script_path):
                shutil.copy(script_path, join(path, &#39;src&#39;, basename(script_path)))

    def copy_src_text(self, filename, text):
        for path in math.flatten(self._paths):
            target = join(path, &#39;src&#39;, filename)
            with open(target, &#34;w&#34;) as file:
                file.writelines(text)

    def mkdir(self):
        for path in math.flatten(self._paths):
            isdir(path) or os.mkdir(path)

    def remove(self):
        &#34;&#34;&#34; Deletes the scene directory and all contained files. &#34;&#34;&#34;
        for p in math.flatten(self._paths):
            p = abspath(p)
            if isdir(p):
                shutil.rmtree(p)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="phi.field.Scene.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>directory:Â str, id:Â intÂ =Â None) â€‘>Â phi.field._scene.Scene</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a <code><a title="phi.field.Scene" href="#phi.field.Scene">Scene</a></code> for an existing directory.</p>
<p>See Also:
<code><a title="phi.field.Scene.create" href="#phi.field.Scene.create">Scene.create()</a></code>, <code><a title="phi.field.Scene.list" href="#phi.field.Scene.list">Scene.list()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>directory</code></strong></dt>
<dd>Either directory containing scene folder if <code>id</code> is given, or scene path if <code>id=None</code>.</dd>
<dt><strong><code>id</code></strong></dt>
<dd>(Optional) Scene <code>id</code>, will be determined from <code>directory</code> if not specified.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.field.Scene" href="#phi.field.Scene">Scene</a></code> object for existing scene.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def at(directory: str or tuple or list or math.Tensor or &#39;Scene&#39;, id: int or math.Tensor or None = None) -&gt; &#39;Scene&#39;:
    &#34;&#34;&#34;
    Creates a `Scene` for an existing directory.

    See Also:
        `Scene.create()`, `Scene.list()`.

    Args:
        directory: Either directory containing scene folder if `id` is given, or scene path if `id=None`.
        id: (Optional) Scene `id`, will be determined from `directory` if not specified.

    Returns:
        `Scene` object for existing scene.
    &#34;&#34;&#34;
    if isinstance(directory, Scene):
        assert id is None, f&#34;Got id={id} but directory is already a Scene.&#34;
        return directory
    if isinstance(directory, (tuple, list)):
        directory = math.wrap(directory, &#39;scenes&#39;)
    directory = math.map(lambda d: expanduser(d), math.wrap(directory))
    if id is None:
        paths = directory
    else:
        id = math.wrap(id)
        paths = math.map(lambda d, i: join(d, f&#34;sim_{i:06d}&#34;), directory, id)
    # test all exist
    for path in math.flatten(paths):
        if not isdir(path):
            raise IOError(f&#34;There is no scene at &#39;{path}&#39;&#34;)
    return Scene(paths)</code></pre>
</details>
</dd>
<dt id="phi.field.Scene.batch_stack"><code class="name flex">
<span>def <span class="ident">batch_stack</span></span>(<span>*scenes:Â <a title="phi.field.Scene" href="#phi.field.Scene">Scene</a>, dim:Â strÂ =Â 'batch') â€‘>Â phi.field._scene.Scene</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def batch_stack(*scenes: &#39;Scene&#39;, dim: str = &#39;batch&#39;) -&gt; &#39;Scene&#39;:
    return Scene(math.batch_stack([s._paths for s in scenes], dim))</code></pre>
</details>
</dd>
<dt id="phi.field.Scene.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>parent_directory:Â str, shape:Â phi.math._shape.ShapeÂ =Â (), copy_calling_script=True, **dimensions) â€‘>Â phi.field._scene.Scene</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new <code><a title="phi.field.Scene" href="#phi.field.Scene">Scene</a></code> or a batch of new scenes inside <code>parent_directory</code>.</p>
<p>See Also:
<code><a title="phi.field.Scene.at" href="#phi.field.Scene.at">Scene.at()</a></code>, <code><a title="phi.field.Scene.list" href="#phi.field.Scene.list">Scene.list()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parent_directory</code></strong></dt>
<dd>Directory to hold the new <code><a title="phi.field.Scene" href="#phi.field.Scene">Scene</a></code>. If it doesn't exist, it will be created.</dd>
<dt><strong><code>shape</code></strong></dt>
<dd>Determines number of scenes to create. Multiple scenes will be represented by a <code><a title="phi.field.Scene" href="#phi.field.Scene">Scene</a></code> with <code>is_batch=True</code>.</dd>
<dt><strong><code>copy_calling_script</code></strong></dt>
<dd>Whether to copy the Python file that invoked this method into the <code>src</code> folder of all created scenes.
See <code><a title="phi.field.Scene.copy_calling_script" href="#phi.field.Scene.copy_calling_script">Scene.copy_calling_script()</a></code>.</dd>
<dt><strong><code>dimensions</code></strong></dt>
<dd>Additional batch dimensions</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Single <code><a title="phi.field.Scene" href="#phi.field.Scene">Scene</a></code> object representing the new scene(s).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def create(parent_directory: str,
           shape: math.Shape = math.EMPTY_SHAPE,
           copy_calling_script=True,
           **dimensions) -&gt; &#39;Scene&#39;:
    &#34;&#34;&#34;
    Creates a new `Scene` or a batch of new scenes inside `parent_directory`.

    See Also:
        `Scene.at()`, `Scene.list()`.

    Args:
        parent_directory: Directory to hold the new `Scene`. If it doesn&#39;t exist, it will be created.
        shape: Determines number of scenes to create. Multiple scenes will be represented by a `Scene` with `is_batch=True`.
        copy_calling_script: Whether to copy the Python file that invoked this method into the `src` folder of all created scenes.
            See `Scene.copy_calling_script()`.
        dimensions: Additional batch dimensions

    Returns:
        Single `Scene` object representing the new scene(s).
    &#34;&#34;&#34;
    shape = (shape &amp; math.shape(**dimensions)).to_batch()
    parent_directory = expanduser(parent_directory)
    abs_dir = abspath(parent_directory)
    if not isdir(abs_dir):
        os.makedirs(abs_dir)
        next_id = 0
    else:
        indices = [int(name[4:]) for name in os.listdir(abs_dir) if name.startswith(&#34;sim_&#34;)]
        next_id = max([-1] + indices) + 1
    ids = math.wrap(tuple(range(next_id, next_id + shape.volume))).vector.split(shape)
    paths = math.map(lambda id_: join(parent_directory, f&#34;sim_{id_:06d}&#34;), ids)
    scene = Scene(paths)
    scene.mkdir()
    if copy_calling_script:
        try:
            scene.copy_calling_script()
        except IOError as err:
            warnings.warn(f&#34;Failed to copy calling script to scene during Scene.create(): {err}&#34;)
    return scene</code></pre>
</details>
</dd>
<dt id="phi.field.Scene.list"><code class="name flex">
<span>def <span class="ident">list</span></span>(<span>parent_directory:Â str, include_other:Â boolÂ =Â False, dim:Â strÂ =Â None) â€‘>Â phi.field._scene.Scene</span>
</code></dt>
<dd>
<div class="desc"><p>Lists all scenes inside the given directory.</p>
<p>See Also:
<code><a title="phi.field.Scene.at" href="#phi.field.Scene.at">Scene.at()</a></code>, <code><a title="phi.field.Scene.create" href="#phi.field.Scene.create">Scene.create()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parent_directory</code></strong></dt>
<dd>Directory that contains scene folders.</dd>
<dt><strong><code>include_other</code></strong></dt>
<dd>Whether folders that do not match the scene format should also be treated as scenes.</dd>
<dt><strong><code>dim</code></strong></dt>
<dd>Stack dimension. If None, returns tuple of <code><a title="phi.field.Scene" href="#phi.field.Scene">Scene</a></code> objects. Otherwise, returns a scene batch with this dimension.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>tuple</code> of scenes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def list(parent_directory: str,
         include_other: bool = False,
         dim: str or None = None) -&gt; &#39;Scene&#39; or tuple:
    &#34;&#34;&#34;
    Lists all scenes inside the given directory.

    See Also:
        `Scene.at()`, `Scene.create()`.

    Args:
        parent_directory: Directory that contains scene folders.
        include_other: Whether folders that do not match the scene format should also be treated as scenes.
        dim: Stack dimension. If None, returns tuple of `Scene` objects. Otherwise, returns a scene batch with this dimension.

    Returns:
        `tuple` of scenes.
    &#34;&#34;&#34;
    parent_directory = expanduser(parent_directory)
    abs_dir = abspath(parent_directory)
    if not isdir(abs_dir):
        return ()
    names = [sim for sim in os.listdir(abs_dir) if sim.startswith(&#34;sim_&#34;) or (include_other and isdir(join(abs_dir, sim)))]
    if dim is None:
        return tuple(Scene(join(parent_directory, name)) for name in names)
    else:
        paths = math.wrap([join(parent_directory, name) for name in names], dim)
        return Scene(paths)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="phi.field.Scene.complete_frames"><code class="name">var <span class="ident">complete_frames</span></code></dt>
<dd>
<div class="desc"><p>Determines all frame number for which all existing fields are available.
If there are multiple fields stored within this scene, a frame is considered complete only if an entry exists for all fields.</p>
<p>See Also:
<code><a title="phi.field.Scene.frames" href="#phi.field.Scene.frames">Scene.frames</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def complete_frames(self):
    &#34;&#34;&#34;
    Determines all frame number for which all existing fields are available.
    If there are multiple fields stored within this scene, a frame is considered complete only if an entry exists for all fields.

    See Also:
        `Scene.frames`
    &#34;&#34;&#34;
    return get_frames(self.path, mode=set.intersection)</code></pre>
</details>
</dd>
<dt id="phi.field.Scene.fieldnames"><code class="name">var <span class="ident">fieldnames</span> :Â tuple</code></dt>
<dd>
<div class="desc"><p>Determines all field names present in this <code><a title="phi.field.Scene" href="#phi.field.Scene">Scene</a></code>, independent of frame.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def fieldnames(self) -&gt; tuple:
    &#34;&#34;&#34; Determines all field names present in this `Scene`, independent of frame. &#34;&#34;&#34;
    return get_fieldnames(self.path)</code></pre>
</details>
</dd>
<dt id="phi.field.Scene.frames"><code class="name">var <span class="ident">frames</span></code></dt>
<dd>
<div class="desc"><p>Determines all frame numbers present in this <code><a title="phi.field.Scene" href="#phi.field.Scene">Scene</a></code>, independent of field names. See <code><a title="phi.field.Scene.complete_frames" href="#phi.field.Scene.complete_frames">Scene.complete_frames</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def frames(self):
    &#34;&#34;&#34; Determines all frame numbers present in this `Scene`, independent of field names. See `Scene.complete_frames`. &#34;&#34;&#34;
    return get_frames(self.path, mode=set.union)</code></pre>
</details>
</dd>
<dt id="phi.field.Scene.is_batch"><code class="name">var <span class="ident">is_batch</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_batch(self):
    return self._paths.rank &gt; 0</code></pre>
</details>
</dd>
<dt id="phi.field.Scene.path"><code class="name">var <span class="ident">path</span> :Â str</code></dt>
<dd>
<div class="desc"><p>Relative path of the scene directory.
This property only exists for single scenes, not scene batches.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def path(self) -&gt; str:
    &#34;&#34;&#34;
    Relative path of the scene directory.
    This property only exists for single scenes, not scene batches.
    &#34;&#34;&#34;
    assert not self.is_batch, &#34;Scene.path is not defined for scene batches.&#34;
    return self._paths.native()</code></pre>
</details>
</dd>
<dt id="phi.field.Scene.paths"><code class="name">var <span class="ident">paths</span> :Â phi.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def paths(self) -&gt; math.Tensor:
    return self._paths</code></pre>
</details>
</dd>
<dt id="phi.field.Scene.properties"><code class="name">var <span class="ident">properties</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def properties(self):
    self._init_properties()
    return self._properties</code></pre>
</details>
</dd>
<dt id="phi.field.Scene.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape(self):
    return self._paths.shape</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phi.field.Scene.copy_calling_script"><code class="name flex">
<span>def <span class="ident">copy_calling_script</span></span>(<span>self, full_trace=False, include_context_information=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Copies the Python file that called this method into the <code>src</code> folder of this <code><a title="phi.field.Scene" href="#phi.field.Scene">Scene</a></code>.</p>
<p>In batch mode, the script is copied to all scenes.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>full_trace</code></strong></dt>
<dd>Whether to include scripts that indirectly called this method.</dd>
<dt><strong><code>include_context_information</code></strong></dt>
<dd>If True, writes the phiflow version and <code>sys.argv</code> into <code>context.json</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy_calling_script(self, full_trace=False, include_context_information=True):
    &#34;&#34;&#34;
    Copies the Python file that called this method into the `src` folder of this `Scene`.

    In batch mode, the script is copied to all scenes.

    Args:
        full_trace: Whether to include scripts that indirectly called this method.
        include_context_information: If True, writes the phiflow version and `sys.argv` into `context.json`.
    &#34;&#34;&#34;
    script_paths = [frame.filename for frame in inspect.stack()]
    script_paths = list(filter(lambda path: not _is_phi_file(path), script_paths))
    script_paths = set(script_paths) if full_trace else [script_paths[0]]
    self.subpath(&#39;src&#39;, create=True)
    for script_path in script_paths:
        if script_path.endswith(&#39;.py&#39;):
            self.copy_src(script_path, only_external=False)
        elif &#39;ipython&#39; in script_path:
            from IPython import get_ipython
            cells = get_ipython().user_ns[&#39;In&#39;]
            blocks = [f&#34;#%% In[{i}]\n{cell}&#34; for i, cell in enumerate(cells)]
            text = &#34;\n\n&#34;.join(blocks)
            self.copy_src_text(&#39;ipython.py&#39;, text)
    if include_context_information:
        for path in math.flatten(self._paths):
            with open(join(path, &#39;src&#39;, &#39;context.json&#39;), &#39;w&#39;) as context_file:
                json.dump({
                    &#39;phi_version&#39;: phi_version,
                    &#39;argv&#39;: sys.argv
                }, context_file)</code></pre>
</details>
</dd>
<dt id="phi.field.Scene.copy_src"><code class="name flex">
<span>def <span class="ident">copy_src</span></span>(<span>self, script_path, only_external=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy_src(self, script_path, only_external=True):
    for path in math.flatten(self._paths):
        if not only_external or not _is_phi_file(script_path):
            shutil.copy(script_path, join(path, &#39;src&#39;, basename(script_path)))</code></pre>
</details>
</dd>
<dt id="phi.field.Scene.copy_src_text"><code class="name flex">
<span>def <span class="ident">copy_src_text</span></span>(<span>self, filename, text)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy_src_text(self, filename, text):
    for path in math.flatten(self._paths):
        target = join(path, &#39;src&#39;, filename)
        with open(target, &#34;w&#34;) as file:
            file.writelines(text)</code></pre>
</details>
</dd>
<dt id="phi.field.Scene.exist_properties"><code class="name flex">
<span>def <span class="ident">exist_properties</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks whether the file <code>description.json</code> exists or has existed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exist_properties(self):
    &#34;&#34;&#34;
    Checks whether the file `description.json` exists or has existed.
    &#34;&#34;&#34;
    if self._properties is not None:
        return True  # must have been written or read
    else:
        json_file = join(next(iter(math.flatten(self._paths))), &#34;description.json&#34;)
        return isfile(json_file)</code></pre>
</details>
</dd>
<dt id="phi.field.Scene.exists_config"><code class="name flex">
<span>def <span class="ident">exists_config</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Tests if the configuration file <em>description.json</em> exists. In batch mode, tests if any configuration exists.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exists_config(self):
    &#34;&#34;&#34; Tests if the configuration file *description.json* exists. In batch mode, tests if any configuration exists. &#34;&#34;&#34;
    if isinstance(self.path, str):
        return isfile(join(self.path, &#34;description.json&#34;))
    else:
        return any(isfile(join(p, &#34;description.json&#34;)) for p in self.path)</code></pre>
</details>
</dd>
<dt id="phi.field.Scene.mkdir"><code class="name flex">
<span>def <span class="ident">mkdir</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mkdir(self):
    for path in math.flatten(self._paths):
        isdir(path) or os.mkdir(path)</code></pre>
</details>
</dd>
<dt id="phi.field.Scene.put_properties"><code class="name flex">
<span>def <span class="ident">put_properties</span></span>(<span>self, update:Â dictÂ =Â None, **kw_updates)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the properties dictionary and stores it in <code>description.json</code> of all scene folders.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>update</code></strong></dt>
<dd>new values, must be JSON serializable.</dd>
<dt><strong><code>kw_updates</code></strong></dt>
<dd>additional update as keyword arguments. This overrides <code>update</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_properties(self, update: dict = None, **kw_updates):
    &#34;&#34;&#34;
    Updates the properties dictionary and stores it in `description.json` of all scene folders.

    Args:
        update: new values, must be JSON serializable.
        kw_updates: additional update as keyword arguments. This overrides `update`.
    &#34;&#34;&#34;
    self._init_properties()
    if update:
        self._properties.update(update)
    self._properties.update(kw_updates)
    self._write_properties()</code></pre>
</details>
</dd>
<dt id="phi.field.Scene.put_property"><code class="name flex">
<span>def <span class="ident">put_property</span></span>(<span>self, key, value)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="phi.field.Scene.put_properties" href="#phi.field.Scene.put_properties">Scene.put_properties()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_property(self, key, value):
    &#34;&#34;&#34; See `Scene.put_properties()`. &#34;&#34;&#34;
    self._init_properties()
    self._properties[key] = value
    self._write_properties()</code></pre>
</details>
</dd>
<dt id="phi.field.Scene.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, *names:Â str, frame=0, convert_to_backend=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Reads one or multiple fields from disc.</p>
<p>See Also:
<code><a title="phi.field.Scene.write" href="#phi.field.Scene.write">Scene.write()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>names</code></strong></dt>
<dd>Single field name or sequence of field names.</dd>
<dt><strong><code>frame</code></strong></dt>
<dd>Frame number.</dd>
<dt><strong><code>convert_to_backend</code></strong></dt>
<dd>Whether to convert the read data to the data format of the default backend, e.g. TensorFlow tensors.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Single <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> or sequence of fields, depending on the type of <code>names</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, *names: str, frame=0, convert_to_backend=True):
    &#34;&#34;&#34;
    Reads one or multiple fields from disc.

    See Also:
        `Scene.write()`.

    Args:
        names: Single field name or sequence of field names.
        frame: Frame number.
        convert_to_backend: Whether to convert the read data to the data format of the default backend, e.g. TensorFlow tensors.

    Returns:
        Single `phi.field.Field` or sequence of fields, depending on the type of `names`.
    &#34;&#34;&#34;
    result = read_sim_frame(self._paths, names, frame=frame, convert_to_backend=convert_to_backend)
    return result[0] if len(names) == 1 else result</code></pre>
</details>
</dd>
<dt id="phi.field.Scene.read_array"><code class="name flex">
<span>def <span class="ident">read_array</span></span>(<span>self, field_name, frame)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_array(self, field_name, frame):
    return read_sim_frame(self._paths, field_name, frame=frame)</code></pre>
</details>
</dd>
<dt id="phi.field.Scene.remove"><code class="name flex">
<span>def <span class="ident">remove</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes the scene directory and all contained files.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove(self):
    &#34;&#34;&#34; Deletes the scene directory and all contained files. &#34;&#34;&#34;
    for p in math.flatten(self._paths):
        p = abspath(p)
        if isdir(p):
            shutil.rmtree(p)</code></pre>
</details>
</dd>
<dt id="phi.field.Scene.subpath"><code class="name flex">
<span>def <span class="ident">subpath</span></span>(<span>self, name:Â str, create:Â boolÂ =Â False) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Resolves the relative path <code>name</code> with this <code><a title="phi.field.Scene" href="#phi.field.Scene">Scene</a></code> as the root folder.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Relative path with this <code><a title="phi.field.Scene" href="#phi.field.Scene">Scene</a></code> as the root folder.</dd>
<dt><strong><code>create</code></strong></dt>
<dd>Whether to create a directory of that name.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Relative path including the path to this <code><a title="phi.field.Scene" href="#phi.field.Scene">Scene</a></code>.
In batch mode, returns a <code>tuple</code>, else a <code>str</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subpath(self, name: str, create: bool = False) -&gt; str or tuple:
    &#34;&#34;&#34;
    Resolves the relative path `name` with this `Scene` as the root folder.

    Args:
        name: Relative path with this `Scene` as the root folder.
        create: Whether to create a directory of that name.

    Returns:
        Relative path including the path to this `Scene`.
        In batch mode, returns a `tuple`, else a `str`.
    &#34;&#34;&#34;
    def single_subpath(path):
        path = join(path, name)
        if create and not isdir(path):
            os.mkdir(path)
        return path

    result = math.map(single_subpath, self._paths)
    if result.rank == 0:
        return result.native()
    else:
        return result</code></pre>
</details>
</dd>
<dt id="phi.field.Scene.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, data:Â dictÂ =Â None, frame=0, **kw_data)</span>
</code></dt>
<dd>
<div class="desc"><p>Writes fields to this scene.
One NumPy file will be created for each <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code></p>
<p>See Also:
<code><a title="phi.field.Scene.read" href="#phi.field.Scene.read">Scene.read()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd><code>dict</code> mapping field names to <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> objects that can be written using <code><a title="phi.field.write" href="#phi.field.write">write()</a></code>.</dd>
<dt><strong><code>kw_data</code></strong></dt>
<dd>Additional data, overrides elements in <code>data</code>.</dd>
<dt><strong><code>frame</code></strong></dt>
<dd>Frame number.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, data: dict = None, frame=0, **kw_data):
    &#34;&#34;&#34;
    Writes fields to this scene.
    One NumPy file will be created for each `phi.field.Field`

    See Also:
        `Scene.read()`.

    Args:
        data: `dict` mapping field names to `Field` objects that can be written using `phi.field.write()`.
        kw_data: Additional data, overrides elements in `data`.
        frame: Frame number.
    &#34;&#34;&#34;
    data = dict(data) if data else {}
    data.update(kw_data)
    write_sim_frame(self._paths, data, names=None, frame=frame)</code></pre>
</details>
</dd>
<dt id="phi.field.Scene.write_sim_frame"><code class="name flex">
<span>def <span class="ident">write_sim_frame</span></span>(<span>self, arrays, fieldnames, frame)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_sim_frame(self, arrays, fieldnames, frame):
    write_sim_frame(self._paths, arrays, names=fieldnames, frame=frame)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="phi.field.SoftGeometryMask"><code class="flex name class">
<span>class <span class="ident">GeometryMask</span></span>
<span>(</span><span>geometry:Â phi.geom._geom.Geometry)</span>
</code></dt>
<dd>
<div class="desc"><p>When sampled given another geometry, the approximate overlap between the geometries is computed, allowing for fractional values between 0 and 1.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SoftGeometryMask(HardGeometryMask):
    &#34;&#34;&#34;
    When sampled given another geometry, the approximate overlap between the geometries is computed, allowing for fractional values between 0 and 1.
    &#34;&#34;&#34;

    def _sample(self, geometry: Geometry) -&gt; Tensor:
        return self.geometry.approximate_fraction_inside(geometry)

    def __getitem__(self, item: dict):
        return SoftGeometryMask(self.geometry[item])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.field._mask.HardGeometryMask</li>
<li>phi.field._field.Field</li>
</ul>
</dd>
<dt id="phi.field.SoftGeometryMask"><code class="flex name class">
<span>class <span class="ident">SoftGeometryMask</span></span>
<span>(</span><span>geometry:Â phi.geom._geom.Geometry)</span>
</code></dt>
<dd>
<div class="desc"><p>When sampled given another geometry, the approximate overlap between the geometries is computed, allowing for fractional values between 0 and 1.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SoftGeometryMask(HardGeometryMask):
    &#34;&#34;&#34;
    When sampled given another geometry, the approximate overlap between the geometries is computed, allowing for fractional values between 0 and 1.
    &#34;&#34;&#34;

    def _sample(self, geometry: Geometry) -&gt; Tensor:
        return self.geometry.approximate_fraction_inside(geometry)

    def __getitem__(self, item: dict):
        return SoftGeometryMask(self.geometry[item])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.field._mask.HardGeometryMask</li>
<li>phi.field._field.Field</li>
</ul>
</dd>
<dt id="phi.field.StaggeredGrid"><code class="flex name class">
<span>class <span class="ident">StaggeredGrid</span></span>
<span>(</span><span>values:Â phi.math._tensors.TensorStack, bounds:Â phi.geom._box.Box, extrapolation:Â <a title="phi.math.extrapolation.Extrapolation" href="../math/extrapolation.html#phi.math.extrapolation.Extrapolation">Extrapolation</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>N-dimensional grid whose vector components are sampled at the respective face centers.
A staggered grid is defined through its values tensor, its bounds describing the physical size, and its extrapolation.</p>
<p>Staggered grids support arbitrary batch and spatial dimensions but only one channel dimension for the staggered vector components.</p>
<p>Use <code><a title="phi.field.grid" href="#phi.field.grid">grid()</a></code> with <code>type=StaggeredGrid</code> to create a staggered grid.
Alternatively, the <code><a title="phi.physics.Domain" href="../physics/index.html#phi.physics.Domain">Domain</a></code> class provides convenience methods for grid creation.</p>
<p>See the <code><a title="phi.field" href="#phi.field">phi.field</a></code> module documentation at <a href="https://tum-pbs.github.io/PhiFlow/Fields.html">https://tum-pbs.github.io/PhiFlow/Fields.html</a></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>values</code></strong></dt>
<dd><code><a title="phi.math.Tensor" href="../math/index.html#phi.math.Tensor">Tensor</a></code> containing all dimensions of this grid.
Must contain a <code>vector</code> dimension with each slice consisting of one more element along the dimension they describe.
Use <code><a title="phi.math.channel_stack" href="../math/index.html#phi.math.channel_stack">channel_stack()</a></code> to manually create this non-uniform tensor.</dd>
<dt><strong><code>bounds</code></strong></dt>
<dd>Physical size and location of the grid.</dd>
<dt><strong><code>extrapolation</code></strong></dt>
<dd>The grid extrapolation determines the value outside the <code>values</code> tensor.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StaggeredGrid(Grid):
    &#34;&#34;&#34;
    N-dimensional grid whose vector components are sampled at the respective face centers.
    A staggered grid is defined through its values tensor, its bounds describing the physical size, and its extrapolation.
    
    Staggered grids support arbitrary batch and spatial dimensions but only one channel dimension for the staggered vector components.

    Use `grid()` with `type=StaggeredGrid` to create a staggered grid.
    Alternatively, the `phi.physics.Domain` class provides convenience methods for grid creation.
    
    See the `phi.field` module documentation at https://tum-pbs.github.io/PhiFlow/Fields.html
    &#34;&#34;&#34;

    def __init__(self, values: TensorStack, bounds: Box, extrapolation: math.Extrapolation):
        &#34;&#34;&#34;
        Args:
            values: `phi.math.Tensor` containing all dimensions of this grid.
                Must contain a `vector` dimension with each slice consisting of one more element along the dimension they describe.
                Use `phi.math.channel_stack()` to manually create this non-uniform tensor.
            bounds: Physical size and location of the grid.
            extrapolation: The grid extrapolation determines the value outside the `values` tensor.
        &#34;&#34;&#34;
        values = _validate_staggered_values(values)
        any_dim = values.shape.spatial.names[0]
        x = values.vector[any_dim]
        resolution = x.shape.spatial.with_size(any_dim, x.shape.get_size(any_dim) - 1)
        grids = [GridCell(resolution, bounds).extend_symmetric(dim, 1) for dim in values.shape.spatial.names]
        elements = GeometryStack(grids, &#39;vector_&#39;, CHANNEL_DIM)
        Grid.__init__(self, elements, values, extrapolation, resolution, bounds)

    def with_(self,
              elements: Geometry or None = None,
              values: TensorStack = None,
              extrapolation: math.Extrapolation = None,
              **other_attributes) -&gt; &#39;StaggeredGrid&#39;:
        assert elements is None
        assert not other_attributes, f&#34;Invalid attributes for type {type(self)}: {other_attributes}&#34;
        values = _validate_staggered_values(values) if values is not None else self.values
        return StaggeredGrid(values, self.bounds, extrapolation if extrapolation is not None else self._extrapolation)

    @property
    def cells(self):
        return GridCell(self.resolution, self.bounds)

    def _sample(self, geometry: Geometry) -&gt; Tensor:
        channels = [sample(component, geometry) for component in self.vector.unstack()]
        return math.channel_stack(channels, &#39;vector&#39;)

    def closest_values(self, points: Geometry):
        assert &#39;vector&#39; not in points.shape
        if &#39;vector_&#39; in points.shape:
            points = points.unstack(&#39;vector_&#39;)
            channels = [component.closest_values(p) for p, component in zip(points, self.vector.unstack())]
        else:
            channels = [component.closest_values(points) for component in self.vector.unstack()]
        return math.channel_stack(channels, &#39;vector&#39;)

    def at_centers(self) -&gt; CenteredGrid:
        return grid(self, resolution=self.resolution, bounds=self.bounds, extrapolation=self.extrapolation)

    def __getitem__(self, item: dict):
        values = self._values[{dim: sel for dim, sel in item.items() if dim not in self.shape.spatial}]
        for dim, sel in item.items():
            if dim in self.shape.spatial:
                sel = slice(sel, sel + 1) if isinstance(sel, int) else sel
                values = []
                for vdim, val in zip(self.shape.spatial.names, self.values.unstack(&#39;vector&#39;)):
                    if vdim == dim:
                        values.append(val[{dim: slice(sel.start, sel.stop + 1)}])
                    else:
                        values.append(val[{dim: sel}])
                values = math.channel_stack(values, &#39;vector&#39;)
        extrapolation = self._extrapolation[item]
        bounds = GridCell(self._resolution, self._bounds)[item].bounds
        if &#39;vector&#39; in item:
            if isinstance(item[&#39;vector&#39;], int):
                dim = self.shape.spatial.names[item[&#39;vector&#39;]]
                comp_cells = GridCell(self.resolution, bounds).extend_symmetric(dim, 1)
                return CenteredGrid(values, comp_cells.bounds, extrapolation)
            else:
                assert isinstance(item[&#39;vector&#39;], slice) and not item[&#39;vector&#39;].start and not item[&#39;vector&#39;].stop
        return StaggeredGrid(values, bounds, extrapolation)

    def staggered_tensor(self):
        return stack_staggered_components(self.values)

    def _op2(self, other, operator):
        if isinstance(other, StaggeredGrid) and self.bounds == other.bounds and self.shape.spatial == other.shape.spatial:
            values = operator(self._values, other.values)
            extrapolation_ = operator(self._extrapolation, other.extrapolation)
            return self.with_(values=values, extrapolation=extrapolation_)
        else:
            return SampledField._op2(self, other, operator)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.field._grid.Grid</li>
<li>phi.field._field.SampledField</li>
<li>phi.field._field.Field</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="phi.field.StaggeredGrid.cells"><code class="name">var <span class="ident">cells</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cells(self):
    return GridCell(self.resolution, self.bounds)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phi.field.StaggeredGrid.at_centers"><code class="name flex">
<span>def <span class="ident">at_centers</span></span>(<span>self) â€‘>Â phi.field._grid.CenteredGrid</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def at_centers(self) -&gt; CenteredGrid:
    return grid(self, resolution=self.resolution, bounds=self.bounds, extrapolation=self.extrapolation)</code></pre>
</details>
</dd>
<dt id="phi.field.StaggeredGrid.closest_values"><code class="name flex">
<span>def <span class="ident">closest_values</span></span>(<span>self, points:Â phi.geom._geom.Geometry)</span>
</code></dt>
<dd>
<div class="desc"><p>Sample the closest grid point values of this field at the world-space locations (in physical units) given by <code>points</code>.
Points must have a single channel dimension named <code>vector</code>.
It may additionally contain any number of batch and spatial dimensions, all treated as batch dimensions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>points</code></strong></dt>
<dd>world-space locations</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Closest grid point values as a <code>Tensor</code>.
For each dimension, the grid points immediately left and right of the sample points are evaluated.
For each point in <code>points</code>, a <em>2^d</em> cube of points is determined where <em>d</em> is the number of spatial dimensions of this field.
These values are stacked along the new dimensions <code>'closest_&lt;dim&gt;'</code> where <code>&lt;dim&gt;</code> refers to the name of a spatial dimension.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def closest_values(self, points: Geometry):
    assert &#39;vector&#39; not in points.shape
    if &#39;vector_&#39; in points.shape:
        points = points.unstack(&#39;vector_&#39;)
        channels = [component.closest_values(p) for p, component in zip(points, self.vector.unstack())]
    else:
        channels = [component.closest_values(points) for component in self.vector.unstack()]
    return math.channel_stack(channels, &#39;vector&#39;)</code></pre>
</details>
</dd>
<dt id="phi.field.StaggeredGrid.staggered_tensor"><code class="name flex">
<span>def <span class="ident">staggered_tensor</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def staggered_tensor(self):
    return stack_staggered_components(self.values)</code></pre>
</details>
</dd>
<dt id="phi.field.StaggeredGrid.with_"><code class="name flex">
<span>def <span class="ident">with_</span></span>(<span>self, elements:Â phi.geom._geom.GeometryÂ =Â None, values:Â phi.math._tensors.TensorStackÂ =Â None, extrapolation:Â <a title="phi.math.extrapolation.Extrapolation" href="../math/extrapolation.html#phi.math.extrapolation.Extrapolation">Extrapolation</a>Â =Â None, **other_attributes) â€‘>Â phi.field._grid.StaggeredGrid</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a copy of this field with one or more properties changed. <code>None</code> keeps the current value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_(self,
          elements: Geometry or None = None,
          values: TensorStack = None,
          extrapolation: math.Extrapolation = None,
          **other_attributes) -&gt; &#39;StaggeredGrid&#39;:
    assert elements is None
    assert not other_attributes, f&#34;Invalid attributes for type {type(self)}: {other_attributes}&#34;
    values = _validate_staggered_values(values) if values is not None else self.values
    return StaggeredGrid(values, self.bounds, extrapolation if extrapolation is not None else self._extrapolation)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="phi" href="../index.html">phi</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="phi.field.abs" href="#phi.field.abs">abs</a></code></li>
<li><code><a title="phi.field.assert_close" href="#phi.field.assert_close">assert_close</a></code></li>
<li><code><a title="phi.field.batch_stack" href="#phi.field.batch_stack">batch_stack</a></code></li>
<li><code><a title="phi.field.cast" href="#phi.field.cast">cast</a></code></li>
<li><code><a title="phi.field.ceil" href="#phi.field.ceil">ceil</a></code></li>
<li><code><a title="phi.field.center_of_mass" href="#phi.field.center_of_mass">center_of_mass</a></code></li>
<li><code><a title="phi.field.channel_stack" href="#phi.field.channel_stack">channel_stack</a></code></li>
<li><code><a title="phi.field.concat" href="#phi.field.concat">concat</a></code></li>
<li><code><a title="phi.field.convert" href="#phi.field.convert">convert</a></code></li>
<li><code><a title="phi.field.cos" href="#phi.field.cos">cos</a></code></li>
<li><code><a title="phi.field.curl" href="#phi.field.curl">curl</a></code></li>
<li><code><a title="phi.field.divergence" href="#phi.field.divergence">divergence</a></code></li>
<li><code><a title="phi.field.downsample2x" href="#phi.field.downsample2x">downsample2x</a></code></li>
<li><code><a title="phi.field.exp" href="#phi.field.exp">exp</a></code></li>
<li><code><a title="phi.field.extrapolate_valid" href="#phi.field.extrapolate_valid">extrapolate_valid</a></code></li>
<li><code><a title="phi.field.floor" href="#phi.field.floor">floor</a></code></li>
<li><code><a title="phi.field.fourier_laplace" href="#phi.field.fourier_laplace">fourier_laplace</a></code></li>
<li><code><a title="phi.field.fourier_poisson" href="#phi.field.fourier_poisson">fourier_poisson</a></code></li>
<li><code><a title="phi.field.frequency_loss" href="#phi.field.frequency_loss">frequency_loss</a></code></li>
<li><code><a title="phi.field.functional_gradient" href="#phi.field.functional_gradient">functional_gradient</a></code></li>
<li><code><a title="phi.field.grid" href="#phi.field.grid">grid</a></code></li>
<li><code><a title="phi.field.imag" href="#phi.field.imag">imag</a></code></li>
<li><code><a title="phi.field.isfinite" href="#phi.field.isfinite">isfinite</a></code></li>
<li><code><a title="phi.field.jit_compile" href="#phi.field.jit_compile">jit_compile</a></code></li>
<li><code><a title="phi.field.jit_compile_linear" href="#phi.field.jit_compile_linear">jit_compile_linear</a></code></li>
<li><code><a title="phi.field.l1_loss" href="#phi.field.l1_loss">l1_loss</a></code></li>
<li><code><a title="phi.field.l2_loss" href="#phi.field.l2_loss">l2_loss</a></code></li>
<li><code><a title="phi.field.laplace" href="#phi.field.laplace">laplace</a></code></li>
<li><code><a title="phi.field.mean" href="#phi.field.mean">mean</a></code></li>
<li><code><a title="phi.field.minimize" href="#phi.field.minimize">minimize</a></code></li>
<li><code><a title="phi.field.native_call" href="#phi.field.native_call">native_call</a></code></li>
<li><code><a title="phi.field.normalize" href="#phi.field.normalize">normalize</a></code></li>
<li><code><a title="phi.field.pad" href="#phi.field.pad">pad</a></code></li>
<li><code><a title="phi.field.read" href="#phi.field.read">read</a></code></li>
<li><code><a title="phi.field.real" href="#phi.field.real">real</a></code></li>
<li><code><a title="phi.field.reduce_sample" href="#phi.field.reduce_sample">reduce_sample</a></code></li>
<li><code><a title="phi.field.round" href="#phi.field.round">round</a></code></li>
<li><code><a title="phi.field.sample" href="#phi.field.sample">sample</a></code></li>
<li><code><a title="phi.field.shift" href="#phi.field.shift">shift</a></code></li>
<li><code><a title="phi.field.sign" href="#phi.field.sign">sign</a></code></li>
<li><code><a title="phi.field.sin" href="#phi.field.sin">sin</a></code></li>
<li><code><a title="phi.field.solve_linear" href="#phi.field.solve_linear">solve_linear</a></code></li>
<li><code><a title="phi.field.solve_nonlinear" href="#phi.field.solve_nonlinear">solve_nonlinear</a></code></li>
<li><code><a title="phi.field.spatial_gradient" href="#phi.field.spatial_gradient">spatial_gradient</a></code></li>
<li><code><a title="phi.field.sqrt" href="#phi.field.sqrt">sqrt</a></code></li>
<li><code><a title="phi.field.stack_staggered_components" href="#phi.field.stack_staggered_components">stack_staggered_components</a></code></li>
<li><code><a title="phi.field.stagger" href="#phi.field.stagger">stagger</a></code></li>
<li><code><a title="phi.field.stop_gradient" href="#phi.field.stop_gradient">stop_gradient</a></code></li>
<li><code><a title="phi.field.to_float" href="#phi.field.to_float">to_float</a></code></li>
<li><code><a title="phi.field.to_int32" href="#phi.field.to_int32">to_int32</a></code></li>
<li><code><a title="phi.field.to_int64" href="#phi.field.to_int64">to_int64</a></code></li>
<li><code><a title="phi.field.unstack" href="#phi.field.unstack">unstack</a></code></li>
<li><code><a title="phi.field.unstack_staggered_tensor" href="#phi.field.unstack_staggered_tensor">unstack_staggered_tensor</a></code></li>
<li><code><a title="phi.field.upsample2x" href="#phi.field.upsample2x">upsample2x</a></code></li>
<li><code><a title="phi.field.vec_abs" href="#phi.field.vec_abs">vec_abs</a></code></li>
<li><code><a title="phi.field.vec_squared" href="#phi.field.vec_squared">vec_squared</a></code></li>
<li><code><a title="phi.field.where" href="#phi.field.where">where</a></code></li>
<li><code><a title="phi.field.write" href="#phi.field.write">write</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="phi.field.AngularVelocity" href="#phi.field.AngularVelocity">AngularVelocity</a></code></h4>
<ul class="">
<li><code><a title="phi.field.AngularVelocity.shape" href="#phi.field.AngularVelocity.shape">shape</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.field.CenteredGrid" href="#phi.field.CenteredGrid">CenteredGrid</a></code></h4>
<ul class="">
<li><code><a title="phi.field.CenteredGrid.closest_values" href="#phi.field.CenteredGrid.closest_values">closest_values</a></code></li>
<li><code><a title="phi.field.CenteredGrid.with_" href="#phi.field.CenteredGrid.with_">with_</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.field.ConstantField" href="#phi.field.ConstantField">ConstantField</a></code></h4>
<ul class="">
<li><code><a title="phi.field.ConstantField.shape" href="#phi.field.ConstantField.shape">shape</a></code></li>
<li><code><a title="phi.field.ConstantField.unstack" href="#phi.field.ConstantField.unstack">unstack</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code></h4>
<ul class="">
<li><code><a title="phi.field.Field.at" href="#phi.field.Field.at">at</a></code></li>
<li><code><a title="phi.field.Field.dimension" href="#phi.field.Field.dimension">dimension</a></code></li>
<li><code><a title="phi.field.Field.shape" href="#phi.field.Field.shape">shape</a></code></li>
<li><code><a title="phi.field.Field.spatial_rank" href="#phi.field.Field.spatial_rank">spatial_rank</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.field.Grid" href="#phi.field.Grid">Grid</a></code></h4>
<ul class="two-column">
<li><code><a title="phi.field.Grid.bounds" href="#phi.field.Grid.bounds">bounds</a></code></li>
<li><code><a title="phi.field.Grid.box" href="#phi.field.Grid.box">box</a></code></li>
<li><code><a title="phi.field.Grid.closest_values" href="#phi.field.Grid.closest_values">closest_values</a></code></li>
<li><code><a title="phi.field.Grid.dx" href="#phi.field.Grid.dx">dx</a></code></li>
<li><code><a title="phi.field.Grid.resolution" href="#phi.field.Grid.resolution">resolution</a></code></li>
<li><code><a title="phi.field.Grid.shape" href="#phi.field.Grid.shape">shape</a></code></li>
<li><code><a title="phi.field.Grid.with_" href="#phi.field.Grid.with_">with_</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.field.HardGeometryMask" href="#phi.field.HardGeometryMask">HardGeometryMask</a></code></h4>
<ul class="">
<li><code><a title="phi.field.HardGeometryMask.shape" href="#phi.field.HardGeometryMask.shape">shape</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.field.Noise" href="#phi.field.Noise">Noise</a></code></h4>
<ul class="">
<li><code><a title="phi.field.Noise.grid_sample" href="#phi.field.Noise.grid_sample">grid_sample</a></code></li>
<li><code><a title="phi.field.Noise.shape" href="#phi.field.Noise.shape">shape</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.field.PointCloud" href="#phi.field.PointCloud">PointCloud</a></code></h4>
<ul class="">
<li><code><a title="phi.field.PointCloud.bounds" href="#phi.field.PointCloud.bounds">bounds</a></code></li>
<li><code><a title="phi.field.PointCloud.color" href="#phi.field.PointCloud.color">color</a></code></li>
<li><code><a title="phi.field.PointCloud.shape" href="#phi.field.PointCloud.shape">shape</a></code></li>
<li><code><a title="phi.field.PointCloud.with_" href="#phi.field.PointCloud.with_">with_</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.field.SampledField" href="#phi.field.SampledField">SampledField</a></code></h4>
<ul class="two-column">
<li><code><a title="phi.field.SampledField.data" href="#phi.field.SampledField.data">data</a></code></li>
<li><code><a title="phi.field.SampledField.elements" href="#phi.field.SampledField.elements">elements</a></code></li>
<li><code><a title="phi.field.SampledField.extrapolation" href="#phi.field.SampledField.extrapolation">extrapolation</a></code></li>
<li><code><a title="phi.field.SampledField.points" href="#phi.field.SampledField.points">points</a></code></li>
<li><code><a title="phi.field.SampledField.shape" href="#phi.field.SampledField.shape">shape</a></code></li>
<li><code><a title="phi.field.SampledField.values" href="#phi.field.SampledField.values">values</a></code></li>
<li><code><a title="phi.field.SampledField.with_" href="#phi.field.SampledField.with_">with_</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.field.Scene" href="#phi.field.Scene">Scene</a></code></h4>
<ul class="two-column">
<li><code><a title="phi.field.Scene.at" href="#phi.field.Scene.at">at</a></code></li>
<li><code><a title="phi.field.Scene.batch_stack" href="#phi.field.Scene.batch_stack">batch_stack</a></code></li>
<li><code><a title="phi.field.Scene.complete_frames" href="#phi.field.Scene.complete_frames">complete_frames</a></code></li>
<li><code><a title="phi.field.Scene.copy_calling_script" href="#phi.field.Scene.copy_calling_script">copy_calling_script</a></code></li>
<li><code><a title="phi.field.Scene.copy_src" href="#phi.field.Scene.copy_src">copy_src</a></code></li>
<li><code><a title="phi.field.Scene.copy_src_text" href="#phi.field.Scene.copy_src_text">copy_src_text</a></code></li>
<li><code><a title="phi.field.Scene.create" href="#phi.field.Scene.create">create</a></code></li>
<li><code><a title="phi.field.Scene.exist_properties" href="#phi.field.Scene.exist_properties">exist_properties</a></code></li>
<li><code><a title="phi.field.Scene.exists_config" href="#phi.field.Scene.exists_config">exists_config</a></code></li>
<li><code><a title="phi.field.Scene.fieldnames" href="#phi.field.Scene.fieldnames">fieldnames</a></code></li>
<li><code><a title="phi.field.Scene.frames" href="#phi.field.Scene.frames">frames</a></code></li>
<li><code><a title="phi.field.Scene.is_batch" href="#phi.field.Scene.is_batch">is_batch</a></code></li>
<li><code><a title="phi.field.Scene.list" href="#phi.field.Scene.list">list</a></code></li>
<li><code><a title="phi.field.Scene.mkdir" href="#phi.field.Scene.mkdir">mkdir</a></code></li>
<li><code><a title="phi.field.Scene.path" href="#phi.field.Scene.path">path</a></code></li>
<li><code><a title="phi.field.Scene.paths" href="#phi.field.Scene.paths">paths</a></code></li>
<li><code><a title="phi.field.Scene.properties" href="#phi.field.Scene.properties">properties</a></code></li>
<li><code><a title="phi.field.Scene.put_properties" href="#phi.field.Scene.put_properties">put_properties</a></code></li>
<li><code><a title="phi.field.Scene.put_property" href="#phi.field.Scene.put_property">put_property</a></code></li>
<li><code><a title="phi.field.Scene.read" href="#phi.field.Scene.read">read</a></code></li>
<li><code><a title="phi.field.Scene.read_array" href="#phi.field.Scene.read_array">read_array</a></code></li>
<li><code><a title="phi.field.Scene.remove" href="#phi.field.Scene.remove">remove</a></code></li>
<li><code><a title="phi.field.Scene.shape" href="#phi.field.Scene.shape">shape</a></code></li>
<li><code><a title="phi.field.Scene.subpath" href="#phi.field.Scene.subpath">subpath</a></code></li>
<li><code><a title="phi.field.Scene.write" href="#phi.field.Scene.write">write</a></code></li>
<li><code><a title="phi.field.Scene.write_sim_frame" href="#phi.field.Scene.write_sim_frame">write_sim_frame</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.field.SoftGeometryMask" href="#phi.field.SoftGeometryMask">SoftGeometryMask</a></code></h4>
</li>
<li>
<h4><code><a title="phi.field.SoftGeometryMask" href="#phi.field.SoftGeometryMask">SoftGeometryMask</a></code></h4>
</li>
<li>
<h4><code><a title="phi.field.StaggeredGrid" href="#phi.field.StaggeredGrid">StaggeredGrid</a></code></h4>
<ul class="">
<li><code><a title="phi.field.StaggeredGrid.at_centers" href="#phi.field.StaggeredGrid.at_centers">at_centers</a></code></li>
<li><code><a title="phi.field.StaggeredGrid.cells" href="#phi.field.StaggeredGrid.cells">cells</a></code></li>
<li><code><a title="phi.field.StaggeredGrid.closest_values" href="#phi.field.StaggeredGrid.closest_values">closest_values</a></code></li>
<li><code><a title="phi.field.StaggeredGrid.staggered_tensor" href="#phi.field.StaggeredGrid.staggered_tensor">staggered_tensor</a></code></li>
<li><code><a title="phi.field.StaggeredGrid.with_" href="#phi.field.StaggeredGrid.with_">with_</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>