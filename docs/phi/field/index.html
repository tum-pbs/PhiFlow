<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>phi.field API documentation</title>
<meta name="description" content="The fields module provides a number of data structures and functions to represent continuous, spatially varying data …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>phi.field</code></h1>
</header>
<section id="section-intro">
<p>The fields module provides a number of data structures and functions to represent continuous, spatially varying data.</p>
<p>All fields are subclasses of Field which provides abstract functions for sampling field values at physical locations.</p>
<p>The most commonly used field types are</p>
<ul>
<li>CenteredGrid embeds a tensor in the physical space. Uses linear interpolation between grid points.</li>
<li>StaggeredGrid samples the vector components at face centers instead of at cell centers.</li>
<li>Noise is a function that produces a procedurally generated noise field</li>
</ul>
<p>See the <code><a title="phi.field" href="#phi.field">phi.field</a></code> module documentation at <a href="https://tum-pbs.github.io/PhiFlow/Fields.html">https://tum-pbs.github.io/PhiFlow/Fields.html</a></p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
The fields module provides a number of data structures and functions to represent continuous, spatially varying data.

All fields are subclasses of Field which provides abstract functions for sampling field values at physical locations.

The most commonly used field types are

* CenteredGrid embeds a tensor in the physical space. Uses linear interpolation between grid points.
* StaggeredGrid samples the vector components at face centers instead of at cell centers.
* Noise is a function that produces a procedurally generated noise field

See the `phi.field` module documentation at https://tum-pbs.github.io/PhiFlow/Fields.html
&#34;&#34;&#34;

from ._field import Field, SampledField
from ._analytic import AnalyticField
from ._constant import ConstantField
from ._mask import HardGeometryMask, SoftGeometryMask as GeometryMask, SoftGeometryMask
from ._grid import Grid, CenteredGrid, StaggeredGrid, unstack_staggered_tensor, stack_staggered_components
from ._point_cloud import PointCloud
from ._noise import Noise
from ._angular_velocity import AngularVelocity
from ._field_math import (
    laplace, gradient, divergence, stagger, staggered_curl_2d,
    mean, pad, shift, normalize,
    expose_tensors,
    solve,
    divergence_free,
    diffuse,
    where,
    l2_loss,
)
from ._field_io import write, read

__all__ = [key for key in globals().keys() if not key.startswith(&#39;_&#39;)]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="phi.field.diffuse"><code class="name flex">
<span>def <span class="ident">diffuse</span></span>(<span>field: ~FieldType, diffusivity, dt, substeps=1) ‑> ~FieldType</span>
</code></dt>
<dd>
<div class="desc"><p>Simulate a finite-time diffusion process of the form dF/dt = α · ΔF on a given <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> FieldType with diffusion coefficient α.</p>
<p>If <code>field</code> is periodic (set via <code>extrapolation='periodic'</code>), diffusion may be simulated in Fourier space.
Otherwise, finite differencing is used to approximate the</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>field</code></strong></dt>
<dd>CenteredGrid, StaggeredGrid or ConstantField</dd>
<dt><strong><code>diffusivity</code></strong></dt>
<dd>diffusion amount = diffusivity * dt</dd>
<dt><strong><code>dt</code></strong></dt>
<dd>diffusion amount = diffusivity * dt</dd>
<dt><strong><code>substeps</code></strong></dt>
<dd>number of iterations to use (Default value = 1)</dd>
<dt><strong><code>field</code></strong></dt>
<dd>FieldType: </dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code></dt>
<dd>Field of same type as <code>field</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def diffuse(field: FieldType, diffusivity, dt, substeps=1) -&gt; FieldType:
    &#34;&#34;&#34;
    Simulate a finite-time diffusion process of the form dF/dt = α · ΔF on a given `Field` FieldType with diffusion coefficient α.
    
    If `field` is periodic (set via `extrapolation=&#39;periodic&#39;`), diffusion may be simulated in Fourier space.
    Otherwise, finite differencing is used to approximate the

    Args:
      field: CenteredGrid, StaggeredGrid or ConstantField
      diffusivity: diffusion amount = diffusivity * dt
      dt: diffusion amount = diffusivity * dt
      substeps: number of iterations to use (Default value = 1)
      field: FieldType: 

    Returns:
      Field: Field of same type as `field`

    &#34;&#34;&#34;
    if isinstance(field, ConstantField):
        return field
    assert isinstance(field, Grid), &#34;Cannot diffuse field of type &#39;%s&#39;&#34; % type(field)
    amount = diffusivity * dt
    if field.extrapolation == &#39;periodic&#39; and not isinstance(amount, Field):
        fft_laplace = -(2 * np.pi) ** 2 * squared(fftfreq(field))
        diffuse_kernel = math.exp(fft_laplace * amount)
        return real(ifft(fft(field) * diffuse_kernel))
    else:
        if isinstance(amount, Field):
            amount = amount.at(field)
        for i in range(substeps):
            field += amount / substeps * laplace(field)
        return field</code></pre>
</details>
</dd>
<dt id="phi.field.divergence"><code class="name flex">
<span>def <span class="ident">divergence</span></span>(<span>field: phi.field._grid.Grid) ‑> phi.field._grid.CenteredGrid</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the divergence of a grid using finite differences.</p>
<p>This function can operate in two modes depending on the type of <code>field</code>:</p>
<ul>
<li><code><a title="phi.field.CenteredGrid" href="#phi.field.CenteredGrid">CenteredGrid</a></code> approximates the divergence at cell centers using central differences</li>
<li><code><a title="phi.field.StaggeredGrid" href="#phi.field.StaggeredGrid">StaggeredGrid</a></code> exactly computes the divergence at cell centers</li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>field</code></strong></dt>
<dd>vector field as <code><a title="phi.field.CenteredGrid" href="#phi.field.CenteredGrid">CenteredGrid</a></code> or <code><a title="phi.field.StaggeredGrid" href="#phi.field.StaggeredGrid">StaggeredGrid</a></code></dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Divergence field as <code><a title="phi.field.CenteredGrid" href="#phi.field.CenteredGrid">CenteredGrid</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def divergence(field: Grid) -&gt; CenteredGrid:
    &#34;&#34;&#34;
    Computes the divergence of a grid using finite differences.

    This function can operate in two modes depending on the type of `field`:

    * `CenteredGrid` approximates the divergence at cell centers using central differences
    * `StaggeredGrid` exactly computes the divergence at cell centers

    Args:
        field: vector field as `CenteredGrid` or `StaggeredGrid`

    Returns:
        Divergence field as `CenteredGrid`
    &#34;&#34;&#34;
    if isinstance(field, StaggeredGrid):
        components = []
        for i, dim in enumerate(field.shape.spatial.names):
            div_dim = math.gradient(field.values.vector[i], dx=field.dx[i], difference=&#39;forward&#39;, padding=None, dims=[dim]).gradient[0]
            components.append(div_dim)
        data = math.sum(components, 0)
        return CenteredGrid(data, field.box, field.extrapolation.gradient())
    elif isinstance(field, CenteredGrid):
        left, right = shift(field, (-1, 1), stack_dim=&#39;div_&#39;)
        grad = (right - left) / (field.dx * 2)
        components = [grad.vector[i].div_[i] for i in range(grad.div_.size)]
        result = sum(components)
        return result
    else:
        raise NotImplementedError(f&#34;{type(field)} not supported. Only StaggeredGrid allowed.&#34;)</code></pre>
</details>
</dd>
<dt id="phi.field.divergence_free"><code class="name flex">
<span>def <span class="ident">divergence_free</span></span>(<span>vector_field: phi.field._grid.Grid, solve_params: phi.math.backend._optim.LinearSolve = &lt;phi.math.backend._optim.LinearSolve object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the divergence-free part of the given vector field.
The boundary conditions are taken from <code>vector_field</code>.</p>
<p>This function solves for a scalar potential with an iterative solver.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>vector_field</code></strong></dt>
<dd>vector grid</dd>
<dt><strong><code>solve_params</code></strong></dt>
<dd>return: divergence-free vector field, scalar potential, number of iterations performed, divergence</dd>
<dt><strong><code>vector_field</code></strong></dt>
<dd>Grid: </dd>
<dt><strong><code>solve_params</code></strong></dt>
<dd>math.LinearSolve:
(Default value = math.LinearSolve(None)</dd>
</dl>
<p>1e-5): </p>
<h2 id="returns">Returns</h2>
<p>divergence-free vector field, scalar potential, number of iterations performed, divergence</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def divergence_free(vector_field: Grid, solve_params: math.LinearSolve = math.LinearSolve(None, 1e-5)):
    &#34;&#34;&#34;
    Returns the divergence-free part of the given vector field.
    The boundary conditions are taken from `vector_field`.
    
    This function solves for a scalar potential with an iterative solver.

    Args:
      vector_field: vector grid
      solve_params: return: divergence-free vector field, scalar potential, number of iterations performed, divergence
      vector_field: Grid: 
      solve_params: math.LinearSolve:  (Default value = math.LinearSolve(None)
      1e-5): 

    Returns:
      divergence-free vector field, scalar potential, number of iterations performed, divergence

    &#34;&#34;&#34;
    div = divergence(vector_field)
    div -= mean(div)
    pressure_extrapolation = vector_field.extrapolation  # periodic -&gt; periodic, closed -&gt; boundary, open -&gt; zero
    pressure_guess = CenteredGrid.sample(0, vector_field.resolution, vector_field.box, extrapolation=pressure_extrapolation)
    converged, potential, iterations = solve(laplace, div, pressure_guess, solve_params)
    gradp = gradient(potential, type=StaggeredGrid)
    vector_field -= gradp
    return vector_field, potential, iterations, div</code></pre>
</details>
</dd>
<dt id="phi.field.expose_tensors"><code class="name flex">
<span>def <span class="ident">expose_tensors</span></span>(<span>field_function, *proto_fields)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expose_tensors(field_function, *proto_fields):
    @wraps(field_function)
    def wrapper(*field_data):
        fields = [proto.with_(values=data) for data, proto in zip(field_data, proto_fields)]
        result = field_function(*fields)
        assert isinstance(result, SampledField), f&#34;function must return an instance of SampledField but returned {result}&#34;
        return result.values
    return wrapper</code></pre>
</details>
</dd>
<dt id="phi.field.gradient"><code class="name flex">
<span>def <span class="ident">gradient</span></span>(<span>field: phi.field._grid.CenteredGrid, type: type = phi.field._grid.CenteredGrid, stack_dim='vector')</span>
</code></dt>
<dd>
<div class="desc"><p>Finite difference gradient.</p>
<p>This function can operate in two modes:</p>
<ul>
<li><code>type=CenteredGrid</code> approximates the gradient at cell centers using central differences</li>
<li><code>type=StaggeredGrid</code> computes the gradient at face centers of neighbouring cells</li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>field</code></strong></dt>
<dd>centered grid of any number of dimensions (scalar field, vector field, tensor field)</dd>
<dt><strong><code>type</code></strong></dt>
<dd>either <code><a title="phi.field.CenteredGrid" href="#phi.field.CenteredGrid">CenteredGrid</a></code> or <code><a title="phi.field.StaggeredGrid" href="#phi.field.StaggeredGrid">StaggeredGrid</a></code></dd>
<dt><strong><code>stack_dim</code></strong></dt>
<dd>name of dimension to be added. This dimension lists the gradient w.r.t. the spatial dimensions.
The <code>field</code> must not have a dimension of the same name.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>gradient field of type <code>type</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gradient(field: CenteredGrid, type: type = CenteredGrid, stack_dim=&#39;vector&#39;):
    &#34;&#34;&#34;
    Finite difference gradient.

    This function can operate in two modes:

    * `type=CenteredGrid` approximates the gradient at cell centers using central differences
    * `type=StaggeredGrid` computes the gradient at face centers of neighbouring cells

    Args:
        field: centered grid of any number of dimensions (scalar field, vector field, tensor field)
        type: either `CenteredGrid` or `StaggeredGrid`
        stack_dim: name of dimension to be added. This dimension lists the gradient w.r.t. the spatial dimensions.
            The `field` must not have a dimension of the same name.

    Returns:
        gradient field of type `type`.

    &#34;&#34;&#34;
    if type == CenteredGrid:
        values = math.gradient(field.values, field.dx.vector.as_channel(name=stack_dim), difference=&#39;central&#39;, padding=field.extrapolation, stack_dim=stack_dim)
        return CenteredGrid(values, field.bounds, field.extrapolation.gradient())
    elif type == StaggeredGrid:
        assert stack_dim == &#39;vector&#39;
        return stagger(field, lambda lower, upper: (upper - lower) / field.dx, field.extrapolation.gradient())
    raise NotImplementedError(f&#34;{type(field)} not supported. Only CenteredGrid and StaggeredGrid allowed.&#34;)</code></pre>
</details>
</dd>
<dt id="phi.field.l2_loss"><code class="name flex">
<span>def <span class="ident">l2_loss</span></span>(<span>field: phi.field._field.SampledField, batch_norm=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def l2_loss(field: SampledField, batch_norm=True):
    return math.l2_loss(field.values, batch_norm=batch_norm)</code></pre>
</details>
</dd>
<dt id="phi.field.laplace"><code class="name flex">
<span>def <span class="ident">laplace</span></span>(<span>field: phi.field._grid.Grid, axes=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def laplace(field: Grid, axes=None):
    result = field._op1(lambda tensor: math.laplace(tensor, dx=field.dx, padding=field.extrapolation, dims=axes))
    return result</code></pre>
</details>
</dd>
<dt id="phi.field.mean"><code class="name flex">
<span>def <span class="ident">mean</span></span>(<span>field: phi.field._grid.Grid)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mean(field: Grid):
    return math.mean(field.values, field.shape.spatial)</code></pre>
</details>
</dd>
<dt id="phi.field.normalize"><code class="name flex">
<span>def <span class="ident">normalize</span></span>(<span>field: phi.field._field.SampledField, norm: phi.field._field.SampledField, epsilon=1e-05)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalize(field: SampledField, norm: SampledField, epsilon=1e-5):
    data = math.normalize_to(field.values, norm.values, epsilon)
    return field.with_(values=data)</code></pre>
</details>
</dd>
<dt id="phi.field.pad"><code class="name flex">
<span>def <span class="ident">pad</span></span>(<span>grid: phi.field._grid.Grid, widths: int)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pad(grid: Grid, widths: int or tuple or list or dict):
    if isinstance(widths, int):
        widths = {axis: (widths, widths) for axis in grid.shape.spatial.names}
    elif isinstance(widths, (tuple, list)):
        widths = {axis: (width if isinstance(width, (tuple, list)) else (width, width)) for axis, width in zip(grid.shape.spatial.names, widths)}
    else:
        assert isinstance(widths, dict)
    widths_list = [widths[axis] for axis in grid.shape.spatial.names]
    if isinstance(grid, Grid):
        data = math.pad(grid.values, widths, grid.extrapolation)
        w_lower = tensor([w[0] for w in widths_list])
        w_upper = tensor([w[1] for w in widths_list])
        box = Box(grid.box.lower - w_lower * grid.dx, grid.box.upper + w_upper * grid.dx)
        return type(grid)(data, box, grid.extrapolation)
    raise NotImplementedError(f&#34;{type(grid)} not supported. Only Grid instances allowed.&#34;)</code></pre>
</details>
</dd>
<dt id="phi.field.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>file: str, convert_to_backend=True) ‑> phi.field._field.SampledField</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(file: str, convert_to_backend=True) -&gt; SampledField:
    stored = np.load(file, allow_pickle=True)
    ftype = stored[&#39;field_type&#39;]
    implemented_types = (&#39;CenteredGrid&#39;, &#39;StaggeredGrid&#39;)
    if ftype in implemented_types:
        data = stored[&#39;data&#39;]
        if convert_to_backend:
            data = math.backend.DYNAMIC_BACKEND.default_backend.as_tensor(data, convert_external=True)
        shape = math.Shape(data.shape, stored[&#39;dim_names&#39;], stored[&#39;dim_types&#39;])
        data = NativeTensor(data, shape)
        lower = math.tensor(stored[&#39;lower&#39;], names=&#39;vector&#39;)
        upper = math.tensor(stored[&#39;upper&#39;], names=&#39;vector&#39;)
        extrapolation = math.extrapolation.from_dict(stored[&#39;extrapolation&#39;][()])
        if ftype == &#39;CenteredGrid&#39;:
            return CenteredGrid(data, geom.Box(lower, upper), extrapolation)
        elif ftype == &#39;StaggeredGrid&#39;:
            data_ = unstack_staggered_tensor(data)
            return StaggeredGrid(data_, geom.Box(lower, upper), extrapolation)
    raise NotImplementedError(f&#34;{ftype} not implemented ({implemented_types})&#34;)</code></pre>
</details>
</dd>
<dt id="phi.field.shift"><code class="name flex">
<span>def <span class="ident">shift</span></span>(<span>grid: phi.field._grid.CenteredGrid, offsets: tuple, stack_dim='shift')</span>
</code></dt>
<dd>
<div class="desc"><p>Wraps :func:<code>math.shift</code> for CenteredGrid.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>grid</code></strong></dt>
<dd>CenteredGrid: </dd>
<dt><strong><code>offsets</code></strong></dt>
<dd>tuple: </dd>
<dt><strong><code>stack_dim</code></strong></dt>
<dd>(Default value = 'shift')</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shift(grid: CenteredGrid, offsets: tuple, stack_dim=&#39;shift&#39;):
    &#34;&#34;&#34;
    Wraps :func:`math.shift` for CenteredGrid.

    Args:
      grid: CenteredGrid: 
      offsets: tuple: 
      stack_dim:  (Default value = &#39;shift&#39;)

    Returns:

    &#34;&#34;&#34;
    data = math.shift(grid.values, offsets, padding=grid.extrapolation, stack_dim=stack_dim)
    return [CenteredGrid(data[i], grid.box, grid.extrapolation) for i in range(len(offsets))]</code></pre>
</details>
</dd>
<dt id="phi.field.solve"><code class="name flex">
<span>def <span class="ident">solve</span></span>(<span>function, y: phi.field._grid.Grid, x0: phi.field._grid.Grid, solve_params: phi.math.backend._optim.Solve, callback=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def solve(function, y: Grid, x0: Grid, solve_params: math.Solve, callback=None):
    if callback is not None:
        def field_callback(x):
            x = x0.with_(values=x)
            callback(x)
    else:
        field_callback = None

    data_function = expose_tensors(function, x0)
    converged, x, iterations = math.solve(data_function, y.values, x0.values, solve_params, field_callback)
    return converged, x0.with_(values=x), iterations</code></pre>
</details>
</dd>
<dt id="phi.field.stack_staggered_components"><code class="name flex">
<span>def <span class="ident">stack_staggered_components</span></span>(<span>data: phi.math._tensors.Tensor) ‑> phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stack_staggered_components(data: Tensor) -&gt; Tensor:
    padded = []
    for dim, component in zip(data.shape.spatial.names, data.unstack(&#39;vector&#39;)):
        padded.append(math.pad(component, {d: (0, 1) for d in data.shape.spatial.without(dim).names}, mode=math.extrapolation.ZERO))
    return math.channel_stack(padded, &#39;vector&#39;)</code></pre>
</details>
</dd>
<dt id="phi.field.stagger"><code class="name flex">
<span>def <span class="ident">stagger</span></span>(<span>field: phi.field._grid.CenteredGrid, face_function: <built-in function callable>, extrapolation: <a title="phi.math.extrapolation.Extrapolation" href="../math/extrapolation.html#phi.math.extrapolation.Extrapolation">Extrapolation</a>, type: type = phi.field._grid.StaggeredGrid)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new grid by evaluating <code>face_function</code> given two neighbouring cells.
One layer of missing cells is inferred from the extrapolation.</p>
<p>This method returns a Field of type <code>type</code> which must be either StaggeredGrid or CenteredGrid.
When returning a StaggeredGrid, the new values are sampled at the faces of neighbouring cells.
When returning a CenteredGrid, the new grid has the same resolution as <code>field</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>field</code></strong></dt>
<dd>centered grid</dd>
<dt><strong><code>face_function</code></strong></dt>
<dd>function mapping (value1: Tensor, value2: Tensor) -&gt; center_value: Tensor</dd>
<dt><strong><code>extrapolation</code></strong></dt>
<dd>extrapolation mode of the returned grid. Has no effect on the values.</dd>
<dt><strong><code>type</code></strong></dt>
<dd>one of (StaggeredGrid, CenteredGrid)</dd>
<dt><strong><code>field</code></strong></dt>
<dd>CenteredGrid: </dd>
<dt><strong><code>face_function</code></strong></dt>
<dd>callable: </dd>
<dt><strong><code>extrapolation</code></strong></dt>
<dd>math.extrapolation.Extrapolation: </dd>
<dt><strong><code>type</code></strong></dt>
<dd>type:
(Default value = StaggeredGrid)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>grid of type matching the <code>type</code> argument</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stagger(field: CenteredGrid, face_function: callable, extrapolation: math.extrapolation.Extrapolation, type: type = StaggeredGrid):
    &#34;&#34;&#34;
    Creates a new grid by evaluating `face_function` given two neighbouring cells.
    One layer of missing cells is inferred from the extrapolation.
    
    This method returns a Field of type `type` which must be either StaggeredGrid or CenteredGrid.
    When returning a StaggeredGrid, the new values are sampled at the faces of neighbouring cells.
    When returning a CenteredGrid, the new grid has the same resolution as `field`.

    Args:
      field: centered grid
      face_function: function mapping (value1: Tensor, value2: Tensor) -&gt; center_value: Tensor
      extrapolation: extrapolation mode of the returned grid. Has no effect on the values.
      type: one of (StaggeredGrid, CenteredGrid)
      field: CenteredGrid: 
      face_function: callable: 
      extrapolation: math.extrapolation.Extrapolation: 
      type: type:  (Default value = StaggeredGrid)

    Returns:
      grid of type matching the `type` argument

    &#34;&#34;&#34;
    all_lower = []
    all_upper = []
    if type == StaggeredGrid:
        for dim in field.shape.spatial.names:
            all_upper.append(math.pad(field.values, {dim: (0, 1)}, field.extrapolation))
            all_lower.append(math.pad(field.values, {dim: (1, 0)}, field.extrapolation))
        all_upper = math.channel_stack(all_upper, &#39;vector&#39;)
        all_lower = math.channel_stack(all_lower, &#39;vector&#39;)
        values = face_function(all_lower, all_upper)
        return StaggeredGrid(values, field.bounds, extrapolation)
    elif type == CenteredGrid:
        left, right = math.shift(field.values, (-1, 1), padding=field.extrapolation, stack_dim=&#39;vector&#39;)
        values = face_function(left, right)
        return CenteredGrid(values, field.bounds, extrapolation)
    else:
        raise ValueError(type)</code></pre>
</details>
</dd>
<dt id="phi.field.staggered_curl_2d"><code class="name flex">
<span>def <span class="ident">staggered_curl_2d</span></span>(<span>grid, pad_width=(1, 2))</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def staggered_curl_2d(grid, pad_width=(1, 2)):
    assert isinstance(grid, CenteredGrid)
    kernel = math.zeros((3, 3, 1, 2))
    kernel[1, :, 0, 0] = [0, 1, -1]  # y-component: - dz/dx
    kernel[:, 1, 0, 1] = [0, -1, 1]  # x-component: dz/dy
    scalar_potential = grid.padded([pad_width, pad_width]).values
    vector_field = math.conv(scalar_potential, kernel, padding=&#39;valid&#39;)
    return StaggeredGrid(vector_field, bounds=grid.box)</code></pre>
</details>
</dd>
<dt id="phi.field.unstack_staggered_tensor"><code class="name flex">
<span>def <span class="ident">unstack_staggered_tensor</span></span>(<span>data: phi.math._tensors.Tensor) ‑> phi.math._tensors.TensorStack</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unstack_staggered_tensor(data: Tensor) -&gt; TensorStack:
    sliced = []
    for dim, component in zip(data.shape.spatial.names, data.unstack(&#39;vector&#39;)):
        sliced.append(component[{d: slice(None, -1) for d in data.shape.spatial.without(dim).names}])
    return math.channel_stack(sliced, &#39;vector&#39;)</code></pre>
</details>
</dd>
<dt id="phi.field.where"><code class="name flex">
<span>def <span class="ident">where</span></span>(<span>mask: phi.field._field.Field, field_true: phi.field._field.Field, field_false: phi.field._field.Field)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def where(mask: Field or Geometry, field_true: Field, field_false: Field):
    if isinstance(mask, Geometry):
        mask = HardGeometryMask(mask)
    elif isinstance(mask, SampledField):
        field_true = field_true.at(mask)
        field_false = field_false.at(mask)
    elif isinstance(field_true, SampledField):
        mask = mask.at(field_true)
        field_false = field_false.at(field_true)
    elif isinstance(field_false, SampledField):
        mask = mask.at(field_true)
        field_true = field_true.at(mask)
    else:
        raise NotImplementedError(&#39;At least one argument must be a SampledField&#39;)
    values = mask.values * field_true.values + (1 - mask.values) * field_false.values
    # values = math.where(mask.values, field_true.values, field_false.values)
    return field_true.with_(values=values)</code></pre>
</details>
</dd>
<dt id="phi.field.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>field: phi.field._field.SampledField, file: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(field: SampledField, file: str):
    if isinstance(field, StaggeredGrid):
        data = field.staggered_tensor().numpy()
    else:
        data = field.values.numpy()
    dim_names = field.values.shape.names
    if isinstance(field, Grid):
        lower = field.box.lower.numpy()
        upper = field.box.upper.numpy()
        extrap = field.extrapolation.to_dict()
        np.savez_compressed(file, dim_names=dim_names, dim_types=field.values.shape.types, field_type=type(field).__name__, lower=lower, upper=upper, extrapolation=extrap, data=data)
    else:
        raise NotImplementedError(f&#34;{type(field)} not implemented. Only Grid allowed.&#34;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="phi.field.AnalyticField"><code class="flex name class">
<span>class <span class="ident">AnalyticField</span></span>
</code></dt>
<dd>
<div class="desc"><p>Base class for all fields.</p>
<p>Important implementations:</p>
<ul>
<li>CenteredGrid</li>
<li>StaggeredGrid</li>
<li>PointCloud</li>
<li>Noise</li>
</ul>
<p>See the <code><a title="phi.field" href="#phi.field">phi.field</a></code> module documentation at <a href="https://tum-pbs.github.io/PhiFlow/Fields.html">https://tum-pbs.github.io/PhiFlow/Fields.html</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AnalyticField(Field):

    def unstack(self, dimension: str) -&gt; tuple:
        components = []
        size = self.shape.get_size(dimension)
        shape = self.shape.without(dimension)
        for i in range(size):
            def _context(index=i):
                return lambda x: x.unstack(dimension)[index]
            components.append(_SymbolicOpField(shape, _context(i), [self]))
        return tuple(components)

    def _op2(self, other, operator):
        if isinstance(other, SampledField):
            self_sampled = self.at(other)
            data = operator(self_sampled.values, other.values)
            return other.with_(values=data)
        other = math.tensor(other)
        new_shape = self.shape.combined(other.shape)
        return _SymbolicOpField(new_shape, operator, [self, other])

    def _op1(self, operator):
        return _SymbolicOpField(self.shape, operator, [self])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.field._field.Field</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>phi.field._analytic._SymbolicOpField</li>
<li>phi.field._angular_velocity.AngularVelocity</li>
<li>phi.field._mask.HardGeometryMask</li>
<li>phi.field._noise.Noise</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="phi.field.AnalyticField.unstack"><code class="name flex">
<span>def <span class="ident">unstack</span></span>(<span>self, dimension: str) ‑> tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Unstack the field along one of its dimensions.
The dimension can be batch, spatial or channel.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dimension</code></strong></dt>
<dd>name of the dimension to unstack, must be part of <code>self.shape</code></dd>
<dt><strong><code>dimension</code></strong></dt>
<dd>str: </dd>
</dl>
<h2 id="returns">Returns</h2>
<p>tuple of Fields</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unstack(self, dimension: str) -&gt; tuple:
    components = []
    size = self.shape.get_size(dimension)
    shape = self.shape.without(dimension)
    for i in range(size):
        def _context(index=i):
            return lambda x: x.unstack(dimension)[index]
        components.append(_SymbolicOpField(shape, _context(i), [self]))
    return tuple(components)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="phi.field.AngularVelocity"><code class="flex name class">
<span>class <span class="ident">AngularVelocity</span></span>
<span>(</span><span>location, strength=1.0, falloff: <built-in function callable> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for all fields.</p>
<p>Important implementations:</p>
<ul>
<li>CenteredGrid</li>
<li>StaggeredGrid</li>
<li>PointCloud</li>
<li>Noise</li>
</ul>
<p>See the <code><a title="phi.field" href="#phi.field">phi.field</a></code> module documentation at <a href="https://tum-pbs.github.io/PhiFlow/Fields.html">https://tum-pbs.github.io/PhiFlow/Fields.html</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AngularVelocity(AnalyticField):

    def __init__(self, location, strength=1.0, falloff: callable = None):
        location = math.tensor(location)
        assert location.shape.channel.names == (&#39;vector&#39;,), &#34;location must have a single channel dimension called &#39;vector&#39;&#34;
        assert location.shape.spatial.is_empty, &#34;location tensor cannot have any spatial dimensions&#34;
        self.location = location
        self.strength = strength
        self.falloff = falloff
        spatial_names = [GLOBAL_AXIS_ORDER.axis_name(i, location.vector.size) for i in range(location.vector.size)]
        self._shape = location.shape.combined(math.spatial_shape([1] * location.vector.size, spatial_names))

    def sample_at(self, points, reduce_channels=()) -&gt; math.Tensor:
        distances = points - self.location
        strength = self.strength if self.falloff is None else self.strength * self.falloff(distances)
        if reduce_channels:
            assert len(reduce_channels) == 1
            velocities = [math.cross_product(strength, dist).vector[i] for i, dist in enumerate(distances.unstack(reduce_channels[0]))]  # TODO this is inefficient, computes components that are discarded
            velocity = math.channel_stack(velocities, &#39;vector&#39;)
        else:
            velocity = math.cross_product(strength, distances)
        velocity = math.sum(velocity, self.location.shape.batch.without(points.shape))
        return velocity

    @property
    def shape(self) -&gt; Shape:
        return self._shape</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.field._analytic.AnalyticField</li>
<li>phi.field._field.Field</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="phi.field.AngularVelocity.shape"><code class="name">var <span class="ident">shape</span> : phi.math._shape.Shape</code></dt>
<dd>
<div class="desc"><p>Returns a shape with the following properties</p>
<ul>
<li>The spatial dimension names match the dimensions of this Field</li>
<li>The batch dimensions match the batch dimensions of this Field</li>
<li>The channel dimensions match the channels of this Field</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape(self) -&gt; Shape:
    return self._shape</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phi.field.AngularVelocity.sample_at"><code class="name flex">
<span>def <span class="ident">sample_at</span></span>(<span>self, points, reduce_channels=()) ‑> phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Sample this field at the world-space locations (in physical units) given by <code>points</code>.
Points must have a single channel dimension named <code>vector</code>.
It may additionally contain any number of batch and spatial dimensions, all treated as batch dimensions.</p>
<p>See <code><a title="phi.field.Field.sample_in" href="#phi.field.Field.sample_in">Field.sample_in()</a></code>, <code><a title="phi.field.Field.at" href="#phi.field.Field.at">Field.at()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>points</code></strong></dt>
<dd>world-space locations</dd>
<dt><strong><code>reduce_channels</code></strong></dt>
<dd>
<p>(optional) Dimensions of <code>points</code> to be reduced against the channel dimensions of this <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code>.
Causes the components of this field to be sampled at different locations.
The result is the same as <code>math.channel_stack([component.sample_at(p) for component, p in zip(field.unstack('vector'), points.unstack(reduce)])</code>
assuming this field as a single channel dimension called <code>vector</code>.</p>
<p>Example:
While <code><a title="phi.field.StaggeredGrid.sample_at" href="#phi.field.StaggeredGrid.sample_at">StaggeredGrid.sample_at()</a>(staggered_points)</code> samples all components at all faces,
<code>StaggeredGrid.sample_at(staggered_points, reduce_channels='staggered')</code> samples each component at the corresponding face only.</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Sampled values as a <code>Tensor</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_at(self, points, reduce_channels=()) -&gt; math.Tensor:
    distances = points - self.location
    strength = self.strength if self.falloff is None else self.strength * self.falloff(distances)
    if reduce_channels:
        assert len(reduce_channels) == 1
        velocities = [math.cross_product(strength, dist).vector[i] for i, dist in enumerate(distances.unstack(reduce_channels[0]))]  # TODO this is inefficient, computes components that are discarded
        velocity = math.channel_stack(velocities, &#39;vector&#39;)
    else:
        velocity = math.cross_product(strength, distances)
    velocity = math.sum(velocity, self.location.shape.batch.without(points.shape))
    return velocity</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="phi.field.CenteredGrid"><code class="flex name class">
<span>class <span class="ident">CenteredGrid</span></span>
<span>(</span><span>values, bounds: phi.geom._box.Box, extrapolation=0)</span>
</code></dt>
<dd>
<div class="desc"><p>N-dimensional grid with values sampled at the cell centers.
A centered grid is defined through its data tensor, its bounds describing the physical size and extrapolation.</p>
<p>Centered grids support arbitrary batch, spatial and channel dimensions.</p>
<p>See the <code><a title="phi.field" href="#phi.field">phi.field</a></code> module documentation at <a href="https://tum-pbs.github.io/PhiFlow/Fields.html">https://tum-pbs.github.io/PhiFlow/Fields.html</a></p>
<p>Args:</p>
<p>Returns:</p>
<p>Base class for fields that are sampled at specific locations such as grids or point clouds.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>elements</code></strong></dt>
<dd>Geometry object specifying the sample points and sizes</dd>
<dt><strong><code>values</code></strong></dt>
<dd>values corresponding to elements</dd>
<dt><strong><code>extrapolation</code></strong></dt>
<dd>values outside elements</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CenteredGrid(Grid):
    &#34;&#34;&#34;
    N-dimensional grid with values sampled at the cell centers.
    A centered grid is defined through its data tensor, its bounds describing the physical size and extrapolation.
    
    Centered grids support arbitrary batch, spatial and channel dimensions.
    
    See the `phi.field` module documentation at https://tum-pbs.github.io/PhiFlow/Fields.html

    Args:

    Returns:

    &#34;&#34;&#34;

    def __init__(self, values, bounds: Box, extrapolation=math.extrapolation.ZERO):
        Grid.__init__(self, values, values.shape.spatial, bounds, extrapolation)

    @staticmethod
    def sample(value: Geometry or Field or int or float or callable,
               resolution: Shape,
               box: Box,
               extrapolation=math.extrapolation.ZERO):
        if isinstance(value, Geometry):
            value = SoftGeometryMask(value)
        if isinstance(value, Field):
            elements = GridCell(resolution, box)
            data = value.sample_in(elements)
        else:
            if callable(value):
                x = GridCell(resolution, box).center
                value = value(x)
            value = tensor(value)
            data = math.zeros(resolution) + value
        return CenteredGrid(data, box, extrapolation)

    def sample_in(self, geometry: Geometry, reduce_channels=()) -&gt; Tensor:
        if reduce_channels:
            assert len(reduce_channels) == 1
            geometries = geometry.unstack(reduce_channels[0])
            components = self.unstack(&#39;vector&#39;)
            sampled = [c.sample_in(g) for c, g in zip(components, geometries)]
            return math.channel_stack(sampled, &#39;vector&#39;)
        if isinstance(geometry, GeometryStack):
            sampled = [self.sample_in(g) for g in geometry.geometries]
            return math.batch_stack(sampled, geometry.stack_dim_name)
        if isinstance(geometry, GridCell):
            if self.elements == geometry:
                return self.values
            elif math.close(self.dx, geometry.size):
                fast_resampled = self._shift_resample(geometry.resolution, geometry.bounds)
                if fast_resampled is not NotImplemented:
                    return fast_resampled
        return self.sample_at(geometry.center, reduce_channels)

    def sample_at(self, points, reduce_channels=()) -&gt; Tensor:
        local_points = self.box.global_to_local(points) * self.resolution - 0.5
        if len(reduce_channels) == 0:
            return math.grid_sample(self.values, local_points, self.extrapolation)
        else:
            assert self.shape.channel.sizes == points.shape.get_size(reduce_channels)
            if len(reduce_channels) &gt; 1:
                raise NotImplementedError(f&#34;{len(reduce_channels)} &gt; 1. Only 1 reduced channel allowed.&#34;)
            channels = []
            for i, channel in enumerate(self.values.vector.unstack()):
                channels.append(math.grid_sample(channel, local_points[{reduce_channels[0]: i}], self.extrapolation))
            return math.channel_stack(channels, &#39;vector&#39;)

    def _shift_resample(self, resolution, box, threshold=1e-5, max_padding=20):
        lower = math.to_int(math.ceil(math.maximum(0, self.box.lower - box.lower) / self.dx - threshold))
        upper = math.to_int(math.ceil(math.maximum(0, box.upper - self.box.upper) / self.dx - threshold))
        total_padding = math.sum(lower) + math.sum(upper)
        if total_padding == 0:
            origin_in_local = self.box.global_to_local(box.lower) * self.resolution
            data = math.sample_subgrid(self.values, origin_in_local, resolution)
            return data
        elif total_padding &lt; max_padding:
            from phi.field import pad
            padded = pad(self, {dim: (int(lower[i]), int(upper[i])) for i, dim in enumerate(self.shape.spatial.names)})
            return padded._shift_resample(resolution, box)

    def closest_values(self, points: Tensor, reduce_channels=()):
        local_points = self.box.global_to_local(points) * self.resolution - 0.5
        return math.closest_grid_values(self.values, local_points, self.extrapolation)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.field._grid.Grid</li>
<li>phi.field._field.SampledField</li>
<li>phi.field._field.Field</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="phi.field.CenteredGrid.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>value: phi.geom._geom.Geometry, resolution: phi.math._shape.Shape, box: phi.geom._box.Box, extrapolation=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def sample(value: Geometry or Field or int or float or callable,
           resolution: Shape,
           box: Box,
           extrapolation=math.extrapolation.ZERO):
    if isinstance(value, Geometry):
        value = SoftGeometryMask(value)
    if isinstance(value, Field):
        elements = GridCell(resolution, box)
        data = value.sample_in(elements)
    else:
        if callable(value):
            x = GridCell(resolution, box).center
            value = value(x)
        value = tensor(value)
        data = math.zeros(resolution) + value
    return CenteredGrid(data, box, extrapolation)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phi.field.CenteredGrid.closest_values"><code class="name flex">
<span>def <span class="ident">closest_values</span></span>(<span>self, points: phi.math._tensors.Tensor, reduce_channels=())</span>
</code></dt>
<dd>
<div class="desc"><p>Sample the closest grid point values of this field at the world-space locations (in physical units) given by <code>points</code>.
Points must have a single channel dimension named <code>vector</code>.
It may additionally contain any number of batch and spatial dimensions, all treated as batch dimensions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>points</code></strong></dt>
<dd>world-space locations</dd>
<dt><strong><code>reduce_channels</code></strong></dt>
<dd>(optional) See <code><a title="phi.field.Field.sample_at" href="#phi.field.Field.sample_at">Field.sample_at()</a></code> for a description.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Closest grid point values as a <code>Tensor</code>.
For each dimension, the grid points immediately left and right of the sample points are evaluated.
For each point in <code>points</code>, a <em>2^d</em> cube of points is determined where <em>d</em> is the number of spatial dimensions of this field.
These values are stacked along the new dimensions <code>'closest_&lt;dim&gt;'</code> where <code>&lt;dim&gt;</code> refers to the name of a spatial dimension.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def closest_values(self, points: Tensor, reduce_channels=()):
    local_points = self.box.global_to_local(points) * self.resolution - 0.5
    return math.closest_grid_values(self.values, local_points, self.extrapolation)</code></pre>
</details>
</dd>
<dt id="phi.field.CenteredGrid.sample_at"><code class="name flex">
<span>def <span class="ident">sample_at</span></span>(<span>self, points, reduce_channels=()) ‑> phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Sample this field at the world-space locations (in physical units) given by <code>points</code>.
Points must have a single channel dimension named <code>vector</code>.
It may additionally contain any number of batch and spatial dimensions, all treated as batch dimensions.</p>
<p>See <code><a title="phi.field.Field.sample_in" href="#phi.field.Field.sample_in">Field.sample_in()</a></code>, <code><a title="phi.field.Field.at" href="#phi.field.Field.at">Field.at()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>points</code></strong></dt>
<dd>world-space locations</dd>
<dt><strong><code>reduce_channels</code></strong></dt>
<dd>
<p>(optional) Dimensions of <code>points</code> to be reduced against the channel dimensions of this <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code>.
Causes the components of this field to be sampled at different locations.
The result is the same as <code>math.channel_stack([component.sample_at(p) for component, p in zip(field.unstack('vector'), points.unstack(reduce)])</code>
assuming this field as a single channel dimension called <code>vector</code>.</p>
<p>Example:
While <code><a title="phi.field.StaggeredGrid.sample_at" href="#phi.field.StaggeredGrid.sample_at">StaggeredGrid.sample_at()</a>(staggered_points)</code> samples all components at all faces,
<code>StaggeredGrid.sample_at(staggered_points, reduce_channels='staggered')</code> samples each component at the corresponding face only.</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Sampled values as a <code>Tensor</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_at(self, points, reduce_channels=()) -&gt; Tensor:
    local_points = self.box.global_to_local(points) * self.resolution - 0.5
    if len(reduce_channels) == 0:
        return math.grid_sample(self.values, local_points, self.extrapolation)
    else:
        assert self.shape.channel.sizes == points.shape.get_size(reduce_channels)
        if len(reduce_channels) &gt; 1:
            raise NotImplementedError(f&#34;{len(reduce_channels)} &gt; 1. Only 1 reduced channel allowed.&#34;)
        channels = []
        for i, channel in enumerate(self.values.vector.unstack()):
            channels.append(math.grid_sample(channel, local_points[{reduce_channels[0]: i}], self.extrapolation))
        return math.channel_stack(channels, &#39;vector&#39;)</code></pre>
</details>
</dd>
<dt id="phi.field.CenteredGrid.sample_in"><code class="name flex">
<span>def <span class="ident">sample_in</span></span>(<span>self, geometry: phi.geom._geom.Geometry, reduce_channels=()) ‑> phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Approximates the mean field value inside the volume of the geometry (batch).</p>
<p>For small volumes, the value at the volume's center may be sampled.
The batch dimensions of the geometry are matched with this Field.
Spatial dimensions can be used to sample a grid of geometries.</p>
<p>The default implementation of this method samples this Field at the center point of the geometry.</p>
<p>See <code><a title="phi.field.Field.sample_at" href="#phi.field.Field.sample_at">Field.sample_at()</a></code>, <code><a title="phi.field.Field.at" href="#phi.field.Field.at">Field.at()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>geometry</code></strong></dt>
<dd>single or batched Geometry object</dd>
<dt><strong><code>reduce_channels</code></strong></dt>
<dd>
<p>(optional) Dimensions of <code>points</code> to be reduced against the channel dimensions of this <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code>.
Causes the components of this field to be sampled at different locations.
The result is the same as <code>math.channel_stack([component.sample_at(p) for component, p in zip(field.unstack('vector'), points.unstack(reduce)])</code>
assuming this field as a single channel dimension called <code>vector</code>.</p>
<p>Example:
While <code><a title="phi.field.StaggeredGrid.sample_at" href="#phi.field.StaggeredGrid.sample_at">StaggeredGrid.sample_at()</a>(staggered_points)</code> samples all components at all faces,
<code>StaggeredGrid.sample_at(staggered_points, reduce_channels='staggered')</code> samples each component at the corresponding face only.</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Sampled values as a <code>Tensor</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_in(self, geometry: Geometry, reduce_channels=()) -&gt; Tensor:
    if reduce_channels:
        assert len(reduce_channels) == 1
        geometries = geometry.unstack(reduce_channels[0])
        components = self.unstack(&#39;vector&#39;)
        sampled = [c.sample_in(g) for c, g in zip(components, geometries)]
        return math.channel_stack(sampled, &#39;vector&#39;)
    if isinstance(geometry, GeometryStack):
        sampled = [self.sample_in(g) for g in geometry.geometries]
        return math.batch_stack(sampled, geometry.stack_dim_name)
    if isinstance(geometry, GridCell):
        if self.elements == geometry:
            return self.values
        elif math.close(self.dx, geometry.size):
            fast_resampled = self._shift_resample(geometry.resolution, geometry.bounds)
            if fast_resampled is not NotImplemented:
                return fast_resampled
    return self.sample_at(geometry.center, reduce_channels)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="phi.field.ConstantField"><code class="flex name class">
<span>class <span class="ident">ConstantField</span></span>
<span>(</span><span>value=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for all fields.</p>
<p>Important implementations:</p>
<ul>
<li>CenteredGrid</li>
<li>StaggeredGrid</li>
<li>PointCloud</li>
<li>Noise</li>
</ul>
<p>See the <code><a title="phi.field" href="#phi.field">phi.field</a></code> module documentation at <a href="https://tum-pbs.github.io/PhiFlow/Fields.html">https://tum-pbs.github.io/PhiFlow/Fields.html</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConstantField(Field):

    def __init__(self, value=1.0):
        self.value = math.tensor(value)

    @property
    def shape(self) -&gt; Shape:
        return self.value.shape

    def _op1(self, operator) -&gt; Field:
        return ConstantField(operator(self.value))

    def _op2(self, other, operator) -&gt; Field:
        return ConstantField(operator(self.value, other))

    def sample_at(self, points, reduce_channels=()) -&gt; math.Tensor:
        return self.value

    def unstack(self, dimension: str):
        return tuple(ConstantField(v) for v in self.value.unstack(dimension))

    def __repr__(self):
        return repr(self.value)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.field._field.Field</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="phi.field.ConstantField.shape"><code class="name">var <span class="ident">shape</span> : phi.math._shape.Shape</code></dt>
<dd>
<div class="desc"><p>Returns a shape with the following properties</p>
<ul>
<li>The spatial dimension names match the dimensions of this Field</li>
<li>The batch dimensions match the batch dimensions of this Field</li>
<li>The channel dimensions match the channels of this Field</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape(self) -&gt; Shape:
    return self.value.shape</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phi.field.ConstantField.sample_at"><code class="name flex">
<span>def <span class="ident">sample_at</span></span>(<span>self, points, reduce_channels=()) ‑> phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Sample this field at the world-space locations (in physical units) given by <code>points</code>.
Points must have a single channel dimension named <code>vector</code>.
It may additionally contain any number of batch and spatial dimensions, all treated as batch dimensions.</p>
<p>See <code><a title="phi.field.Field.sample_in" href="#phi.field.Field.sample_in">Field.sample_in()</a></code>, <code><a title="phi.field.Field.at" href="#phi.field.Field.at">Field.at()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>points</code></strong></dt>
<dd>world-space locations</dd>
<dt><strong><code>reduce_channels</code></strong></dt>
<dd>
<p>(optional) Dimensions of <code>points</code> to be reduced against the channel dimensions of this <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code>.
Causes the components of this field to be sampled at different locations.
The result is the same as <code>math.channel_stack([component.sample_at(p) for component, p in zip(field.unstack('vector'), points.unstack(reduce)])</code>
assuming this field as a single channel dimension called <code>vector</code>.</p>
<p>Example:
While <code><a title="phi.field.StaggeredGrid.sample_at" href="#phi.field.StaggeredGrid.sample_at">StaggeredGrid.sample_at()</a>(staggered_points)</code> samples all components at all faces,
<code>StaggeredGrid.sample_at(staggered_points, reduce_channels='staggered')</code> samples each component at the corresponding face only.</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Sampled values as a <code>Tensor</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_at(self, points, reduce_channels=()) -&gt; math.Tensor:
    return self.value</code></pre>
</details>
</dd>
<dt id="phi.field.ConstantField.unstack"><code class="name flex">
<span>def <span class="ident">unstack</span></span>(<span>self, dimension: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Unstack the field along one of its dimensions.
The dimension can be batch, spatial or channel.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dimension</code></strong></dt>
<dd>name of the dimension to unstack, must be part of <code>self.shape</code></dd>
<dt><strong><code>dimension</code></strong></dt>
<dd>str: </dd>
</dl>
<h2 id="returns">Returns</h2>
<p>tuple of Fields</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unstack(self, dimension: str):
    return tuple(ConstantField(v) for v in self.value.unstack(dimension))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="phi.field.Field"><code class="flex name class">
<span>class <span class="ident">Field</span></span>
</code></dt>
<dd>
<div class="desc"><p>Base class for all fields.</p>
<p>Important implementations:</p>
<ul>
<li>CenteredGrid</li>
<li>StaggeredGrid</li>
<li>PointCloud</li>
<li>Noise</li>
</ul>
<p>See the <code><a title="phi.field" href="#phi.field">phi.field</a></code> module documentation at <a href="https://tum-pbs.github.io/PhiFlow/Fields.html">https://tum-pbs.github.io/PhiFlow/Fields.html</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Field:
    &#34;&#34;&#34;
    Base class for all fields.
    
    Important implementations:
    
    * CenteredGrid
    * StaggeredGrid
    * PointCloud
    * Noise
    
    See the `phi.field` module documentation at https://tum-pbs.github.io/PhiFlow/Fields.html
    &#34;&#34;&#34;

    @property
    def shape(self) -&gt; Shape:
        &#34;&#34;&#34;
        Returns a shape with the following properties
        
        * The spatial dimension names match the dimensions of this Field
        * The batch dimensions match the batch dimensions of this Field
        * The channel dimensions match the channels of this Field
        &#34;&#34;&#34;
        raise NotImplementedError()

    @property
    def spatial_rank(self) -&gt; int:
        &#34;&#34;&#34;
        Spatial rank of the field (1 for 1D, 2 for 2D, 3 for 3D).
        This is equal to the spatial rank of the `data`.
        &#34;&#34;&#34;
        return self.shape.spatial.rank

    def sample_in(self, geometry: Geometry, reduce_channels=()) -&gt; Tensor:
        &#34;&#34;&#34;
        Approximates the mean field value inside the volume of the geometry (batch).
        
        For small volumes, the value at the volume&#39;s center may be sampled.
        The batch dimensions of the geometry are matched with this Field.
        Spatial dimensions can be used to sample a grid of geometries.
        
        The default implementation of this method samples this Field at the center point of the geometry.

        See `Field.sample_at()`, `Field.at()`.

        Args:
          geometry: single or batched Geometry object
          reduce_channels: (optional) Dimensions of `points` to be reduced against the channel dimensions of this `Field`.
            Causes the components of this field to be sampled at different locations.
            The result is the same as `math.channel_stack([component.sample_at(p) for component, p in zip(field.unstack(&#39;vector&#39;), points.unstack(reduce)])`
            assuming this field as a single channel dimension called `vector`.

            Example:
            While `StaggeredGrid.sample_at(staggered_points)` samples all components at all faces,
            `StaggeredGrid.sample_at(staggered_points, reduce_channels=&#39;staggered&#39;)` samples each component at the corresponding face only.

        Returns:
          Sampled values as a `Tensor`
        &#34;&#34;&#34;
        return self.sample_at(geometry.center, reduce_channels)

    def sample_at(self, points: Tensor, reduce_channels=()) -&gt; Tensor:
        &#34;&#34;&#34;
        Sample this field at the world-space locations (in physical units) given by `points`.
        Points must have a single channel dimension named `vector`.
        It may additionally contain any number of batch and spatial dimensions, all treated as batch dimensions.

        See `Field.sample_in()`, `Field.at()`.

        Args:
          points: world-space locations
          reduce_channels: (optional) Dimensions of `points` to be reduced against the channel dimensions of this `Field`.
            Causes the components of this field to be sampled at different locations.
            The result is the same as `math.channel_stack([component.sample_at(p) for component, p in zip(field.unstack(&#39;vector&#39;), points.unstack(reduce)])`
            assuming this field as a single channel dimension called `vector`.

            Example:
            While `StaggeredGrid.sample_at(staggered_points)` samples all components at all faces,
            `StaggeredGrid.sample_at(staggered_points, reduce_channels=&#39;staggered&#39;)` samples each component at the corresponding face only.

        Returns:
          Sampled values as a `Tensor`
        &#34;&#34;&#34;
        raise NotImplementedError(self)

    def at(self, representation: SampledField) -&gt; SampledField:
        &#34;&#34;&#34;
        Samples this field at the sample points of `representation`.
        The result will approximate the values of this field on the data structure of `representation`.
        
        Unlike `Field.sample_at()` or `Field.sample_in()`, this method returns a `Field` object, not a `Tensor`.

        Equal to `self &gt;&gt; representation`.

        Args:
          representation: Field object defining the sample points. The values of `representation` are ignored.
          representation: SampledField: 

        Returns:
          Field object of same type as `representation`

        &#34;&#34;&#34;
        elements = representation.elements
        resampled = self.sample_in(elements, reduce_channels=elements.shape.non_channel.without(representation.shape).names)
        extrap = self.extrapolation if isinstance(self, SampledField) else representation.extrapolation
        return representation._op1(lambda old: extrap if isinstance(old, math.extrapolation.Extrapolation) else resampled)

    def __rshift__(self, other: SampledField):
        &#34;&#34;&#34;
        Resampling operator.

        :param other: instance of SampledField
        :return: copy of other with values determined by resampling this Field
        &#34;&#34;&#34;
        return self.at(other)

    def unstack(self, dimension: str) -&gt; tuple:
        &#34;&#34;&#34;
        Unstack the field along one of its dimensions.
        The dimension can be batch, spatial or channel.

        Args:
          dimension: name of the dimension to unstack, must be part of `self.shape`
          dimension: str: 

        Returns:
          tuple of Fields

        &#34;&#34;&#34;
        raise NotImplementedError()

    def dimension(self, name: str):
        &#34;&#34;&#34;
        Returns a reference to one of the dimensions of this field.

        The dimension reference can be used the same way as a `Tensor` dimension reference.
        Notable properties and methods of a dimension reference are:
        indexing using `[index]`, `unstack()`, `size`, `exists`, `is_batch`, `is_spatial`, `is_channel`.

        A shortcut to calling this function is the syntax `field.&lt;dim_name&gt;` which calls `field.dimension(&lt;dim_name&gt;)`.

        Args:
            name: dimension name

        Returns:
            dimension reference

        &#34;&#34;&#34;
        return _FieldDim(self, name)

    def __getattr__(self, name: str) -&gt; _FieldDim:
        if name.startswith(&#39;_&#39;):
            raise AttributeError(f&#34;&#39;{type(self)}&#39; object has no attribute &#39;{name}&#39;&#34;)
        if hasattr(self.__class__, name):
            raise RuntimeError(f&#34;Failed to get attribute &#39;{name}&#39; of {self}&#34;)
        return _FieldDim(self, name)

    def __mul__(self, other):
        return self._op2(other, lambda d1, d2: d1 * d2)

    __rmul__ = __mul__

    def __truediv__(self, other):
        return self._op2(other, lambda d1, d2: d1 / d2)

    def __rtruediv__(self, other):
        return self._op2(other, lambda d1, d2: d2 / d1)

    def __sub__(self, other):
        return self._op2(other, lambda d1, d2: d1 - d2)

    def __rsub__(self, other):
        return self._op2(other, lambda d1, d2: d2 - d1)

    def __add__(self, other):
        return self._op2(other, lambda d1, d2: d1 + d2)

    __radd__ = __add__

    def __pow__(self, power, modulo=None):
        return self._op2(power, lambda f, p: f ** p)

    def __neg__(self):
        return self._op1(lambda x: -x)

    def __gt__(self, other):
        return self._op2(other, lambda x, y: x &gt; y)

    def __ge__(self, other):
        return self._op2(other, lambda x, y: x &gt;= y)

    def __lt__(self, other):
        return self._op2(other, lambda x, y: x &lt; y)

    def __le__(self, other):
        return self._op2(other, lambda x, y: x &lt;= y)

    def __abs__(self):
        return self._op1(lambda x: abs(x))

    def _op1(self, operator) -&gt; Field:
        &#34;&#34;&#34;
        Perform an operation on the data of this field.

        Args:
          operator: function that accepts tensors and extrapolations and returns objects of the same type and dimensions

        Returns:
          Field of same type

        &#34;&#34;&#34;
        raise NotImplementedError()

    def _op2(self, other, operator) -&gt; Field:
        raise NotImplementedError()</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li>phi.field._analytic.AnalyticField</li>
<li>phi.field._constant.ConstantField</li>
<li>phi.field._field.SampledField</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="phi.field.Field.shape"><code class="name">var <span class="ident">shape</span> : phi.math._shape.Shape</code></dt>
<dd>
<div class="desc"><p>Returns a shape with the following properties</p>
<ul>
<li>The spatial dimension names match the dimensions of this Field</li>
<li>The batch dimensions match the batch dimensions of this Field</li>
<li>The channel dimensions match the channels of this Field</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape(self) -&gt; Shape:
    &#34;&#34;&#34;
    Returns a shape with the following properties
    
    * The spatial dimension names match the dimensions of this Field
    * The batch dimensions match the batch dimensions of this Field
    * The channel dimensions match the channels of this Field
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="phi.field.Field.spatial_rank"><code class="name">var <span class="ident">spatial_rank</span> : int</code></dt>
<dd>
<div class="desc"><p>Spatial rank of the field (1 for 1D, 2 for 2D, 3 for 3D).
This is equal to the spatial rank of the <code>data</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def spatial_rank(self) -&gt; int:
    &#34;&#34;&#34;
    Spatial rank of the field (1 for 1D, 2 for 2D, 3 for 3D).
    This is equal to the spatial rank of the `data`.
    &#34;&#34;&#34;
    return self.shape.spatial.rank</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phi.field.Field.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>self, representation: <a title="phi.field.SampledField" href="#phi.field.SampledField">SampledField</a>) ‑> phi.field._field.SampledField</span>
</code></dt>
<dd>
<div class="desc"><p>Samples this field at the sample points of <code>representation</code>.
The result will approximate the values of this field on the data structure of <code>representation</code>.</p>
<p>Unlike <code><a title="phi.field.Field.sample_at" href="#phi.field.Field.sample_at">Field.sample_at()</a></code> or <code><a title="phi.field.Field.sample_in" href="#phi.field.Field.sample_in">Field.sample_in()</a></code>, this method returns a <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> object, not a <code>Tensor</code>.</p>
<p>Equal to <code>self &gt;&gt; representation</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>representation</code></strong></dt>
<dd>Field object defining the sample points. The values of <code>representation</code> are ignored.</dd>
<dt><strong><code>representation</code></strong></dt>
<dd>SampledField: </dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Field object of same type as <code>representation</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def at(self, representation: SampledField) -&gt; SampledField:
    &#34;&#34;&#34;
    Samples this field at the sample points of `representation`.
    The result will approximate the values of this field on the data structure of `representation`.
    
    Unlike `Field.sample_at()` or `Field.sample_in()`, this method returns a `Field` object, not a `Tensor`.

    Equal to `self &gt;&gt; representation`.

    Args:
      representation: Field object defining the sample points. The values of `representation` are ignored.
      representation: SampledField: 

    Returns:
      Field object of same type as `representation`

    &#34;&#34;&#34;
    elements = representation.elements
    resampled = self.sample_in(elements, reduce_channels=elements.shape.non_channel.without(representation.shape).names)
    extrap = self.extrapolation if isinstance(self, SampledField) else representation.extrapolation
    return representation._op1(lambda old: extrap if isinstance(old, math.extrapolation.Extrapolation) else resampled)</code></pre>
</details>
</dd>
<dt id="phi.field.Field.dimension"><code class="name flex">
<span>def <span class="ident">dimension</span></span>(<span>self, name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a reference to one of the dimensions of this field.</p>
<p>The dimension reference can be used the same way as a <code>Tensor</code> dimension reference.
Notable properties and methods of a dimension reference are:
indexing using <code>[index]</code>, <code>unstack()</code>, <code>size</code>, <code>exists</code>, <code>is_batch</code>, <code>is_spatial</code>, <code>is_channel</code>.</p>
<p>A shortcut to calling this function is the syntax <code>field.&lt;dim_name&gt;</code> which calls <code>field.dimension(&lt;dim_name&gt;)</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>dimension name</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>dimension reference</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dimension(self, name: str):
    &#34;&#34;&#34;
    Returns a reference to one of the dimensions of this field.

    The dimension reference can be used the same way as a `Tensor` dimension reference.
    Notable properties and methods of a dimension reference are:
    indexing using `[index]`, `unstack()`, `size`, `exists`, `is_batch`, `is_spatial`, `is_channel`.

    A shortcut to calling this function is the syntax `field.&lt;dim_name&gt;` which calls `field.dimension(&lt;dim_name&gt;)`.

    Args:
        name: dimension name

    Returns:
        dimension reference

    &#34;&#34;&#34;
    return _FieldDim(self, name)</code></pre>
</details>
</dd>
<dt id="phi.field.Field.sample_at"><code class="name flex">
<span>def <span class="ident">sample_at</span></span>(<span>self, points: Tensor, reduce_channels=()) ‑> phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Sample this field at the world-space locations (in physical units) given by <code>points</code>.
Points must have a single channel dimension named <code>vector</code>.
It may additionally contain any number of batch and spatial dimensions, all treated as batch dimensions.</p>
<p>See <code><a title="phi.field.Field.sample_in" href="#phi.field.Field.sample_in">Field.sample_in()</a></code>, <code><a title="phi.field.Field.at" href="#phi.field.Field.at">Field.at()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>points</code></strong></dt>
<dd>world-space locations</dd>
<dt><strong><code>reduce_channels</code></strong></dt>
<dd>
<p>(optional) Dimensions of <code>points</code> to be reduced against the channel dimensions of this <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code>.
Causes the components of this field to be sampled at different locations.
The result is the same as <code>math.channel_stack([component.sample_at(p) for component, p in zip(field.unstack('vector'), points.unstack(reduce)])</code>
assuming this field as a single channel dimension called <code>vector</code>.</p>
<p>Example:
While <code><a title="phi.field.StaggeredGrid.sample_at" href="#phi.field.StaggeredGrid.sample_at">StaggeredGrid.sample_at()</a>(staggered_points)</code> samples all components at all faces,
<code>StaggeredGrid.sample_at(staggered_points, reduce_channels='staggered')</code> samples each component at the corresponding face only.</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Sampled values as a <code>Tensor</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_at(self, points: Tensor, reduce_channels=()) -&gt; Tensor:
    &#34;&#34;&#34;
    Sample this field at the world-space locations (in physical units) given by `points`.
    Points must have a single channel dimension named `vector`.
    It may additionally contain any number of batch and spatial dimensions, all treated as batch dimensions.

    See `Field.sample_in()`, `Field.at()`.

    Args:
      points: world-space locations
      reduce_channels: (optional) Dimensions of `points` to be reduced against the channel dimensions of this `Field`.
        Causes the components of this field to be sampled at different locations.
        The result is the same as `math.channel_stack([component.sample_at(p) for component, p in zip(field.unstack(&#39;vector&#39;), points.unstack(reduce)])`
        assuming this field as a single channel dimension called `vector`.

        Example:
        While `StaggeredGrid.sample_at(staggered_points)` samples all components at all faces,
        `StaggeredGrid.sample_at(staggered_points, reduce_channels=&#39;staggered&#39;)` samples each component at the corresponding face only.

    Returns:
      Sampled values as a `Tensor`
    &#34;&#34;&#34;
    raise NotImplementedError(self)</code></pre>
</details>
</dd>
<dt id="phi.field.Field.sample_in"><code class="name flex">
<span>def <span class="ident">sample_in</span></span>(<span>self, geometry: Geometry, reduce_channels=()) ‑> phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Approximates the mean field value inside the volume of the geometry (batch).</p>
<p>For small volumes, the value at the volume's center may be sampled.
The batch dimensions of the geometry are matched with this Field.
Spatial dimensions can be used to sample a grid of geometries.</p>
<p>The default implementation of this method samples this Field at the center point of the geometry.</p>
<p>See <code><a title="phi.field.Field.sample_at" href="#phi.field.Field.sample_at">Field.sample_at()</a></code>, <code><a title="phi.field.Field.at" href="#phi.field.Field.at">Field.at()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>geometry</code></strong></dt>
<dd>single or batched Geometry object</dd>
<dt><strong><code>reduce_channels</code></strong></dt>
<dd>
<p>(optional) Dimensions of <code>points</code> to be reduced against the channel dimensions of this <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code>.
Causes the components of this field to be sampled at different locations.
The result is the same as <code>math.channel_stack([component.sample_at(p) for component, p in zip(field.unstack('vector'), points.unstack(reduce)])</code>
assuming this field as a single channel dimension called <code>vector</code>.</p>
<p>Example:
While <code><a title="phi.field.StaggeredGrid.sample_at" href="#phi.field.StaggeredGrid.sample_at">StaggeredGrid.sample_at()</a>(staggered_points)</code> samples all components at all faces,
<code>StaggeredGrid.sample_at(staggered_points, reduce_channels='staggered')</code> samples each component at the corresponding face only.</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Sampled values as a <code>Tensor</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_in(self, geometry: Geometry, reduce_channels=()) -&gt; Tensor:
    &#34;&#34;&#34;
    Approximates the mean field value inside the volume of the geometry (batch).
    
    For small volumes, the value at the volume&#39;s center may be sampled.
    The batch dimensions of the geometry are matched with this Field.
    Spatial dimensions can be used to sample a grid of geometries.
    
    The default implementation of this method samples this Field at the center point of the geometry.

    See `Field.sample_at()`, `Field.at()`.

    Args:
      geometry: single or batched Geometry object
      reduce_channels: (optional) Dimensions of `points` to be reduced against the channel dimensions of this `Field`.
        Causes the components of this field to be sampled at different locations.
        The result is the same as `math.channel_stack([component.sample_at(p) for component, p in zip(field.unstack(&#39;vector&#39;), points.unstack(reduce)])`
        assuming this field as a single channel dimension called `vector`.

        Example:
        While `StaggeredGrid.sample_at(staggered_points)` samples all components at all faces,
        `StaggeredGrid.sample_at(staggered_points, reduce_channels=&#39;staggered&#39;)` samples each component at the corresponding face only.

    Returns:
      Sampled values as a `Tensor`
    &#34;&#34;&#34;
    return self.sample_at(geometry.center, reduce_channels)</code></pre>
</details>
</dd>
<dt id="phi.field.Field.unstack"><code class="name flex">
<span>def <span class="ident">unstack</span></span>(<span>self, dimension: str) ‑> tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Unstack the field along one of its dimensions.
The dimension can be batch, spatial or channel.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dimension</code></strong></dt>
<dd>name of the dimension to unstack, must be part of <code>self.shape</code></dd>
<dt><strong><code>dimension</code></strong></dt>
<dd>str: </dd>
</dl>
<h2 id="returns">Returns</h2>
<p>tuple of Fields</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unstack(self, dimension: str) -&gt; tuple:
    &#34;&#34;&#34;
    Unstack the field along one of its dimensions.
    The dimension can be batch, spatial or channel.

    Args:
      dimension: name of the dimension to unstack, must be part of `self.shape`
      dimension: str: 

    Returns:
      tuple of Fields

    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="phi.field.Grid"><code class="flex name class">
<span>class <span class="ident">Grid</span></span>
<span>(</span><span>values: phi.math._tensors.Tensor, resolution: phi.math._shape.Shape, bounds: phi.geom._box.Box, extrapolation=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for CenteredGrid, StaggeredGrid.</p>
<p>Grids are defined by</p>
<ul>
<li>data: Tensor, defines resolution</li>
<li>bounds: physical size of the grid, defines dx</li>
<li>extrapolation: values of virtual grid points lying outside the data bounds</li>
</ul>
<p>Args:</p>
<p>Returns:</p>
<p>Base class for fields that are sampled at specific locations such as grids or point clouds.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>elements</code></strong></dt>
<dd>Geometry object specifying the sample points and sizes</dd>
<dt><strong><code>values</code></strong></dt>
<dd>values corresponding to elements</dd>
<dt><strong><code>extrapolation</code></strong></dt>
<dd>values outside elements</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Grid(SampledField):
    &#34;&#34;&#34;
    Base class for CenteredGrid, StaggeredGrid.
    
    Grids are defined by
    
    * data: Tensor, defines resolution
    * bounds: physical size of the grid, defines dx
    * extrapolation: values of virtual grid points lying outside the data bounds

    Args:

    Returns:

    &#34;&#34;&#34;

    def __init__(self, values: Tensor, resolution: Shape, bounds: Box, extrapolation=math.extrapolation.ZERO):
        SampledField.__init__(self, GridCell(resolution, bounds), values, extrapolation)
        self._bounds = bounds
        assert_same_rank(self.values.shape, bounds, &#39;data dimensions %s do not match box %s&#39; % (self.values.shape, bounds))

    def sample_at(self, points: Tensor, reduce_channels=()) -&gt; Tensor:
        raise NotImplementedError(self)

    def closest_values(self, points: Tensor, reduce_channels=()):
        &#34;&#34;&#34;
        Sample the closest grid point values of this field at the world-space locations (in physical units) given by `points`.
        Points must have a single channel dimension named `vector`.
        It may additionally contain any number of batch and spatial dimensions, all treated as batch dimensions.

        Args:
          points: world-space locations
          reduce_channels: (optional) See `Field.sample_at()` for a description.

        Returns:
          Closest grid point values as a `Tensor`.
          For each dimension, the grid points immediately left and right of the sample points are evaluated.
          For each point in `points`, a *2^d* cube of points is determined where *d* is the number of spatial dimensions of this field.
          These values are stacked along the new dimensions `&#39;closest_&lt;dim&gt;&#39;` where `&lt;dim&gt;` refers to the name of a spatial dimension.
        &#34;&#34;&#34;
        raise NotImplementedError(self)

    @property
    def bounds(self) -&gt; Box:
        return self._bounds

    @property
    def box(self) -&gt; Box:
        return self._bounds

    @property
    def resolution(self) -&gt; Shape:
        return self.shape.spatial

    @property
    def dx(self) -&gt; Tensor:
        return self.box.size / self.resolution

    def __repr__(self):
        return f&#34;{self.__class__.__name__}[{self.shape}, size={self.box.size}, extrapolation={self._extrapolation}]&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.field._field.SampledField</li>
<li>phi.field._field.Field</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>phi.field._grid.CenteredGrid</li>
<li>phi.field._grid.StaggeredGrid</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="phi.field.Grid.bounds"><code class="name">var <span class="ident">bounds</span> : phi.geom._box.Box</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bounds(self) -&gt; Box:
    return self._bounds</code></pre>
</details>
</dd>
<dt id="phi.field.Grid.box"><code class="name">var <span class="ident">box</span> : phi.geom._box.Box</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def box(self) -&gt; Box:
    return self._bounds</code></pre>
</details>
</dd>
<dt id="phi.field.Grid.dx"><code class="name">var <span class="ident">dx</span> : phi.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def dx(self) -&gt; Tensor:
    return self.box.size / self.resolution</code></pre>
</details>
</dd>
<dt id="phi.field.Grid.resolution"><code class="name">var <span class="ident">resolution</span> : phi.math._shape.Shape</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def resolution(self) -&gt; Shape:
    return self.shape.spatial</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phi.field.Grid.closest_values"><code class="name flex">
<span>def <span class="ident">closest_values</span></span>(<span>self, points: phi.math._tensors.Tensor, reduce_channels=())</span>
</code></dt>
<dd>
<div class="desc"><p>Sample the closest grid point values of this field at the world-space locations (in physical units) given by <code>points</code>.
Points must have a single channel dimension named <code>vector</code>.
It may additionally contain any number of batch and spatial dimensions, all treated as batch dimensions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>points</code></strong></dt>
<dd>world-space locations</dd>
<dt><strong><code>reduce_channels</code></strong></dt>
<dd>(optional) See <code><a title="phi.field.Field.sample_at" href="#phi.field.Field.sample_at">Field.sample_at()</a></code> for a description.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Closest grid point values as a <code>Tensor</code>.
For each dimension, the grid points immediately left and right of the sample points are evaluated.
For each point in <code>points</code>, a <em>2^d</em> cube of points is determined where <em>d</em> is the number of spatial dimensions of this field.
These values are stacked along the new dimensions <code>'closest_&lt;dim&gt;'</code> where <code>&lt;dim&gt;</code> refers to the name of a spatial dimension.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def closest_values(self, points: Tensor, reduce_channels=()):
    &#34;&#34;&#34;
    Sample the closest grid point values of this field at the world-space locations (in physical units) given by `points`.
    Points must have a single channel dimension named `vector`.
    It may additionally contain any number of batch and spatial dimensions, all treated as batch dimensions.

    Args:
      points: world-space locations
      reduce_channels: (optional) See `Field.sample_at()` for a description.

    Returns:
      Closest grid point values as a `Tensor`.
      For each dimension, the grid points immediately left and right of the sample points are evaluated.
      For each point in `points`, a *2^d* cube of points is determined where *d* is the number of spatial dimensions of this field.
      These values are stacked along the new dimensions `&#39;closest_&lt;dim&gt;&#39;` where `&lt;dim&gt;` refers to the name of a spatial dimension.
    &#34;&#34;&#34;
    raise NotImplementedError(self)</code></pre>
</details>
</dd>
<dt id="phi.field.Grid.sample_at"><code class="name flex">
<span>def <span class="ident">sample_at</span></span>(<span>self, points: phi.math._tensors.Tensor, reduce_channels=()) ‑> phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Sample this field at the world-space locations (in physical units) given by <code>points</code>.
Points must have a single channel dimension named <code>vector</code>.
It may additionally contain any number of batch and spatial dimensions, all treated as batch dimensions.</p>
<p>See <code><a title="phi.field.Field.sample_in" href="#phi.field.Field.sample_in">Field.sample_in()</a></code>, <code><a title="phi.field.Field.at" href="#phi.field.Field.at">Field.at()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>points</code></strong></dt>
<dd>world-space locations</dd>
<dt><strong><code>reduce_channels</code></strong></dt>
<dd>
<p>(optional) Dimensions of <code>points</code> to be reduced against the channel dimensions of this <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code>.
Causes the components of this field to be sampled at different locations.
The result is the same as <code>math.channel_stack([component.sample_at(p) for component, p in zip(field.unstack('vector'), points.unstack(reduce)])</code>
assuming this field as a single channel dimension called <code>vector</code>.</p>
<p>Example:
While <code><a title="phi.field.StaggeredGrid.sample_at" href="#phi.field.StaggeredGrid.sample_at">StaggeredGrid.sample_at()</a>(staggered_points)</code> samples all components at all faces,
<code>StaggeredGrid.sample_at(staggered_points, reduce_channels='staggered')</code> samples each component at the corresponding face only.</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Sampled values as a <code>Tensor</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_at(self, points: Tensor, reduce_channels=()) -&gt; Tensor:
    raise NotImplementedError(self)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="phi.field.HardGeometryMask"><code class="flex name class">
<span>class <span class="ident">HardGeometryMask</span></span>
<span>(</span><span>geometry: phi.geom._geom.Geometry)</span>
</code></dt>
<dd>
<div class="desc"><p>Field that takes the value 1 inside a Geometry object and 0 outside.
For volume sampling, performs sampling at the center points.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HardGeometryMask(AnalyticField):
    &#34;&#34;&#34;
    Field that takes the value 1 inside a Geometry object and 0 outside.
    For volume sampling, performs sampling at the center points.
    &#34;&#34;&#34;

    def __init__(self, geometry: Geometry):
        assert isinstance(geometry, Geometry)
        self.geometry = geometry

    @property
    def shape(self):
        return self.geometry.shape.non_channel

    def sample_at(self, points: Tensor, reduce_channels=()) -&gt; Tensor:
        inside = math.to_float(self.geometry.lies_inside(points))
        if reduce_channels:
            assert len(reduce_channels) == 1
            inside = inside.dimension(reduce_channels[0]).as_channel(&#39;vector&#39;)
        return inside</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.field._analytic.AnalyticField</li>
<li>phi.field._field.Field</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>phi.field._mask.SoftGeometryMask</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="phi.field.HardGeometryMask.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<div class="desc"><p>Returns a shape with the following properties</p>
<ul>
<li>The spatial dimension names match the dimensions of this Field</li>
<li>The batch dimensions match the batch dimensions of this Field</li>
<li>The channel dimensions match the channels of this Field</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape(self):
    return self.geometry.shape.non_channel</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phi.field.HardGeometryMask.sample_at"><code class="name flex">
<span>def <span class="ident">sample_at</span></span>(<span>self, points: phi.math._tensors.Tensor, reduce_channels=()) ‑> phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Sample this field at the world-space locations (in physical units) given by <code>points</code>.
Points must have a single channel dimension named <code>vector</code>.
It may additionally contain any number of batch and spatial dimensions, all treated as batch dimensions.</p>
<p>See <code><a title="phi.field.Field.sample_in" href="#phi.field.Field.sample_in">Field.sample_in()</a></code>, <code><a title="phi.field.Field.at" href="#phi.field.Field.at">Field.at()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>points</code></strong></dt>
<dd>world-space locations</dd>
<dt><strong><code>reduce_channels</code></strong></dt>
<dd>
<p>(optional) Dimensions of <code>points</code> to be reduced against the channel dimensions of this <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code>.
Causes the components of this field to be sampled at different locations.
The result is the same as <code>math.channel_stack([component.sample_at(p) for component, p in zip(field.unstack('vector'), points.unstack(reduce)])</code>
assuming this field as a single channel dimension called <code>vector</code>.</p>
<p>Example:
While <code><a title="phi.field.StaggeredGrid.sample_at" href="#phi.field.StaggeredGrid.sample_at">StaggeredGrid.sample_at()</a>(staggered_points)</code> samples all components at all faces,
<code>StaggeredGrid.sample_at(staggered_points, reduce_channels='staggered')</code> samples each component at the corresponding face only.</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Sampled values as a <code>Tensor</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_at(self, points: Tensor, reduce_channels=()) -&gt; Tensor:
    inside = math.to_float(self.geometry.lies_inside(points))
    if reduce_channels:
        assert len(reduce_channels) == 1
        inside = inside.dimension(reduce_channels[0]).as_channel(&#39;vector&#39;)
    return inside</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="phi.field.Noise"><code class="flex name class">
<span>class <span class="ident">Noise</span></span>
<span>(</span><span>shape=(), scale=10, smoothness=1.0, **dims)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for all fields.</p>
<p>Important implementations:</p>
<ul>
<li>CenteredGrid</li>
<li>StaggeredGrid</li>
<li>PointCloud</li>
<li>Noise</li>
</ul>
<p>See the <code><a title="phi.field" href="#phi.field">phi.field</a></code> module documentation at <a href="https://tum-pbs.github.io/PhiFlow/Fields.html">https://tum-pbs.github.io/PhiFlow/Fields.html</a></p>
<p>Generates random noise fluctuations which can be configured in physical size and smoothness.
Each time values are sampled from a Noise field, a new noise field is generated.</p>
<pre><code>Noise is typically used as an initializer for CenteredGrids or StaggeredGrids.
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>channels</code></strong></dt>
<dd>Number of independent random scalar fields this Field consists of</dd>
<dt><strong><code>scale</code></strong></dt>
<dd>Size of noise fluctuations in physical units</dd>
<dt><strong><code>smoothness</code></strong></dt>
<dd>Determines how quickly high frequencies die out</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Noise(AnalyticField):

    def __init__(self, shape=math.EMPTY_SHAPE, scale=10, smoothness=1.0, **dims):
        &#34;&#34;&#34;
        Generates random noise fluctuations which can be configured in physical size and smoothness.
            Each time values are sampled from a Noise field, a new noise field is generated.

            Noise is typically used as an initializer for CenteredGrids or StaggeredGrids.

        Args:
          channels: Number of independent random scalar fields this Field consists of
          scale: Size of noise fluctuations in physical units
          smoothness: Determines how quickly high frequencies die out
        &#34;&#34;&#34;
        self.scale = scale
        self.smoothness = smoothness
        self._shape = shape &amp; math.shape(**dims)

    @property
    def shape(self):
        return self._shape

    def sample_in(self, geometry: Geometry, reduce_channels=()) -&gt; Tensor:
        if isinstance(geometry, GridCell):
            return self.grid_sample(geometry.resolution, geometry.grid_size, self._shape.without(reduce_channels))
        raise NotImplementedError(f&#34;{type(geometry)} not supported. Only GridCell allowed.&#34;)

    def sample_at(self, points, reduce_channels=()) -&gt; math.Tensor:
        raise NotImplementedError()

    def grid_sample(self, resolution: math.Shape, size, shape: math.Shape = None):
        shape = (self._shape if shape is None else shape).combined(resolution)
        rndj = math.to_complex(random_normal(shape)) + 1j * math.to_complex(random_normal(shape))  # Note: there is no complex32
        with math.SCIPY_BACKEND:
            k = math.fftfreq(resolution) * resolution / size * self.scale  # in physical units
            k = math.vec_squared(k)
        lowest_frequency = 0.1
        weight_mask = 1 / (1 + math.exp((lowest_frequency - k) * 1e3))  # High pass filter
        # --- Compute 1/k ---
        k.native()[(0,) * len(k.shape)] = np.inf
        inv_k = 1 / k
        inv_k.native()[(0,) * len(k.shape)] = 0
        # --- Compute result ---
        fft = rndj * inv_k ** self.smoothness * weight_mask
        array = math.real(math.ifft(fft))
        array /= math.std(array, dim=array.shape.non_batch)
        array -= math.mean(array, dim=array.shape.non_batch)
        array = math.to_float(array)
        return array

    def unstack(self, dimension: str) -&gt; tuple:
        count = self.shape.get_size(dimension)
        reduced_shape = self.shape.without(dimension)
        return (Noise(reduced_shape, self.scale, self.smoothness),) * count

    def __repr__(self):
        return &#34;%s, scale=%f, smoothness=%f&#34; % (self._shape, self.scale, self.smoothness)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.field._analytic.AnalyticField</li>
<li>phi.field._field.Field</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="phi.field.Noise.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<div class="desc"><p>Returns a shape with the following properties</p>
<ul>
<li>The spatial dimension names match the dimensions of this Field</li>
<li>The batch dimensions match the batch dimensions of this Field</li>
<li>The channel dimensions match the channels of this Field</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape(self):
    return self._shape</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phi.field.Noise.grid_sample"><code class="name flex">
<span>def <span class="ident">grid_sample</span></span>(<span>self, resolution: phi.math._shape.Shape, size, shape: phi.math._shape.Shape = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def grid_sample(self, resolution: math.Shape, size, shape: math.Shape = None):
    shape = (self._shape if shape is None else shape).combined(resolution)
    rndj = math.to_complex(random_normal(shape)) + 1j * math.to_complex(random_normal(shape))  # Note: there is no complex32
    with math.SCIPY_BACKEND:
        k = math.fftfreq(resolution) * resolution / size * self.scale  # in physical units
        k = math.vec_squared(k)
    lowest_frequency = 0.1
    weight_mask = 1 / (1 + math.exp((lowest_frequency - k) * 1e3))  # High pass filter
    # --- Compute 1/k ---
    k.native()[(0,) * len(k.shape)] = np.inf
    inv_k = 1 / k
    inv_k.native()[(0,) * len(k.shape)] = 0
    # --- Compute result ---
    fft = rndj * inv_k ** self.smoothness * weight_mask
    array = math.real(math.ifft(fft))
    array /= math.std(array, dim=array.shape.non_batch)
    array -= math.mean(array, dim=array.shape.non_batch)
    array = math.to_float(array)
    return array</code></pre>
</details>
</dd>
<dt id="phi.field.Noise.sample_at"><code class="name flex">
<span>def <span class="ident">sample_at</span></span>(<span>self, points, reduce_channels=()) ‑> phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Sample this field at the world-space locations (in physical units) given by <code>points</code>.
Points must have a single channel dimension named <code>vector</code>.
It may additionally contain any number of batch and spatial dimensions, all treated as batch dimensions.</p>
<p>See <code><a title="phi.field.Field.sample_in" href="#phi.field.Field.sample_in">Field.sample_in()</a></code>, <code><a title="phi.field.Field.at" href="#phi.field.Field.at">Field.at()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>points</code></strong></dt>
<dd>world-space locations</dd>
<dt><strong><code>reduce_channels</code></strong></dt>
<dd>
<p>(optional) Dimensions of <code>points</code> to be reduced against the channel dimensions of this <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code>.
Causes the components of this field to be sampled at different locations.
The result is the same as <code>math.channel_stack([component.sample_at(p) for component, p in zip(field.unstack('vector'), points.unstack(reduce)])</code>
assuming this field as a single channel dimension called <code>vector</code>.</p>
<p>Example:
While <code><a title="phi.field.StaggeredGrid.sample_at" href="#phi.field.StaggeredGrid.sample_at">StaggeredGrid.sample_at()</a>(staggered_points)</code> samples all components at all faces,
<code>StaggeredGrid.sample_at(staggered_points, reduce_channels='staggered')</code> samples each component at the corresponding face only.</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Sampled values as a <code>Tensor</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_at(self, points, reduce_channels=()) -&gt; math.Tensor:
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="phi.field.Noise.sample_in"><code class="name flex">
<span>def <span class="ident">sample_in</span></span>(<span>self, geometry: phi.geom._geom.Geometry, reduce_channels=()) ‑> phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Approximates the mean field value inside the volume of the geometry (batch).</p>
<p>For small volumes, the value at the volume's center may be sampled.
The batch dimensions of the geometry are matched with this Field.
Spatial dimensions can be used to sample a grid of geometries.</p>
<p>The default implementation of this method samples this Field at the center point of the geometry.</p>
<p>See <code><a title="phi.field.Field.sample_at" href="#phi.field.Field.sample_at">Field.sample_at()</a></code>, <code><a title="phi.field.Field.at" href="#phi.field.Field.at">Field.at()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>geometry</code></strong></dt>
<dd>single or batched Geometry object</dd>
<dt><strong><code>reduce_channels</code></strong></dt>
<dd>
<p>(optional) Dimensions of <code>points</code> to be reduced against the channel dimensions of this <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code>.
Causes the components of this field to be sampled at different locations.
The result is the same as <code>math.channel_stack([component.sample_at(p) for component, p in zip(field.unstack('vector'), points.unstack(reduce)])</code>
assuming this field as a single channel dimension called <code>vector</code>.</p>
<p>Example:
While <code><a title="phi.field.StaggeredGrid.sample_at" href="#phi.field.StaggeredGrid.sample_at">StaggeredGrid.sample_at()</a>(staggered_points)</code> samples all components at all faces,
<code>StaggeredGrid.sample_at(staggered_points, reduce_channels='staggered')</code> samples each component at the corresponding face only.</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Sampled values as a <code>Tensor</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_in(self, geometry: Geometry, reduce_channels=()) -&gt; Tensor:
    if isinstance(geometry, GridCell):
        return self.grid_sample(geometry.resolution, geometry.grid_size, self._shape.without(reduce_channels))
    raise NotImplementedError(f&#34;{type(geometry)} not supported. Only GridCell allowed.&#34;)</code></pre>
</details>
</dd>
<dt id="phi.field.Noise.unstack"><code class="name flex">
<span>def <span class="ident">unstack</span></span>(<span>self, dimension: str) ‑> tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Unstack the field along one of its dimensions.
The dimension can be batch, spatial or channel.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dimension</code></strong></dt>
<dd>name of the dimension to unstack, must be part of <code>self.shape</code></dd>
<dt><strong><code>dimension</code></strong></dt>
<dd>str: </dd>
</dl>
<h2 id="returns">Returns</h2>
<p>tuple of Fields</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unstack(self, dimension: str) -&gt; tuple:
    count = self.shape.get_size(dimension)
    reduced_shape = self.shape.without(dimension)
    return (Noise(reduced_shape, self.scale, self.smoothness),) * count</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="phi.field.PointCloud"><code class="flex name class">
<span>class <span class="ident">PointCloud</span></span>
<span>(</span><span>elements: phi.geom._geom.Geometry, values: Any = 1, extrapolation=0, add_overlapping=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for all fields.</p>
<p>Important implementations:</p>
<ul>
<li>CenteredGrid</li>
<li>StaggeredGrid</li>
<li>PointCloud</li>
<li>Noise</li>
</ul>
<p>See the <code><a title="phi.field" href="#phi.field">phi.field</a></code> module documentation at <a href="https://tum-pbs.github.io/PhiFlow/Fields.html">https://tum-pbs.github.io/PhiFlow/Fields.html</a></p>
<p>A point cloud consists of elements at arbitrary locations.
A value or vector is associated with each element.</p>
<pre><code>Outside of elements, the value of the field is determined by the extrapolation.

All points belonging to one example must be listed in the 'points' dimension.

Unlike with GeometryMask, the elements of a PointCloud are assumed to be small.
When sampling this field on a grid, scatter functions may be used.

See the &lt;code&gt;&lt;a title="phi.field" href="#phi.field"&gt;phi.field&lt;/a&gt;&lt;/code&gt; module documentation at &lt;https://tum-pbs.github.io/PhiFlow/Fields.html&gt;
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>elements</code></strong></dt>
<dd>Geometry object specifying the sample points and sizes</dd>
<dt><strong><code>values</code></strong></dt>
<dd>values corresponding to elements</dd>
<dt><strong><code>extrapolation</code></strong></dt>
<dd>values outside elements</dd>
<dt><strong><code>add_overlapping</code></strong></dt>
<dd>True: values of overlapping geometries are summed. False: values between overlapping geometries are interpolated</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PointCloud(SampledField):

    def __init__(self, elements: Geometry, values: Any = 1, extrapolation=math.extrapolation.ZERO, add_overlapping=False):
        &#34;&#34;&#34;
        A point cloud consists of elements at arbitrary locations.
            A value or vector is associated with each element.

            Outside of elements, the value of the field is determined by the extrapolation.

            All points belonging to one example must be listed in the &#39;points&#39; dimension.

            Unlike with GeometryMask, the elements of a PointCloud are assumed to be small.
            When sampling this field on a grid, scatter functions may be used.

            See the `phi.field` module documentation at https://tum-pbs.github.io/PhiFlow/Fields.html

        Args:
          elements: Geometry object specifying the sample points and sizes
          values: values corresponding to elements
          extrapolation: values outside elements
          add_overlapping: True: values of overlapping geometries are summed. False: values between overlapping geometries are interpolated
        &#34;&#34;&#34;
        SampledField.__init__(self, elements, values, extrapolation)
        self._add_overlapping = add_overlapping
        assert &#39;points&#39; in self.shape, &#34;Cannot create PointCloud without &#39;points&#39; dimension. Add it either to elements or to values as batch dimension.&#34;

    def sample_in(self, geometry: Geometry, reduce_channels=()) -&gt; Tensor:
        if not reduce_channels:
            if geometry == self.elements:
                return self.values
            elif isinstance(geometry, GridCell):
                return self._grid_scatter(geometry.bounds, geometry.resolution)
            elif isinstance(geometry, GeometryStack):
                sampled = [self.sample_at(g) for g in geometry.geometries]
                return math.batch_stack(sampled, geometry.stack_dim_name)
            else:
                raise NotImplementedError()
        else:
            assert len(reduce_channels) == 1
            components = self.unstack(&#39;vector&#39;) if &#39;vector&#39; in self.shape else (self,) * geometry.shape.get_size(reduce_channels[0])
            sampled = [c.sample_in(p) for c, p in zip(components, geometry.unstack(reduce_channels[0]))]
            return math.channel_stack(sampled, &#39;vector&#39;)

    def sample_at(self, points, reduce_channels=()) -&gt; Tensor:
        raise NotImplementedError()

    def _grid_scatter(self, box: Box, resolution: math.Shape):
        &#34;&#34;&#34;
        Approximately samples this field on a regular grid using math.scatter().

        Args:
          box: physical dimensions of the grid
          resolution: grid resolution
          box: Box: 
          resolution: math.Shape: 

        Returns:
          CenteredGrid

        &#34;&#34;&#34;
        closest_index = math.to_int(math.round(box.global_to_local(self.points) * resolution - 0.5))
        if self._add_overlapping:
            duplicates_handling = &#39;add&#39;
        else:
            if self.values.shape.spatial_rank &gt; 0:
                duplicates_handling = &#39;mean&#39;
            else:
                duplicates_handling = &#39;any&#39;  # constant value, no need for interpolation
        scattered = math.scatter(closest_index, self.values, resolution, duplicates_handling=duplicates_handling, outside_handling=&#39;discard&#39;, scatter_dims=(&#39;points&#39;,))
        return scattered

    def __repr__(self):
        return &#34;PointCloud[%s]&#34; % (self.shape,)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.field._field.SampledField</li>
<li>phi.field._field.Field</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="phi.field.PointCloud.sample_at"><code class="name flex">
<span>def <span class="ident">sample_at</span></span>(<span>self, points, reduce_channels=()) ‑> phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Sample this field at the world-space locations (in physical units) given by <code>points</code>.
Points must have a single channel dimension named <code>vector</code>.
It may additionally contain any number of batch and spatial dimensions, all treated as batch dimensions.</p>
<p>See <code><a title="phi.field.Field.sample_in" href="#phi.field.Field.sample_in">Field.sample_in()</a></code>, <code><a title="phi.field.Field.at" href="#phi.field.Field.at">Field.at()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>points</code></strong></dt>
<dd>world-space locations</dd>
<dt><strong><code>reduce_channels</code></strong></dt>
<dd>
<p>(optional) Dimensions of <code>points</code> to be reduced against the channel dimensions of this <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code>.
Causes the components of this field to be sampled at different locations.
The result is the same as <code>math.channel_stack([component.sample_at(p) for component, p in zip(field.unstack('vector'), points.unstack(reduce)])</code>
assuming this field as a single channel dimension called <code>vector</code>.</p>
<p>Example:
While <code><a title="phi.field.StaggeredGrid.sample_at" href="#phi.field.StaggeredGrid.sample_at">StaggeredGrid.sample_at()</a>(staggered_points)</code> samples all components at all faces,
<code>StaggeredGrid.sample_at(staggered_points, reduce_channels='staggered')</code> samples each component at the corresponding face only.</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Sampled values as a <code>Tensor</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_at(self, points, reduce_channels=()) -&gt; Tensor:
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="phi.field.PointCloud.sample_in"><code class="name flex">
<span>def <span class="ident">sample_in</span></span>(<span>self, geometry: phi.geom._geom.Geometry, reduce_channels=()) ‑> phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Approximates the mean field value inside the volume of the geometry (batch).</p>
<p>For small volumes, the value at the volume's center may be sampled.
The batch dimensions of the geometry are matched with this Field.
Spatial dimensions can be used to sample a grid of geometries.</p>
<p>The default implementation of this method samples this Field at the center point of the geometry.</p>
<p>See <code><a title="phi.field.Field.sample_at" href="#phi.field.Field.sample_at">Field.sample_at()</a></code>, <code><a title="phi.field.Field.at" href="#phi.field.Field.at">Field.at()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>geometry</code></strong></dt>
<dd>single or batched Geometry object</dd>
<dt><strong><code>reduce_channels</code></strong></dt>
<dd>
<p>(optional) Dimensions of <code>points</code> to be reduced against the channel dimensions of this <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code>.
Causes the components of this field to be sampled at different locations.
The result is the same as <code>math.channel_stack([component.sample_at(p) for component, p in zip(field.unstack('vector'), points.unstack(reduce)])</code>
assuming this field as a single channel dimension called <code>vector</code>.</p>
<p>Example:
While <code><a title="phi.field.StaggeredGrid.sample_at" href="#phi.field.StaggeredGrid.sample_at">StaggeredGrid.sample_at()</a>(staggered_points)</code> samples all components at all faces,
<code>StaggeredGrid.sample_at(staggered_points, reduce_channels='staggered')</code> samples each component at the corresponding face only.</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Sampled values as a <code>Tensor</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_in(self, geometry: Geometry, reduce_channels=()) -&gt; Tensor:
    if not reduce_channels:
        if geometry == self.elements:
            return self.values
        elif isinstance(geometry, GridCell):
            return self._grid_scatter(geometry.bounds, geometry.resolution)
        elif isinstance(geometry, GeometryStack):
            sampled = [self.sample_at(g) for g in geometry.geometries]
            return math.batch_stack(sampled, geometry.stack_dim_name)
        else:
            raise NotImplementedError()
    else:
        assert len(reduce_channels) == 1
        components = self.unstack(&#39;vector&#39;) if &#39;vector&#39; in self.shape else (self,) * geometry.shape.get_size(reduce_channels[0])
        sampled = [c.sample_in(p) for c, p in zip(components, geometry.unstack(reduce_channels[0]))]
        return math.channel_stack(sampled, &#39;vector&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="phi.field.SampledField"><code class="flex name class">
<span>class <span class="ident">SampledField</span></span>
<span>(</span><span>elements: Geometry, values: Tensor or float or int, extrapolation: math.Extrapolation)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for all fields.</p>
<p>Important implementations:</p>
<ul>
<li>CenteredGrid</li>
<li>StaggeredGrid</li>
<li>PointCloud</li>
<li>Noise</li>
</ul>
<p>See the <code><a title="phi.field" href="#phi.field">phi.field</a></code> module documentation at <a href="https://tum-pbs.github.io/PhiFlow/Fields.html">https://tum-pbs.github.io/PhiFlow/Fields.html</a></p>
<p>Base class for fields that are sampled at specific locations such as grids or point clouds.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>elements</code></strong></dt>
<dd>Geometry object specifying the sample points and sizes</dd>
<dt><strong><code>values</code></strong></dt>
<dd>values corresponding to elements</dd>
<dt><strong><code>extrapolation</code></strong></dt>
<dd>values outside elements</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SampledField(Field):

    def __init__(self, elements: Geometry, values: Tensor or float or int, extrapolation: math.Extrapolation):
        &#34;&#34;&#34;
        Base class for fields that are sampled at specific locations such as grids or point clouds.

        Args:
          elements: Geometry object specifying the sample points and sizes
          values: values corresponding to elements
          extrapolation: values outside elements
        &#34;&#34;&#34;
        assert isinstance(extrapolation, (Extrapolation, tuple, list)), extrapolation
        assert isinstance(elements, Geometry), elements
        self._elements = elements
        self._values = math.tensor(values)
        self._extrapolation = extrapolation
        self._shape = elements.shape.non_channel &amp; self._values.shape.non_spatial

    def with_(self,
              elements: Geometry or None = None,
              values: Tensor = None,
              extrapolation: math.Extrapolation = None) -&gt; SampledField:
        &#34;&#34;&#34; Creates a copy of this field with one or more properties changed. `None` keeps the current value. &#34;&#34;&#34;
        copied = copy.copy(self)
        SampledField.__init__(copied,
                              elements if elements is not None else self._elements,
                              values if values is not None else self._values,  # do not use == check
                              extrapolation if extrapolation is not None else self._extrapolation)
        return copied

    copied_with = with_

    @property
    def elements(self) -&gt; Geometry:
        &#34;&#34;&#34;
        Returns a geometrical representation of the discretized volume elements.
        The result is a tuple of Geometry objects, each of which can have additional spatial (but not batch) dimensions.
        
        For grids, the geometries are boxes while particle fields may be represented as spheres.
        
        If this Field has no discrete points, this method returns an empty geometry.
        &#34;&#34;&#34;
        return self._elements

    @property
    def points(self) -&gt; Tensor:
        return self.elements.center

    @property
    def values(self) -&gt; Tensor:
        return self._values

    data = values

    @property
    def extrapolation(self) -&gt; Extrapolation:
        return self._extrapolation

    @property
    def shape(self) -&gt; Shape:
        return self._shape

    def sample_at(self, points, reduce_channels=()) -&gt; Tensor:
        raise NotImplementedError(self)

    def unstack(self, dimension: str) -&gt; tuple:
        values = self._values.unstack(dimension)
        return tuple(self.with_(values=v) for i, v in enumerate(values))

    def _op1(self, operator) -&gt; Field:
        values = operator(self.values)
        extrapolation_ = operator(self._extrapolation)
        return self.with_(values=values, extrapolation=extrapolation_)

    def _op2(self, other, operator) -&gt; Field:
        if isinstance(other, Field):
            other_values = other.sample_in(self._elements)
            values = operator(self._values, other_values)
            extrapolation_ = operator(self._extrapolation, other.extrapolation)
            return self.with_(values=values, extrapolation=extrapolation_)
        else:
            other = math.tensor(other)
            values = operator(self._values, other)
            return self.with_(values=values)

    def __getitem__(self, item):
        values = self._values[item]
        return self.with_(values=values)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.field._field.Field</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>phi.field._grid.Grid</li>
<li>phi.field._point_cloud.PointCloud</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="phi.field.SampledField.data"><code class="name">var <span class="ident">data</span> : phi.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def values(self) -&gt; Tensor:
    return self._values</code></pre>
</details>
</dd>
<dt id="phi.field.SampledField.elements"><code class="name">var <span class="ident">elements</span> : phi.geom._geom.Geometry</code></dt>
<dd>
<div class="desc"><p>Returns a geometrical representation of the discretized volume elements.
The result is a tuple of Geometry objects, each of which can have additional spatial (but not batch) dimensions.</p>
<p>For grids, the geometries are boxes while particle fields may be represented as spheres.</p>
<p>If this Field has no discrete points, this method returns an empty geometry.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def elements(self) -&gt; Geometry:
    &#34;&#34;&#34;
    Returns a geometrical representation of the discretized volume elements.
    The result is a tuple of Geometry objects, each of which can have additional spatial (but not batch) dimensions.
    
    For grids, the geometries are boxes while particle fields may be represented as spheres.
    
    If this Field has no discrete points, this method returns an empty geometry.
    &#34;&#34;&#34;
    return self._elements</code></pre>
</details>
</dd>
<dt id="phi.field.SampledField.extrapolation"><code class="name">var <span class="ident">extrapolation</span> : <a title="phi.math.extrapolation.Extrapolation" href="../math/extrapolation.html#phi.math.extrapolation.Extrapolation">Extrapolation</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def extrapolation(self) -&gt; Extrapolation:
    return self._extrapolation</code></pre>
</details>
</dd>
<dt id="phi.field.SampledField.points"><code class="name">var <span class="ident">points</span> : phi.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def points(self) -&gt; Tensor:
    return self.elements.center</code></pre>
</details>
</dd>
<dt id="phi.field.SampledField.shape"><code class="name">var <span class="ident">shape</span> : phi.math._shape.Shape</code></dt>
<dd>
<div class="desc"><p>Returns a shape with the following properties</p>
<ul>
<li>The spatial dimension names match the dimensions of this Field</li>
<li>The batch dimensions match the batch dimensions of this Field</li>
<li>The channel dimensions match the channels of this Field</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape(self) -&gt; Shape:
    return self._shape</code></pre>
</details>
</dd>
<dt id="phi.field.SampledField.values"><code class="name">var <span class="ident">values</span> : phi.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def values(self) -&gt; Tensor:
    return self._values</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phi.field.SampledField.copied_with"><code class="name flex">
<span>def <span class="ident">copied_with</span></span>(<span>self, elements: Geometry or None = None, values: Tensor = None, extrapolation: math.Extrapolation = None) ‑> phi.field._field.SampledField</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a copy of this field with one or more properties changed. <code>None</code> keeps the current value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_(self,
          elements: Geometry or None = None,
          values: Tensor = None,
          extrapolation: math.Extrapolation = None) -&gt; SampledField:
    &#34;&#34;&#34; Creates a copy of this field with one or more properties changed. `None` keeps the current value. &#34;&#34;&#34;
    copied = copy.copy(self)
    SampledField.__init__(copied,
                          elements if elements is not None else self._elements,
                          values if values is not None else self._values,  # do not use == check
                          extrapolation if extrapolation is not None else self._extrapolation)
    return copied</code></pre>
</details>
</dd>
<dt id="phi.field.SampledField.sample_at"><code class="name flex">
<span>def <span class="ident">sample_at</span></span>(<span>self, points, reduce_channels=()) ‑> phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Sample this field at the world-space locations (in physical units) given by <code>points</code>.
Points must have a single channel dimension named <code>vector</code>.
It may additionally contain any number of batch and spatial dimensions, all treated as batch dimensions.</p>
<p>See <code><a title="phi.field.Field.sample_in" href="#phi.field.Field.sample_in">Field.sample_in()</a></code>, <code><a title="phi.field.Field.at" href="#phi.field.Field.at">Field.at()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>points</code></strong></dt>
<dd>world-space locations</dd>
<dt><strong><code>reduce_channels</code></strong></dt>
<dd>
<p>(optional) Dimensions of <code>points</code> to be reduced against the channel dimensions of this <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code>.
Causes the components of this field to be sampled at different locations.
The result is the same as <code>math.channel_stack([component.sample_at(p) for component, p in zip(field.unstack('vector'), points.unstack(reduce)])</code>
assuming this field as a single channel dimension called <code>vector</code>.</p>
<p>Example:
While <code><a title="phi.field.StaggeredGrid.sample_at" href="#phi.field.StaggeredGrid.sample_at">StaggeredGrid.sample_at()</a>(staggered_points)</code> samples all components at all faces,
<code>StaggeredGrid.sample_at(staggered_points, reduce_channels='staggered')</code> samples each component at the corresponding face only.</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Sampled values as a <code>Tensor</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_at(self, points, reduce_channels=()) -&gt; Tensor:
    raise NotImplementedError(self)</code></pre>
</details>
</dd>
<dt id="phi.field.SampledField.unstack"><code class="name flex">
<span>def <span class="ident">unstack</span></span>(<span>self, dimension: str) ‑> tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Unstack the field along one of its dimensions.
The dimension can be batch, spatial or channel.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dimension</code></strong></dt>
<dd>name of the dimension to unstack, must be part of <code>self.shape</code></dd>
<dt><strong><code>dimension</code></strong></dt>
<dd>str: </dd>
</dl>
<h2 id="returns">Returns</h2>
<p>tuple of Fields</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unstack(self, dimension: str) -&gt; tuple:
    values = self._values.unstack(dimension)
    return tuple(self.with_(values=v) for i, v in enumerate(values))</code></pre>
</details>
</dd>
<dt id="phi.field.SampledField.with_"><code class="name flex">
<span>def <span class="ident">with_</span></span>(<span>self, elements: Geometry or None = None, values: Tensor = None, extrapolation: math.Extrapolation = None) ‑> phi.field._field.SampledField</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a copy of this field with one or more properties changed. <code>None</code> keeps the current value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_(self,
          elements: Geometry or None = None,
          values: Tensor = None,
          extrapolation: math.Extrapolation = None) -&gt; SampledField:
    &#34;&#34;&#34; Creates a copy of this field with one or more properties changed. `None` keeps the current value. &#34;&#34;&#34;
    copied = copy.copy(self)
    SampledField.__init__(copied,
                          elements if elements is not None else self._elements,
                          values if values is not None else self._values,  # do not use == check
                          extrapolation if extrapolation is not None else self._extrapolation)
    return copied</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="phi.field.SoftGeometryMask"><code class="flex name class">
<span>class <span class="ident">GeometryMask</span></span>
<span>(</span><span>geometry: phi.geom._geom.Geometry)</span>
</code></dt>
<dd>
<div class="desc"><p>When sampled given another geometry, the approximate overlap between the geometries is computed, allowing for fractional values between 0 and 1.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SoftGeometryMask(HardGeometryMask):
    &#34;&#34;&#34;
    When sampled given another geometry, the approximate overlap between the geometries is computed, allowing for fractional values between 0 and 1.
    &#34;&#34;&#34;

    def sample_at(self, points: Tensor, reduce_channels=()) -&gt; Tensor:
        raise NotImplementedError(&#34;Use HardGeometryMask to sample at points&#34;)

    def sample_in(self, geometry: Geometry, reduce_channels=()) -&gt; Tensor:
        inside = self.geometry.approximate_fraction_inside(geometry)
        if reduce_channels:
            assert len(reduce_channels) == 1
            inside = inside.dimension(reduce_channels[0]).as_channel(&#39;vector&#39;)
        return inside</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.field._mask.HardGeometryMask</li>
<li>phi.field._analytic.AnalyticField</li>
<li>phi.field._field.Field</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="phi.field.SoftGeometryMask.sample_at"><code class="name flex">
<span>def <span class="ident">sample_at</span></span>(<span>self, points: phi.math._tensors.Tensor, reduce_channels=()) ‑> phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Sample this field at the world-space locations (in physical units) given by <code>points</code>.
Points must have a single channel dimension named <code>vector</code>.
It may additionally contain any number of batch and spatial dimensions, all treated as batch dimensions.</p>
<p>See <code><a title="phi.field.Field.sample_in" href="#phi.field.Field.sample_in">Field.sample_in()</a></code>, <code><a title="phi.field.Field.at" href="#phi.field.Field.at">Field.at()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>points</code></strong></dt>
<dd>world-space locations</dd>
<dt><strong><code>reduce_channels</code></strong></dt>
<dd>
<p>(optional) Dimensions of <code>points</code> to be reduced against the channel dimensions of this <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code>.
Causes the components of this field to be sampled at different locations.
The result is the same as <code>math.channel_stack([component.sample_at(p) for component, p in zip(field.unstack('vector'), points.unstack(reduce)])</code>
assuming this field as a single channel dimension called <code>vector</code>.</p>
<p>Example:
While <code><a title="phi.field.StaggeredGrid.sample_at" href="#phi.field.StaggeredGrid.sample_at">StaggeredGrid.sample_at()</a>(staggered_points)</code> samples all components at all faces,
<code>StaggeredGrid.sample_at(staggered_points, reduce_channels='staggered')</code> samples each component at the corresponding face only.</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Sampled values as a <code>Tensor</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_at(self, points: Tensor, reduce_channels=()) -&gt; Tensor:
    raise NotImplementedError(&#34;Use HardGeometryMask to sample at points&#34;)</code></pre>
</details>
</dd>
<dt id="phi.field.SoftGeometryMask.sample_in"><code class="name flex">
<span>def <span class="ident">sample_in</span></span>(<span>self, geometry: phi.geom._geom.Geometry, reduce_channels=()) ‑> phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Approximates the mean field value inside the volume of the geometry (batch).</p>
<p>For small volumes, the value at the volume's center may be sampled.
The batch dimensions of the geometry are matched with this Field.
Spatial dimensions can be used to sample a grid of geometries.</p>
<p>The default implementation of this method samples this Field at the center point of the geometry.</p>
<p>See <code><a title="phi.field.Field.sample_at" href="#phi.field.Field.sample_at">Field.sample_at()</a></code>, <code><a title="phi.field.Field.at" href="#phi.field.Field.at">Field.at()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>geometry</code></strong></dt>
<dd>single or batched Geometry object</dd>
<dt><strong><code>reduce_channels</code></strong></dt>
<dd>
<p>(optional) Dimensions of <code>points</code> to be reduced against the channel dimensions of this <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code>.
Causes the components of this field to be sampled at different locations.
The result is the same as <code>math.channel_stack([component.sample_at(p) for component, p in zip(field.unstack('vector'), points.unstack(reduce)])</code>
assuming this field as a single channel dimension called <code>vector</code>.</p>
<p>Example:
While <code><a title="phi.field.StaggeredGrid.sample_at" href="#phi.field.StaggeredGrid.sample_at">StaggeredGrid.sample_at()</a>(staggered_points)</code> samples all components at all faces,
<code>StaggeredGrid.sample_at(staggered_points, reduce_channels='staggered')</code> samples each component at the corresponding face only.</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Sampled values as a <code>Tensor</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_in(self, geometry: Geometry, reduce_channels=()) -&gt; Tensor:
    inside = self.geometry.approximate_fraction_inside(geometry)
    if reduce_channels:
        assert len(reduce_channels) == 1
        inside = inside.dimension(reduce_channels[0]).as_channel(&#39;vector&#39;)
    return inside</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="phi.field.SoftGeometryMask"><code class="flex name class">
<span>class <span class="ident">SoftGeometryMask</span></span>
<span>(</span><span>geometry: phi.geom._geom.Geometry)</span>
</code></dt>
<dd>
<div class="desc"><p>When sampled given another geometry, the approximate overlap between the geometries is computed, allowing for fractional values between 0 and 1.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SoftGeometryMask(HardGeometryMask):
    &#34;&#34;&#34;
    When sampled given another geometry, the approximate overlap between the geometries is computed, allowing for fractional values between 0 and 1.
    &#34;&#34;&#34;

    def sample_at(self, points: Tensor, reduce_channels=()) -&gt; Tensor:
        raise NotImplementedError(&#34;Use HardGeometryMask to sample at points&#34;)

    def sample_in(self, geometry: Geometry, reduce_channels=()) -&gt; Tensor:
        inside = self.geometry.approximate_fraction_inside(geometry)
        if reduce_channels:
            assert len(reduce_channels) == 1
            inside = inside.dimension(reduce_channels[0]).as_channel(&#39;vector&#39;)
        return inside</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.field._mask.HardGeometryMask</li>
<li>phi.field._analytic.AnalyticField</li>
<li>phi.field._field.Field</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="phi.field.SoftGeometryMask.sample_at"><code class="name flex">
<span>def <span class="ident">sample_at</span></span>(<span>self, points: phi.math._tensors.Tensor, reduce_channels=()) ‑> phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Sample this field at the world-space locations (in physical units) given by <code>points</code>.
Points must have a single channel dimension named <code>vector</code>.
It may additionally contain any number of batch and spatial dimensions, all treated as batch dimensions.</p>
<p>See <code><a title="phi.field.Field.sample_in" href="#phi.field.Field.sample_in">Field.sample_in()</a></code>, <code><a title="phi.field.Field.at" href="#phi.field.Field.at">Field.at()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>points</code></strong></dt>
<dd>world-space locations</dd>
<dt><strong><code>reduce_channels</code></strong></dt>
<dd>
<p>(optional) Dimensions of <code>points</code> to be reduced against the channel dimensions of this <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code>.
Causes the components of this field to be sampled at different locations.
The result is the same as <code>math.channel_stack([component.sample_at(p) for component, p in zip(field.unstack('vector'), points.unstack(reduce)])</code>
assuming this field as a single channel dimension called <code>vector</code>.</p>
<p>Example:
While <code><a title="phi.field.StaggeredGrid.sample_at" href="#phi.field.StaggeredGrid.sample_at">StaggeredGrid.sample_at()</a>(staggered_points)</code> samples all components at all faces,
<code>StaggeredGrid.sample_at(staggered_points, reduce_channels='staggered')</code> samples each component at the corresponding face only.</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Sampled values as a <code>Tensor</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_at(self, points: Tensor, reduce_channels=()) -&gt; Tensor:
    raise NotImplementedError(&#34;Use HardGeometryMask to sample at points&#34;)</code></pre>
</details>
</dd>
<dt id="phi.field.SoftGeometryMask.sample_in"><code class="name flex">
<span>def <span class="ident">sample_in</span></span>(<span>self, geometry: phi.geom._geom.Geometry, reduce_channels=()) ‑> phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Approximates the mean field value inside the volume of the geometry (batch).</p>
<p>For small volumes, the value at the volume's center may be sampled.
The batch dimensions of the geometry are matched with this Field.
Spatial dimensions can be used to sample a grid of geometries.</p>
<p>The default implementation of this method samples this Field at the center point of the geometry.</p>
<p>See <code><a title="phi.field.Field.sample_at" href="#phi.field.Field.sample_at">Field.sample_at()</a></code>, <code><a title="phi.field.Field.at" href="#phi.field.Field.at">Field.at()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>geometry</code></strong></dt>
<dd>single or batched Geometry object</dd>
<dt><strong><code>reduce_channels</code></strong></dt>
<dd>
<p>(optional) Dimensions of <code>points</code> to be reduced against the channel dimensions of this <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code>.
Causes the components of this field to be sampled at different locations.
The result is the same as <code>math.channel_stack([component.sample_at(p) for component, p in zip(field.unstack('vector'), points.unstack(reduce)])</code>
assuming this field as a single channel dimension called <code>vector</code>.</p>
<p>Example:
While <code><a title="phi.field.StaggeredGrid.sample_at" href="#phi.field.StaggeredGrid.sample_at">StaggeredGrid.sample_at()</a>(staggered_points)</code> samples all components at all faces,
<code>StaggeredGrid.sample_at(staggered_points, reduce_channels='staggered')</code> samples each component at the corresponding face only.</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Sampled values as a <code>Tensor</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_in(self, geometry: Geometry, reduce_channels=()) -&gt; Tensor:
    inside = self.geometry.approximate_fraction_inside(geometry)
    if reduce_channels:
        assert len(reduce_channels) == 1
        inside = inside.dimension(reduce_channels[0]).as_channel(&#39;vector&#39;)
    return inside</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="phi.field.StaggeredGrid"><code class="flex name class">
<span>class <span class="ident">StaggeredGrid</span></span>
<span>(</span><span>values: phi.math._tensors.TensorStack, bounds=None, extrapolation=0)</span>
</code></dt>
<dd>
<div class="desc"><p>N-dimensional grid whose vector components are sampled at the respective face centers.
A staggered grid is defined through its values tensor, its bounds describing the physical size and extrapolation.</p>
<p>Staggered grids support arbitrary batch and spatial dimensions but only one channel dimension for the staggered vector components.</p>
<p>See the <code><a title="phi.field" href="#phi.field">phi.field</a></code> module documentation at <a href="https://tum-pbs.github.io/PhiFlow/Fields.html">https://tum-pbs.github.io/PhiFlow/Fields.html</a></p>
<p>Args:</p>
<p>Returns:</p>
<p>Base class for fields that are sampled at specific locations such as grids or point clouds.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>elements</code></strong></dt>
<dd>Geometry object specifying the sample points and sizes</dd>
<dt><strong><code>values</code></strong></dt>
<dd>values corresponding to elements</dd>
<dt><strong><code>extrapolation</code></strong></dt>
<dd>values outside elements</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StaggeredGrid(Grid):
    &#34;&#34;&#34;
    N-dimensional grid whose vector components are sampled at the respective face centers.
    A staggered grid is defined through its values tensor, its bounds describing the physical size and extrapolation.
    
    Staggered grids support arbitrary batch and spatial dimensions but only one channel dimension for the staggered vector components.
    
    See the `phi.field` module documentation at https://tum-pbs.github.io/PhiFlow/Fields.html

    Args:

    Returns:

    &#34;&#34;&#34;

    def __init__(self, values: TensorStack, bounds=None, extrapolation=math.extrapolation.ZERO):
        values = _validate_staggered_values(values)
        x = values.vector[0 if math.GLOBAL_AXIS_ORDER.is_x_first else -1]
        resolution = x.shape.spatial.with_size(&#39;x&#39;, x.shape.get_size(&#39;x&#39;) - 1)
        Grid.__init__(self, values, resolution, bounds, extrapolation)

    @staticmethod
    def sample(value: Field or Geometry or callable or Tensor or float or int,
               resolution: Shape,
               bounds: Box,
               extrapolation=math.extrapolation.ZERO) -&gt; &#39;StaggeredGrid&#39;:
        &#34;&#34;&#34;
        Creates a StaggeredGrid from `value`.
        `value` has to be one of the following:
        
        * Geometry: sets inside values to 1, outside to 0
        * Field: resamples the Field to the staggered sample points
        * float, int: uses the value for all sample points
        * tuple, list: interprets the sequence as vector, used for all sample points
        * Tensor compatible with grid dims: uses tensor values as grid values

        Args:
          value: values to use for the grid
          resolution: grid resolution
          bounds: physical grid bounds
          extrapolation: return: Sampled values in staggered grid form matching domain resolution (Default value = math.extrapolation.ZERO)
          value: Field or Geometry or callable or Tensor or float or int: 
          resolution: Shape: 
          bounds: Box: 

        Returns:
          Sampled values in staggered grid form matching domain resolution

        &#34;&#34;&#34;
        if isinstance(value, Geometry):
            value = HardGeometryMask(value)
        if isinstance(value, Field):
            assert_same_rank(value.spatial_rank, bounds.spatial_rank, &#39;rank of value (%s) does not match domain (%s)&#39; % (value.spatial_rank, bounds.spatial_rank))
            if isinstance(value, StaggeredGrid) and value.bounds == bounds and np.all(value.resolution == resolution):
                return value
            else:
                components = value.vector.unstack(bounds.spatial_rank)
                tensors = []
                for dim, comp in zip(resolution.spatial.names, components):
                    comp_cells = GridCell(resolution, bounds).extend_symmetric(dim, 1)
                    comp_grid = CenteredGrid.sample(comp, comp_cells.resolution, comp_cells.bounds, extrapolation)
                    tensors.append(comp_grid.values)
                return StaggeredGrid(math.channel_stack(tensors, &#39;vector&#39;), bounds, extrapolation)
        else:  # value is function or constant
            if callable(value):
                points = GridCell(resolution, bounds).face_centers()
                value = value(points)
            value = tensor(value)
            components = (value.staggered if &#39;staggered&#39; in value.shape else value.vector).unstack(resolution.spatial_rank)
            tensors = []
            for dim, component in zip(resolution.spatial.names, components):
                comp_cells = GridCell(resolution, bounds).extend_symmetric(dim, 1)
                tensors.append(math.zeros(comp_cells.resolution) + component)
            return StaggeredGrid(math.channel_stack(tensors, &#39;vector&#39;), bounds, extrapolation)

    def with_(self,
              elements: Geometry or None = None,
              values: Tensor = None,
              extrapolation: math.Extrapolation = None) -&gt; SampledField:
        assert elements is None
        values = _validate_staggered_values(values) if values is not None else None
        return Grid.with_(self, values=values, extrapolation=extrapolation)

    @property
    def cells(self):
        return GridCell(self.resolution, self.bounds)

    def sample_in(self, geometry: Geometry, reduce_channels=()) -&gt; Tensor:
        if geometry == self.elements and reduce_channels:
            return self.values
        if not reduce_channels:
            channels = [component.sample_in(geometry) for component in self.unstack()]
        else:
            assert len(reduce_channels) == 1
            geometries = geometry.unstack(reduce_channels[0])
            channels = [component.sample_in(g) for g, component in zip(geometries, self.unstack())]
        return math.channel_stack(channels, &#39;vector&#39;)

    def sample_at(self, points: Tensor, reduce_channels=()) -&gt; Tensor:
        if not reduce_channels:
            channels = [component.sample_at(points) for component in self.unstack()]
        else:
            assert len(reduce_channels) == 1
            points = points.unstack(reduce_channels[0])
            channels = [component.sample_at(p) for p, component in zip(points, self.unstack())]
        return math.channel_stack(channels, &#39;vector&#39;)

    def closest_values(self, points: Tensor, reduce_channels=()):
        if not reduce_channels:
            channels = [component.sample_at(points) for component in self.unstack()]
        else:
            assert len(reduce_channels) == 1
            points = points.unstack(reduce_channels[0])
            channels = [component.closest_values(p) for p, component in zip(points, self.unstack())]
        return math.channel_stack(channels, &#39;vector&#39;)

    def at_centers(self) -&gt; CenteredGrid:
        return CenteredGrid(self.sample_in(self.cells), self.bounds, self.extrapolation)

    def unstack(self, dimension=&#39;vector&#39;):
        if dimension == &#39;vector&#39;:
            result = []
            for dim, data in zip(self.resolution.spatial.names, self.values.vector.unstack()):
                comp_cells = GridCell(self.resolution, self._bounds).extend_symmetric(dim, 1)
                result.append(CenteredGrid(data, comp_cells.bounds, self.extrapolation))
            return tuple(result)
        else:
            raise NotImplementedError(f&#34;dimension={dimension}. Only &#39;vector&#39; allowed.&#34;)

    @property
    def x(self) -&gt; CenteredGrid:
        &#34;&#34;&#34; x component &#34;&#34;&#34;
        return self.unstack()[self.resolution.index(&#39;x&#39;)]

    @property
    def y(self) -&gt; CenteredGrid:
        &#34;&#34;&#34; y component &#34;&#34;&#34;
        return self.unstack()[self.resolution.index(&#39;y&#39;)]

    @property
    def z(self) -&gt; CenteredGrid:
        &#34;&#34;&#34; z component &#34;&#34;&#34;
        return self.unstack()[self.resolution.index(&#39;z&#39;)]

    @property
    def elements(self):
        grids = [grid.elements for grid in self.unstack()]
        return GeometryStack(grids, &#39;staggered&#39;)

    def staggered_tensor(self):
        return stack_staggered_components(self.values)

    def _op2(self, other, operator):
        if isinstance(other, StaggeredGrid) and self.bounds == other.bounds and self.shape.spatial == other.shape.spatial:
            values = operator(self._values, other.values)
            extrapolation_ = operator(self._extrapolation, other.extrapolation)
            return self.with_(values=values, extrapolation=extrapolation_)
        else:
            return SampledField._op2(self, other, operator)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.field._grid.Grid</li>
<li>phi.field._field.SampledField</li>
<li>phi.field._field.Field</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="phi.field.StaggeredGrid.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>value: phi.field._field.Field, resolution: phi.math._shape.Shape, bounds: phi.geom._box.Box, extrapolation=0) ‑> phi.field._grid.StaggeredGrid</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a StaggeredGrid from <code>value</code>.
<code>value</code> has to be one of the following:</p>
<ul>
<li>Geometry: sets inside values to 1, outside to 0</li>
<li>Field: resamples the Field to the staggered sample points</li>
<li>float, int: uses the value for all sample points</li>
<li>tuple, list: interprets the sequence as vector, used for all sample points</li>
<li>Tensor compatible with grid dims: uses tensor values as grid values</li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong></dt>
<dd>values to use for the grid</dd>
<dt><strong><code>resolution</code></strong></dt>
<dd>grid resolution</dd>
<dt><strong><code>bounds</code></strong></dt>
<dd>physical grid bounds</dd>
<dt><strong><code>extrapolation</code></strong></dt>
<dd>return: Sampled values in staggered grid form matching domain resolution (Default value = math.extrapolation.ZERO)</dd>
<dt><strong><code>value</code></strong></dt>
<dd>Field or Geometry or callable or Tensor or float or int: </dd>
<dt><strong><code>resolution</code></strong></dt>
<dd>Shape: </dd>
<dt><strong><code>bounds</code></strong></dt>
<dd>Box: </dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Sampled values in staggered grid form matching domain resolution</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def sample(value: Field or Geometry or callable or Tensor or float or int,
           resolution: Shape,
           bounds: Box,
           extrapolation=math.extrapolation.ZERO) -&gt; &#39;StaggeredGrid&#39;:
    &#34;&#34;&#34;
    Creates a StaggeredGrid from `value`.
    `value` has to be one of the following:
    
    * Geometry: sets inside values to 1, outside to 0
    * Field: resamples the Field to the staggered sample points
    * float, int: uses the value for all sample points
    * tuple, list: interprets the sequence as vector, used for all sample points
    * Tensor compatible with grid dims: uses tensor values as grid values

    Args:
      value: values to use for the grid
      resolution: grid resolution
      bounds: physical grid bounds
      extrapolation: return: Sampled values in staggered grid form matching domain resolution (Default value = math.extrapolation.ZERO)
      value: Field or Geometry or callable or Tensor or float or int: 
      resolution: Shape: 
      bounds: Box: 

    Returns:
      Sampled values in staggered grid form matching domain resolution

    &#34;&#34;&#34;
    if isinstance(value, Geometry):
        value = HardGeometryMask(value)
    if isinstance(value, Field):
        assert_same_rank(value.spatial_rank, bounds.spatial_rank, &#39;rank of value (%s) does not match domain (%s)&#39; % (value.spatial_rank, bounds.spatial_rank))
        if isinstance(value, StaggeredGrid) and value.bounds == bounds and np.all(value.resolution == resolution):
            return value
        else:
            components = value.vector.unstack(bounds.spatial_rank)
            tensors = []
            for dim, comp in zip(resolution.spatial.names, components):
                comp_cells = GridCell(resolution, bounds).extend_symmetric(dim, 1)
                comp_grid = CenteredGrid.sample(comp, comp_cells.resolution, comp_cells.bounds, extrapolation)
                tensors.append(comp_grid.values)
            return StaggeredGrid(math.channel_stack(tensors, &#39;vector&#39;), bounds, extrapolation)
    else:  # value is function or constant
        if callable(value):
            points = GridCell(resolution, bounds).face_centers()
            value = value(points)
        value = tensor(value)
        components = (value.staggered if &#39;staggered&#39; in value.shape else value.vector).unstack(resolution.spatial_rank)
        tensors = []
        for dim, component in zip(resolution.spatial.names, components):
            comp_cells = GridCell(resolution, bounds).extend_symmetric(dim, 1)
            tensors.append(math.zeros(comp_cells.resolution) + component)
        return StaggeredGrid(math.channel_stack(tensors, &#39;vector&#39;), bounds, extrapolation)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="phi.field.StaggeredGrid.cells"><code class="name">var <span class="ident">cells</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cells(self):
    return GridCell(self.resolution, self.bounds)</code></pre>
</details>
</dd>
<dt id="phi.field.StaggeredGrid.elements"><code class="name">var <span class="ident">elements</span></code></dt>
<dd>
<div class="desc"><p>Returns a geometrical representation of the discretized volume elements.
The result is a tuple of Geometry objects, each of which can have additional spatial (but not batch) dimensions.</p>
<p>For grids, the geometries are boxes while particle fields may be represented as spheres.</p>
<p>If this Field has no discrete points, this method returns an empty geometry.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def elements(self):
    grids = [grid.elements for grid in self.unstack()]
    return GeometryStack(grids, &#39;staggered&#39;)</code></pre>
</details>
</dd>
<dt id="phi.field.StaggeredGrid.x"><code class="name">var <span class="ident">x</span> : phi.field._grid.CenteredGrid</code></dt>
<dd>
<div class="desc"><p>x component</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def x(self) -&gt; CenteredGrid:
    &#34;&#34;&#34; x component &#34;&#34;&#34;
    return self.unstack()[self.resolution.index(&#39;x&#39;)]</code></pre>
</details>
</dd>
<dt id="phi.field.StaggeredGrid.y"><code class="name">var <span class="ident">y</span> : phi.field._grid.CenteredGrid</code></dt>
<dd>
<div class="desc"><p>y component</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def y(self) -&gt; CenteredGrid:
    &#34;&#34;&#34; y component &#34;&#34;&#34;
    return self.unstack()[self.resolution.index(&#39;y&#39;)]</code></pre>
</details>
</dd>
<dt id="phi.field.StaggeredGrid.z"><code class="name">var <span class="ident">z</span> : phi.field._grid.CenteredGrid</code></dt>
<dd>
<div class="desc"><p>z component</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def z(self) -&gt; CenteredGrid:
    &#34;&#34;&#34; z component &#34;&#34;&#34;
    return self.unstack()[self.resolution.index(&#39;z&#39;)]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phi.field.StaggeredGrid.at_centers"><code class="name flex">
<span>def <span class="ident">at_centers</span></span>(<span>self) ‑> phi.field._grid.CenteredGrid</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def at_centers(self) -&gt; CenteredGrid:
    return CenteredGrid(self.sample_in(self.cells), self.bounds, self.extrapolation)</code></pre>
</details>
</dd>
<dt id="phi.field.StaggeredGrid.closest_values"><code class="name flex">
<span>def <span class="ident">closest_values</span></span>(<span>self, points: phi.math._tensors.Tensor, reduce_channels=())</span>
</code></dt>
<dd>
<div class="desc"><p>Sample the closest grid point values of this field at the world-space locations (in physical units) given by <code>points</code>.
Points must have a single channel dimension named <code>vector</code>.
It may additionally contain any number of batch and spatial dimensions, all treated as batch dimensions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>points</code></strong></dt>
<dd>world-space locations</dd>
<dt><strong><code>reduce_channels</code></strong></dt>
<dd>(optional) See <code><a title="phi.field.Field.sample_at" href="#phi.field.Field.sample_at">Field.sample_at()</a></code> for a description.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Closest grid point values as a <code>Tensor</code>.
For each dimension, the grid points immediately left and right of the sample points are evaluated.
For each point in <code>points</code>, a <em>2^d</em> cube of points is determined where <em>d</em> is the number of spatial dimensions of this field.
These values are stacked along the new dimensions <code>'closest_&lt;dim&gt;'</code> where <code>&lt;dim&gt;</code> refers to the name of a spatial dimension.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def closest_values(self, points: Tensor, reduce_channels=()):
    if not reduce_channels:
        channels = [component.sample_at(points) for component in self.unstack()]
    else:
        assert len(reduce_channels) == 1
        points = points.unstack(reduce_channels[0])
        channels = [component.closest_values(p) for p, component in zip(points, self.unstack())]
    return math.channel_stack(channels, &#39;vector&#39;)</code></pre>
</details>
</dd>
<dt id="phi.field.StaggeredGrid.sample_at"><code class="name flex">
<span>def <span class="ident">sample_at</span></span>(<span>self, points: phi.math._tensors.Tensor, reduce_channels=()) ‑> phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Sample this field at the world-space locations (in physical units) given by <code>points</code>.
Points must have a single channel dimension named <code>vector</code>.
It may additionally contain any number of batch and spatial dimensions, all treated as batch dimensions.</p>
<p>See <code><a title="phi.field.Field.sample_in" href="#phi.field.Field.sample_in">Field.sample_in()</a></code>, <code><a title="phi.field.Field.at" href="#phi.field.Field.at">Field.at()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>points</code></strong></dt>
<dd>world-space locations</dd>
<dt><strong><code>reduce_channels</code></strong></dt>
<dd>
<p>(optional) Dimensions of <code>points</code> to be reduced against the channel dimensions of this <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code>.
Causes the components of this field to be sampled at different locations.
The result is the same as <code>math.channel_stack([component.sample_at(p) for component, p in zip(field.unstack('vector'), points.unstack(reduce)])</code>
assuming this field as a single channel dimension called <code>vector</code>.</p>
<p>Example:
While <code><a title="phi.field.StaggeredGrid.sample_at" href="#phi.field.StaggeredGrid.sample_at">StaggeredGrid.sample_at()</a>(staggered_points)</code> samples all components at all faces,
<code>StaggeredGrid.sample_at(staggered_points, reduce_channels='staggered')</code> samples each component at the corresponding face only.</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Sampled values as a <code>Tensor</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_at(self, points: Tensor, reduce_channels=()) -&gt; Tensor:
    if not reduce_channels:
        channels = [component.sample_at(points) for component in self.unstack()]
    else:
        assert len(reduce_channels) == 1
        points = points.unstack(reduce_channels[0])
        channels = [component.sample_at(p) for p, component in zip(points, self.unstack())]
    return math.channel_stack(channels, &#39;vector&#39;)</code></pre>
</details>
</dd>
<dt id="phi.field.StaggeredGrid.sample_in"><code class="name flex">
<span>def <span class="ident">sample_in</span></span>(<span>self, geometry: phi.geom._geom.Geometry, reduce_channels=()) ‑> phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Approximates the mean field value inside the volume of the geometry (batch).</p>
<p>For small volumes, the value at the volume's center may be sampled.
The batch dimensions of the geometry are matched with this Field.
Spatial dimensions can be used to sample a grid of geometries.</p>
<p>The default implementation of this method samples this Field at the center point of the geometry.</p>
<p>See <code><a title="phi.field.Field.sample_at" href="#phi.field.Field.sample_at">Field.sample_at()</a></code>, <code><a title="phi.field.Field.at" href="#phi.field.Field.at">Field.at()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>geometry</code></strong></dt>
<dd>single or batched Geometry object</dd>
<dt><strong><code>reduce_channels</code></strong></dt>
<dd>
<p>(optional) Dimensions of <code>points</code> to be reduced against the channel dimensions of this <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code>.
Causes the components of this field to be sampled at different locations.
The result is the same as <code>math.channel_stack([component.sample_at(p) for component, p in zip(field.unstack('vector'), points.unstack(reduce)])</code>
assuming this field as a single channel dimension called <code>vector</code>.</p>
<p>Example:
While <code><a title="phi.field.StaggeredGrid.sample_at" href="#phi.field.StaggeredGrid.sample_at">StaggeredGrid.sample_at()</a>(staggered_points)</code> samples all components at all faces,
<code>StaggeredGrid.sample_at(staggered_points, reduce_channels='staggered')</code> samples each component at the corresponding face only.</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Sampled values as a <code>Tensor</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_in(self, geometry: Geometry, reduce_channels=()) -&gt; Tensor:
    if geometry == self.elements and reduce_channels:
        return self.values
    if not reduce_channels:
        channels = [component.sample_in(geometry) for component in self.unstack()]
    else:
        assert len(reduce_channels) == 1
        geometries = geometry.unstack(reduce_channels[0])
        channels = [component.sample_in(g) for g, component in zip(geometries, self.unstack())]
    return math.channel_stack(channels, &#39;vector&#39;)</code></pre>
</details>
</dd>
<dt id="phi.field.StaggeredGrid.staggered_tensor"><code class="name flex">
<span>def <span class="ident">staggered_tensor</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def staggered_tensor(self):
    return stack_staggered_components(self.values)</code></pre>
</details>
</dd>
<dt id="phi.field.StaggeredGrid.unstack"><code class="name flex">
<span>def <span class="ident">unstack</span></span>(<span>self, dimension='vector')</span>
</code></dt>
<dd>
<div class="desc"><p>Unstack the field along one of its dimensions.
The dimension can be batch, spatial or channel.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dimension</code></strong></dt>
<dd>name of the dimension to unstack, must be part of <code>self.shape</code></dd>
<dt><strong><code>dimension</code></strong></dt>
<dd>str: </dd>
</dl>
<h2 id="returns">Returns</h2>
<p>tuple of Fields</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unstack(self, dimension=&#39;vector&#39;):
    if dimension == &#39;vector&#39;:
        result = []
        for dim, data in zip(self.resolution.spatial.names, self.values.vector.unstack()):
            comp_cells = GridCell(self.resolution, self._bounds).extend_symmetric(dim, 1)
            result.append(CenteredGrid(data, comp_cells.bounds, self.extrapolation))
        return tuple(result)
    else:
        raise NotImplementedError(f&#34;dimension={dimension}. Only &#39;vector&#39; allowed.&#34;)</code></pre>
</details>
</dd>
<dt id="phi.field.StaggeredGrid.with_"><code class="name flex">
<span>def <span class="ident">with_</span></span>(<span>self, elements: phi.geom._geom.Geometry = None, values: phi.math._tensors.Tensor = None, extrapolation: <a title="phi.math.extrapolation.Extrapolation" href="../math/extrapolation.html#phi.math.extrapolation.Extrapolation">Extrapolation</a> = None) ‑> phi.field._field.SampledField</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a copy of this field with one or more properties changed. <code>None</code> keeps the current value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_(self,
          elements: Geometry or None = None,
          values: Tensor = None,
          extrapolation: math.Extrapolation = None) -&gt; SampledField:
    assert elements is None
    values = _validate_staggered_values(values) if values is not None else None
    return Grid.with_(self, values=values, extrapolation=extrapolation)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="phi" href="../index.html">phi</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="phi.field.diffuse" href="#phi.field.diffuse">diffuse</a></code></li>
<li><code><a title="phi.field.divergence" href="#phi.field.divergence">divergence</a></code></li>
<li><code><a title="phi.field.divergence_free" href="#phi.field.divergence_free">divergence_free</a></code></li>
<li><code><a title="phi.field.expose_tensors" href="#phi.field.expose_tensors">expose_tensors</a></code></li>
<li><code><a title="phi.field.gradient" href="#phi.field.gradient">gradient</a></code></li>
<li><code><a title="phi.field.l2_loss" href="#phi.field.l2_loss">l2_loss</a></code></li>
<li><code><a title="phi.field.laplace" href="#phi.field.laplace">laplace</a></code></li>
<li><code><a title="phi.field.mean" href="#phi.field.mean">mean</a></code></li>
<li><code><a title="phi.field.normalize" href="#phi.field.normalize">normalize</a></code></li>
<li><code><a title="phi.field.pad" href="#phi.field.pad">pad</a></code></li>
<li><code><a title="phi.field.read" href="#phi.field.read">read</a></code></li>
<li><code><a title="phi.field.shift" href="#phi.field.shift">shift</a></code></li>
<li><code><a title="phi.field.solve" href="#phi.field.solve">solve</a></code></li>
<li><code><a title="phi.field.stack_staggered_components" href="#phi.field.stack_staggered_components">stack_staggered_components</a></code></li>
<li><code><a title="phi.field.stagger" href="#phi.field.stagger">stagger</a></code></li>
<li><code><a title="phi.field.staggered_curl_2d" href="#phi.field.staggered_curl_2d">staggered_curl_2d</a></code></li>
<li><code><a title="phi.field.unstack_staggered_tensor" href="#phi.field.unstack_staggered_tensor">unstack_staggered_tensor</a></code></li>
<li><code><a title="phi.field.where" href="#phi.field.where">where</a></code></li>
<li><code><a title="phi.field.write" href="#phi.field.write">write</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="phi.field.AnalyticField" href="#phi.field.AnalyticField">AnalyticField</a></code></h4>
<ul class="">
<li><code><a title="phi.field.AnalyticField.unstack" href="#phi.field.AnalyticField.unstack">unstack</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.field.AngularVelocity" href="#phi.field.AngularVelocity">AngularVelocity</a></code></h4>
<ul class="">
<li><code><a title="phi.field.AngularVelocity.sample_at" href="#phi.field.AngularVelocity.sample_at">sample_at</a></code></li>
<li><code><a title="phi.field.AngularVelocity.shape" href="#phi.field.AngularVelocity.shape">shape</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.field.CenteredGrid" href="#phi.field.CenteredGrid">CenteredGrid</a></code></h4>
<ul class="">
<li><code><a title="phi.field.CenteredGrid.closest_values" href="#phi.field.CenteredGrid.closest_values">closest_values</a></code></li>
<li><code><a title="phi.field.CenteredGrid.sample" href="#phi.field.CenteredGrid.sample">sample</a></code></li>
<li><code><a title="phi.field.CenteredGrid.sample_at" href="#phi.field.CenteredGrid.sample_at">sample_at</a></code></li>
<li><code><a title="phi.field.CenteredGrid.sample_in" href="#phi.field.CenteredGrid.sample_in">sample_in</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.field.ConstantField" href="#phi.field.ConstantField">ConstantField</a></code></h4>
<ul class="">
<li><code><a title="phi.field.ConstantField.sample_at" href="#phi.field.ConstantField.sample_at">sample_at</a></code></li>
<li><code><a title="phi.field.ConstantField.shape" href="#phi.field.ConstantField.shape">shape</a></code></li>
<li><code><a title="phi.field.ConstantField.unstack" href="#phi.field.ConstantField.unstack">unstack</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code></h4>
<ul class="two-column">
<li><code><a title="phi.field.Field.at" href="#phi.field.Field.at">at</a></code></li>
<li><code><a title="phi.field.Field.dimension" href="#phi.field.Field.dimension">dimension</a></code></li>
<li><code><a title="phi.field.Field.sample_at" href="#phi.field.Field.sample_at">sample_at</a></code></li>
<li><code><a title="phi.field.Field.sample_in" href="#phi.field.Field.sample_in">sample_in</a></code></li>
<li><code><a title="phi.field.Field.shape" href="#phi.field.Field.shape">shape</a></code></li>
<li><code><a title="phi.field.Field.spatial_rank" href="#phi.field.Field.spatial_rank">spatial_rank</a></code></li>
<li><code><a title="phi.field.Field.unstack" href="#phi.field.Field.unstack">unstack</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.field.Grid" href="#phi.field.Grid">Grid</a></code></h4>
<ul class="two-column">
<li><code><a title="phi.field.Grid.bounds" href="#phi.field.Grid.bounds">bounds</a></code></li>
<li><code><a title="phi.field.Grid.box" href="#phi.field.Grid.box">box</a></code></li>
<li><code><a title="phi.field.Grid.closest_values" href="#phi.field.Grid.closest_values">closest_values</a></code></li>
<li><code><a title="phi.field.Grid.dx" href="#phi.field.Grid.dx">dx</a></code></li>
<li><code><a title="phi.field.Grid.resolution" href="#phi.field.Grid.resolution">resolution</a></code></li>
<li><code><a title="phi.field.Grid.sample_at" href="#phi.field.Grid.sample_at">sample_at</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.field.HardGeometryMask" href="#phi.field.HardGeometryMask">HardGeometryMask</a></code></h4>
<ul class="">
<li><code><a title="phi.field.HardGeometryMask.sample_at" href="#phi.field.HardGeometryMask.sample_at">sample_at</a></code></li>
<li><code><a title="phi.field.HardGeometryMask.shape" href="#phi.field.HardGeometryMask.shape">shape</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.field.Noise" href="#phi.field.Noise">Noise</a></code></h4>
<ul class="">
<li><code><a title="phi.field.Noise.grid_sample" href="#phi.field.Noise.grid_sample">grid_sample</a></code></li>
<li><code><a title="phi.field.Noise.sample_at" href="#phi.field.Noise.sample_at">sample_at</a></code></li>
<li><code><a title="phi.field.Noise.sample_in" href="#phi.field.Noise.sample_in">sample_in</a></code></li>
<li><code><a title="phi.field.Noise.shape" href="#phi.field.Noise.shape">shape</a></code></li>
<li><code><a title="phi.field.Noise.unstack" href="#phi.field.Noise.unstack">unstack</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.field.PointCloud" href="#phi.field.PointCloud">PointCloud</a></code></h4>
<ul class="">
<li><code><a title="phi.field.PointCloud.sample_at" href="#phi.field.PointCloud.sample_at">sample_at</a></code></li>
<li><code><a title="phi.field.PointCloud.sample_in" href="#phi.field.PointCloud.sample_in">sample_in</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.field.SampledField" href="#phi.field.SampledField">SampledField</a></code></h4>
<ul class="two-column">
<li><code><a title="phi.field.SampledField.copied_with" href="#phi.field.SampledField.copied_with">copied_with</a></code></li>
<li><code><a title="phi.field.SampledField.data" href="#phi.field.SampledField.data">data</a></code></li>
<li><code><a title="phi.field.SampledField.elements" href="#phi.field.SampledField.elements">elements</a></code></li>
<li><code><a title="phi.field.SampledField.extrapolation" href="#phi.field.SampledField.extrapolation">extrapolation</a></code></li>
<li><code><a title="phi.field.SampledField.points" href="#phi.field.SampledField.points">points</a></code></li>
<li><code><a title="phi.field.SampledField.sample_at" href="#phi.field.SampledField.sample_at">sample_at</a></code></li>
<li><code><a title="phi.field.SampledField.shape" href="#phi.field.SampledField.shape">shape</a></code></li>
<li><code><a title="phi.field.SampledField.unstack" href="#phi.field.SampledField.unstack">unstack</a></code></li>
<li><code><a title="phi.field.SampledField.values" href="#phi.field.SampledField.values">values</a></code></li>
<li><code><a title="phi.field.SampledField.with_" href="#phi.field.SampledField.with_">with_</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.field.SoftGeometryMask" href="#phi.field.SoftGeometryMask">SoftGeometryMask</a></code></h4>
<ul class="">
<li><code><a title="phi.field.SoftGeometryMask.sample_at" href="#phi.field.SoftGeometryMask.sample_at">sample_at</a></code></li>
<li><code><a title="phi.field.SoftGeometryMask.sample_in" href="#phi.field.SoftGeometryMask.sample_in">sample_in</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.field.SoftGeometryMask" href="#phi.field.SoftGeometryMask">SoftGeometryMask</a></code></h4>
<ul class="">
<li><code><a title="phi.field.SoftGeometryMask.sample_at" href="#phi.field.SoftGeometryMask.sample_at">sample_at</a></code></li>
<li><code><a title="phi.field.SoftGeometryMask.sample_in" href="#phi.field.SoftGeometryMask.sample_in">sample_in</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.field.StaggeredGrid" href="#phi.field.StaggeredGrid">StaggeredGrid</a></code></h4>
<ul class="two-column">
<li><code><a title="phi.field.StaggeredGrid.at_centers" href="#phi.field.StaggeredGrid.at_centers">at_centers</a></code></li>
<li><code><a title="phi.field.StaggeredGrid.cells" href="#phi.field.StaggeredGrid.cells">cells</a></code></li>
<li><code><a title="phi.field.StaggeredGrid.closest_values" href="#phi.field.StaggeredGrid.closest_values">closest_values</a></code></li>
<li><code><a title="phi.field.StaggeredGrid.elements" href="#phi.field.StaggeredGrid.elements">elements</a></code></li>
<li><code><a title="phi.field.StaggeredGrid.sample" href="#phi.field.StaggeredGrid.sample">sample</a></code></li>
<li><code><a title="phi.field.StaggeredGrid.sample_at" href="#phi.field.StaggeredGrid.sample_at">sample_at</a></code></li>
<li><code><a title="phi.field.StaggeredGrid.sample_in" href="#phi.field.StaggeredGrid.sample_in">sample_in</a></code></li>
<li><code><a title="phi.field.StaggeredGrid.staggered_tensor" href="#phi.field.StaggeredGrid.staggered_tensor">staggered_tensor</a></code></li>
<li><code><a title="phi.field.StaggeredGrid.unstack" href="#phi.field.StaggeredGrid.unstack">unstack</a></code></li>
<li><code><a title="phi.field.StaggeredGrid.with_" href="#phi.field.StaggeredGrid.with_">with_</a></code></li>
<li><code><a title="phi.field.StaggeredGrid.x" href="#phi.field.StaggeredGrid.x">x</a></code></li>
<li><code><a title="phi.field.StaggeredGrid.y" href="#phi.field.StaggeredGrid.y">y</a></code></li>
<li><code><a title="phi.field.StaggeredGrid.z" href="#phi.field.StaggeredGrid.z">z</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>