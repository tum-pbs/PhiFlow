<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.1">
<title>phi.field API documentation</title>
<meta name="description" content="The fields module provides a number of data structures and functions to represent continuous, spatially varying data …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>phi.field</code></h1>
</header>
<section id="section-intro">
<p>The fields module provides a number of data structures and functions to represent continuous, spatially varying data.</p>
<p>All fields are subclasses of <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> which provides abstract functions for sampling field values at physical locations.</p>
<p>The most important field types are:</p>
<ul>
<li><code><a title="phi.field.CenteredGrid" href="#phi.field.CenteredGrid">CenteredGrid()</a></code> embeds a tensor in the physical space. Uses linear interpolation between grid points.</li>
<li><code><a title="phi.field.StaggeredGrid" href="#phi.field.StaggeredGrid">StaggeredGrid()</a></code> samples the vector components at face centers instead of at cell centers.</li>
<li><code><a title="phi.field.Noise" href="#phi.field.Noise">Noise</a></code> is a function that produces a procedurally generated noise field</li>
</ul>
<p>Use <code>grid()</code> to create a <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> from data or by sampling another <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> or <code><a title="phi.geom.Geometry" href="../geom/index.html#phi.geom.Geometry">Geometry</a></code>.
Alternatively, the <code>phi.physics.Domain</code> class provides convenience methods for grid creation.</p>
<p>All fields can be sampled at physical locations or volumes using <code><a title="phi.field.sample" href="#phi.field.sample">sample()</a></code> or <code><a title="phi.field.reduce_sample" href="#phi.field.reduce_sample">reduce_sample()</a></code>.</p>
<p>See the <code><a title="phi.field" href="#phi.field">phi.field</a></code> module documentation at <a href="https://tum-pbs.github.io/PhiFlow/Fields.html">https://tum-pbs.github.io/PhiFlow/Fields.html</a></p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="phi.field.CenteredGrid"><code class="name flex">
<span>def <span class="ident">CenteredGrid</span></span>(<span>values: Any = 0.0, boundary: Any = 0.0, bounds: phi.geom._box.Box = None, resolution: int = None, extrapolation: Any = None, convert=True, **resolution_: int) ‑> phi.field._field.Field</span>
</code></dt>
<dd>
<div class="desc"><p>Create an n-dimensional grid with values sampled at the cell centers.
A centered grid is defined through its <code>CenteredGrid.values</code> <code>phi.math.Tensor</code>, its <code>CenteredGrid.bounds</code> <code><a title="phi.geom.Box" href="../geom/index.html#phi.geom.Box">Box</a></code> describing the physical size, and its <code>CenteredGrid.extrapolation</code> (<code>phi.math.extrapolation.Extrapolation</code>).</p>
<p>Centered grids support batch, spatial and channel dimensions.</p>
<p>See Also:
<code><a title="phi.field.StaggeredGrid" href="#phi.field.StaggeredGrid">StaggeredGrid()</a></code>,
<code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code>,
<code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code>,
<code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code>,
module documentation at <a href="https://tum-pbs.github.io/PhiFlow/Fields.html">https://tum-pbs.github.io/PhiFlow/Fields.html</a></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>values</code></strong></dt>
<dd>
<p>Values to use for the grid.
Has to be one of the following:</p>
<ul>
<li><code><a title="phi.geom.Geometry" href="../geom/index.html#phi.geom.Geometry">Geometry</a></code>: sets inside values to 1, outside to 0</li>
<li><code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code>: resamples the Field to the staggered sample points</li>
<li><code>Number</code>: uses the value for all sample points</li>
<li><code>tuple</code> or <code>list</code>: interprets the sequence as vector, used for all sample points</li>
<li><code>phi.math.Tensor</code> compatible with grid dims: uses tensor values as grid values</li>
<li>Function <code>values(x)</code> where <code>x</code> is a <code>phi.math.Tensor</code> representing the physical location.
The spatial dimensions of the grid will be passed as batch dimensions to the function.</li>
</ul>
</dd>
<dt><strong><code>extrapolation</code></strong></dt>
<dd>The grid extrapolation determines the value outside the <code>values</code> tensor.
Allowed types: <code>float</code>, <code>phi.math.Tensor</code>, <code>phi.math.extrapolation.Extrapolation</code>.</dd>
<dt><strong><code>bounds</code></strong></dt>
<dd>Physical size and location of the grid as <code><a title="phi.geom.Box" href="../geom/index.html#phi.geom.Box">Box</a></code>.
If the resolution is determined through <code>resolution</code> of <code>values</code>, a <code>float</code> can be passed for <code>bounds</code> to create a unit box.</dd>
<dt><strong><code>resolution</code></strong></dt>
<dd>Grid resolution as purely spatial <code>phi.math.Shape</code>.
If <code>bounds</code> is given as a <code>Box</code>, the resolution may be specified as an <code>int</code> to be equal along all axes.</dd>
<dt><strong><code>**resolution_</code></strong></dt>
<dd>Spatial dimensions as keyword arguments. Typically either <code>resolution</code> or <code>spatial_dims</code> are specified.</dd>
<dt><strong><code>convert</code></strong></dt>
<dd>Whether to convert <code>values</code> to the default backend.</dd>
</dl></div>
</dd>
<dt id="phi.field.PointCloud"><code class="name flex">
<span>def <span class="ident">PointCloud</span></span>(<span>elements: Union[phiml.math._tensors.Tensor, phi.geom._geom.Geometry], values: Any = 1.0, extrapolation: Union[phiml.math.extrapolation.Extrapolation, float] = 0.0, bounds: phi.geom._box.Box = None) ‑> phi.field._field.Field</span>
</code></dt>
<dd>
<div class="desc"><p>A <code><a title="phi.field.PointCloud" href="#phi.field.PointCloud">PointCloud()</a></code> comprises:</p>
<ul>
<li><code>elements</code>: a <code>Geometry</code> representing all points or volumes</li>
<li><code>values</code>: a <code>Tensor</code> representing the values corresponding to <code>elements</code></li>
<li><code>extrapolation</code>: an <code>Extrapolation</code> defining the field value outside of <code>values</code></li>
</ul>
<p>The points / elements of the <code><a title="phi.field.PointCloud" href="#phi.field.PointCloud">PointCloud()</a></code> are listed along <em>instance</em> or <em>spatial</em> dimensions of <code>elements</code>.
These dimensions are automatically added to <code>values</code> if not already present.</p>
<p>When sampling or resampling a <code><a title="phi.field.PointCloud" href="#phi.field.PointCloud">PointCloud()</a></code>, the following keyword arguments can be specified.</p>
<ul>
<li><code>soft</code>: default=False.
If <code>True</code>, interpolates smoothly from 1 to 0 between the inside and outside of elements.
If <code>False</code>, only the center position of the new representation elements is checked against the point cloud elements.</li>
<li><code>scatter</code>: default=False.
If <code>True</code>, scattering will be used to sample the point cloud onto grids. Then, each element of the point cloud can only affect a single cell. This is only recommended when the points are much smaller than the cells.</li>
<li><code>outside_handling</code>: default='discard'. One of <code>'discard'</code>, <code>'clamp'</code>, <code>'undefined'</code>.</li>
<li><code>balance</code>: default=0.5. Only used when <code>soft=True</code>.
See the description in <code><a title="phi.geom.Geometry.approximate_fraction_inside" href="../geom/index.html#phi.geom.Geometry.approximate_fraction_inside">Geometry.approximate_fraction_inside()</a></code>.</li>
</ul>
<p>See the <code><a title="phi.field" href="#phi.field">phi.field</a></code> module documentation at <a href="https://tum-pbs.github.io/PhiFlow/Fields.html">https://tum-pbs.github.io/PhiFlow/Fields.html</a></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>elements</code></strong></dt>
<dd><code>Tensor</code> or <code>Geometry</code> object specifying the sample points and sizes</dd>
<dt><strong><code>values</code></strong></dt>
<dd>values corresponding to elements</dd>
<dt><strong><code>extrapolation</code></strong></dt>
<dd>values outside elements</dd>
<dt><strong><code>bounds</code></strong></dt>
<dd>Deprecated. Has no use since 2.5.</dd>
</dl></div>
</dd>
<dt id="phi.field.StaggeredGrid"><code class="name flex">
<span>def <span class="ident">StaggeredGrid</span></span>(<span>values: Any = 0.0, boundary: float = 0, bounds: phi.geom._box.Box = None, resolution: phiml.math._shape.Shape = None, extrapolation: float = None, convert=True, **resolution_: int) ‑> phi.field._field.Field</span>
</code></dt>
<dd>
<div class="desc"><p>N-dimensional grid whose vector components are sampled at the respective face centers.
A staggered grid is defined through its values tensor, its bounds describing the physical size, and its extrapolation.</p>
<p>Staggered grids support batch and spatial dimensions but only one channel dimension for the staggered vector components.</p>
<p>See Also:
<code><a title="phi.field.CenteredGrid" href="#phi.field.CenteredGrid">CenteredGrid()</a></code>,
<code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code>,
<code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code>,
<code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code>,
module documentation at <a href="https://tum-pbs.github.io/PhiFlow/Fields.html">https://tum-pbs.github.io/PhiFlow/Fields.html</a></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>values</code></strong></dt>
<dd>
<p>Values to use for the grid.
Has to be one of the following:</p>
<ul>
<li><code><a title="phi.geom.Geometry" href="../geom/index.html#phi.geom.Geometry">Geometry</a></code>: sets inside values to 1, outside to 0</li>
<li><code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code>: resamples the Field to the staggered sample points</li>
<li><code>Number</code>: uses the value for all sample points</li>
<li><code>tuple</code> or <code>list</code>: interprets the sequence as vector, used for all sample points</li>
<li><code>phi.math.Tensor</code> with staggered shape: uses tensor values as grid values.
Must contain a <code>vector</code> dimension with each slice consisting of one more element along the dimension they describe.
Use <code>phi.math.stack()</code> to manually create this non-uniform tensor.</li>
<li>Function <code>values(x)</code> where <code>x</code> is a <code>phi.math.Tensor</code> representing the physical location.
The spatial dimensions of the grid will be passed as batch dimensions to the function.</li>
</ul>
</dd>
<dt><strong><code>boundary</code></strong></dt>
<dd>The grid extrapolation determines the value outside the <code>values</code> tensor.
Allowed types: <code>float</code>, <code>phi.math.Tensor</code>, <code>phi.math.extrapolation.Extrapolation</code>.</dd>
<dt><strong><code>bounds</code></strong></dt>
<dd>Physical size and location of the grid as <code><a title="phi.geom.Box" href="../geom/index.html#phi.geom.Box">Box</a></code>.
If the resolution is determined through <code>resolution</code> of <code>values</code>, a <code>float</code> can be passed for <code>bounds</code> to create a unit box.</dd>
<dt><strong><code>resolution</code></strong></dt>
<dd>Grid resolution as purely spatial <code>phi.math.Shape</code>.
If <code>bounds</code> is given as a <code>Box</code>, the resolution may be specified as an <code>int</code> to be equal along all axes.</dd>
<dt><strong><code>convert</code></strong></dt>
<dd>Whether to convert <code>values</code> to the default backend.</dd>
<dt><strong><code>**resolution_</code></strong></dt>
<dd>Spatial dimensions as keyword arguments. Typically either <code>resolution</code> or <code>spatial_dims</code> are specified.</dd>
</dl></div>
</dd>
<dt id="phi.field.abs"><code class="name flex">
<span>def <span class="ident">abs</span></span>(<span>x: ~TensorOrTree) ‑> ~TensorOrTree</span>
</code></dt>
<dd>
<div class="desc"><p>Computes <em>||x||<sub>1</sub></em>.
Complex <code>x</code> result in matching precision float values.</p>
<p><em>Note</em>: The gradient of this operation is undefined for <em>x=0</em>.
TensorFlow and PyTorch return 0 while Jax returns 1.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong></dt>
<dd><code>Tensor</code> or <code>phiml.math.magic.PhiTreeNode</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Absolute value of <code>x</code> of same type as <code>x</code>.</p></div>
</dd>
<dt id="phi.field.as_boundary"><code class="name flex">
<span>def <span class="ident">as_boundary</span></span>(<span>obj: Union[phiml.math.extrapolation.Extrapolation, phiml.math._tensors.Tensor, float, phi.field._field.Field, ForwardRef(None)]) ‑> phiml.math.extrapolation.Extrapolation</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an <code>Extrapolation</code> representing <code>obj</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>obj</code></strong></dt>
<dd>
<p>One of</p>
<ul>
<li><code>float</code> or <code>Tensor</code>: Extrapolate with a constant value</li>
<li><code>Extrapolation</code>: Use as-is.</li>
<li><code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code>: Sample values from <code>obj</code>, embedding another field inside <code>obj</code>.</li>
</ul>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>Extrapolation</code></p></div>
</dd>
<dt id="phi.field.assert_close"><code class="name flex">
<span>def <span class="ident">assert_close</span></span>(<span>*fields: phi.field._field.Field, rel_tolerance: float = 1e-05, abs_tolerance: float = 0, msg: str = '', verbose: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Raises an AssertionError if the <code>values</code> of the given fields are not close. See <code>phi.math.assert_close()</code>.</p></div>
</dd>
<dt id="phi.field.bake_extrapolation"><code class="name flex">
<span>def <span class="ident">bake_extrapolation</span></span>(<span>grid: phi.field._field.Field) ‑> phi.field._field.Field</span>
</code></dt>
<dd>
<div class="desc"><p>Pads <code>grid</code> with its current extrapolation.
For <code><a title="phi.field.StaggeredGrid" href="#phi.field.StaggeredGrid">StaggeredGrid()</a></code>s, the resulting grid will have a consistent shape, independent of the original extrapolation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>grid</code></strong></dt>
<dd><code><a title="phi.field.CenteredGrid" href="#phi.field.CenteredGrid">CenteredGrid()</a></code> or <code><a title="phi.field.StaggeredGrid" href="#phi.field.StaggeredGrid">StaggeredGrid()</a></code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Padded grid with extrapolation <code>phi.math.extrapolation.NONE</code>.</p></div>
</dd>
<dt id="phi.field.cast"><code class="name flex">
<span>def <span class="ident">cast</span></span>(<span>x: ~MagicType, dtype: Union[phiml.backend._dtype.DType, type]) ‑> ~OtherMagicType</span>
</code></dt>
<dd>
<div class="desc"><p>Casts <code>x</code> to a different data type.</p>
<p>Implementations:</p>
<ul>
<li>NumPy: <a href="numpy.ndarray.astype"><code>x.astype()</code></a></li>
<li>PyTorch: <a href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor.to"><code>x.to()</code></a></li>
<li>TensorFlow: <a href="https://www.tensorflow.org/api_docs/python/tf/cast"><code>tf.cast</code></a></li>
<li>Jax: <a href="https://jax.readthedocs.io/en/latest/_autosummary/jax.numpy.array.html"><code>jax.numpy.array</code></a></li>
</ul>
<p>See Also:
<code><a title="phi.field.to_float" href="#phi.field.to_float">to_float()</a></code>, <code><a title="phi.field.to_int32" href="#phi.field.to_int32">to_int32()</a></code>, <code><a title="phi.field.to_int64" href="#phi.field.to_int64">to_int64()</a></code>, <code>to_complex</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong></dt>
<dd><code>Tensor</code></dd>
<dt><strong><code>dtype</code></strong></dt>
<dd>New data type as <code>phiml.math.DType</code>, e.g. <code>DType(int, 16)</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>Tensor</code> with data type <code>dtype</code></p></div>
</dd>
<dt id="phi.field.ceil"><code class="name flex">
<span>def <span class="ident">ceil</span></span>(<span>x: ~TensorOrTree) ‑> ~TensorOrTree</span>
</code></dt>
<dd>
<div class="desc"><p>Computes <em>⌈x⌉</em> of the <code>Tensor</code> or <code>phiml.math.magic.PhiTreeNode</code> <code>x</code>.</p></div>
</dd>
<dt id="phi.field.center_of_mass"><code class="name flex">
<span>def <span class="ident">center_of_mass</span></span>(<span>density: phi.field._field.Field)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the center of mass of a density field.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>density</code></strong></dt>
<dd>Scalar <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code></dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>Tensor</code> holding only batch dimensions.</p></div>
</dd>
<dt id="phi.field.concat"><code class="name flex">
<span>def <span class="ident">concat</span></span>(<span>fields: Sequence[phi.field._field.Field], dim: str) ‑> phi.field._field.Field</span>
</code></dt>
<dd>
<div class="desc"><p>Concatenates the given <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code>s along <code>dim</code>.</p>
<p>See Also:
<code><a title="phi.field.stack" href="#phi.field.stack">stack()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>fields</code></strong></dt>
<dd>List of matching <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> instances.</dd>
<dt><strong><code>dim</code></strong></dt>
<dd>Concatenation dimension as <code>Shape</code>. Size is ignored.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> matching concatenated fields.</p></div>
</dd>
<dt id="phi.field.convert"><code class="name flex">
<span>def <span class="ident">convert</span></span>(<span>x, backend: phiml.backend._backend.Backend = None, use_dlpack=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert the native representation of a <code>Tensor</code> or <code>phiml.math.magic.PhiTreeNode</code> to the native format of <code>backend</code>.</p>
<p><em>Warning</em>: This operation breaks the automatic differentiation chain.</p>
<p>See Also:
<code>phiml.math.backend.convert()</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong></dt>
<dd><code>Tensor</code> to convert. If <code>x</code> is a <code>phiml.math.magic.PhiTreeNode</code>, its variable attributes are converted.</dd>
<dt><strong><code>backend</code></strong></dt>
<dd>Target backend. If <code>None</code>, uses the current default backend, see <code>phiml.math.backend.default_backend()</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>Tensor</code> with native representation belonging to <code>backend</code>.</p></div>
</dd>
<dt id="phi.field.cos"><code class="name flex">
<span>def <span class="ident">cos</span></span>(<span>x: ~TensorOrTree) ‑> ~TensorOrTree</span>
</code></dt>
<dd>
<div class="desc"><p>Computes <em>cos(x)</em> of the <code>Tensor</code> or <code>phiml.math.magic.PhiTreeNode</code> <code>x</code>.</p></div>
</dd>
<dt id="phi.field.curl"><code class="name flex">
<span>def <span class="ident">curl</span></span>(<span>field: phi.field._field.Field, at='corner')</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the finite-difference curl of the give 2D <code><a title="phi.field.StaggeredGrid" href="#phi.field.StaggeredGrid">StaggeredGrid()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>field</code></strong></dt>
<dd><code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code></dd>
<dt><strong><code>at</code></strong></dt>
<dd>Either <code>center</code> or <code>face</code>.</dd>
</dl></div>
</dd>
<dt id="phi.field.divergence"><code class="name flex">
<span>def <span class="ident">divergence</span></span>(<span>field: phi.field._field.Field, order=2, implicit: phiml.math._optimize.Solve = None, upwind: phi.field._field.Field = None, implicitness: int = None) ‑> <function <a title="phi.field.CenteredGrid" href="#phi.field.CenteredGrid">CenteredGrid()</a> at 0x7fe5ed35ec00></span>
</code></dt>
<dd>
<div class="desc"><p>Computes the divergence of a grid using finite differences.</p>
<p>This function can operate in two modes depending on the type of <code>field</code>:</p>
<ul>
<li><code><a title="phi.field.CenteredGrid" href="#phi.field.CenteredGrid">CenteredGrid()</a></code> approximates the divergence at cell centers using central differences</li>
<li><code><a title="phi.field.StaggeredGrid" href="#phi.field.StaggeredGrid">StaggeredGrid()</a></code> exactly computes the divergence at cell centers</li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>field</code></strong></dt>
<dd>vector field as <code><a title="phi.field.CenteredGrid" href="#phi.field.CenteredGrid">CenteredGrid()</a></code> or <code><a title="phi.field.StaggeredGrid" href="#phi.field.StaggeredGrid">StaggeredGrid()</a></code></dd>
<dt><strong><code>order</code></strong></dt>
<dd>Spatial order of accuracy.
Higher orders entail larger stencils and more computation time but result in more accurate results assuming a large enough resolution.
Supported: 2 explicit, 4 explicit, 6 implicit.</dd>
<dt><strong><code>implicit</code></strong></dt>
<dd>When a <code>Solve</code> object is passed, performs an implicit operation with the specified solver and tolerances.
Otherwise, an explicit stencil is used.</dd>
<dt><strong><code>implicitness</code></strong></dt>
<dd>specifies the size of the implicit stencil in case an implicit treatment is used</dd>
<dt><strong><code>upwind</code></strong></dt>
<dd>For unstructured meshes only. Whether to use upwind interpolation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Divergence field as <code><a title="phi.field.CenteredGrid" href="#phi.field.CenteredGrid">CenteredGrid()</a></code></p></div>
</dd>
<dt id="phi.field.downsample2x"><code class="name flex">
<span>def <span class="ident">downsample2x</span></span>(<span>grid: phi.field._field.Field) ‑> phi.field._field.Field</span>
</code></dt>
<dd>
<div class="desc"><p>Reduces the number of sample points by a factor of 2 in each spatial dimension.
The new values are determined via linear interpolation.</p>
<p>See Also:
<code><a title="phi.field.upsample2x" href="#phi.field.upsample2x">upsample2x()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>grid</code></strong></dt>
<dd><code><a title="phi.field.CenteredGrid" href="#phi.field.CenteredGrid">CenteredGrid()</a></code> or <code><a title="phi.field.StaggeredGrid" href="#phi.field.StaggeredGrid">StaggeredGrid()</a></code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> of same type as <code>grid</code>.</p></div>
</dd>
<dt id="phi.field.exp"><code class="name flex">
<span>def <span class="ident">exp</span></span>(<span>x: ~TensorOrTree) ‑> ~TensorOrTree</span>
</code></dt>
<dd>
<div class="desc"><p>Computes <em>exp(x)</em> of the <code>Tensor</code> or <code>phiml.math.magic.PhiTreeNode</code> <code>x</code>.</p></div>
</dd>
<dt id="phi.field.finite_fill"><code class="name flex">
<span>def <span class="ident">finite_fill</span></span>(<span>grid: phi.field._field.Field, distance=1, diagonal=True) ‑> phi.field._field.Field</span>
</code></dt>
<dd>
<div class="desc"><p>Extrapolates values of <code>grid</code> which are marked by nonzero values in <code>valid</code> using `phi.math.masked_fill().
If <code>values</code> is a StaggeredGrid, its components get extrapolated independently.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>grid</code></strong></dt>
<dd>Grid holding the values for extrapolation and possible non-finite values to be filled.</dd>
<dt><strong><code>distance</code></strong></dt>
<dd>Number of extrapolation steps, i.e. how far a cell can be from the closest finite value to get filled.</dd>
<dt><strong><code>diagonal</code></strong></dt>
<dd>Whether to extrapolate values to their diagonal neighbors per step.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>grid</code></dt>
<dd>Grid with extrapolated values.</dd>
<dt><code>valid</code></dt>
<dd>binary Grid marking all valid values after extrapolation.</dd>
</dl></div>
</dd>
<dt id="phi.field.floor"><code class="name flex">
<span>def <span class="ident">floor</span></span>(<span>x: ~TensorOrTree) ‑> ~TensorOrTree</span>
</code></dt>
<dd>
<div class="desc"><p>Computes <em>⌊x⌋</em> of the <code>Tensor</code> or <code>phiml.math.magic.PhiTreeNode</code> <code>x</code>.</p></div>
</dd>
<dt id="phi.field.fourier_laplace"><code class="name flex">
<span>def <span class="ident">fourier_laplace</span></span>(<span>grid: phi.field._field.Field, times=1) ‑> phi.field._field.Field</span>
</code></dt>
<dd>
<div class="desc"><p>See <code>phi.math.fourier_laplace()</code></p></div>
</dd>
<dt id="phi.field.fourier_poisson"><code class="name flex">
<span>def <span class="ident">fourier_poisson</span></span>(<span>grid: phi.field._field.Field, times=1) ‑> phi.field._field.Field</span>
</code></dt>
<dd>
<div class="desc"><p>See <code>phi.math.fourier_poisson()</code></p></div>
</dd>
<dt id="phi.field.frequency_loss"><code class="name flex">
<span>def <span class="ident">frequency_loss</span></span>(<span>x, frequency_falloff: float = 100, threshold=1e-05, ignore_mean=False, n=2) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Penalizes the squared <code>values</code> in frequency (Fourier) space.
Lower frequencies are weighted more strongly then higher frequencies, depending on <code>frequency_falloff</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong></dt>
<dd><code>Tensor</code> or <code>phiml.math.magic.PhiTreeNode</code> Values to penalize, typically <code>actual - target</code>.</dd>
<dt><strong><code>frequency_falloff</code></strong></dt>
<dd>Large values put more emphasis on lower frequencies, 1.0 weights all frequencies equally.
<em>Note</em>: The total loss is not normalized. Varying the value will result in losses of different magnitudes.</dd>
<dt><strong><code>threshold</code></strong></dt>
<dd>Frequency amplitudes below this value are ignored.
Setting this to zero may cause infinities or NaN values during backpropagation.</dd>
<dt><strong><code>ignore_mean</code></strong></dt>
<dd>If <code>True</code>, does not penalize the mean value (frequency=0 component).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Scalar loss value</p></div>
</dd>
<dt id="phi.field.functional_gradient"><code class="name flex">
<span>def <span class="ident">functional_gradient</span></span>(<span>f: Callable, wrt: str = None, get_output=True) ‑> Callable</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a function which computes the gradient of <code>f</code>.</p>
<p>Example:</p>
<pre><code class="language-python">def loss_function(x, y):
    prediction = f(x)
    loss = math.l2_loss(prediction - y)
    return loss, prediction

dx = gradient(loss_function, 'x', get_output=False)(x, y)

(loss, prediction), (dx, dy) = gradient(loss_function,
                                        'x,y', get_output=True)(x, y)
</code></pre>
<p>Functional gradients are implemented for the following backends:</p>
<ul>
<li>PyTorch: <a href="https://pytorch.org/docs/stable/autograd.html#torch.autograd.grad"><code>torch.autograd.grad</code></a> / <a href="https://pytorch.org/docs/stable/autograd.html#torch.autograd.backward"><code>torch.autograd.backward</code></a></li>
<li>TensorFlow: <a href="https://www.tensorflow.org/api_docs/python/tf/GradientTape"><code>tf.GradientTape</code></a></li>
<li>Jax: <a href="https://jax.readthedocs.io/en/latest/jax.html#jax.grad"><code>jax.grad</code></a></li>
</ul>
<p>When the gradient function is invoked, <code>f</code> is called with tensors that track the gradient.
For PyTorch, <code>arg.requires_grad = True</code> for all positional arguments of <code>f</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>f</code></strong></dt>
<dd>Function to be differentiated.
<code>f</code> must return a floating point <code>Tensor</code> with rank zero.
It can return additional tensors which are treated as auxiliary data and will be returned by the gradient function if <code>return_values=True</code>.
All arguments for which the gradient is computed must be of dtype float or complex.</dd>
<dt><strong><code>get_output</code></strong></dt>
<dd>Whether the gradient function should also return the return values of <code>f</code>.</dd>
<dt><strong><code>wrt</code></strong></dt>
<dd>Comma-separated parameter names of <code>f</code> with respect to which the gradient should be computed.
If not specified, the gradient will be computed w.r.t. the first positional argument (highly discouraged).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Function with the same arguments as <code>f</code> that returns the value of <code>f</code>, auxiliary data and gradient of <code>f</code> if <code>get_output=True</code>, else just the gradient of <code>f</code>.</p></div>
</dd>
<dt id="phi.field.gradient"><code class="name flex">
<span>def <span class="ident">gradient</span></span>(<span>f: Callable, wrt: str = None, get_output=True) ‑> Callable</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a function which computes the gradient of <code>f</code>.</p>
<p>Example:</p>
<pre><code class="language-python">def loss_function(x, y):
    prediction = f(x)
    loss = math.l2_loss(prediction - y)
    return loss, prediction

dx = gradient(loss_function, 'x', get_output=False)(x, y)

(loss, prediction), (dx, dy) = gradient(loss_function,
                                        'x,y', get_output=True)(x, y)
</code></pre>
<p>Functional gradients are implemented for the following backends:</p>
<ul>
<li>PyTorch: <a href="https://pytorch.org/docs/stable/autograd.html#torch.autograd.grad"><code>torch.autograd.grad</code></a> / <a href="https://pytorch.org/docs/stable/autograd.html#torch.autograd.backward"><code>torch.autograd.backward</code></a></li>
<li>TensorFlow: <a href="https://www.tensorflow.org/api_docs/python/tf/GradientTape"><code>tf.GradientTape</code></a></li>
<li>Jax: <a href="https://jax.readthedocs.io/en/latest/jax.html#jax.grad"><code>jax.grad</code></a></li>
</ul>
<p>When the gradient function is invoked, <code>f</code> is called with tensors that track the gradient.
For PyTorch, <code>arg.requires_grad = True</code> for all positional arguments of <code>f</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>f</code></strong></dt>
<dd>Function to be differentiated.
<code>f</code> must return a floating point <code>Tensor</code> with rank zero.
It can return additional tensors which are treated as auxiliary data and will be returned by the gradient function if <code>return_values=True</code>.
All arguments for which the gradient is computed must be of dtype float or complex.</dd>
<dt><strong><code>get_output</code></strong></dt>
<dd>Whether the gradient function should also return the return values of <code>f</code>.</dd>
<dt><strong><code>wrt</code></strong></dt>
<dd>Comma-separated parameter names of <code>f</code> with respect to which the gradient should be computed.
If not specified, the gradient will be computed w.r.t. the first positional argument (highly discouraged).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Function with the same arguments as <code>f</code> that returns the value of <code>f</code>, auxiliary data and gradient of <code>f</code> if <code>get_output=True</code>, else just the gradient of <code>f</code>.</p></div>
</dd>
<dt id="phi.field.imag"><code class="name flex">
<span>def <span class="ident">imag</span></span>(<span>x: ~TensorOrTree) ‑> ~TensorOrTree</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the imaginary part of <code>x</code>.
If <code>x</code> does not store complex numbers, returns a zero tensor with the same shape and dtype as this tensor.</p>
<p>See Also:
<code><a title="phi.field.real" href="#phi.field.real">real()</a></code>, <code>conjugate()</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong></dt>
<dd><code>Tensor</code> or <code>phiml.math.magic.PhiTreeNode</code> or native tensor.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Imaginary component of <code>x</code> if <code>x</code> is complex, zeros otherwise.</p></div>
</dd>
<dt id="phi.field.integrate"><code class="name flex">
<span>def <span class="ident">integrate</span></span>(<span>field: phi.field._field.Field, region: phi.geom._geom.Geometry, **kwargs) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Computes <em>∫<sub>R</sub> f(x) dx<sup>d</sup></em> , where <em>f</em> denotes the <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code>, <em>R</em> the <code>region</code> and <em>d</em> the number of spatial dimensions (<code>d=field.shape.spatial_rank</code>).
Depending on the <code><a title="phi.field.sample" href="#phi.field.sample">sample()</a></code> implementation for <code>field</code>, the integral may be a rough approximation.</p>
<p>This method is currently only implemented for <code><a title="phi.field.CenteredGrid" href="#phi.field.CenteredGrid">CenteredGrid()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>field</code></strong></dt>
<dd><code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> to integrate.</dd>
<dt><strong><code>region</code></strong></dt>
<dd>Region to integrate over.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Specify numerical scheme.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Integral as <code>phi.Tensor</code></p></div>
</dd>
<dt id="phi.field.is_finite"><code class="name flex">
<span>def <span class="ident">is_finite</span></span>(<span>x: ~TensorOrTree) ‑> ~TensorOrTree</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a <code>Tensor</code> or <code>phiml.math.magic.PhiTreeNode</code> matching <code>x</code> with values <code>True</code> where <code>x</code> has a finite value and <code>False</code> otherwise.</p></div>
</dd>
<dt id="phi.field.isfinite"><code class="name flex">
<span>def <span class="ident">isfinite</span></span>(<span>x: ~TensorOrTree) ‑> ~TensorOrTree</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a <code>Tensor</code> or <code>phiml.math.magic.PhiTreeNode</code> matching <code>x</code> with values <code>True</code> where <code>x</code> has a finite value and <code>False</code> otherwise.</p></div>
</dd>
<dt id="phi.field.jacobian"><code class="name flex">
<span>def <span class="ident">jacobian</span></span>(<span>f: Callable, wrt: str = None, get_output=True) ‑> Callable</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a function which computes the Jacobian matrix of <code>f</code>.
For scalar functions, consider using <code><a title="phi.field.gradient" href="#phi.field.gradient">gradient()</a></code> instead.</p>
<p>Example:</p>
<pre><code class="language-python">def f(x, y):
    prediction = f(x)
    loss = math.l2_loss(prediction - y)
    return loss, prediction

dx = jacobian(loss_function, wrt='x', get_output=False)(x, y)

(loss, prediction), (dx, dy) = jacobian(loss_function,
                                    wrt='x,y', get_output=True)(x, y)
</code></pre>
<p>Functional gradients are implemented for the following backends:</p>
<ul>
<li>PyTorch: <a href="https://pytorch.org/docs/stable/autograd.html#torch.autograd.grad"><code>torch.autograd.grad</code></a> / <a href="https://pytorch.org/docs/stable/autograd.html#torch.autograd.backward"><code>torch.autograd.backward</code></a></li>
<li>TensorFlow: <a href="https://www.tensorflow.org/api_docs/python/tf/GradientTape"><code>tf.GradientTape</code></a></li>
<li>Jax: <a href="https://jax.readthedocs.io/en/latest/jax.html#jax.grad"><code>jax.grad</code></a></li>
</ul>
<p>When the gradient function is invoked, <code>f</code> is called with tensors that track the gradient.
For PyTorch, <code>arg.requires_grad = True</code> for all positional arguments of <code>f</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>f</code></strong></dt>
<dd>Function to be differentiated.
<code>f</code> must return a floating point <code>Tensor</code> with rank zero.
It can return additional tensors which are treated as auxiliary data and will be returned by the gradient function if <code>return_values=True</code>.
All arguments for which the gradient is computed must be of dtype float or complex.</dd>
<dt><strong><code>get_output</code></strong></dt>
<dd>Whether the gradient function should also return the return values of <code>f</code>.</dd>
<dt><strong><code>wrt</code></strong></dt>
<dd>Comma-separated parameter names of <code>f</code> with respect to which the gradient should be computed.
If not specified, the gradient will be computed w.r.t. the first positional argument (highly discouraged).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Function with the same arguments as <code>f</code> that returns the value of <code>f</code>, auxiliary data and Jacobian of <code>f</code> if <code>get_output=True</code>, else just the Jacobian of <code>f</code>.</p></div>
</dd>
<dt id="phi.field.jit_compile"><code class="name flex">
<span>def <span class="ident">jit_compile</span></span>(<span>f: Callable = None, auxiliary_args: str = '', forget_traces: bool = None) ‑> Callable</span>
</code></dt>
<dd>
<div class="desc"><p>Compiles a graph based on the function <code>f</code>.
The graph compilation is performed just-in-time (jit), e.g. when the returned function is called for the first time.</p>
<p>The traced function will compute the same result as <code>f</code> but may run much faster.
Some checks may be disabled in the compiled function.</p>
<p>Can be used as a decorator:</p>
<pre><code class="language-python">@math.jit_compile
def my_function(x: math.Tensor) -&gt; math.Tensor:
</code></pre>
<p>Invoking the returned function may invoke re-tracing / re-compiling <code>f</code> after the first call if either</p>
<ul>
<li>it is called with a different number of arguments,</li>
<li>the tensor arguments have different dimension names or types (the dimension order also counts),</li>
<li>any <code>Tensor</code> arguments require a different backend than previous invocations,</li>
<li><code>phiml.math.magic.PhiTreeNode</code> positional arguments do not match in non-variable properties.</li>
</ul>
<p>Compilation is implemented for the following backends:</p>
<ul>
<li>PyTorch: <a href="https://pytorch.org/docs/stable/jit.html"><code>torch.jit.trace</code></a></li>
<li>TensorFlow: <a href="https://www.tensorflow.org/guide/function"><code>tf.function</code></a></li>
<li>Jax: <a href="https://jax.readthedocs.io/en/latest/notebooks/quickstart.html#using-jit-to-speed-up-functions"><code>jax.jit</code></a></li>
</ul>
<p>Jit-compilations cannot be nested, i.e. you cannot call <code><a title="phi.field.jit_compile" href="#phi.field.jit_compile">jit_compile()</a></code> while another function is being compiled.
An exception to this is <code><a title="phi.field.jit_compile_linear" href="#phi.field.jit_compile_linear">jit_compile_linear()</a></code> which can be called from within a jit-compiled function.</p>
<p>See Also:
<code><a title="phi.field.jit_compile_linear" href="#phi.field.jit_compile_linear">jit_compile_linear()</a></code></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>f</code></strong></dt>
<dd>Function to be traced.
All positional arguments must be of type <code>Tensor</code> or <code>phiml.math.magic.PhiTreeNode</code> returning a single <code>Tensor</code> or <code>phiml.math.magic.PhiTreeNode</code>.</dd>
<dt><strong><code>auxiliary_args</code></strong></dt>
<dd>Comma-separated parameter names of arguments that are not relevant to backpropagation.</dd>
<dt><strong><code>forget_traces</code></strong></dt>
<dd>If <code>True</code>, only remembers the most recent compiled instance of this function.
Upon tracing with new instance (due to changed shapes or auxiliary args), deletes the previous traces.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Function with similar signature and return values as <code>f</code>.</p></div>
</dd>
<dt id="phi.field.jit_compile_linear"><code class="name flex">
<span>def <span class="ident">jit_compile_linear</span></span>(<span>f: Callable[[~X], ~Y] = None, auxiliary_args: str = None, forget_traces: bool = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Compile an optimized representation of the linear function <code>f</code>.
For backends that support sparse tensors, a sparse matrix will be constructed for <code>f</code>.</p>
<p>Can be used as a decorator:</p>
<pre><code class="language-python">@math.jit_compile_linear
def my_linear_function(x: math.Tensor) -&gt; math.Tensor:
</code></pre>
<p>Unlike <code><a title="phi.field.jit_compile" href="#phi.field.jit_compile">jit_compile()</a></code>, <code><a title="phi.field.jit_compile_linear" href="#phi.field.jit_compile_linear">jit_compile_linear()</a></code> can be called during a regular jit compilation.</p>
<p>See Also:
<code><a title="phi.field.jit_compile" href="#phi.field.jit_compile">jit_compile()</a></code></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>f</code></strong></dt>
<dd>Function that is linear in its positional arguments.
All positional arguments must be of type <code>Tensor</code> and <code>f</code> must return a <code>Tensor</code>.</dd>
<dt><strong><code>auxiliary_args</code></strong></dt>
<dd>Which parameters <code>f</code> is not linear in. These arguments are treated as conditioning arguments and will cause re-tracing on change.</dd>
<dt><strong><code>forget_traces</code></strong></dt>
<dd>If <code>True</code>, only remembers the most recent compiled instance of this function.
Upon tracing with new instance (due to changed shapes or auxiliary args), deletes the previous traces.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>LinearFunction</code> with similar signature and return values as <code>f</code>.</p></div>
</dd>
<dt id="phi.field.l1_loss"><code class="name flex">
<span>def <span class="ident">l1_loss</span></span>(<span>x, reduce: Union[str, tuple, list, set, ForwardRef('Shape'), Callable] = &lt;function non_batch&gt;) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Computes <em>∑<sub>i</sub> ||x<sub>i</sub>||<sub>1</sub></em>, summing over all non-batch dimensions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong></dt>
<dd><code>Tensor</code> or <code>phiml.math.magic.PhiTreeNode</code> or 0D or 1D native tensor.
For <code>phiml.math.magic.PhiTreeNode</code> objects, only value the sum over all value attributes is computed.</dd>
<dt><strong><code>reduce</code></strong></dt>
<dd>Dimensions to reduce as <code>DimFilter</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>loss</code></dt>
<dd><code>Tensor</code></dd>
</dl></div>
</dd>
<dt id="phi.field.l2_loss"><code class="name flex">
<span>def <span class="ident">l2_loss</span></span>(<span>x, reduce: Union[str, tuple, list, set, ForwardRef('Shape'), Callable] = &lt;function non_batch&gt;) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Computes <em>∑<sub>i</sub> ||x<sub>i</sub>||<sub>2</sub><sup>2</sup> / 2</em>, summing over all non-batch dimensions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong></dt>
<dd><code>Tensor</code> or <code>phiml.math.magic.PhiTreeNode</code> or 0D or 1D native tensor.
For <code>phiml.math.magic.PhiTreeNode</code> objects, only value the sum over all value attributes is computed.</dd>
<dt><strong><code>reduce</code></strong></dt>
<dd>Dimensions to reduce as <code>DimFilter</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>loss</code></dt>
<dd><code>Tensor</code></dd>
</dl></div>
</dd>
<dt id="phi.field.laplace"><code class="name flex">
<span>def <span class="ident">laplace</span></span>(<span>u: phi.field._field.Field, axes: Union[str, tuple, list, set, ForwardRef('Shape'), Callable] = &lt;function spatial&gt;, gradient: phi.field._field.Field = None, order=2, implicit: phiml.math._optimize.Solve = None, implicitness: int = None, weights: Union[phiml.math._tensors.Tensor, phi.field._field.Field] = None, upwind: phi.field._field.Field = None, correct_skew=True) ‑> phi.field._field.Field</span>
</code></dt>
<dd>
<div class="desc"><p>Spatial Laplace operator for scalar grid.</p>
<p>For grids, uses a finite difference scheme specified by <code>order</code> and <code>implicit</code>.
For unstructured meshes, the scheme is specified via <code>order</code> and <code>upwind</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>u</code></strong></dt>
<dd>n-dimensional grid or mesh.</dd>
<dt><strong><code>axes</code></strong></dt>
<dd>The second derivative along these dimensions is summed over</dd>
<dt><strong><code>weights</code></strong></dt>
<dd>(Optional) Multiply the axis terms by these factors before summation.
Must be a <code>phi.math.Tensor</code> or <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> with a single channel dimension that lists all laplace axes by name.</dd>
<dt><strong><code>gradient</code></strong></dt>
<dd>Only used by FVM at the moment. Approximate gradient of <code>u</code>, e.g. ∇u of the previous time step.
If <code>None</code>, approximates the gradient as <code>(u_neighbor - u_self) / distance</code>.</dd>
<dt><strong><code>order</code></strong></dt>
<dd>Spatial order of accuracy.
Higher orders entail larger stencils and more computation time but result in more accurate results assuming a large enough resolution.
Supported: 2 explicit, 4 explicit, 6 implicit (inherited from <code><a title="phi.field.laplace" href="#phi.field.laplace">laplace()</a></code>).
For FVM, the order is used when interpolating <code>v</code> and <code>prev_v</code> to cell faces if needed.</dd>
<dt><strong><code>implicit</code></strong></dt>
<dd>When a <code>Solve</code> object is passed, performs an implicit operation with the specified solver and tolerances.
Otherwise, an explicit stencil is used.</dd>
<dt><strong><code>implicitness</code></strong></dt>
<dd>specifies the size of the implicit stencil in case an implicit treatment is used</dd>
<dt><strong><code>upwind</code></strong></dt>
<dd>FVM only. Whether to use upwind interpolation.</dd>
<dt><strong><code>correct_skew</code></strong></dt>
<dd>If <code>True</code>, adds a correction term for cell skewness. This requires <code><a title="phi.field.gradient" href="#phi.field.gradient">gradient()</a></code> to be passed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>laplacian field as <code><a title="phi.field.CenteredGrid" href="#phi.field.CenteredGrid">CenteredGrid()</a></code></p></div>
</dd>
<dt id="phi.field.mask"><code class="name flex">
<span>def <span class="ident">mask</span></span>(<span>obj: phi.field._field.Field) ‑> phi.field._field.Field</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> that masks the inside (or non-zero values when <code>obj</code> is a grid) of a physical object.
The mask takes the value 1 inside the object and 0 outside.
For <code><a title="phi.field.CenteredGrid" href="#phi.field.CenteredGrid">CenteredGrid()</a></code> and <code><a title="phi.field.StaggeredGrid" href="#phi.field.StaggeredGrid">StaggeredGrid()</a></code>, the mask labels non-zero non-NaN entries as 1 and all other values as 0</p>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> type or <code><a title="phi.field.PointCloud" href="#phi.field.PointCloud">PointCloud()</a></code></p></div>
</dd>
<dt id="phi.field.maximum"><code class="name flex">
<span>def <span class="ident">maximum</span></span>(<span>f1: phi.field._field.Field, f2: phi.field._field.Field)</span>
</code></dt>
<dd>
<div class="desc"><p>Element-wise maximum.
One of the given fields needs to be an instance of <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> and the the result will be sampled at the corresponding points.
If both are <code>Fields</code> but have different points, <code>f1</code> takes priority.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>f1</code></strong></dt>
<dd><code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> or <code>Geometry</code> or constant.</dd>
<dt><strong><code>f2</code></strong></dt>
<dd><code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> or <code>Geometry</code> or constant.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code></p></div>
</dd>
<dt id="phi.field.mean"><code class="name flex">
<span>def <span class="ident">mean</span></span>(<span>field: phi.field._field.Field, dim=&lt;function &lt;lambda&gt;&gt;) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the mean value by reducing all spatial / instance dimensions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>field</code></strong></dt>
<dd><code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code></dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>phi.Tensor</code></p></div>
</dd>
<dt id="phi.field.minimize"><code class="name flex">
<span>def <span class="ident">minimize</span></span>(<span>f: Callable[[~X], ~Y], solve: phiml.math._optimize.Solve[~X, ~Y]) ‑> ~X</span>
</code></dt>
<dd>
<div class="desc"><p>Finds a minimum of the scalar function <em>f(x)</em>.
The <code>method</code> argument of <code>solve</code> determines which optimizer is used.
All optimizers supported by <code>scipy.optimize.minimize</code> are supported,
see <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html</a> .
Additionally a gradient descent solver with adaptive step size can be used with <code>method='GD'</code>.</p>
<p><code>math.minimize()</code> is limited to backends that support <code><a title="phi.field.jacobian" href="#phi.field.jacobian">jacobian()</a></code>, i.e. PyTorch, TensorFlow and Jax.</p>
<p>To obtain additional information about the performed solve, use a <code>SolveTape</code>.</p>
<p>See Also:
<code><a title="phi.field.solve_nonlinear" href="#phi.field.solve_nonlinear">solve_nonlinear()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>f</code></strong></dt>
<dd>Function whose output is subject to minimization.
All positional arguments of <code>f</code> are optimized and must be <code>Tensor</code> or <code>phiml.math.magic.PhiTreeNode</code>.
If <code>solve.x0</code> is a <code>tuple</code> or <code>list</code>, it will be passed to <em>f</em> as varargs, <code>f(*x0)</code>.
To minimize a subset of the positional arguments, define a new (lambda) function depending only on those.
The first return value of <code>f</code> must be a scalar float <code>Tensor</code> or <code>phiml.math.magic.PhiTreeNode</code>.</dd>
<dt><strong><code>solve</code></strong></dt>
<dd><code>Solve</code> object to specify method type, parameters and initial guess for <code>x</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>x</code></dt>
<dd>solution, the minimum point <code>x</code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NotConverged</code></dt>
<dd>If the desired accuracy was not be reached within the maximum number of iterations.</dd>
<dt><code>Diverged</code></dt>
<dd>If the optimization failed prematurely.</dd>
</dl></div>
</dd>
<dt id="phi.field.minimum"><code class="name flex">
<span>def <span class="ident">minimum</span></span>(<span>f1: phi.field._field.Field, f2: phi.field._field.Field)</span>
</code></dt>
<dd>
<div class="desc"><p>Element-wise minimum.
One of the given fields needs to be an instance of <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> and the the result will be sampled at the corresponding points.
If both are <code>Fields</code> but have different points, <code>f1</code> takes priority.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>f1</code></strong></dt>
<dd><code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> or <code>Geometry</code> or constant.</dd>
<dt><strong><code>f2</code></strong></dt>
<dd><code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> or <code>Geometry</code> or constant.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code></p></div>
</dd>
<dt id="phi.field.native_call"><code class="name flex">
<span>def <span class="ident">native_call</span></span>(<span>f, *inputs, channels_last=None, channel_dim='vector', extrapolation=None) ‑> Union[phiml.math._tensors.Tensor, phi.field._field.Field]</span>
</code></dt>
<dd>
<div class="desc"><p>Similar to <code>phi.math.native_call()</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>f</code></strong></dt>
<dd>Function to be called on native tensors of <code>inputs.values</code>.
The function output must have the same dimension layout as the inputs and the batch size must be identical.</dd>
<dt><strong><code>*inputs</code></strong></dt>
<dd><code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> or <code>phi.Tensor</code> instances.</dd>
<dt><strong><code>extrapolation</code></strong></dt>
<dd>(Optional) Extrapolation of the output field. If <code>None</code>, uses the extrapolation of the first input field.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> matching the first <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> in <code>inputs</code>.</p></div>
</dd>
<dt id="phi.field.normalize"><code class="name flex">
<span>def <span class="ident">normalize</span></span>(<span>field: phi.field._field.Field, norm: phi.field._field.Field, epsilon=1e-05)</span>
</code></dt>
<dd>
<div class="desc"><p>Multiplies the values of <code>field</code> so that its sum matches the source.</p></div>
</dd>
<dt id="phi.field.pack_dims"><code class="name flex">
<span>def <span class="ident">pack_dims</span></span>(<span>field: phi.field._field.Field, dims: phiml.math._shape.Shape, packed_dim: phiml.math._shape.Shape, pos: int = None) ‑> phi.field._field.Field</span>
</code></dt>
<dd>
<div class="desc"><p>Currently only supports grids and non-spatial dimensions.</p>
<p>See Also:
<code>phi.math.pack_dims()</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>field</code></strong></dt>
<dd><code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code></dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> of same type as <code>field</code>.</p></div>
</dd>
<dt id="phi.field.pad"><code class="name flex">
<span>def <span class="ident">pad</span></span>(<span>grid: phi.field._field.Field, widths: Union[int, tuple, list, dict]) ‑> phi.field._field.Field</span>
</code></dt>
<dd>
<div class="desc"><p>Pads a <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> using its extrapolation.</p>
<p>Unlike <code>phi.math.pad()</code>, this function also affects the <code>bounds</code> of the grid, changing its size and origin depending on <code>widths</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>grid</code></strong></dt>
<dd><code><a title="phi.field.CenteredGrid" href="#phi.field.CenteredGrid">CenteredGrid()</a></code> or <code><a title="phi.field.StaggeredGrid" href="#phi.field.StaggeredGrid">StaggeredGrid()</a></code></dd>
<dt><strong><code>widths</code></strong></dt>
<dd>Either <code>int</code> or <code>(lower, upper)</code> to pad the same number of cells in all spatial dimensions
or <code>dict</code> mapping dimension names to <code>(lower, upper)</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> of the same type as <code>grid</code></p></div>
</dd>
<dt id="phi.field.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>file: Union[str, phiml.math._tensors.Tensor], convert_to_backend=True) ‑> phi.field._field.Field</span>
</code></dt>
<dd>
<div class="desc"><p>Loads a previously saved <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> from disc.</p>
<p>See Also:
<code><a title="phi.field.write" href="#phi.field.write">write()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file</code></strong></dt>
<dd>Single file as <code>str</code> or <code>Tensor</code> of string type.
If <code>file</code> is a tensor, all contained files are loaded an stacked according to the dimensions of <code>file</code>.</dd>
<dt><strong><code>convert_to_backend</code></strong></dt>
<dd>Whether to convert the read data to the data format of the default backend, e.g. TensorFlow tensors.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Loaded <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code>.</p></div>
</dd>
<dt id="phi.field.real"><code class="name flex">
<span>def <span class="ident">real</span></span>(<span>x: ~TensorOrTree) ‑> ~TensorOrTree</span>
</code></dt>
<dd>
<div class="desc"><p>See Also:
<code><a title="phi.field.imag" href="#phi.field.imag">imag()</a></code>, <code>conjugate()</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong></dt>
<dd><code>Tensor</code> or <code>phiml.math.magic.PhiTreeNode</code> or native tensor.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Real component of <code>x</code>.</p></div>
</dd>
<dt id="phi.field.reduce_sample"><code class="name flex">
<span>def <span class="ident">reduce_sample</span></span>(<span>field: Union[phi.field._field.Field, phi.geom._geom.Geometry, phi.field._field.FieldInitializer, Callable], geometry: phi.geom._geom.Geometry, **kwargs) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for <code><a title="phi.field.sample" href="#phi.field.sample">sample()</a></code> with <code>dot_face_normal=field.geometry</code>.</p></div>
</dd>
<dt id="phi.field.resample"><code class="name flex">
<span>def <span class="ident">resample</span></span>(<span>value: Union[phi.field._field.Field, phi.geom._geom.Geometry, phiml.math._tensors.Tensor, float, phi.field._field.FieldInitializer], to: Union[phi.field._field.Field, phi.geom._geom.Geometry], keep_boundary=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Samples a <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code>, <code>Geometry</code> or value at the sample points of the field <code>to</code>.
The result will approximate <code>value</code> on the data structure of <code>to</code>.
Unlike <code><a title="phi.field.sample" href="#phi.field.sample">sample()</a></code>, this method returns a <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> object, not a <code>Tensor</code>.</p>
<h2 id="aliases">Aliases</h2>
<p><code>value.at(to)</code>, (and the deprecated <code>value @ to</code>).</p>
<p>See Also:
<code><a title="phi.field.sample" href="#phi.field.sample">sample()</a></code>, <code><a title="phi.field.reduce_sample" href="#phi.field.reduce_sample">reduce_sample()</a></code>, <code><a title="phi.field.Field.at" href="#phi.field.Field.at">Field.at()</a></code>, <a href="https://tum-pbs.github.io/PhiFlow/Fields.html#resampling-fields">Resampling overview</a>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong></dt>
<dd>Object containing values to resample.
This can be</dd>
<dt><strong><code>to</code></strong></dt>
<dd><code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> (<code><a title="phi.field.CenteredGrid" href="#phi.field.CenteredGrid">CenteredGrid()</a></code>, <code><a title="phi.field.StaggeredGrid" href="#phi.field.StaggeredGrid">StaggeredGrid()</a></code> or <code><a title="phi.field.PointCloud" href="#phi.field.PointCloud">PointCloud()</a></code>) object defining the sample points.
The current values of <code>to</code> are ignored.</dd>
<dt><strong><code>keep_boundary</code></strong></dt>
<dd>Only available if <code>self</code> is a <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code>.
If True, the resampled field will inherit the extrapolation from <code>self</code> instead of <code>representation</code>.
This can result in non-compatible value tensors for staggered grids where the tensor size depends on the extrapolation type.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Sampling arguments, e.g. to specify the numerical scheme.
By default, linear interpolation is used.
Grids also support 6th order implicit sampling at mid-points.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Field object of same type as <code>representation</code></p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; grid = CenteredGrid(x=64, y=32)
&gt;&gt;&gt; field.resample(Noise(), to=grid)
CenteredGrid[(xˢ=64, yˢ=32), size=(x=64, y=32), extrapolation=float64 0.0]
&gt;&gt;&gt; field.resample(1, to=grid)
CenteredGrid[(xˢ=64, yˢ=32), size=(x=64, y=32), extrapolation=float64 0.0]
&gt;&gt;&gt; field.resample(Box(x=1, y=2), to=grid)
CenteredGrid[(xˢ=64, yˢ=32), size=(x=64, y=32), extrapolation=float64 0.0]
&gt;&gt;&gt; field.resample(grid, to=grid) == grid
True
</code></pre></div>
</dd>
<dt id="phi.field.round"><code class="name flex">
<span>def <span class="ident">round</span></span>(<span>x: ~TensorOrTree) ‑> ~TensorOrTree</span>
</code></dt>
<dd>
<div class="desc"><p>Rounds the <code>Tensor</code> or <code>phiml.math.magic.PhiTreeNode</code> <code>x</code> to the closest integer.</p></div>
</dd>
<dt id="phi.field.safe_mul"><code class="name flex">
<span>def <span class="ident">safe_mul</span></span>(<span>x, y)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code>phiml.math.safe_mul()</code></p></div>
</dd>
<dt id="phi.field.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>field: Union[phi.field._field.Field, phi.geom._geom.Geometry, phi.field._field.FieldInitializer, Callable], geometry: phi.geom._geom.Geometry, at: str = 'center', boundary: Union[phiml.math.extrapolation.Extrapolation, phiml.math._tensors.Tensor, numbers.Number] = None, dot_face_normal: Optional[phi.geom._geom.Geometry] = None, **kwargs) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the field value inside the volume of the (batched) <code>geometry</code>.</p>
<p>The field value may be determined by integrating over the volume, sampling the central value or any other way.</p>
<p>The batch dimensions of <code>geometry</code> are matched with this field.
The <code>geometry</code> must not share any channel dimensions with this field.
Spatial dimensions of <code>geometry</code> can be used to sample a grid of geometries.</p>
<p>See Also:
<code><a title="phi.field.Field.at" href="#phi.field.Field.at">Field.at()</a></code>, <a href="https://tum-pbs.github.io/PhiFlow/Fields.html#resampling-fields">Resampling overview</a>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>field</code></strong></dt>
<dd>Source <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> to sample.</dd>
<dt><strong><code>geometry</code></strong></dt>
<dd>Single or batched <code><a title="phi.geom.Geometry" href="../geom/index.html#phi.geom.Geometry">Geometry</a></code> or <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> or location <code>Tensor</code>.
When passing a <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code>, its <code>elements</code> are used as sample points.
When passing a vector-valued <code>Tensor</code>, a <code>Point</code> geometry will be created.</dd>
<dt><strong><code>at</code></strong></dt>
<dd>One of 'center', 'face', 'vertex'</dd>
<dt><strong><code>boundary</code></strong></dt>
<dd>Target extrapolation.</dd>
<dt><strong><code>dot_face_normal</code></strong></dt>
<dd>If not <code>None</code> and , <code>field</code> is a vector field and <code>at=='face'</code>, the dot product between sampled field vectors and the face normals is returned instead.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Sampling arguments, e.g. to specify the numerical scheme.
By default, linear interpolation is used.
Grids also support 6th order implicit sampling at mid-points.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Sampled values as a <code>phi.math.Tensor</code></p></div>
</dd>
<dt id="phi.field.shift"><code class="name flex">
<span>def <span class="ident">shift</span></span>(<span>grid: phi.field._field.Field, offsets: tuple, stack_dim: Optional[phiml.math._shape.Shape] = (shiftᶜ=None), dims=&lt;function spatial&gt;, pad=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Wraps :func:<code>math.shift</code> for CenteredGrid.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>grid</code></strong></dt>
<dd>CenteredGrid: </dd>
<dt><strong><code>offsets</code></strong></dt>
<dd>tuple: </dd>
<dt><strong><code>stack_dim</code></strong></dt>
<dd>(Default value = 'shift')</dd>
</dl></div>
</dd>
<dt id="phi.field.sign"><code class="name flex">
<span>def <span class="ident">sign</span></span>(<span>x: ~TensorOrTree) ‑> ~TensorOrTree</span>
</code></dt>
<dd>
<div class="desc"><p>The sign of positive numbers is 1 and -1 for negative numbers.
The sign of 0 is undefined.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong></dt>
<dd><code>Tensor</code> or <code>phiml.math.magic.PhiTreeNode</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>Tensor</code> or <code>phiml.math.magic.PhiTreeNode</code> matching <code>x</code>.</p></div>
</dd>
<dt id="phi.field.sin"><code class="name flex">
<span>def <span class="ident">sin</span></span>(<span>x: ~TensorOrTree) ‑> ~TensorOrTree</span>
</code></dt>
<dd>
<div class="desc"><p>Computes <em>sin(x)</em> of the <code>Tensor</code> or <code>phiml.math.magic.PhiTreeNode</code> <code>x</code>.</p></div>
</dd>
<dt id="phi.field.solve_linear"><code class="name flex">
<span>def <span class="ident">solve_linear</span></span>(<span>f: Union[Callable[[~X], ~Y], phiml.math._tensors.Tensor], y: ~Y, solve: phiml.math._optimize.Solve[~X, ~Y], *f_args, grad_for_f=False, f_kwargs: dict = None, **f_kwargs_) ‑> ~X</span>
</code></dt>
<dd>
<div class="desc"><p>Solves the system of linear equations <em>f(x) = y</em> and returns <em>x</em>.
This method will use the solver specified in <code>solve</code>.
The following method identifiers are supported by all backends:</p>
<ul>
<li><code>'auto'</code>: Automatically choose a solver</li>
<li><code>'CG'</code>: Conjugate gradient, only for symmetric and positive definite matrices.</li>
<li><code>'CG-adaptive'</code>: Conjugate gradient with adaptive step size, only for symmetric and positive definite matrices.</li>
<li><code>'biCG'</code> or <code>'biCG-stab(0)'</code>: Biconjugate gradient</li>
<li><code>'biCG-stab'</code> or <code>'biCG-stab(1)'</code>: Biconjugate gradient stabilized, first order</li>
<li><code>'biCG-stab(2)'</code>, <code>'biCG-stab(4)'</code>, &hellip;: Biconjugate gradient stabilized, second or higher order</li>
<li><code>'scipy-direct'</code>: SciPy direct solve always run oh the CPU using <code>scipy.sparse.linalg.spsolve</code>.</li>
<li><code>'scipy-CG'</code>, <code>'scipy-GMres'</code>, <code>'scipy-biCG'</code>, <code>'scipy-biCG-stab'</code>, <code>'scipy-CGS'</code>, <code>'scipy-QMR'</code>, <code>'scipy-GCrotMK'</code>: SciPy iterative solvers always run oh the CPU, both in eager execution and JIT mode.</li>
</ul>
<p>For maximum performance, compile <code>f</code> using <code><a title="phi.field.jit_compile_linear" href="#phi.field.jit_compile_linear">jit_compile_linear()</a></code> beforehand.
Then, an optimized representation of <code>f</code> (such as a sparse matrix) will be used to solve the linear system.</p>
<p><strong>Caution:</strong> The matrix construction may potentially be performed each time <code><a title="phi.field.solve_linear" href="#phi.field.solve_linear">solve_linear()</a></code> is called if auxiliary arguments change.
To prevent this, jit-compile the function that makes the call to <code><a title="phi.field.solve_linear" href="#phi.field.solve_linear">solve_linear()</a></code>.</p>
<p>To obtain additional information about the performed solve, perform the solve within a <code>SolveTape</code> context.
The used implementation can be obtained as <code>SolveInfo.method</code>.</p>
<p>The gradient of this operation will perform another linear solve with the parameters specified by <code>Solve.gradient_solve</code>.</p>
<p>See Also:
<code><a title="phi.field.solve_nonlinear" href="#phi.field.solve_nonlinear">solve_nonlinear()</a></code>, <code><a title="phi.field.jit_compile_linear" href="#phi.field.jit_compile_linear">jit_compile_linear()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>f</code></strong></dt>
<dd>
<p>One of the following:</p>
<ul>
<li>Linear function with <code>Tensor</code> or <code>phiml.math.magic.PhiTreeNode</code> first parameter and return value. <code>f</code> can have additional auxiliary arguments and return auxiliary values.</li>
<li>Dense matrix (<code>Tensor</code> with at least one dual dimension)</li>
<li>Sparse matrix (Sparse <code>Tensor</code> with at least one dual dimension)</li>
<li>Native tensor (not yet supported)</li>
</ul>
</dd>
<dt><strong><code>y</code></strong></dt>
<dd>Desired output of <code>f(x)</code> as <code>Tensor</code> or <code>phiml.math.magic.PhiTreeNode</code>.</dd>
<dt><strong><code>solve</code></strong></dt>
<dd><code>Solve</code> object specifying optimization method, parameters and initial guess for <code>x</code>.</dd>
<dt><strong><code>*f_args</code></strong></dt>
<dd>Positional arguments to be passed to <code>f</code> after <code>solve.x0</code>. These arguments will not be solved for.
Supports vararg mode or pass all arguments as a <code>tuple</code>.</dd>
<dt><strong><code>f_kwargs</code></strong></dt>
<dd>Additional keyword arguments to be passed to <code>f</code>.
These arguments are treated as auxiliary arguments and can be of any type.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>x</code></dt>
<dd>solution of the linear system of equations <code>f(x) = y</code> as <code>Tensor</code> or <code>phiml.math.magic.PhiTreeNode</code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NotConverged</code></dt>
<dd>If the desired accuracy was not be reached within the maximum number of iterations.</dd>
<dt><code>Diverged</code></dt>
<dd>If the solve failed prematurely.</dd>
</dl></div>
</dd>
<dt id="phi.field.solve_nonlinear"><code class="name flex">
<span>def <span class="ident">solve_nonlinear</span></span>(<span>f: Callable, y, solve: phiml.math._optimize.Solve) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Solves the non-linear equation <em>f(x) = y</em> by minimizing the norm of the residual.</p>
<p>This method is limited to backends that support <code><a title="phi.field.jacobian" href="#phi.field.jacobian">jacobian()</a></code>, currently PyTorch, TensorFlow and Jax.</p>
<p>To obtain additional information about the performed solve, use a <code>SolveTape</code>.</p>
<p>See Also:
<code><a title="phi.field.minimize" href="#phi.field.minimize">minimize()</a></code>, <code><a title="phi.field.solve_linear" href="#phi.field.solve_linear">solve_linear()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>f</code></strong></dt>
<dd>Function whose output is optimized to match <code>y</code>.
All positional arguments of <code>f</code> are optimized and must be <code>Tensor</code> or <code>phiml.math.magic.PhiTreeNode</code>.
The output of <code>f</code> must match <code>y</code>.</dd>
<dt><strong><code>y</code></strong></dt>
<dd>Desired output of <code>f(x)</code> as <code>Tensor</code> or <code>phiml.math.magic.PhiTreeNode</code>.</dd>
<dt><strong><code>solve</code></strong></dt>
<dd><code>Solve</code> object specifying optimization method, parameters and initial guess for <code>x</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>x</code></dt>
<dd>Solution fulfilling <code>f(x) = y</code> within specified tolerance as <code>Tensor</code> or <code>phiml.math.magic.PhiTreeNode</code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NotConverged</code></dt>
<dd>If the desired accuracy was not be reached within the maximum number of iterations.</dd>
<dt><code>Diverged</code></dt>
<dd>If the solve failed prematurely.</dd>
</dl></div>
</dd>
<dt id="phi.field.spatial_gradient"><code class="name flex">
<span>def <span class="ident">spatial_gradient</span></span>(<span>field: phi.field._field.Field, boundary: phiml.math.extrapolation.Extrapolation = None, at: str = 'center', dims: Union[str, tuple, list, set, ForwardRef('Shape'), Callable] = &lt;function spatial&gt;, stack_dim: Union[phiml.math._shape.Shape, str] = (vectorᶜ=None), order=2, implicit: phiml.math._optimize.Solve = None, implicitness: int = None, scheme=None, upwind: phi.field._field.Field = None, gradient_extrapolation: phiml.math.extrapolation.Extrapolation = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Finite difference spatial_gradient.</p>
<p>This function can operate in two modes:</p>
<ul>
<li><code>type=CenteredGrid</code> approximates the spatial_gradient at cell centers using central differences</li>
<li><code>type=StaggeredGrid</code> computes the spatial_gradient at face centers of neighbouring cells</li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>field</code></strong></dt>
<dd>centered grid of any number of dimensions (scalar field, vector field, tensor field)</dd>
<dt><strong><code>boundary</code></strong></dt>
<dd>Boundary conditions of the gradient field.</dd>
<dt><strong><code>at</code></strong></dt>
<dd>Either <code>'face'</code> or <code>'center'</code></dd>
<dt><strong><code>dims</code></strong></dt>
<dd>Along which dimensions to compute the spatial gradient. Only supported when <code>type==CenteredGrid</code>.</dd>
<dt><strong><code>stack_dim</code></strong></dt>
<dd>Dimension to be added. This dimension lists the spatial_gradient w.r.t. the spatial dimensions.
The <code>field</code> must not have a dimension of the same name.</dd>
<dt><strong><code>order</code></strong></dt>
<dd>Spatial order of accuracy.
Higher orders entail larger stencils and more computation time but result in more accurate results assuming a large enough resolution.
Supported: 2 explicit, 4 explicit, 6 implicit.</dd>
<dt><strong><code>implicit</code></strong></dt>
<dd>When a <code>Solve</code> object is passed, performs an implicit operation with the specified solver and tolerances.
Otherwise, an explicit stencil is used.</dd>
<dt><strong><code>implicitness</code></strong></dt>
<dd>specifies the size of the implicit stencil in case an implicit treatment is used</dd>
<dt><strong><code>gradient_extrapolation</code></strong></dt>
<dd>Alias for <code>boundary</code>.</dd>
<dt><strong><code>scheme</code></strong></dt>
<dd>For unstructured meshes only. Currently only <code>'green-gauss'</code> is supported.</dd>
<dt><strong><code>upwind</code></strong></dt>
<dd>For unstructured meshes only. Whether to use upwind interpolation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>spatial_gradient field of type <code>type</code>.</p></div>
</dd>
<dt id="phi.field.sqrt"><code class="name flex">
<span>def <span class="ident">sqrt</span></span>(<span>x: ~TensorOrTree) ‑> ~TensorOrTree</span>
</code></dt>
<dd>
<div class="desc"><p>Computes <em>sqrt(x)</em> of the <code>Tensor</code> or <code>phiml.math.magic.PhiTreeNode</code> <code>x</code>.</p></div>
</dd>
<dt id="phi.field.stack"><code class="name flex">
<span>def <span class="ident">stack</span></span>(<span>fields: Sequence[phi.field._field.Field], dim: phiml.math._shape.Shape, dim_bounds: phi.geom._box.Box = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Stacks the given <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code>s along <code>dim</code>.</p>
<p>See Also:
<code><a title="phi.field.concat" href="#phi.field.concat">concat()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>fields</code></strong></dt>
<dd>List of matching <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> instances.</dd>
<dt><strong><code>dim</code></strong></dt>
<dd>Stack dimension as <code>Shape</code>. Size is ignored.</dd>
<dt><strong><code>dim_bounds</code></strong></dt>
<dd><code>Box</code> defining the physical size for <code>dim</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> matching stacked fields.</p></div>
</dd>
<dt id="phi.field.stagger"><code class="name flex">
<span>def <span class="ident">stagger</span></span>(<span>field: phi.field._field.Field, face_function: Callable, boundary: float, at='face', dims=&lt;function spatial&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new grid by evaluating <code>face_function</code> given two neighbouring cells.
One layer of missing cells is inferred from the extrapolation.</p>
<p>This method returns a Field of type <code>type</code> which must be either StaggeredGrid or CenteredGrid.
When returning a StaggeredGrid, the new values are sampled at the faces of neighbouring cells.
When returning a CenteredGrid, the new grid has the same resolution as <code>field</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>field</code></strong></dt>
<dd>Grid</dd>
<dt><strong><code>face_function</code></strong></dt>
<dd>function mapping (value1: Tensor, value2: Tensor) -&gt; center_value: Tensor</dd>
<dt><strong><code>boundary</code></strong></dt>
<dd>extrapolation mode of the returned grid. Has no effect on the values.</dd>
<dt><strong><code>at</code></strong></dt>
<dd>Where the result should be sampled, one of 'face', 'center'</dd>
<dt><strong><code>dims</code></strong></dt>
<dd>Which dimensions to stagger. Defaults to all spatial axes.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Grid sampled either at centers or faces depending on <code>at</code>.</p></div>
</dd>
<dt id="phi.field.stop_gradient"><code class="name flex">
<span>def <span class="ident">stop_gradient</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"><p>Disables gradients for the given tensor.
This may switch off the gradients for <code>x</code> itself or create a copy of <code>x</code> with disabled gradients.</p>
<p>Implementations:</p>
<ul>
<li>PyTorch: <a href="https://pytorch.org/docs/stable/autograd.html#torch.Tensor.detach"><code>x.detach()</code></a></li>
<li>TensorFlow: <a href="https://www.tensorflow.org/api_docs/python/tf/stop_gradient"><code>tf.stop_gradient</code></a></li>
<li>Jax: <a href="https://jax.readthedocs.io/en/latest/_autosummary/jax.lax.stop_gradient.html"><code>jax.lax.stop_gradient</code></a></li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong></dt>
<dd><code>Tensor</code> or <code>phiml.math.magic.PhiTreeNode</code> for which gradients should be disabled.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Copy of <code>x</code>.</p></div>
</dd>
<dt id="phi.field.support"><code class="name flex">
<span>def <span class="ident">support</span></span>(<span>field: phi.field._field.Field, list_dim: phiml.math._shape.Shape = (nonzeroⁱ=None)) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the points at which the field values are non-zero.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>field</code></strong></dt>
<dd><code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code></dd>
<dt><strong><code>list_dim</code></strong></dt>
<dd>Dimension to list the non-zero values.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>Tensor</code> with shape <code>(list_dim, vector)</code></p></div>
</dd>
<dt id="phi.field.to_float"><code class="name flex">
<span>def <span class="ident">to_float</span></span>(<span>x: ~TensorOrTree) ‑> ~TensorOrTree</span>
</code></dt>
<dd>
<div class="desc"><p>Converts the given tensor to floating point format with the currently specified precision.</p>
<p>The precision can be set globally using <code>math.set_global_precision()</code> and locally using <code>with math.precision()</code>.</p>
<p>See the documentation at <a href="https://tum-pbs.github.io/PhiML/Data_Types.html">https://tum-pbs.github.io/PhiML/Data_Types.html</a></p>
<p>See Also:
<code><a title="phi.field.cast" href="#phi.field.cast">cast()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong></dt>
<dd><code>Tensor</code> or <code>phiml.math.magic.PhiTreeNode</code> to convert</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>Tensor</code> or <code>phiml.math.magic.PhiTreeNode</code> matching <code>x</code>.</p></div>
</dd>
<dt id="phi.field.to_int32"><code class="name flex">
<span>def <span class="ident">to_int32</span></span>(<span>x: ~TensorOrTree) ‑> ~TensorOrTree</span>
</code></dt>
<dd>
<div class="desc"><p>Converts the <code>Tensor</code> or <code>phiml.math.magic.PhiTreeNode</code> <code>x</code> to 32-bit integer.</p></div>
</dd>
<dt id="phi.field.to_int64"><code class="name flex">
<span>def <span class="ident">to_int64</span></span>(<span>x: ~TensorOrTree) ‑> ~TensorOrTree</span>
</code></dt>
<dd>
<div class="desc"><p>Converts the <code>Tensor</code> or <code>phiml.math.magic.PhiTreeNode</code> <code>x</code> to 64-bit integer.</p></div>
</dd>
<dt id="phi.field.unstack"><code class="name flex">
<span>def <span class="ident">unstack</span></span>(<span>value, dim: Union[str, tuple, list, set, ForwardRef('Shape'), Callable]) ‑> tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Un-stacks a <code>Sliceable</code> along one or multiple dimensions.</p>
<p>If multiple dimensions are given, the order of elements will be according to the dimension order in <code>dim</code>, i.e. elements along the last dimension will be neighbors in the returned <code>tuple</code>.
If no dimension is given or none of the given dimensions exists on <code>value</code>, returns a list containing only <code>value</code>.</p>
<p>See Also:
<code>phiml.math.slice</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong></dt>
<dd><code>phiml.math.magic.Shapable</code>, such as <code>phiml.math.Tensor</code></dd>
<dt><strong><code>dim</code></strong></dt>
<dd>Dimensions as <code>Shape</code> or comma-separated <code>str</code> or dimension type, i.e. <code>channel</code>, <code>spatial</code>, <code>instance</code>, <code>batch</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>tuple</code> of objects matching the type of <code>value</code>.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; unstack(expand(0, spatial(x=5)), 'x')
(0.0, 0.0, 0.0, 0.0, 0.0)
</code></pre></div>
</dd>
<dt id="phi.field.upsample2x"><code class="name flex">
<span>def <span class="ident">upsample2x</span></span>(<span>grid: phi.field._field.Field) ‑> phi.field._field.Field</span>
</code></dt>
<dd>
<div class="desc"><p>Increases the number of sample points by a factor of 2 in each spatial dimension.
The new values are determined via linear interpolation.</p>
<p>See Also:
<code><a title="phi.field.downsample2x" href="#phi.field.downsample2x">downsample2x()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>grid</code></strong></dt>
<dd><code><a title="phi.field.CenteredGrid" href="#phi.field.CenteredGrid">CenteredGrid()</a></code> or <code><a title="phi.field.StaggeredGrid" href="#phi.field.StaggeredGrid">StaggeredGrid()</a></code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> of same type as <code>grid</code>.</p></div>
</dd>
<dt id="phi.field.vec_abs"><code class="name flex">
<span>def <span class="ident">vec_abs</span></span>(<span>field: phi.field._field.Field)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code>phi.math.vec_abs()</code></p></div>
</dd>
<dt id="phi.field.vec_length"><code class="name flex">
<span>def <span class="ident">vec_length</span></span>(<span>field: phi.field._field.Field)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code>phi.math.vec_abs()</code></p></div>
</dd>
<dt id="phi.field.vec_squared"><code class="name flex">
<span>def <span class="ident">vec_squared</span></span>(<span>field: phi.field._field.Field)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code>phi.math.vec_squared()</code></p></div>
</dd>
<dt id="phi.field.where"><code class="name flex">
<span>def <span class="ident">where</span></span>(<span>mask: phi.field._field.Field, field_true: phi.field._field.Field, field_false: phi.field._field.Field) ‑> phi.field._field.Field</span>
</code></dt>
<dd>
<div class="desc"><p>Element-wise where operation.
Picks the value of <code>field_true</code> where <code>mask=1 / True</code> and the value of <code>field_false</code> where <code>mask=0 / False</code>.</p>
<p>The fields are automatically resampled if necessary, preferring the sample points of <code><a title="phi.field.mask" href="#phi.field.mask">mask()</a></code>.
At least one of the arguments must be a <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mask</code></strong></dt>
<dd><code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> or <code>Geometry</code> object.</dd>
<dt><strong><code>field_true</code></strong></dt>
<dd><code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code></dd>
<dt><strong><code>field_false</code></strong></dt>
<dd><code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code></dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code></p></div>
</dd>
<dt id="phi.field.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>field: phi.field._field.Field, file: Union[str, phiml.math._tensors.Tensor])</span>
</code></dt>
<dd>
<div class="desc"><p>Writes a field to disc using a NumPy file format.
Depending on <code>file</code>, the data may be split up into multiple files.</p>
<p>All characteristics of the field are serialized so that it can be fully restored using <code><a title="phi.field.read" href="#phi.field.read">read()</a></code>.</p>
<p>See Also:
<code><a title="phi.field.read" href="#phi.field.read">read()</a></code></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>field</code></strong></dt>
<dd>Field to be saved.</dd>
<dt><strong><code>file</code></strong></dt>
<dd>Single file as <code>str</code> or <code>Tensor</code> of string type.
If <code>file</code> is a tensor, the dimensions of <code>field</code> are matched to the dimensions of <code>file</code>.
Dimensions of <code>file</code> that are missing in <code>field</code> result in data duplication.
Dimensions of <code>field</code> that are missing in <code>file</code> result in larger files.</dd>
</dl></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="phi.field.AngularVelocity"><code class="flex name class">
<span>class <span class="ident">AngularVelocity</span></span>
<span>(</span><span>location: Union[phiml.math._tensors.Tensor, tuple, list, numbers.Number], strength: Union[phiml.math._tensors.Tensor, numbers.Number] = 1.0, falloff: Callable = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Model of a single vortex or set of vortices.
The falloff of the velocity magnitude can be controlled.</p>
<p>Without a specified falloff, the velocity increases linearly with the distance from the vortex center.
This is the case with rotating rigid bodies, for example.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AngularVelocity(FieldInitializer):
    &#34;&#34;&#34;
    Model of a single vortex or set of vortices.
    The falloff of the velocity magnitude can be controlled.

    Without a specified falloff, the velocity increases linearly with the distance from the vortex center.
    This is the case with rotating rigid bodies, for example.
    &#34;&#34;&#34;

    def __init__(self,
                 location: Union[Tensor, tuple, list, Number],
                 strength: Union[Tensor, Number] = 1.0,
                 falloff: Callable = None):
        location = wrap(location)
        strength = wrap(strength)
        assert location.shape.channel.names == (&#39;vector&#39;,), &#34;location must have a single channel dimension called &#39;vector&#39;&#34;
        assert location.shape.spatial.is_empty, &#34;location tensor cannot have any spatial dimensions&#34;
        assert not instance(location), &#34;AngularVelocity does not support instance dimensions&#34;
        self.location = location
        self.strength = strength
        self.falloff = falloff
        spatial_names = location.vector.item_names
        assert spatial_names is not None, &#34;location.vector must list spatial dimensions as item names&#34;
        self._shape = location.shape &amp; spatial(**{dim: 1 for dim in spatial_names})

    def _sample(self, geometry: Geometry, at: str, boundaries: Extrapolation, **kwargs) -&gt; math.Tensor:
        points = get_sample_points(geometry, at, boundaries)
        distances = points - self.location
        strength = self.strength if self.falloff is None else self.strength * self.falloff(distances)
        velocity = math.cross_product(strength, distances)
        velocity = math.sum(velocity, self.location.shape.batch.without(points.shape))
        return velocity</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.field._field.FieldInitializer</li>
</ul>
</dd>
<dt id="phi.field.Field"><code class="flex name class">
<span>class <span class="ident">Field</span></span>
<span>(</span><span>geometry: Union[phiml.math._tensors.Tensor, phi.geom._geom.Geometry], values: Union[phiml.math._tensors.Tensor, numbers.Number, bool, Callable, phi.field._field.FieldInitializer, phi.geom._geom.Geometry, ForwardRef('<a title="phi.field.Field" href="#phi.field.Field">Field</a>')], boundary: Union[numbers.Number, phiml.math.extrapolation.Extrapolation, ForwardRef('<a title="phi.field.Field" href="#phi.field.Field">Field</a>'), dict] = 0, **sampling_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for all fields.</p>
<p>Important implementations:</p>
<ul>
<li>CenteredGrid</li>
<li>StaggeredGrid</li>
<li>PointCloud</li>
<li>Noise</li>
</ul>
<p>See the <code><a title="phi.field" href="#phi.field">phi.field</a></code> module documentation at <a href="https://tum-pbs.github.io/PhiFlow/Fields.html">https://tum-pbs.github.io/PhiFlow/Fields.html</a></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>elements</code></strong></dt>
<dd>Geometry object specifying the sample points and sizes</dd>
<dt><strong><code>values</code></strong></dt>
<dd>values corresponding to elements</dd>
<dt><strong><code>extrapolation</code></strong></dt>
<dd>values outside elements</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Field:
    &#34;&#34;&#34;
    Base class for all fields.
    
    Important implementations:
    
    * CenteredGrid
    * StaggeredGrid
    * PointCloud
    * Noise
    
    See the `phi.field` module documentation at https://tum-pbs.github.io/PhiFlow/Fields.html
    &#34;&#34;&#34;

    def __init__(self,
                 geometry: Union[Geometry, Tensor],
                 values: Union[Tensor, Number, bool, Callable, FieldInitializer, Geometry, &#39;Field&#39;],
                 boundary: Union[Number, Extrapolation, &#39;Field&#39;, dict] = 0,
                 **sampling_kwargs):
        &#34;&#34;&#34;
        Args:
          elements: Geometry object specifying the sample points and sizes
          values: values corresponding to elements
          extrapolation: values outside elements
        &#34;&#34;&#34;
        assert isinstance(geometry, Geometry), f&#34;geometry must be a Geometry object but got {type(geometry).__name__}&#34;
        self._boundary: Extrapolation = as_boundary(boundary, geometry)
        self._geometry: Geometry = geometry
        if isinstance(values, (Tensor, Number, bool)):
            values = wrap(values)
        else:
            from ._resample import sample
            values = sample(values, geometry, &#39;center&#39;, self._boundary, **sampling_kwargs)
        matching_sets = [s for s, s_shape in geometry.sets.items() if s_shape in values.shape]
        if not matching_sets:
            values = expand(wrap(values), non_batch(geometry) - &#39;vector&#39;)
        self._values: Tensor = values
        math.merge_shapes(values, non_batch(self.sampled_elements).non_channel)  # shape check

    @property
    def geometry(self) -&gt; Geometry:
        &#34;&#34;&#34;
        Returns a geometrical representation of the discrete volume elements.
        The result is a tuple of Geometry objects, each of which can have additional spatial (but not batch) dimensions.
        
        For grids, the geometries are boxes while particle fields may be represented as spheres.
        
        If this Field has no discrete points, this method returns an empty geometry.
        &#34;&#34;&#34;
        return self._geometry

    @property
    def mesh(self) -&gt; Mesh:
        &#34;&#34;&#34;Cast `self.geometry` to a `phi.geom.Mesh`.&#34;&#34;&#34;
        assert isinstance(self._geometry, Mesh), f&#34;Geometry is not a mesh but {type(self._geometry)}&#34;
        return self._geometry

    @property
    def graph(self) -&gt; Graph:
        &#34;&#34;&#34;Cast `self.geometry` to a `phi.geom.Graph`.&#34;&#34;&#34;
        assert isinstance(self._geometry, Graph), f&#34;Geometry is not a mesh but {type(self._geometry)}&#34;
        return self._geometry

    @property
    def faces(self):
        return get_faces(self._geometry, self._boundary)

    @property
    def face_centers(self):
        return self._geometry.face_centers
        # return slice_off_constant_faces(self._geometry.face_centers, self._geometry.boundary_faces, self._boundary)

    @property
    def face_normals(self):
        return self._geometry.face_normals
        # return slice_off_constant_faces(self._geometry.face_normals, self._geometry.boundary_faces, self._boundary)

    @property
    def face_areas(self):
        return self._geometry.face_areas
        # return slice_off_constant_faces(self._geometry.face_areas, self._geometry.boundary_faces, self._boundary)

    @property
    def sampled_elements(self) -&gt; Geometry:
        &#34;&#34;&#34;
        If the values represent are sampled at the element centers or represent the whole element, returns `self.geometry`.
        If the values are sampled at the faces, returns `self.faces`.
        &#34;&#34;&#34;
        return get_faces(self._geometry, self._boundary) if is_staggered(self._values, self._geometry) else self._geometry

    @property
    def elements(self):
        # raise SyntaxError(&#34;Field.elements is deprecated. Use Field.geometry or Field.sampled_elements instead.&#34;)
        warnings.warn(&#34;Field.elements is deprecated. Use Field.geometry or Field.sampled_elements instead. Field.elements now defaults to Field.geometry.&#34;, DeprecationWarning, stacklevel=2)
        return self._geometry

    @property
    def is_centered(self):
        return not self.is_staggered

    @property
    def is_staggered(self):
        return is_staggered(self._values, self._geometry)

    @property
    def center(self) -&gt; Tensor:
        &#34;&#34;&#34; Returns the center points of the `elements` of this `Field`. &#34;&#34;&#34;
        all_points = self._geometry.get_points(self.sampled_at)
        boundary = self._geometry.get_boundary(self.sampled_at)
        return slice_off_constant_faces(all_points, boundary, self.extrapolation)

    @property
    def points(self):
        return self.center

    @property
    def values(self) -&gt; Tensor:
        &#34;&#34;&#34; Returns the `values` of this `Field`. &#34;&#34;&#34;
        return self._values

    data = values

    def numpy(self, order: DimFilter = None):
        &#34;&#34;&#34;
        Return the field values as `NumPy` array(s).

        Args:
            order: Dimension order as `str` or `Shape`.

        Returns:
            A single NumPy array for uniform values, else a list of NumPy arrays.
        &#34;&#34;&#34;
        if order is None and self.is_grid:
            axes = self._values.shape.only(self._geometry.vector.item_names, reorder=True)
            order = concat_shapes(self._values.shape.dual, self._values.shape.batch, axes, self._values.shape.channel)
        if self._values.shape.is_uniform:
            return self._values.numpy(order)
        else:
            assert order is not None, f&#34;order must be specified for non-uniform Field values&#34;
            order = self._values.shape.only(order, reorder=True)
            stack_dims = order.non_uniform_shape
            inner_order = order.without(stack_dims)
            return [v.numpy(inner_order) for v in unstack(self._values, stack_dims)]

    def uniform_values(self):
        &#34;&#34;&#34;
        Returns a uniform tensor containing `values`.

        For periodic grids, which always have a uniform value tensor, `values&#39; is returned directly.
        If `values` is not uniform, it is padded as in `StaggeredGrid.staggered_tensor()`.
        &#34;&#34;&#34;
        if self.values.shape.is_uniform:
            return self.values
        else:
            return self.staggered_tensor()

    @property
    def boundary(self) -&gt; Extrapolation:
        &#34;&#34;&#34;
        Returns the boundary conditions set for this `Field`.

        Returns:
            Single `Extrapolation` instance that encodes the (varying) boundary conditions for all boundaries of this field&#39;s `elements`.
        &#34;&#34;&#34;
        return self._boundary

    @property
    def extrapolation(self) -&gt; Extrapolation:
        &#34;&#34;&#34; Returns the `Extrapolation` of this `Field`. &#34;&#34;&#34;
        return self._boundary

    @property
    def shape(self) -&gt; Shape:
        &#34;&#34;&#34;
        Returns a shape with the following properties
        
        * The spatial dimension names match the dimensions of this Field
        * The batch dimensions match the batch dimensions of this Field
        * The channel dimensions match the channels of this Field
        &#34;&#34;&#34;
        if self.is_staggered and self.is_grid:
            return batch(self._geometry) &amp; self.resolution &amp; non_dual(self._values).without(self.resolution) &amp; self._geometry.shape[&#39;vector&#39;]
        set_shape = self._geometry.sets[self.sampled_at]
        return batch(self._geometry) &amp; (channel(self._geometry) - &#39;vector&#39;) &amp; set_shape &amp; self._values

    @property
    def resolution(self):
        return self._geometry.shape.non_channel.non_dual.non_batch

    @property
    def spatial_rank(self) -&gt; int:
        &#34;&#34;&#34;
        Spatial rank of the field (1 for 1D, 2 for 2D, 3 for 3D).
        This is equal to the spatial rank of the `data`.
        &#34;&#34;&#34;
        return self._geometry.spatial_rank

    @property
    def bounds(self) -&gt; BaseBox:
        &#34;&#34;&#34;
        The bounds represent the area inside which the values of this `Field` are valid.
        The bounds will also be used as axis limits for plots.

        The bounds can be set manually in the constructor, otherwise default bounds will be generated.

        For fields that are valid without bounds, the lower and upper limit of `bounds` is set to `-inf` and `inf`, respectively.

        Fields whose spatial rank is determined only during sampling return an empty `Box`.
        &#34;&#34;&#34;
        if isinstance(self._geometry.bounds, BaseBox):
            return self._geometry.bounds
        extent = self._geometry.bounding_half_extent().vector.as_dual(&#39;_extent&#39;)
        points = self._geometry.center + extent
        lower = math.min(points, dim=points.shape.non_batch.non_channel)
        upper = math.max(points, dim=points.shape.non_batch.non_channel)
        return Box(lower, upper)

    box = bounds

    @property
    def is_grid(self):
        &#34;&#34;&#34;A Field represents grid data if its `geometry` is a `phi.geom.UniformGrid` instance.&#34;&#34;&#34;
        return isinstance(self._geometry, UniformGrid)

    @property
    def is_mesh(self):
        &#34;&#34;&#34;A Field represents mesh data if its `geometry` is a `phi.geom.Mesh` instance.&#34;&#34;&#34;
        return isinstance(self._geometry, Mesh)

    @property
    def is_graph(self):
        &#34;&#34;&#34;A Field represents graph data if its `geometry` is a `phi.geom.Graph` instance.&#34;&#34;&#34;
        return isinstance(self._geometry, Graph)

    @property
    def is_point_cloud(self):
        &#34;&#34;&#34;A Field represents graph data if its `geometry` is not a set of connected elements, but rather individual geometric objects.&#34;&#34;&#34;
        if isinstance(self._geometry, (UniformGrid, Mesh, Graph)):
            return False
        if isinstance(self._geometry, (BaseBox, Sphere, Point)):
            return True
        return True

    @property
    def dx(self) -&gt; Tensor:
        assert spatial(self._geometry), f&#34;dx is only defined for elements with spatial dims but Field has elements {self._geometry.shape}&#34;
        return self.bounds.size / self.resolution

    @property
    def cells(self):
        assert isinstance(self._geometry, (UniformGrid, Mesh))
        return self._geometry

    def to_grid(self, resolution=math.EMPTY_SHAPE, bounds=None, **resolution_):
        resolution = resolution.spatial &amp; spatial(**resolution_)
        if self.is_grid and (not resolution or resolution == self.resolution) and (bounds is None or bounds == self.bounds):
            return self
        bounds = self.bounds if bounds is None else bounds
        if not resolution:
            half_sizes = self._geometry.bounding_half_extent()
            if (half_sizes &gt; 0).all:
                size = math.min(2 * half_sizes, non_batch(half_sizes).non_channel)
            else:
                cell_count = non_batch(self._geometry).non_channel.non_dual.volume
                size = (bounds.volume / cell_count) ** (1 / self.spatial_rank)
            res = math.maximum(1, math.round(bounds.size / size))
            resolution = spatial(**res.vector)
        return Field(UniformGrid(resolution, bounds), self, self.boundary)

    def as_points(self, list_dim: Optional[Shape] = instance(&#39;elements&#39;)) -&gt; &#39;Field&#39;:
        &#34;&#34;&#34;
        Returns this field as a PointCloud.
        This replaces the `Field.geometry` with a `phi.geom.Point` instance while leaving the sample points unchanged.

        See Also:
            `Field.as_spheres()`.

        Args:
            list_dim: If not `None`, packs spatial, instance and dual dims.
                Defaults to `instance(&#39;elements&#39;)`.

        Returns:
            `Field` with same values and boundaries but `Point` geometry.
        &#34;&#34;&#34;
        points = self.sampled_elements.center
        values = self._values
        if list_dim:
            dims = non_batch(points).non_channel &amp; non_batch(points).non_channel
            points = pack_dims(points, dims, list_dim)
            values = pack_dims(values, dims, list_dim)
        return Field(Point(points), values, self._boundary)

    def as_spheres(self, list_dim: Optional[Shape] = instance(&#39;elements&#39;)) -&gt; &#39;Field&#39;:
        &#34;&#34;&#34;
        Returns this field as a PointCloud with spherical / circular elements, preserving element volumes.
        This replaces the `Field.geometry` with a `phi.geom.Sphere` instance while leaving the sample points unchanged.

        See Also:
            `Field.as_points()`.

        Args:
            list_dim: If not `None`, packs spatial, instance and dual dims.
                Defaults to `instance(&#39;elements&#39;)`.

        Returns:
            `Field` with same values and boundaries but `Sphere` geometry.
        &#34;&#34;&#34;
        points = self.sampled_elements.center
        volumes = self.sampled_elements.volume
        values = self._values
        if list_dim:
            dims = non_batch(points).non_channel &amp; non_batch(points).non_channel
            points = pack_dims(points, dims, list_dim)
            values = pack_dims(values, dims, list_dim)
            volumes = pack_dims(volumes, dims, list_dim)
        return Field(Sphere(points, volume=volumes), values, self._boundary)

    def at_centers(self, **kwargs) -&gt; &#39;Field&#39;:
        &#34;&#34;&#34;
        Interpolates the values to the cell centers.

        See Also:
            `Field.at_faces()`, `Field.at()`, `resample`.

        Args:
            **kwargs: Sampling arguments.

        Returns:
            `CenteredGrid` sampled at cell centers.
        &#34;&#34;&#34;
        if self.is_centered:
            return self
        from ._resample import sample
        values = sample(self, self._geometry, at=&#39;center&#39;, boundary=self._boundary, **kwargs)
        return Field(self._geometry, values, self._boundary)

    def at_faces(self, boundary=None, **kwargs) -&gt; &#39;Field&#39;:
        if self.is_staggered and not boundary:
            return self
        boundary = as_boundary(boundary, self._geometry) if boundary else self._boundary
        from ._resample import sample
        values = sample(self, self._geometry, at=&#39;face&#39;, boundary=boundary, **kwargs)
        return Field(self._geometry, values, boundary)

    @property
    def sampled_at(self):
        matching_sets = [s for s, s_shape in self._geometry.sets.items() if s_shape in self._values.shape]
        return matching_sets[-1]

    def at(self, representation: Union[&#39;Field&#39;, Geometry], keep_boundary=False, **kwargs) -&gt; &#39;Field&#39;:
        &#34;&#34;&#34;
        Short for `resample(self, representation)`

        See Also
            `resample()`.

        Returns:
            Field object of same type as `representation`
        &#34;&#34;&#34;
        from ._resample import resample
        return resample(self, representation, keep_boundary, **kwargs)

    def sample(self, where: Union[Geometry, &#39;Field&#39;, Tensor], at: str = &#39;center&#39;, **kwargs) -&gt; &#39;Tensor&#39;:
        &#34;&#34;&#34;
        Sample the values of this `Field` at the given location or geometry.

        Args:
            where: Location `Tensor` or `Geometry` or
            at: `&#39;center&#39;` or `&#39;face&#39;`.
            **kwargs: Sampling arguments.

        Returns:
            `Tensor`
        &#34;&#34;&#34;
        from ._resample import sample
        return sample(self, where, at, **kwargs)

    def closest_values(self, points: Tensor):
        &#34;&#34;&#34;
        Sample the closest grid point values of this field at the world-space locations (in physical units) given by `points`.
        Points must have a single channel dimension named `vector`.
        It may additionally contain any number of batch and spatial dimensions, all treated as batch dimensions.

        Args:
            points: world-space locations

        Returns:
            Closest grid point values as a `Tensor`.
            For each dimension, the grid points immediately left and right of the sample points are evaluated.
            For each point in `points`, a *2^d* cube of points is determined where *d* is the number of spatial dimensions of this field.
            These values are stacked along the new dimensions `&#39;closest_&lt;dim&gt;&#39;` where `&lt;dim&gt;` refers to the name of a spatial dimension.
        &#34;&#34;&#34;
        warnings.warn(&#34;Field.closest_values() is deprecated.&#34;, DeprecationWarning, stacklevel=2)
        if isinstance(points, Geometry):
            points = points.center
        # --- CenteredGrid ---
        local_points = self.box.global_to_local(points) * self.resolution - 0.5
        return math.closest_grid_values(self.values, local_points, self.extrapolation)
        # --- StaggeredGrid ---
        if &#39;staggered_direction&#39; in points.shape:
            points_ = math.unstack(points, &#39;~vector&#39;)
            channels = [component.closest_values(p) for p, component in zip(points_, self.vector.unstack())]
        else:
            channels = [component.closest_values(points) for component in self.vector.unstack()]
        return math.stack(channels, points.shape[&#39;~vector&#39;])

    def with_values(self, values, **sampling_kwargs):
        &#34;&#34;&#34; Returns a copy of this field with `values` replaced. &#34;&#34;&#34;
        if not isinstance(values, (Tensor, Number)):
            from ._resample import sample
            values = sample(values, self._geometry, self.sampled_at, self._boundary, dot_face_normal=self._geometry if &#39;vector&#39; not in self._values.shape else None, **sampling_kwargs)
        else:
            if not spatial(values):
                geo_shape = self.sampled_elements.shape if self.is_staggered else self._geometry.shape
                if &#39;~vector&#39; in geo_shape and &#39;vector&#39; in shape(values) and &#39;~vector&#39; not in shape(values):
                    values = values.vector.as_dual()
                values = expand(wrap(values), geo_shape.non_batch.non_channel)
        return Field(self._geometry, values, self._boundary)

    def with_boundary(self, boundary):
        &#34;&#34;&#34; Returns a copy of this field with the `boundary` replaced. &#34;&#34;&#34;
        boundary = as_boundary(boundary, self._geometry)
        boundary_elements = &#39;boundary_faces&#39; if self.is_staggered else &#39;boundary_elements&#39;
        old_determined_slices = {k: s for k, s in getattr(self._geometry, boundary_elements).items() if self._boundary.determines_boundary_values(k)}
        new_determined_slices = {k: s for k, s in getattr(self._geometry, boundary_elements).items() if boundary.determines_boundary_values(k)}
        if old_determined_slices.values() == new_determined_slices.values():
            return Field(self._geometry, self._values, boundary)  # ToDo unnecessary once the rest is implemented
        to_add = {k: sl for k, sl in old_determined_slices.items() if sl not in new_determined_slices.values()}
        to_remove = [sl for sl in new_determined_slices.values() if sl not in old_determined_slices.values()]
        values = math.slice_off(self._values, *to_remove)
        if to_add:
            if self.is_mesh:
                values = self.mesh.pad_boundary(values, to_add, self._boundary)
            elif self.is_grid and self.is_staggered:
                values = self._values.vector.dual.as_channel()
                to_add = {k: {&#39;vector&#39; if dim == &#39;~vector&#39; else dim: v for dim, v in sl.items()} for k, sl in to_add.items()}
                values = math.pad(values, list(to_add.values()), self._boundary, bounds=self.bounds)
                values = values.vector.as_dual()
            else:
                values = math.pad(values, list(to_add.values()), self._boundary, bounds=self.bounds)
        return Field(self._geometry, values, boundary)

    with_extrapolation = with_boundary

    def with_bounds(self, bounds: Box):
        &#34;&#34;&#34; Returns a copy of this field with `bounds` replaced. &#34;&#34;&#34;
        order = list(bounds.vector.item_names)
        geometry = self._geometry.vector[order]
        new_shape = self._values.shape.without(order) &amp; self._values.shape.only(order, reorder=True)
        values = math.transpose(self._values, new_shape)
        return Field(geometry, values, self._boundary)

    def with_geometry(self, elements: Geometry):
        &#34;&#34;&#34; Returns a copy of this field with `elements` replaced. &#34;&#34;&#34;
        assert non_batch(elements) == non_batch(self._geometry), f&#34;Field.with_elements() only accepts elements with equal non-batch dimensions but got {elements.shape} for Field with shape {self._geometry.shape}&#34;
        return Field(elements, self._values, self._boundary)

    with_elements = with_geometry

    def shifted(self, delta: Tensor) -&gt; &#39;Field&#39;:
        &#34;&#34;&#34;
        Move the positions of this field&#39;s `geometry` by `delta`.

        See Also:
            `Field.shifted_to`.

        Args:
            delta: Shift amount for each center position of `geometry`.

        Returns:
            New `Field` sampled at `geometry.center + delta`.
        &#34;&#34;&#34;
        return self.with_geometry(self._geometry.shifted(delta))

    def shifted_to(self, position: Tensor) -&gt; &#39;Field&#39;:
        &#34;&#34;&#34;
        Move the positions of this field&#39;s `geometry` to `positions`.

        See Also:
            `Field.shifted`.

        Args:
            position: New center positions of `geometry`.

        Returns:
            New `Field` sampled at given positions.
        &#34;&#34;&#34;
        return self.with_geometry(self._geometry.at(position))

    def pad(self, widths: Union[int, tuple, list, dict]) -&gt; &#39;Field&#39;:
        &#34;&#34;&#34;
        Alias for `phi.field.pad()`.

        Pads this `Field` using its extrapolation.

        Unlike padding the values, this function also affects the `geometry` of the field, changing its size and origin depending on `widths`.

        Args:
            widths: Either `int` or `(lower, upper)` to pad the same number of cells in all spatial dimensions
                or `dict` mapping dimension names to `(lower, upper)`.

        Returns:
            Padded `Field`
        &#34;&#34;&#34;
        from ._field_math import pad
        return pad(self, widths)

    def gradient(self,
                 boundary: Extrapolation = None,
                 at: str = &#39;center&#39;,
                 dims: math.DimFilter = spatial,
                 stack_dim: Union[Shape, str] = channel(&#39;vector&#39;),
                 order=2,
                 implicit: Solve = None,
                 scheme=None,
                 upwind: &#39;Field&#39; = None,
                 gradient_extrapolation: Extrapolation = None):
        &#34;&#34;&#34;Alias for `phi.field.spatial_gradient`&#34;&#34;&#34;
        from ._field_math import spatial_gradient
        return spatial_gradient(self, boundary=boundary, at=at, dims=dims, stack_dim=stack_dim, order=order, implicit=implicit, scheme=scheme, upwind=upwind, gradient_extrapolation=gradient_extrapolation)

    def divergence(self, order=2, implicit: Solve = None, upwind: &#39;Field&#39; = None):
        &#34;&#34;&#34;Alias for `phi.field.divergence`&#34;&#34;&#34;
        from ._field_math import divergence
        return divergence(self, order=order, implicit=implicit, upwind=upwind)

    def curl(self, at=&#39;corner&#39;):
        &#34;&#34;&#34;Alias for `phi.field.curl`&#34;&#34;&#34;
        from ._field_math import curl
        return curl(self, at=at)

    def laplace(self,
                axes: DimFilter = spatial,
                gradient: &#39;Field&#39; = None,
                order=2,
                implicit: math.Solve = None,
                weights: Union[Tensor, &#39;Field&#39;] = None,
                upwind: &#39;Field&#39; = None,
                correct_skew=True):
        &#34;&#34;&#34;Alias for `phi.field.laplace`&#34;&#34;&#34;
        from ._field_math import laplace
        return laplace(self, axes=axes, gradient=gradient, order=order, implicit=implicit, weights=weights, upwind=upwind, correct_skew=correct_skew)

    def downsample(self, factor: int):
        from ._field_math import downsample2x
        result = self
        while factor &gt;= 2:
            result = downsample2x(result)
            factor /= 2
        if math.close(factor, 1.):
            return result
        from ._resample import resample
        raise NotImplementedError(f&#34;downsample does not support fractional re-sampling. Only 2^n currently supported.&#34;)

    def staggered_tensor(self) -&gt; Tensor:
        &#34;&#34;&#34;
        Stacks all component grids into a single uniform `phi.math.Tensor`.
        The individual components are padded to a common (larger) shape before being stacked.
        The shape of the returned tensor is exactly one cell larger than the grid `resolution` in every spatial dimension.

        Returns:
            Uniform `phi.math.Tensor`.
        &#34;&#34;&#34;
        assert self.resolution.names == self.shape.get_item_names(&#39;vector&#39;), &#34;Field.staggered_tensor() only defined for Fields whose vector components match the resolution&#34;
        padded = []
        for dim, component in zip(self.resolution.names, self.vector):
            widths = {d: (0, 1) for d in self.resolution.names}
            lo_valid, up_valid = self.extrapolation.valid_outer_faces(dim)
            widths[dim] = (int(not lo_valid), int(not up_valid))
            padded.append(math.pad(component.values, widths, self.extrapolation[{&#39;vector&#39;: dim}], bounds=self.bounds))
        result = math.stack(padded, channel(vector=self.resolution))
        assert result.shape.is_uniform
        return result

    @staticmethod
    def __stack__(values: tuple, dim: Shape, **kwargs) -&gt; &#39;Field&#39;:
        from ._field_math import stack
        return stack(values, dim, kwargs.get(&#39;bounds&#39;, None))

    @staticmethod
    def __concat__(values: tuple, dim: str, **kwargs) -&gt; &#39;Field&#39;:
        from ._field_math import concat
        return concat(values, dim)

    def __and__(self, other):
        assert isinstance(other, Field)
        assert instance(self).rank == instance(other).rank == 1, f&#34;Can only use &amp; on PointClouds that have a single instance dimension but got shapes {self.shape} &amp; {other.shape}&#34;
        from ._field_math import concat
        return concat([self, other], instance(self))

    def __matmul__(self, other: &#39;Field&#39;):  # value @ representation
        # Deprecated. Use `resample(value, field)` instead.
        warnings.warn(&#34;value @ field is deprecated. Use resample(value, field) instead.&#34;, DeprecationWarning)
        from ._resample import resample
        return resample(self, to=other, keep_boundary=False)

    def __rmatmul__(self, other):  # values @ representation
        if isinstance(other, (Geometry, Number, tuple, list, FieldInitializer)):
            warnings.warn(&#34;value @ field is deprecated. Use resample(value, field) instead.&#34;, DeprecationWarning)
            from ._resample import resample
            return resample(other, to=self, keep_boundary=False)
        return NotImplemented

    def __rshift__(self, other):
        if isinstance(other, (Field, Geometry)):
            warnings.warn(&#34;&gt;&gt; operator for Fields is deprecated. Use field.at(), the constructor or obj @ field instead.&#34;, SyntaxWarning, stacklevel=2)
            return self.at(other, keep_boundary=False)
        else:
            return NotImplemented

    def __rrshift__(self, other):
        return self.with_values(other)

    def __lshift__(self, other):
        return self.with_values(other)

    def __rrshift__(self, other):
        warnings.warn(&#34;&gt;&gt; operator for Fields is deprecated. Use field.at(), the constructor or obj @ field instead.&#34;, SyntaxWarning, stacklevel=2)
        if not isinstance(self, Field):
            return NotImplemented
        if isinstance(other, (Geometry, float, int, complex, tuple, list, FieldInitializer)):
            from ._resample import resample
            return resample(other, to=self, keep_boundary=False)
        return NotImplemented

    def __getitem__(self, item) -&gt; &#39;Field&#39;:
        &#34;&#34;&#34;
        Access a slice of the Field.
        The returned `Field` may be of a different type than `self`.

        Args:
            item: `dict` mapping dimensions (`str`) to selections (`int` or `slice`) or other supported type, such as `int` or `str`.

        Returns:
            Sliced `Field`.
        &#34;&#34;&#34;
        item = slicing_dict(self, item)
        if not item:
            return self
        boundary = domain_slice(self._boundary, item, self.resolution)
        item_without_vec = {dim: selection for dim, selection in item.items() if dim != &#39;vector&#39;}
        geometry = self._geometry[item_without_vec]
        if self.is_staggered and &#39;vector&#39; in item and &#39;~vector&#39; in self.geometry.face_shape:
            assert isinstance(self._geometry, UniformGrid), f&#34;Vector slicing is only supported for grids&#34;
            dims = item[&#39;vector&#39;]
            dims_ = self._geometry.shape[&#39;vector&#39;].after_gather({&#39;vector&#39;: dims})
            dims = dims_.item_names[0] if dims_ else [dims] if isinstance(dims, str) else [self._geometry.shape[&#39;vector&#39;].item_names[0][dims]]
            proj_dims = set(self.resolution.names) - set(dims)
            if any(dim not in item for dim in proj_dims):
                # warnings.warn(f&#34;Projecting a staggered grid (by slicing &#39;vector&#39; without the corresponding spatial dims) will return a non-staggered grid. The projected dims {proj_dims} were not sliced off.\nFull slice: {item}&#34;)
                item[&#39;~vector&#39;] = item[&#39;vector&#39;]
                del item[&#39;vector&#39;]
                geometry = self.sampled_elements[item]
            else:
                item[&#39;~vector&#39;] = dims
                del item[&#39;vector&#39;]
        values = self._values[item]
        return Field(geometry, values, boundary)

    def __getattr__(self, name: str) -&gt; BoundDim:
        return BoundDim(self, name)

    def dimension(self, name: str):
        &#34;&#34;&#34;
        Returns a reference to one of the dimensions of this field.

        The dimension reference can be used the same way as a `Tensor` dimension reference.
        Notable properties and methods of a dimension reference are:
        indexing using `[index]`, `unstack()`, `size`, `exists`, `is_batch`, `is_spatial`, `is_channel`.

        A shortcut to calling this function is the syntax `field.&lt;dim_name&gt;` which calls `field.dimension(&lt;dim_name&gt;)`.

        Args:
            name: dimension name

        Returns:
            dimension reference

        &#34;&#34;&#34;
        return BoundDim(self, name)

    def __value_attrs__(self):
        return &#39;_values&#39;,

    def __variable_attrs__(self):
        return &#39;_values&#39;, &#39;_geometry&#39;, &#39;_boundary&#39;

    def __expand__(self, dims: Shape, **kwargs) -&gt; &#39;Field&#39;:
        return self.with_values(expand(self.values, dims, **kwargs))

    def __replace_dims__(self, dims: Tuple[str, ...], new_dims: Shape, **kwargs) -&gt; &#39;Field&#39;:
        elements = math.rename_dims(self._geometry, dims, new_dims)
        values = math.rename_dims(self._values, dims, new_dims)
        extrapolation = math.rename_dims(self._boundary, dims, new_dims, **kwargs)
        return Field(elements, values, extrapolation)

    def __eq__(self, other):
        if not isinstance(other, Field):
            return False
        if self._geometry != other._geometry:
            return False
        if self._boundary != other.boundary:
            return False
        return math.always_close(self._values, other._values)

    def __hash__(self):
        return hash((self._geometry, self._boundary))

    def __mul__(self, other):
        return self._op2(other, lambda d1, d2: d1 * d2)

    __rmul__ = __mul__

    def __truediv__(self, other):
        return self._op2(other, lambda d1, d2: d1 / d2)

    def __rtruediv__(self, other):
        return self._op2(other, lambda d1, d2: d2 / d1)

    def __sub__(self, other):
        return self._op2(other, lambda d1, d2: d1 - d2)

    def __rsub__(self, other):
        return self._op2(other, lambda d1, d2: d2 - d1)

    def __add__(self, other):
        return self._op2(other, lambda d1, d2: d1 + d2)

    __radd__ = __add__

    def __pow__(self, power, modulo=None):
        return self._op2(power, lambda f, p: f ** p)

    def __neg__(self):
        return self._op1(lambda x: -x)

    def __gt__(self, other):
        return self._op2(other, lambda x, y: x &gt; y)

    def __ge__(self, other):
        return self._op2(other, lambda x, y: x &gt;= y)

    def __lt__(self, other):
        return self._op2(other, lambda x, y: x &lt; y)

    def __le__(self, other):
        return self._op2(other, lambda x, y: x &lt;= y)

    def __abs__(self):
        return self._op1(lambda x: abs(x))

    def _op1(self: &#39;Field&#39;, operator: Callable) -&gt; &#39;Field&#39;:
        &#34;&#34;&#34;
        Perform an operation on the data of this field.

        Args:
          operator: function that accepts tensors and extrapolations and returns objects of the same type and dimensions

        Returns:
          Field of same type
        &#34;&#34;&#34;
        values = operator(self.values)
        extrapolation_ = operator(self._boundary)
        return self.with_values(values).with_extrapolation(extrapolation_)

    def _op2(self, other, operator) -&gt; &#39;Field&#39;:
        if isinstance(other, Geometry):
            raise ValueError(f&#34;Cannot combine {self.__class__.__name__} with a Geometry, got {type(other)}&#34;)
        if isinstance(other, Field):
            if self._geometry == other._geometry:
                values = operator(self._values, other.values)
                extrapolation_ = operator(self._boundary, other.extrapolation)
                return Field(self._geometry, values, extrapolation_)
            from ._resample import sample
            other_values = sample(other, self._geometry, self.sampled_at, self.boundary, dot_face_normal=self._geometry)
            values = operator(self._values, other_values)
            boundary = operator(self._boundary, other.extrapolation)
            return Field(self._geometry, values, boundary)
        else:
            if isinstance(other, (tuple, list)) and len(other) == self.spatial_rank:
                other = math.wrap(other, self._geometry.shape[&#39;vector&#39;])
            else:
                other = math.wrap(other)
            # try:
            #     boundary = operator(self._boundary, as_boundary(other, self._geometry))
            # except TypeError:  # e.g. ZERO_GRADIENT + constant
            boundary = self._boundary  # constants don&#39;t affect the boundary conditions (legacy reasons)
            if &#39;vector&#39; in self.shape and &#39;vector&#39; not in self.values.shape and &#39;~vector&#39; in self.values.shape:
                other = other.vector.as_dual()
            values = operator(self._values, other)
            return Field(self._geometry, values, boundary)

    def __repr__(self):
        if self.is_grid:
            type_name = &#34;Grid&#34; if self.is_centered else &#34;Grid faces&#34;
        elif self.is_mesh:
            type_name = &#34;Mesh&#34; if self.is_centered else &#34;Mesh faces&#34;
        elif self.is_point_cloud:
            type_name = &#34;Point cloud&#34; if self.is_centered else &#34;Point cloud edges&#34;
        elif self.is_graph:
            type_name = &#34;Graph&#34; if self.is_centered else &#34;Graph edges&#34;
        else:
            type_name = self.__class__.__name__
        if self._values is not None:
            return f&#34;{type_name}[{self.values}, ext={self._boundary}]&#34;
        else:
            return f&#34;{type_name}[{self.resolution}, ext={self._boundary}]&#34;

    def grid_scatter(self, *args, **kwargs):
        &#34;&#34;&#34;Deprecated. Use `sample` with `scatter=True` instead.&#34;&#34;&#34;
        warnings.warn(&#34;Field.grid_scatter() is deprecated. Use field.sample() with scatter=True instead.&#34;, DeprecationWarning, stacklevel=2)
        from ._resample import grid_scatter
        return grid_scatter(self, *args, **kwargs)

    def as_boundary(self) -&gt; Extrapolation:
        &#34;&#34;&#34;
        Returns an `Extrapolation` representing this &#39;Field&#39;&#39;s values as a Dirichlet (constant) boundary.
        If this `Field` encloses the required boundaries, its values will be interpolated to the required boundaries.
        If boundaries outside of this `Field`&#39;s sampled domain are required, this `Field`&#39;s boundary conditions will be applied to determine the boundary values.

        Returns:
            `Extrapolation`
        &#34;&#34;&#34;
        from ._embed import FieldEmbedding
        return FieldEmbedding(self)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li>phi.field._mask.HardGeometryMask</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="phi.field.Field.boundary"><code class="name">prop <span class="ident">boundary</span> : phiml.math.extrapolation.Extrapolation</code></dt>
<dd>
<div class="desc"><p>Returns the boundary conditions set for this <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code>.</p>
<h2 id="returns">Returns</h2>
<p>Single <code>Extrapolation</code> instance that encodes the (varying) boundary conditions for all boundaries of this field's <code>elements</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def boundary(self) -&gt; Extrapolation:
    &#34;&#34;&#34;
    Returns the boundary conditions set for this `Field`.

    Returns:
        Single `Extrapolation` instance that encodes the (varying) boundary conditions for all boundaries of this field&#39;s `elements`.
    &#34;&#34;&#34;
    return self._boundary</code></pre>
</details>
</dd>
<dt id="phi.field.Field.bounds"><code class="name">prop <span class="ident">bounds</span> : phi.geom._box.BaseBox</code></dt>
<dd>
<div class="desc"><p>The bounds represent the area inside which the values of this <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> are valid.
The bounds will also be used as axis limits for plots.</p>
<p>The bounds can be set manually in the constructor, otherwise default bounds will be generated.</p>
<p>For fields that are valid without bounds, the lower and upper limit of <code>bounds</code> is set to <code>-inf</code> and <code>inf</code>, respectively.</p>
<p>Fields whose spatial rank is determined only during sampling return an empty <code>Box</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bounds(self) -&gt; BaseBox:
    &#34;&#34;&#34;
    The bounds represent the area inside which the values of this `Field` are valid.
    The bounds will also be used as axis limits for plots.

    The bounds can be set manually in the constructor, otherwise default bounds will be generated.

    For fields that are valid without bounds, the lower and upper limit of `bounds` is set to `-inf` and `inf`, respectively.

    Fields whose spatial rank is determined only during sampling return an empty `Box`.
    &#34;&#34;&#34;
    if isinstance(self._geometry.bounds, BaseBox):
        return self._geometry.bounds
    extent = self._geometry.bounding_half_extent().vector.as_dual(&#39;_extent&#39;)
    points = self._geometry.center + extent
    lower = math.min(points, dim=points.shape.non_batch.non_channel)
    upper = math.max(points, dim=points.shape.non_batch.non_channel)
    return Box(lower, upper)</code></pre>
</details>
</dd>
<dt id="phi.field.Field.box"><code class="name">prop <span class="ident">box</span> : phi.geom._box.BaseBox</code></dt>
<dd>
<div class="desc"><p>The bounds represent the area inside which the values of this <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> are valid.
The bounds will also be used as axis limits for plots.</p>
<p>The bounds can be set manually in the constructor, otherwise default bounds will be generated.</p>
<p>For fields that are valid without bounds, the lower and upper limit of <code>bounds</code> is set to <code>-inf</code> and <code>inf</code>, respectively.</p>
<p>Fields whose spatial rank is determined only during sampling return an empty <code>Box</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bounds(self) -&gt; BaseBox:
    &#34;&#34;&#34;
    The bounds represent the area inside which the values of this `Field` are valid.
    The bounds will also be used as axis limits for plots.

    The bounds can be set manually in the constructor, otherwise default bounds will be generated.

    For fields that are valid without bounds, the lower and upper limit of `bounds` is set to `-inf` and `inf`, respectively.

    Fields whose spatial rank is determined only during sampling return an empty `Box`.
    &#34;&#34;&#34;
    if isinstance(self._geometry.bounds, BaseBox):
        return self._geometry.bounds
    extent = self._geometry.bounding_half_extent().vector.as_dual(&#39;_extent&#39;)
    points = self._geometry.center + extent
    lower = math.min(points, dim=points.shape.non_batch.non_channel)
    upper = math.max(points, dim=points.shape.non_batch.non_channel)
    return Box(lower, upper)</code></pre>
</details>
</dd>
<dt id="phi.field.Field.cells"><code class="name">prop <span class="ident">cells</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cells(self):
    assert isinstance(self._geometry, (UniformGrid, Mesh))
    return self._geometry</code></pre>
</details>
</dd>
<dt id="phi.field.Field.center"><code class="name">prop <span class="ident">center</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p>Returns the center points of the <code>elements</code> of this <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def center(self) -&gt; Tensor:
    &#34;&#34;&#34; Returns the center points of the `elements` of this `Field`. &#34;&#34;&#34;
    all_points = self._geometry.get_points(self.sampled_at)
    boundary = self._geometry.get_boundary(self.sampled_at)
    return slice_off_constant_faces(all_points, boundary, self.extrapolation)</code></pre>
</details>
</dd>
<dt id="phi.field.Field.data"><code class="name">prop <span class="ident">data</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p>Returns the <code>values</code> of this <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def values(self) -&gt; Tensor:
    &#34;&#34;&#34; Returns the `values` of this `Field`. &#34;&#34;&#34;
    return self._values</code></pre>
</details>
</dd>
<dt id="phi.field.Field.dx"><code class="name">prop <span class="ident">dx</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def dx(self) -&gt; Tensor:
    assert spatial(self._geometry), f&#34;dx is only defined for elements with spatial dims but Field has elements {self._geometry.shape}&#34;
    return self.bounds.size / self.resolution</code></pre>
</details>
</dd>
<dt id="phi.field.Field.elements"><code class="name">prop <span class="ident">elements</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def elements(self):
    # raise SyntaxError(&#34;Field.elements is deprecated. Use Field.geometry or Field.sampled_elements instead.&#34;)
    warnings.warn(&#34;Field.elements is deprecated. Use Field.geometry or Field.sampled_elements instead. Field.elements now defaults to Field.geometry.&#34;, DeprecationWarning, stacklevel=2)
    return self._geometry</code></pre>
</details>
</dd>
<dt id="phi.field.Field.extrapolation"><code class="name">prop <span class="ident">extrapolation</span> : phiml.math.extrapolation.Extrapolation</code></dt>
<dd>
<div class="desc"><p>Returns the <code>Extrapolation</code> of this <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def extrapolation(self) -&gt; Extrapolation:
    &#34;&#34;&#34; Returns the `Extrapolation` of this `Field`. &#34;&#34;&#34;
    return self._boundary</code></pre>
</details>
</dd>
<dt id="phi.field.Field.face_areas"><code class="name">prop <span class="ident">face_areas</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_areas(self):
    return self._geometry.face_areas
    # return slice_off_constant_faces(self._geometry.face_areas, self._geometry.boundary_faces, self._boundary)</code></pre>
</details>
</dd>
<dt id="phi.field.Field.face_centers"><code class="name">prop <span class="ident">face_centers</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_centers(self):
    return self._geometry.face_centers
    # return slice_off_constant_faces(self._geometry.face_centers, self._geometry.boundary_faces, self._boundary)</code></pre>
</details>
</dd>
<dt id="phi.field.Field.face_normals"><code class="name">prop <span class="ident">face_normals</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_normals(self):
    return self._geometry.face_normals
    # return slice_off_constant_faces(self._geometry.face_normals, self._geometry.boundary_faces, self._boundary)</code></pre>
</details>
</dd>
<dt id="phi.field.Field.faces"><code class="name">prop <span class="ident">faces</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def faces(self):
    return get_faces(self._geometry, self._boundary)</code></pre>
</details>
</dd>
<dt id="phi.field.Field.geometry"><code class="name">prop <span class="ident">geometry</span> : phi.geom._geom.Geometry</code></dt>
<dd>
<div class="desc"><p>Returns a geometrical representation of the discrete volume elements.
The result is a tuple of Geometry objects, each of which can have additional spatial (but not batch) dimensions.</p>
<p>For grids, the geometries are boxes while particle fields may be represented as spheres.</p>
<p>If this Field has no discrete points, this method returns an empty geometry.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def geometry(self) -&gt; Geometry:
    &#34;&#34;&#34;
    Returns a geometrical representation of the discrete volume elements.
    The result is a tuple of Geometry objects, each of which can have additional spatial (but not batch) dimensions.
    
    For grids, the geometries are boxes while particle fields may be represented as spheres.
    
    If this Field has no discrete points, this method returns an empty geometry.
    &#34;&#34;&#34;
    return self._geometry</code></pre>
</details>
</dd>
<dt id="phi.field.Field.graph"><code class="name">prop <span class="ident">graph</span> : phi.geom._graph.Graph</code></dt>
<dd>
<div class="desc"><p>Cast <code>self.geometry</code> to a <code><a title="phi.geom.Graph" href="../geom/index.html#phi.geom.Graph">Graph</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def graph(self) -&gt; Graph:
    &#34;&#34;&#34;Cast `self.geometry` to a `phi.geom.Graph`.&#34;&#34;&#34;
    assert isinstance(self._geometry, Graph), f&#34;Geometry is not a mesh but {type(self._geometry)}&#34;
    return self._geometry</code></pre>
</details>
</dd>
<dt id="phi.field.Field.is_centered"><code class="name">prop <span class="ident">is_centered</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_centered(self):
    return not self.is_staggered</code></pre>
</details>
</dd>
<dt id="phi.field.Field.is_graph"><code class="name">prop <span class="ident">is_graph</span></code></dt>
<dd>
<div class="desc"><p>A Field represents graph data if its <code>geometry</code> is a <code><a title="phi.geom.Graph" href="../geom/index.html#phi.geom.Graph">Graph</a></code> instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_graph(self):
    &#34;&#34;&#34;A Field represents graph data if its `geometry` is a `phi.geom.Graph` instance.&#34;&#34;&#34;
    return isinstance(self._geometry, Graph)</code></pre>
</details>
</dd>
<dt id="phi.field.Field.is_grid"><code class="name">prop <span class="ident">is_grid</span></code></dt>
<dd>
<div class="desc"><p>A Field represents grid data if its <code>geometry</code> is a <code><a title="phi.geom.UniformGrid" href="../geom/index.html#phi.geom.UniformGrid">UniformGrid</a></code> instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_grid(self):
    &#34;&#34;&#34;A Field represents grid data if its `geometry` is a `phi.geom.UniformGrid` instance.&#34;&#34;&#34;
    return isinstance(self._geometry, UniformGrid)</code></pre>
</details>
</dd>
<dt id="phi.field.Field.is_mesh"><code class="name">prop <span class="ident">is_mesh</span></code></dt>
<dd>
<div class="desc"><p>A Field represents mesh data if its <code>geometry</code> is a <code><a title="phi.geom.Mesh" href="../geom/index.html#phi.geom.Mesh">Mesh</a></code> instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_mesh(self):
    &#34;&#34;&#34;A Field represents mesh data if its `geometry` is a `phi.geom.Mesh` instance.&#34;&#34;&#34;
    return isinstance(self._geometry, Mesh)</code></pre>
</details>
</dd>
<dt id="phi.field.Field.is_point_cloud"><code class="name">prop <span class="ident">is_point_cloud</span></code></dt>
<dd>
<div class="desc"><p>A Field represents graph data if its <code>geometry</code> is not a set of connected elements, but rather individual geometric objects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_point_cloud(self):
    &#34;&#34;&#34;A Field represents graph data if its `geometry` is not a set of connected elements, but rather individual geometric objects.&#34;&#34;&#34;
    if isinstance(self._geometry, (UniformGrid, Mesh, Graph)):
        return False
    if isinstance(self._geometry, (BaseBox, Sphere, Point)):
        return True
    return True</code></pre>
</details>
</dd>
<dt id="phi.field.Field.is_staggered"><code class="name">prop <span class="ident">is_staggered</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_staggered(self):
    return is_staggered(self._values, self._geometry)</code></pre>
</details>
</dd>
<dt id="phi.field.Field.mesh"><code class="name">prop <span class="ident">mesh</span> : phi.geom._mesh.Mesh</code></dt>
<dd>
<div class="desc"><p>Cast <code>self.geometry</code> to a <code><a title="phi.geom.Mesh" href="../geom/index.html#phi.geom.Mesh">Mesh</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mesh(self) -&gt; Mesh:
    &#34;&#34;&#34;Cast `self.geometry` to a `phi.geom.Mesh`.&#34;&#34;&#34;
    assert isinstance(self._geometry, Mesh), f&#34;Geometry is not a mesh but {type(self._geometry)}&#34;
    return self._geometry</code></pre>
</details>
</dd>
<dt id="phi.field.Field.points"><code class="name">prop <span class="ident">points</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def points(self):
    return self.center</code></pre>
</details>
</dd>
<dt id="phi.field.Field.resolution"><code class="name">prop <span class="ident">resolution</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def resolution(self):
    return self._geometry.shape.non_channel.non_dual.non_batch</code></pre>
</details>
</dd>
<dt id="phi.field.Field.sampled_at"><code class="name">prop <span class="ident">sampled_at</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sampled_at(self):
    matching_sets = [s for s, s_shape in self._geometry.sets.items() if s_shape in self._values.shape]
    return matching_sets[-1]</code></pre>
</details>
</dd>
<dt id="phi.field.Field.sampled_elements"><code class="name">prop <span class="ident">sampled_elements</span> : phi.geom._geom.Geometry</code></dt>
<dd>
<div class="desc"><p>If the values represent are sampled at the element centers or represent the whole element, returns <code>self.geometry</code>.
If the values are sampled at the faces, returns <code>self.faces</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sampled_elements(self) -&gt; Geometry:
    &#34;&#34;&#34;
    If the values represent are sampled at the element centers or represent the whole element, returns `self.geometry`.
    If the values are sampled at the faces, returns `self.faces`.
    &#34;&#34;&#34;
    return get_faces(self._geometry, self._boundary) if is_staggered(self._values, self._geometry) else self._geometry</code></pre>
</details>
</dd>
<dt id="phi.field.Field.shape"><code class="name">prop <span class="ident">shape</span> : phiml.math._shape.Shape</code></dt>
<dd>
<div class="desc"><p>Returns a shape with the following properties</p>
<ul>
<li>The spatial dimension names match the dimensions of this Field</li>
<li>The batch dimensions match the batch dimensions of this Field</li>
<li>The channel dimensions match the channels of this Field</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape(self) -&gt; Shape:
    &#34;&#34;&#34;
    Returns a shape with the following properties
    
    * The spatial dimension names match the dimensions of this Field
    * The batch dimensions match the batch dimensions of this Field
    * The channel dimensions match the channels of this Field
    &#34;&#34;&#34;
    if self.is_staggered and self.is_grid:
        return batch(self._geometry) &amp; self.resolution &amp; non_dual(self._values).without(self.resolution) &amp; self._geometry.shape[&#39;vector&#39;]
    set_shape = self._geometry.sets[self.sampled_at]
    return batch(self._geometry) &amp; (channel(self._geometry) - &#39;vector&#39;) &amp; set_shape &amp; self._values</code></pre>
</details>
</dd>
<dt id="phi.field.Field.spatial_rank"><code class="name">prop <span class="ident">spatial_rank</span> : int</code></dt>
<dd>
<div class="desc"><p>Spatial rank of the field (1 for 1D, 2 for 2D, 3 for 3D).
This is equal to the spatial rank of the <code>data</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def spatial_rank(self) -&gt; int:
    &#34;&#34;&#34;
    Spatial rank of the field (1 for 1D, 2 for 2D, 3 for 3D).
    This is equal to the spatial rank of the `data`.
    &#34;&#34;&#34;
    return self._geometry.spatial_rank</code></pre>
</details>
</dd>
<dt id="phi.field.Field.values"><code class="name">prop <span class="ident">values</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p>Returns the <code>values</code> of this <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def values(self) -&gt; Tensor:
    &#34;&#34;&#34; Returns the `values` of this `Field`. &#34;&#34;&#34;
    return self._values</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phi.field.Field.as_boundary"><code class="name flex">
<span>def <span class="ident">as_boundary</span></span>(<span>self) ‑> phiml.math.extrapolation.Extrapolation</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an <code>Extrapolation</code> representing this 'Field''s values as a Dirichlet (constant) boundary.
If this <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> encloses the required boundaries, its values will be interpolated to the required boundaries.
If boundaries outside of this <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code>'s sampled domain are required, this <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code>'s boundary conditions will be applied to determine the boundary values.</p>
<h2 id="returns">Returns</h2>
<p><code>Extrapolation</code></p></div>
</dd>
<dt id="phi.field.Field.as_points"><code class="name flex">
<span>def <span class="ident">as_points</span></span>(<span>self, list_dim: Optional[phiml.math._shape.Shape] = (elementsⁱ=None)) ‑> phi.field._field.Field</span>
</code></dt>
<dd>
<div class="desc"><p>Returns this field as a PointCloud.
This replaces the <code><a title="phi.field.Field.geometry" href="#phi.field.Field.geometry">Field.geometry</a></code> with a <code><a title="phi.geom.Point" href="../geom/index.html#phi.geom.Point">Point</a></code> instance while leaving the sample points unchanged.</p>
<p>See Also:
<code><a title="phi.field.Field.as_spheres" href="#phi.field.Field.as_spheres">Field.as_spheres()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>list_dim</code></strong></dt>
<dd>If not <code>None</code>, packs spatial, instance and dual dims.
Defaults to <code>instance('elements')</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> with same values and boundaries but <code>Point</code> geometry.</p></div>
</dd>
<dt id="phi.field.Field.as_spheres"><code class="name flex">
<span>def <span class="ident">as_spheres</span></span>(<span>self, list_dim: Optional[phiml.math._shape.Shape] = (elementsⁱ=None)) ‑> phi.field._field.Field</span>
</code></dt>
<dd>
<div class="desc"><p>Returns this field as a PointCloud with spherical / circular elements, preserving element volumes.
This replaces the <code><a title="phi.field.Field.geometry" href="#phi.field.Field.geometry">Field.geometry</a></code> with a <code><a title="phi.geom.Sphere" href="../geom/index.html#phi.geom.Sphere">Sphere</a></code> instance while leaving the sample points unchanged.</p>
<p>See Also:
<code><a title="phi.field.Field.as_points" href="#phi.field.Field.as_points">Field.as_points()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>list_dim</code></strong></dt>
<dd>If not <code>None</code>, packs spatial, instance and dual dims.
Defaults to <code>instance('elements')</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> with same values and boundaries but <code>Sphere</code> geometry.</p></div>
</dd>
<dt id="phi.field.Field.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>self, representation: Union[ForwardRef('<a title="phi.field.Field" href="#phi.field.Field">Field</a>'), phi.geom._geom.Geometry], keep_boundary=False, **kwargs) ‑> phi.field._field.Field</span>
</code></dt>
<dd>
<div class="desc"><p>Short for <code><a title="phi.field.resample" href="#phi.field.resample">resample()</a>(self, representation)</code></p>
<p>See Also
<code><a title="phi.field.resample" href="#phi.field.resample">resample()</a></code>.</p>
<h2 id="returns">Returns</h2>
<p>Field object of same type as <code>representation</code></p></div>
</dd>
<dt id="phi.field.Field.at_centers"><code class="name flex">
<span>def <span class="ident">at_centers</span></span>(<span>self, **kwargs) ‑> phi.field._field.Field</span>
</code></dt>
<dd>
<div class="desc"><p>Interpolates the values to the cell centers.</p>
<p>See Also:
<code><a title="phi.field.Field.at_faces" href="#phi.field.Field.at_faces">Field.at_faces()</a></code>, <code><a title="phi.field.Field.at" href="#phi.field.Field.at">Field.at()</a></code>, <code><a title="phi.field.resample" href="#phi.field.resample">resample()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Sampling arguments.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.field.CenteredGrid" href="#phi.field.CenteredGrid">CenteredGrid()</a></code> sampled at cell centers.</p></div>
</dd>
<dt id="phi.field.Field.at_faces"><code class="name flex">
<span>def <span class="ident">at_faces</span></span>(<span>self, boundary=None, **kwargs) ‑> phi.field._field.Field</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="phi.field.Field.closest_values"><code class="name flex">
<span>def <span class="ident">closest_values</span></span>(<span>self, points: phiml.math._tensors.Tensor)</span>
</code></dt>
<dd>
<div class="desc"><p>Sample the closest grid point values of this field at the world-space locations (in physical units) given by <code>points</code>.
Points must have a single channel dimension named <code>vector</code>.
It may additionally contain any number of batch and spatial dimensions, all treated as batch dimensions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>points</code></strong></dt>
<dd>world-space locations</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Closest grid point values as a <code>Tensor</code>.
For each dimension, the grid points immediately left and right of the sample points are evaluated.
For each point in <code>points</code>, a <em>2^d</em> cube of points is determined where <em>d</em> is the number of spatial dimensions of this field.
These values are stacked along the new dimensions <code>'closest_&lt;dim&gt;'</code> where <code>&lt;dim&gt;</code> refers to the name of a spatial dimension.</p></div>
</dd>
<dt id="phi.field.Field.curl"><code class="name flex">
<span>def <span class="ident">curl</span></span>(<span>self, at='corner')</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for <code><a title="phi.field.curl" href="#phi.field.curl">curl()</a></code></p></div>
</dd>
<dt id="phi.field.Field.dimension"><code class="name flex">
<span>def <span class="ident">dimension</span></span>(<span>self, name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a reference to one of the dimensions of this field.</p>
<p>The dimension reference can be used the same way as a <code>Tensor</code> dimension reference.
Notable properties and methods of a dimension reference are:
indexing using <code>[index]</code>, <code><a title="phi.field.unstack" href="#phi.field.unstack">unstack()</a></code>, <code>size</code>, <code>exists</code>, <code>is_batch</code>, <code>is_spatial</code>, <code>is_channel</code>.</p>
<p>A shortcut to calling this function is the syntax <code>field.&lt;dim_name&gt;</code> which calls <code>field.dimension(&lt;dim_name&gt;)</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>dimension name</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>dimension reference</p></div>
</dd>
<dt id="phi.field.Field.divergence"><code class="name flex">
<span>def <span class="ident">divergence</span></span>(<span>self, order=2, implicit: phiml.math._optimize.Solve = None, upwind: <a title="phi.field.Field" href="#phi.field.Field">Field</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for <code><a title="phi.field.divergence" href="#phi.field.divergence">divergence()</a></code></p></div>
</dd>
<dt id="phi.field.Field.downsample"><code class="name flex">
<span>def <span class="ident">downsample</span></span>(<span>self, factor: int)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="phi.field.Field.gradient"><code class="name flex">
<span>def <span class="ident">gradient</span></span>(<span>self, boundary: phiml.math.extrapolation.Extrapolation = None, at: str = 'center', dims: Union[str, tuple, list, set, ForwardRef('Shape'), Callable] = &lt;function spatial&gt;, stack_dim: Union[phiml.math._shape.Shape, str] = (vectorᶜ=None), order=2, implicit: phiml.math._optimize.Solve = None, scheme=None, upwind: <a title="phi.field.Field" href="#phi.field.Field">Field</a> = None, gradient_extrapolation: phiml.math.extrapolation.Extrapolation = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for <code><a title="phi.field.spatial_gradient" href="#phi.field.spatial_gradient">spatial_gradient()</a></code></p></div>
</dd>
<dt id="phi.field.Field.grid_scatter"><code class="name flex">
<span>def <span class="ident">grid_scatter</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Deprecated. Use <code><a title="phi.field.sample" href="#phi.field.sample">sample()</a></code> with <code>scatter=True</code> instead.</p></div>
</dd>
<dt id="phi.field.Field.laplace"><code class="name flex">
<span>def <span class="ident">laplace</span></span>(<span>self, axes: Union[str, tuple, list, set, ForwardRef('Shape'), Callable] = &lt;function spatial&gt;, gradient: <a title="phi.field.Field" href="#phi.field.Field">Field</a> = None, order=2, implicit: phiml.math._optimize.Solve = None, weights: Union[phiml.math._tensors.Tensor, ForwardRef('<a title="phi.field.Field" href="#phi.field.Field">Field</a>')] = None, upwind: <a title="phi.field.Field" href="#phi.field.Field">Field</a> = None, correct_skew=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for <code><a title="phi.field.laplace" href="#phi.field.laplace">laplace()</a></code></p></div>
</dd>
<dt id="phi.field.Field.numpy"><code class="name flex">
<span>def <span class="ident">numpy</span></span>(<span>self, order: Union[str, tuple, list, set, ForwardRef('Shape'), Callable] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the field values as <code>NumPy</code> array(s).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>order</code></strong></dt>
<dd>Dimension order as <code>str</code> or <code>Shape</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A single NumPy array for uniform values, else a list of NumPy arrays.</p></div>
</dd>
<dt id="phi.field.Field.pad"><code class="name flex">
<span>def <span class="ident">pad</span></span>(<span>self, widths: Union[int, tuple, list, dict]) ‑> phi.field._field.Field</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for <code><a title="phi.field.pad" href="#phi.field.pad">pad()</a></code>.</p>
<p>Pads this <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> using its extrapolation.</p>
<p>Unlike padding the values, this function also affects the <code>geometry</code> of the field, changing its size and origin depending on <code>widths</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>widths</code></strong></dt>
<dd>Either <code>int</code> or <code>(lower, upper)</code> to pad the same number of cells in all spatial dimensions
or <code>dict</code> mapping dimension names to <code>(lower, upper)</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Padded <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code></p></div>
</dd>
<dt id="phi.field.Field.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>self, where: Union[phi.geom._geom.Geometry, ForwardRef('<a title="phi.field.Field" href="#phi.field.Field">Field</a>'), phiml.math._tensors.Tensor], at: str = 'center', **kwargs) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Sample the values of this <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> at the given location or geometry.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>where</code></strong></dt>
<dd>Location <code>Tensor</code> or <code>Geometry</code> or</dd>
<dt><strong><code>at</code></strong></dt>
<dd><code>'center'</code> or <code>'face'</code>.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Sampling arguments.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>Tensor</code></p></div>
</dd>
<dt id="phi.field.Field.shifted"><code class="name flex">
<span>def <span class="ident">shifted</span></span>(<span>self, delta: phiml.math._tensors.Tensor) ‑> phi.field._field.Field</span>
</code></dt>
<dd>
<div class="desc"><p>Move the positions of this field's <code>geometry</code> by <code>delta</code>.</p>
<p>See Also:
<code><a title="phi.field.Field.shifted_to" href="#phi.field.Field.shifted_to">Field.shifted_to()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>delta</code></strong></dt>
<dd>Shift amount for each center position of <code>geometry</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>New <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> sampled at <code>geometry.center + delta</code>.</p></div>
</dd>
<dt id="phi.field.Field.shifted_to"><code class="name flex">
<span>def <span class="ident">shifted_to</span></span>(<span>self, position: phiml.math._tensors.Tensor) ‑> phi.field._field.Field</span>
</code></dt>
<dd>
<div class="desc"><p>Move the positions of this field's <code>geometry</code> to <code>positions</code>.</p>
<p>See Also:
<code><a title="phi.field.Field.shifted" href="#phi.field.Field.shifted">Field.shifted()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>position</code></strong></dt>
<dd>New center positions of <code>geometry</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>New <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> sampled at given positions.</p></div>
</dd>
<dt id="phi.field.Field.staggered_tensor"><code class="name flex">
<span>def <span class="ident">staggered_tensor</span></span>(<span>self) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Stacks all component grids into a single uniform <code>phi.math.Tensor</code>.
The individual components are padded to a common (larger) shape before being stacked.
The shape of the returned tensor is exactly one cell larger than the grid <code>resolution</code> in every spatial dimension.</p>
<h2 id="returns">Returns</h2>
<p>Uniform <code>phi.math.Tensor</code>.</p></div>
</dd>
<dt id="phi.field.Field.to_grid"><code class="name flex">
<span>def <span class="ident">to_grid</span></span>(<span>self, resolution=(), bounds=None, **resolution_)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="phi.field.Field.uniform_values"><code class="name flex">
<span>def <span class="ident">uniform_values</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a uniform tensor containing <code>values</code>.</p>
<p>For periodic grids, which always have a uniform value tensor, `values' is returned directly.
If <code>values</code> is not uniform, it is padded as in <code>StaggeredGrid.staggered_tensor()</code>.</p></div>
</dd>
<dt id="phi.field.Field.with_boundary"><code class="name flex">
<span>def <span class="ident">with_boundary</span></span>(<span>self, boundary)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a copy of this field with the <code>boundary</code> replaced.</p></div>
</dd>
<dt id="phi.field.Field.with_bounds"><code class="name flex">
<span>def <span class="ident">with_bounds</span></span>(<span>self, bounds: phi.geom._box.Box)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a copy of this field with <code>bounds</code> replaced.</p></div>
</dd>
<dt id="phi.field.Field.with_elements"><code class="name flex">
<span>def <span class="ident">with_elements</span></span>(<span>self, elements: phi.geom._geom.Geometry)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a copy of this field with <code>elements</code> replaced.</p></div>
</dd>
<dt id="phi.field.Field.with_extrapolation"><code class="name flex">
<span>def <span class="ident">with_extrapolation</span></span>(<span>self, boundary)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a copy of this field with the <code>boundary</code> replaced.</p></div>
</dd>
<dt id="phi.field.Field.with_geometry"><code class="name flex">
<span>def <span class="ident">with_geometry</span></span>(<span>self, elements: phi.geom._geom.Geometry)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a copy of this field with <code>elements</code> replaced.</p></div>
</dd>
<dt id="phi.field.Field.with_values"><code class="name flex">
<span>def <span class="ident">with_values</span></span>(<span>self, values, **sampling_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a copy of this field with <code>values</code> replaced.</p></div>
</dd>
</dl>
</dd>
<dt id="phi.field.Field"><code class="flex name class">
<span>class <span class="ident">SampledField</span></span>
<span>(</span><span>geometry: Union[phiml.math._tensors.Tensor, phi.geom._geom.Geometry], values: Union[phiml.math._tensors.Tensor, numbers.Number, bool, Callable, phi.field._field.FieldInitializer, phi.geom._geom.Geometry, ForwardRef('<a title="phi.field.Field" href="#phi.field.Field">Field</a>')], boundary: Union[numbers.Number, phiml.math.extrapolation.Extrapolation, ForwardRef('<a title="phi.field.Field" href="#phi.field.Field">Field</a>'), dict] = 0, **sampling_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for all fields.</p>
<p>Important implementations:</p>
<ul>
<li>CenteredGrid</li>
<li>StaggeredGrid</li>
<li>PointCloud</li>
<li>Noise</li>
</ul>
<p>See the <code><a title="phi.field" href="#phi.field">phi.field</a></code> module documentation at <a href="https://tum-pbs.github.io/PhiFlow/Fields.html">https://tum-pbs.github.io/PhiFlow/Fields.html</a></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>elements</code></strong></dt>
<dd>Geometry object specifying the sample points and sizes</dd>
<dt><strong><code>values</code></strong></dt>
<dd>values corresponding to elements</dd>
<dt><strong><code>extrapolation</code></strong></dt>
<dd>values outside elements</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Field:
    &#34;&#34;&#34;
    Base class for all fields.
    
    Important implementations:
    
    * CenteredGrid
    * StaggeredGrid
    * PointCloud
    * Noise
    
    See the `phi.field` module documentation at https://tum-pbs.github.io/PhiFlow/Fields.html
    &#34;&#34;&#34;

    def __init__(self,
                 geometry: Union[Geometry, Tensor],
                 values: Union[Tensor, Number, bool, Callable, FieldInitializer, Geometry, &#39;Field&#39;],
                 boundary: Union[Number, Extrapolation, &#39;Field&#39;, dict] = 0,
                 **sampling_kwargs):
        &#34;&#34;&#34;
        Args:
          elements: Geometry object specifying the sample points and sizes
          values: values corresponding to elements
          extrapolation: values outside elements
        &#34;&#34;&#34;
        assert isinstance(geometry, Geometry), f&#34;geometry must be a Geometry object but got {type(geometry).__name__}&#34;
        self._boundary: Extrapolation = as_boundary(boundary, geometry)
        self._geometry: Geometry = geometry
        if isinstance(values, (Tensor, Number, bool)):
            values = wrap(values)
        else:
            from ._resample import sample
            values = sample(values, geometry, &#39;center&#39;, self._boundary, **sampling_kwargs)
        matching_sets = [s for s, s_shape in geometry.sets.items() if s_shape in values.shape]
        if not matching_sets:
            values = expand(wrap(values), non_batch(geometry) - &#39;vector&#39;)
        self._values: Tensor = values
        math.merge_shapes(values, non_batch(self.sampled_elements).non_channel)  # shape check

    @property
    def geometry(self) -&gt; Geometry:
        &#34;&#34;&#34;
        Returns a geometrical representation of the discrete volume elements.
        The result is a tuple of Geometry objects, each of which can have additional spatial (but not batch) dimensions.
        
        For grids, the geometries are boxes while particle fields may be represented as spheres.
        
        If this Field has no discrete points, this method returns an empty geometry.
        &#34;&#34;&#34;
        return self._geometry

    @property
    def mesh(self) -&gt; Mesh:
        &#34;&#34;&#34;Cast `self.geometry` to a `phi.geom.Mesh`.&#34;&#34;&#34;
        assert isinstance(self._geometry, Mesh), f&#34;Geometry is not a mesh but {type(self._geometry)}&#34;
        return self._geometry

    @property
    def graph(self) -&gt; Graph:
        &#34;&#34;&#34;Cast `self.geometry` to a `phi.geom.Graph`.&#34;&#34;&#34;
        assert isinstance(self._geometry, Graph), f&#34;Geometry is not a mesh but {type(self._geometry)}&#34;
        return self._geometry

    @property
    def faces(self):
        return get_faces(self._geometry, self._boundary)

    @property
    def face_centers(self):
        return self._geometry.face_centers
        # return slice_off_constant_faces(self._geometry.face_centers, self._geometry.boundary_faces, self._boundary)

    @property
    def face_normals(self):
        return self._geometry.face_normals
        # return slice_off_constant_faces(self._geometry.face_normals, self._geometry.boundary_faces, self._boundary)

    @property
    def face_areas(self):
        return self._geometry.face_areas
        # return slice_off_constant_faces(self._geometry.face_areas, self._geometry.boundary_faces, self._boundary)

    @property
    def sampled_elements(self) -&gt; Geometry:
        &#34;&#34;&#34;
        If the values represent are sampled at the element centers or represent the whole element, returns `self.geometry`.
        If the values are sampled at the faces, returns `self.faces`.
        &#34;&#34;&#34;
        return get_faces(self._geometry, self._boundary) if is_staggered(self._values, self._geometry) else self._geometry

    @property
    def elements(self):
        # raise SyntaxError(&#34;Field.elements is deprecated. Use Field.geometry or Field.sampled_elements instead.&#34;)
        warnings.warn(&#34;Field.elements is deprecated. Use Field.geometry or Field.sampled_elements instead. Field.elements now defaults to Field.geometry.&#34;, DeprecationWarning, stacklevel=2)
        return self._geometry

    @property
    def is_centered(self):
        return not self.is_staggered

    @property
    def is_staggered(self):
        return is_staggered(self._values, self._geometry)

    @property
    def center(self) -&gt; Tensor:
        &#34;&#34;&#34; Returns the center points of the `elements` of this `Field`. &#34;&#34;&#34;
        all_points = self._geometry.get_points(self.sampled_at)
        boundary = self._geometry.get_boundary(self.sampled_at)
        return slice_off_constant_faces(all_points, boundary, self.extrapolation)

    @property
    def points(self):
        return self.center

    @property
    def values(self) -&gt; Tensor:
        &#34;&#34;&#34; Returns the `values` of this `Field`. &#34;&#34;&#34;
        return self._values

    data = values

    def numpy(self, order: DimFilter = None):
        &#34;&#34;&#34;
        Return the field values as `NumPy` array(s).

        Args:
            order: Dimension order as `str` or `Shape`.

        Returns:
            A single NumPy array for uniform values, else a list of NumPy arrays.
        &#34;&#34;&#34;
        if order is None and self.is_grid:
            axes = self._values.shape.only(self._geometry.vector.item_names, reorder=True)
            order = concat_shapes(self._values.shape.dual, self._values.shape.batch, axes, self._values.shape.channel)
        if self._values.shape.is_uniform:
            return self._values.numpy(order)
        else:
            assert order is not None, f&#34;order must be specified for non-uniform Field values&#34;
            order = self._values.shape.only(order, reorder=True)
            stack_dims = order.non_uniform_shape
            inner_order = order.without(stack_dims)
            return [v.numpy(inner_order) for v in unstack(self._values, stack_dims)]

    def uniform_values(self):
        &#34;&#34;&#34;
        Returns a uniform tensor containing `values`.

        For periodic grids, which always have a uniform value tensor, `values&#39; is returned directly.
        If `values` is not uniform, it is padded as in `StaggeredGrid.staggered_tensor()`.
        &#34;&#34;&#34;
        if self.values.shape.is_uniform:
            return self.values
        else:
            return self.staggered_tensor()

    @property
    def boundary(self) -&gt; Extrapolation:
        &#34;&#34;&#34;
        Returns the boundary conditions set for this `Field`.

        Returns:
            Single `Extrapolation` instance that encodes the (varying) boundary conditions for all boundaries of this field&#39;s `elements`.
        &#34;&#34;&#34;
        return self._boundary

    @property
    def extrapolation(self) -&gt; Extrapolation:
        &#34;&#34;&#34; Returns the `Extrapolation` of this `Field`. &#34;&#34;&#34;
        return self._boundary

    @property
    def shape(self) -&gt; Shape:
        &#34;&#34;&#34;
        Returns a shape with the following properties
        
        * The spatial dimension names match the dimensions of this Field
        * The batch dimensions match the batch dimensions of this Field
        * The channel dimensions match the channels of this Field
        &#34;&#34;&#34;
        if self.is_staggered and self.is_grid:
            return batch(self._geometry) &amp; self.resolution &amp; non_dual(self._values).without(self.resolution) &amp; self._geometry.shape[&#39;vector&#39;]
        set_shape = self._geometry.sets[self.sampled_at]
        return batch(self._geometry) &amp; (channel(self._geometry) - &#39;vector&#39;) &amp; set_shape &amp; self._values

    @property
    def resolution(self):
        return self._geometry.shape.non_channel.non_dual.non_batch

    @property
    def spatial_rank(self) -&gt; int:
        &#34;&#34;&#34;
        Spatial rank of the field (1 for 1D, 2 for 2D, 3 for 3D).
        This is equal to the spatial rank of the `data`.
        &#34;&#34;&#34;
        return self._geometry.spatial_rank

    @property
    def bounds(self) -&gt; BaseBox:
        &#34;&#34;&#34;
        The bounds represent the area inside which the values of this `Field` are valid.
        The bounds will also be used as axis limits for plots.

        The bounds can be set manually in the constructor, otherwise default bounds will be generated.

        For fields that are valid without bounds, the lower and upper limit of `bounds` is set to `-inf` and `inf`, respectively.

        Fields whose spatial rank is determined only during sampling return an empty `Box`.
        &#34;&#34;&#34;
        if isinstance(self._geometry.bounds, BaseBox):
            return self._geometry.bounds
        extent = self._geometry.bounding_half_extent().vector.as_dual(&#39;_extent&#39;)
        points = self._geometry.center + extent
        lower = math.min(points, dim=points.shape.non_batch.non_channel)
        upper = math.max(points, dim=points.shape.non_batch.non_channel)
        return Box(lower, upper)

    box = bounds

    @property
    def is_grid(self):
        &#34;&#34;&#34;A Field represents grid data if its `geometry` is a `phi.geom.UniformGrid` instance.&#34;&#34;&#34;
        return isinstance(self._geometry, UniformGrid)

    @property
    def is_mesh(self):
        &#34;&#34;&#34;A Field represents mesh data if its `geometry` is a `phi.geom.Mesh` instance.&#34;&#34;&#34;
        return isinstance(self._geometry, Mesh)

    @property
    def is_graph(self):
        &#34;&#34;&#34;A Field represents graph data if its `geometry` is a `phi.geom.Graph` instance.&#34;&#34;&#34;
        return isinstance(self._geometry, Graph)

    @property
    def is_point_cloud(self):
        &#34;&#34;&#34;A Field represents graph data if its `geometry` is not a set of connected elements, but rather individual geometric objects.&#34;&#34;&#34;
        if isinstance(self._geometry, (UniformGrid, Mesh, Graph)):
            return False
        if isinstance(self._geometry, (BaseBox, Sphere, Point)):
            return True
        return True

    @property
    def dx(self) -&gt; Tensor:
        assert spatial(self._geometry), f&#34;dx is only defined for elements with spatial dims but Field has elements {self._geometry.shape}&#34;
        return self.bounds.size / self.resolution

    @property
    def cells(self):
        assert isinstance(self._geometry, (UniformGrid, Mesh))
        return self._geometry

    def to_grid(self, resolution=math.EMPTY_SHAPE, bounds=None, **resolution_):
        resolution = resolution.spatial &amp; spatial(**resolution_)
        if self.is_grid and (not resolution or resolution == self.resolution) and (bounds is None or bounds == self.bounds):
            return self
        bounds = self.bounds if bounds is None else bounds
        if not resolution:
            half_sizes = self._geometry.bounding_half_extent()
            if (half_sizes &gt; 0).all:
                size = math.min(2 * half_sizes, non_batch(half_sizes).non_channel)
            else:
                cell_count = non_batch(self._geometry).non_channel.non_dual.volume
                size = (bounds.volume / cell_count) ** (1 / self.spatial_rank)
            res = math.maximum(1, math.round(bounds.size / size))
            resolution = spatial(**res.vector)
        return Field(UniformGrid(resolution, bounds), self, self.boundary)

    def as_points(self, list_dim: Optional[Shape] = instance(&#39;elements&#39;)) -&gt; &#39;Field&#39;:
        &#34;&#34;&#34;
        Returns this field as a PointCloud.
        This replaces the `Field.geometry` with a `phi.geom.Point` instance while leaving the sample points unchanged.

        See Also:
            `Field.as_spheres()`.

        Args:
            list_dim: If not `None`, packs spatial, instance and dual dims.
                Defaults to `instance(&#39;elements&#39;)`.

        Returns:
            `Field` with same values and boundaries but `Point` geometry.
        &#34;&#34;&#34;
        points = self.sampled_elements.center
        values = self._values
        if list_dim:
            dims = non_batch(points).non_channel &amp; non_batch(points).non_channel
            points = pack_dims(points, dims, list_dim)
            values = pack_dims(values, dims, list_dim)
        return Field(Point(points), values, self._boundary)

    def as_spheres(self, list_dim: Optional[Shape] = instance(&#39;elements&#39;)) -&gt; &#39;Field&#39;:
        &#34;&#34;&#34;
        Returns this field as a PointCloud with spherical / circular elements, preserving element volumes.
        This replaces the `Field.geometry` with a `phi.geom.Sphere` instance while leaving the sample points unchanged.

        See Also:
            `Field.as_points()`.

        Args:
            list_dim: If not `None`, packs spatial, instance and dual dims.
                Defaults to `instance(&#39;elements&#39;)`.

        Returns:
            `Field` with same values and boundaries but `Sphere` geometry.
        &#34;&#34;&#34;
        points = self.sampled_elements.center
        volumes = self.sampled_elements.volume
        values = self._values
        if list_dim:
            dims = non_batch(points).non_channel &amp; non_batch(points).non_channel
            points = pack_dims(points, dims, list_dim)
            values = pack_dims(values, dims, list_dim)
            volumes = pack_dims(volumes, dims, list_dim)
        return Field(Sphere(points, volume=volumes), values, self._boundary)

    def at_centers(self, **kwargs) -&gt; &#39;Field&#39;:
        &#34;&#34;&#34;
        Interpolates the values to the cell centers.

        See Also:
            `Field.at_faces()`, `Field.at()`, `resample`.

        Args:
            **kwargs: Sampling arguments.

        Returns:
            `CenteredGrid` sampled at cell centers.
        &#34;&#34;&#34;
        if self.is_centered:
            return self
        from ._resample import sample
        values = sample(self, self._geometry, at=&#39;center&#39;, boundary=self._boundary, **kwargs)
        return Field(self._geometry, values, self._boundary)

    def at_faces(self, boundary=None, **kwargs) -&gt; &#39;Field&#39;:
        if self.is_staggered and not boundary:
            return self
        boundary = as_boundary(boundary, self._geometry) if boundary else self._boundary
        from ._resample import sample
        values = sample(self, self._geometry, at=&#39;face&#39;, boundary=boundary, **kwargs)
        return Field(self._geometry, values, boundary)

    @property
    def sampled_at(self):
        matching_sets = [s for s, s_shape in self._geometry.sets.items() if s_shape in self._values.shape]
        return matching_sets[-1]

    def at(self, representation: Union[&#39;Field&#39;, Geometry], keep_boundary=False, **kwargs) -&gt; &#39;Field&#39;:
        &#34;&#34;&#34;
        Short for `resample(self, representation)`

        See Also
            `resample()`.

        Returns:
            Field object of same type as `representation`
        &#34;&#34;&#34;
        from ._resample import resample
        return resample(self, representation, keep_boundary, **kwargs)

    def sample(self, where: Union[Geometry, &#39;Field&#39;, Tensor], at: str = &#39;center&#39;, **kwargs) -&gt; &#39;Tensor&#39;:
        &#34;&#34;&#34;
        Sample the values of this `Field` at the given location or geometry.

        Args:
            where: Location `Tensor` or `Geometry` or
            at: `&#39;center&#39;` or `&#39;face&#39;`.
            **kwargs: Sampling arguments.

        Returns:
            `Tensor`
        &#34;&#34;&#34;
        from ._resample import sample
        return sample(self, where, at, **kwargs)

    def closest_values(self, points: Tensor):
        &#34;&#34;&#34;
        Sample the closest grid point values of this field at the world-space locations (in physical units) given by `points`.
        Points must have a single channel dimension named `vector`.
        It may additionally contain any number of batch and spatial dimensions, all treated as batch dimensions.

        Args:
            points: world-space locations

        Returns:
            Closest grid point values as a `Tensor`.
            For each dimension, the grid points immediately left and right of the sample points are evaluated.
            For each point in `points`, a *2^d* cube of points is determined where *d* is the number of spatial dimensions of this field.
            These values are stacked along the new dimensions `&#39;closest_&lt;dim&gt;&#39;` where `&lt;dim&gt;` refers to the name of a spatial dimension.
        &#34;&#34;&#34;
        warnings.warn(&#34;Field.closest_values() is deprecated.&#34;, DeprecationWarning, stacklevel=2)
        if isinstance(points, Geometry):
            points = points.center
        # --- CenteredGrid ---
        local_points = self.box.global_to_local(points) * self.resolution - 0.5
        return math.closest_grid_values(self.values, local_points, self.extrapolation)
        # --- StaggeredGrid ---
        if &#39;staggered_direction&#39; in points.shape:
            points_ = math.unstack(points, &#39;~vector&#39;)
            channels = [component.closest_values(p) for p, component in zip(points_, self.vector.unstack())]
        else:
            channels = [component.closest_values(points) for component in self.vector.unstack()]
        return math.stack(channels, points.shape[&#39;~vector&#39;])

    def with_values(self, values, **sampling_kwargs):
        &#34;&#34;&#34; Returns a copy of this field with `values` replaced. &#34;&#34;&#34;
        if not isinstance(values, (Tensor, Number)):
            from ._resample import sample
            values = sample(values, self._geometry, self.sampled_at, self._boundary, dot_face_normal=self._geometry if &#39;vector&#39; not in self._values.shape else None, **sampling_kwargs)
        else:
            if not spatial(values):
                geo_shape = self.sampled_elements.shape if self.is_staggered else self._geometry.shape
                if &#39;~vector&#39; in geo_shape and &#39;vector&#39; in shape(values) and &#39;~vector&#39; not in shape(values):
                    values = values.vector.as_dual()
                values = expand(wrap(values), geo_shape.non_batch.non_channel)
        return Field(self._geometry, values, self._boundary)

    def with_boundary(self, boundary):
        &#34;&#34;&#34; Returns a copy of this field with the `boundary` replaced. &#34;&#34;&#34;
        boundary = as_boundary(boundary, self._geometry)
        boundary_elements = &#39;boundary_faces&#39; if self.is_staggered else &#39;boundary_elements&#39;
        old_determined_slices = {k: s for k, s in getattr(self._geometry, boundary_elements).items() if self._boundary.determines_boundary_values(k)}
        new_determined_slices = {k: s for k, s in getattr(self._geometry, boundary_elements).items() if boundary.determines_boundary_values(k)}
        if old_determined_slices.values() == new_determined_slices.values():
            return Field(self._geometry, self._values, boundary)  # ToDo unnecessary once the rest is implemented
        to_add = {k: sl for k, sl in old_determined_slices.items() if sl not in new_determined_slices.values()}
        to_remove = [sl for sl in new_determined_slices.values() if sl not in old_determined_slices.values()]
        values = math.slice_off(self._values, *to_remove)
        if to_add:
            if self.is_mesh:
                values = self.mesh.pad_boundary(values, to_add, self._boundary)
            elif self.is_grid and self.is_staggered:
                values = self._values.vector.dual.as_channel()
                to_add = {k: {&#39;vector&#39; if dim == &#39;~vector&#39; else dim: v for dim, v in sl.items()} for k, sl in to_add.items()}
                values = math.pad(values, list(to_add.values()), self._boundary, bounds=self.bounds)
                values = values.vector.as_dual()
            else:
                values = math.pad(values, list(to_add.values()), self._boundary, bounds=self.bounds)
        return Field(self._geometry, values, boundary)

    with_extrapolation = with_boundary

    def with_bounds(self, bounds: Box):
        &#34;&#34;&#34; Returns a copy of this field with `bounds` replaced. &#34;&#34;&#34;
        order = list(bounds.vector.item_names)
        geometry = self._geometry.vector[order]
        new_shape = self._values.shape.without(order) &amp; self._values.shape.only(order, reorder=True)
        values = math.transpose(self._values, new_shape)
        return Field(geometry, values, self._boundary)

    def with_geometry(self, elements: Geometry):
        &#34;&#34;&#34; Returns a copy of this field with `elements` replaced. &#34;&#34;&#34;
        assert non_batch(elements) == non_batch(self._geometry), f&#34;Field.with_elements() only accepts elements with equal non-batch dimensions but got {elements.shape} for Field with shape {self._geometry.shape}&#34;
        return Field(elements, self._values, self._boundary)

    with_elements = with_geometry

    def shifted(self, delta: Tensor) -&gt; &#39;Field&#39;:
        &#34;&#34;&#34;
        Move the positions of this field&#39;s `geometry` by `delta`.

        See Also:
            `Field.shifted_to`.

        Args:
            delta: Shift amount for each center position of `geometry`.

        Returns:
            New `Field` sampled at `geometry.center + delta`.
        &#34;&#34;&#34;
        return self.with_geometry(self._geometry.shifted(delta))

    def shifted_to(self, position: Tensor) -&gt; &#39;Field&#39;:
        &#34;&#34;&#34;
        Move the positions of this field&#39;s `geometry` to `positions`.

        See Also:
            `Field.shifted`.

        Args:
            position: New center positions of `geometry`.

        Returns:
            New `Field` sampled at given positions.
        &#34;&#34;&#34;
        return self.with_geometry(self._geometry.at(position))

    def pad(self, widths: Union[int, tuple, list, dict]) -&gt; &#39;Field&#39;:
        &#34;&#34;&#34;
        Alias for `phi.field.pad()`.

        Pads this `Field` using its extrapolation.

        Unlike padding the values, this function also affects the `geometry` of the field, changing its size and origin depending on `widths`.

        Args:
            widths: Either `int` or `(lower, upper)` to pad the same number of cells in all spatial dimensions
                or `dict` mapping dimension names to `(lower, upper)`.

        Returns:
            Padded `Field`
        &#34;&#34;&#34;
        from ._field_math import pad
        return pad(self, widths)

    def gradient(self,
                 boundary: Extrapolation = None,
                 at: str = &#39;center&#39;,
                 dims: math.DimFilter = spatial,
                 stack_dim: Union[Shape, str] = channel(&#39;vector&#39;),
                 order=2,
                 implicit: Solve = None,
                 scheme=None,
                 upwind: &#39;Field&#39; = None,
                 gradient_extrapolation: Extrapolation = None):
        &#34;&#34;&#34;Alias for `phi.field.spatial_gradient`&#34;&#34;&#34;
        from ._field_math import spatial_gradient
        return spatial_gradient(self, boundary=boundary, at=at, dims=dims, stack_dim=stack_dim, order=order, implicit=implicit, scheme=scheme, upwind=upwind, gradient_extrapolation=gradient_extrapolation)

    def divergence(self, order=2, implicit: Solve = None, upwind: &#39;Field&#39; = None):
        &#34;&#34;&#34;Alias for `phi.field.divergence`&#34;&#34;&#34;
        from ._field_math import divergence
        return divergence(self, order=order, implicit=implicit, upwind=upwind)

    def curl(self, at=&#39;corner&#39;):
        &#34;&#34;&#34;Alias for `phi.field.curl`&#34;&#34;&#34;
        from ._field_math import curl
        return curl(self, at=at)

    def laplace(self,
                axes: DimFilter = spatial,
                gradient: &#39;Field&#39; = None,
                order=2,
                implicit: math.Solve = None,
                weights: Union[Tensor, &#39;Field&#39;] = None,
                upwind: &#39;Field&#39; = None,
                correct_skew=True):
        &#34;&#34;&#34;Alias for `phi.field.laplace`&#34;&#34;&#34;
        from ._field_math import laplace
        return laplace(self, axes=axes, gradient=gradient, order=order, implicit=implicit, weights=weights, upwind=upwind, correct_skew=correct_skew)

    def downsample(self, factor: int):
        from ._field_math import downsample2x
        result = self
        while factor &gt;= 2:
            result = downsample2x(result)
            factor /= 2
        if math.close(factor, 1.):
            return result
        from ._resample import resample
        raise NotImplementedError(f&#34;downsample does not support fractional re-sampling. Only 2^n currently supported.&#34;)

    def staggered_tensor(self) -&gt; Tensor:
        &#34;&#34;&#34;
        Stacks all component grids into a single uniform `phi.math.Tensor`.
        The individual components are padded to a common (larger) shape before being stacked.
        The shape of the returned tensor is exactly one cell larger than the grid `resolution` in every spatial dimension.

        Returns:
            Uniform `phi.math.Tensor`.
        &#34;&#34;&#34;
        assert self.resolution.names == self.shape.get_item_names(&#39;vector&#39;), &#34;Field.staggered_tensor() only defined for Fields whose vector components match the resolution&#34;
        padded = []
        for dim, component in zip(self.resolution.names, self.vector):
            widths = {d: (0, 1) for d in self.resolution.names}
            lo_valid, up_valid = self.extrapolation.valid_outer_faces(dim)
            widths[dim] = (int(not lo_valid), int(not up_valid))
            padded.append(math.pad(component.values, widths, self.extrapolation[{&#39;vector&#39;: dim}], bounds=self.bounds))
        result = math.stack(padded, channel(vector=self.resolution))
        assert result.shape.is_uniform
        return result

    @staticmethod
    def __stack__(values: tuple, dim: Shape, **kwargs) -&gt; &#39;Field&#39;:
        from ._field_math import stack
        return stack(values, dim, kwargs.get(&#39;bounds&#39;, None))

    @staticmethod
    def __concat__(values: tuple, dim: str, **kwargs) -&gt; &#39;Field&#39;:
        from ._field_math import concat
        return concat(values, dim)

    def __and__(self, other):
        assert isinstance(other, Field)
        assert instance(self).rank == instance(other).rank == 1, f&#34;Can only use &amp; on PointClouds that have a single instance dimension but got shapes {self.shape} &amp; {other.shape}&#34;
        from ._field_math import concat
        return concat([self, other], instance(self))

    def __matmul__(self, other: &#39;Field&#39;):  # value @ representation
        # Deprecated. Use `resample(value, field)` instead.
        warnings.warn(&#34;value @ field is deprecated. Use resample(value, field) instead.&#34;, DeprecationWarning)
        from ._resample import resample
        return resample(self, to=other, keep_boundary=False)

    def __rmatmul__(self, other):  # values @ representation
        if isinstance(other, (Geometry, Number, tuple, list, FieldInitializer)):
            warnings.warn(&#34;value @ field is deprecated. Use resample(value, field) instead.&#34;, DeprecationWarning)
            from ._resample import resample
            return resample(other, to=self, keep_boundary=False)
        return NotImplemented

    def __rshift__(self, other):
        if isinstance(other, (Field, Geometry)):
            warnings.warn(&#34;&gt;&gt; operator for Fields is deprecated. Use field.at(), the constructor or obj @ field instead.&#34;, SyntaxWarning, stacklevel=2)
            return self.at(other, keep_boundary=False)
        else:
            return NotImplemented

    def __rrshift__(self, other):
        return self.with_values(other)

    def __lshift__(self, other):
        return self.with_values(other)

    def __rrshift__(self, other):
        warnings.warn(&#34;&gt;&gt; operator for Fields is deprecated. Use field.at(), the constructor or obj @ field instead.&#34;, SyntaxWarning, stacklevel=2)
        if not isinstance(self, Field):
            return NotImplemented
        if isinstance(other, (Geometry, float, int, complex, tuple, list, FieldInitializer)):
            from ._resample import resample
            return resample(other, to=self, keep_boundary=False)
        return NotImplemented

    def __getitem__(self, item) -&gt; &#39;Field&#39;:
        &#34;&#34;&#34;
        Access a slice of the Field.
        The returned `Field` may be of a different type than `self`.

        Args:
            item: `dict` mapping dimensions (`str`) to selections (`int` or `slice`) or other supported type, such as `int` or `str`.

        Returns:
            Sliced `Field`.
        &#34;&#34;&#34;
        item = slicing_dict(self, item)
        if not item:
            return self
        boundary = domain_slice(self._boundary, item, self.resolution)
        item_without_vec = {dim: selection for dim, selection in item.items() if dim != &#39;vector&#39;}
        geometry = self._geometry[item_without_vec]
        if self.is_staggered and &#39;vector&#39; in item and &#39;~vector&#39; in self.geometry.face_shape:
            assert isinstance(self._geometry, UniformGrid), f&#34;Vector slicing is only supported for grids&#34;
            dims = item[&#39;vector&#39;]
            dims_ = self._geometry.shape[&#39;vector&#39;].after_gather({&#39;vector&#39;: dims})
            dims = dims_.item_names[0] if dims_ else [dims] if isinstance(dims, str) else [self._geometry.shape[&#39;vector&#39;].item_names[0][dims]]
            proj_dims = set(self.resolution.names) - set(dims)
            if any(dim not in item for dim in proj_dims):
                # warnings.warn(f&#34;Projecting a staggered grid (by slicing &#39;vector&#39; without the corresponding spatial dims) will return a non-staggered grid. The projected dims {proj_dims} were not sliced off.\nFull slice: {item}&#34;)
                item[&#39;~vector&#39;] = item[&#39;vector&#39;]
                del item[&#39;vector&#39;]
                geometry = self.sampled_elements[item]
            else:
                item[&#39;~vector&#39;] = dims
                del item[&#39;vector&#39;]
        values = self._values[item]
        return Field(geometry, values, boundary)

    def __getattr__(self, name: str) -&gt; BoundDim:
        return BoundDim(self, name)

    def dimension(self, name: str):
        &#34;&#34;&#34;
        Returns a reference to one of the dimensions of this field.

        The dimension reference can be used the same way as a `Tensor` dimension reference.
        Notable properties and methods of a dimension reference are:
        indexing using `[index]`, `unstack()`, `size`, `exists`, `is_batch`, `is_spatial`, `is_channel`.

        A shortcut to calling this function is the syntax `field.&lt;dim_name&gt;` which calls `field.dimension(&lt;dim_name&gt;)`.

        Args:
            name: dimension name

        Returns:
            dimension reference

        &#34;&#34;&#34;
        return BoundDim(self, name)

    def __value_attrs__(self):
        return &#39;_values&#39;,

    def __variable_attrs__(self):
        return &#39;_values&#39;, &#39;_geometry&#39;, &#39;_boundary&#39;

    def __expand__(self, dims: Shape, **kwargs) -&gt; &#39;Field&#39;:
        return self.with_values(expand(self.values, dims, **kwargs))

    def __replace_dims__(self, dims: Tuple[str, ...], new_dims: Shape, **kwargs) -&gt; &#39;Field&#39;:
        elements = math.rename_dims(self._geometry, dims, new_dims)
        values = math.rename_dims(self._values, dims, new_dims)
        extrapolation = math.rename_dims(self._boundary, dims, new_dims, **kwargs)
        return Field(elements, values, extrapolation)

    def __eq__(self, other):
        if not isinstance(other, Field):
            return False
        if self._geometry != other._geometry:
            return False
        if self._boundary != other.boundary:
            return False
        return math.always_close(self._values, other._values)

    def __hash__(self):
        return hash((self._geometry, self._boundary))

    def __mul__(self, other):
        return self._op2(other, lambda d1, d2: d1 * d2)

    __rmul__ = __mul__

    def __truediv__(self, other):
        return self._op2(other, lambda d1, d2: d1 / d2)

    def __rtruediv__(self, other):
        return self._op2(other, lambda d1, d2: d2 / d1)

    def __sub__(self, other):
        return self._op2(other, lambda d1, d2: d1 - d2)

    def __rsub__(self, other):
        return self._op2(other, lambda d1, d2: d2 - d1)

    def __add__(self, other):
        return self._op2(other, lambda d1, d2: d1 + d2)

    __radd__ = __add__

    def __pow__(self, power, modulo=None):
        return self._op2(power, lambda f, p: f ** p)

    def __neg__(self):
        return self._op1(lambda x: -x)

    def __gt__(self, other):
        return self._op2(other, lambda x, y: x &gt; y)

    def __ge__(self, other):
        return self._op2(other, lambda x, y: x &gt;= y)

    def __lt__(self, other):
        return self._op2(other, lambda x, y: x &lt; y)

    def __le__(self, other):
        return self._op2(other, lambda x, y: x &lt;= y)

    def __abs__(self):
        return self._op1(lambda x: abs(x))

    def _op1(self: &#39;Field&#39;, operator: Callable) -&gt; &#39;Field&#39;:
        &#34;&#34;&#34;
        Perform an operation on the data of this field.

        Args:
          operator: function that accepts tensors and extrapolations and returns objects of the same type and dimensions

        Returns:
          Field of same type
        &#34;&#34;&#34;
        values = operator(self.values)
        extrapolation_ = operator(self._boundary)
        return self.with_values(values).with_extrapolation(extrapolation_)

    def _op2(self, other, operator) -&gt; &#39;Field&#39;:
        if isinstance(other, Geometry):
            raise ValueError(f&#34;Cannot combine {self.__class__.__name__} with a Geometry, got {type(other)}&#34;)
        if isinstance(other, Field):
            if self._geometry == other._geometry:
                values = operator(self._values, other.values)
                extrapolation_ = operator(self._boundary, other.extrapolation)
                return Field(self._geometry, values, extrapolation_)
            from ._resample import sample
            other_values = sample(other, self._geometry, self.sampled_at, self.boundary, dot_face_normal=self._geometry)
            values = operator(self._values, other_values)
            boundary = operator(self._boundary, other.extrapolation)
            return Field(self._geometry, values, boundary)
        else:
            if isinstance(other, (tuple, list)) and len(other) == self.spatial_rank:
                other = math.wrap(other, self._geometry.shape[&#39;vector&#39;])
            else:
                other = math.wrap(other)
            # try:
            #     boundary = operator(self._boundary, as_boundary(other, self._geometry))
            # except TypeError:  # e.g. ZERO_GRADIENT + constant
            boundary = self._boundary  # constants don&#39;t affect the boundary conditions (legacy reasons)
            if &#39;vector&#39; in self.shape and &#39;vector&#39; not in self.values.shape and &#39;~vector&#39; in self.values.shape:
                other = other.vector.as_dual()
            values = operator(self._values, other)
            return Field(self._geometry, values, boundary)

    def __repr__(self):
        if self.is_grid:
            type_name = &#34;Grid&#34; if self.is_centered else &#34;Grid faces&#34;
        elif self.is_mesh:
            type_name = &#34;Mesh&#34; if self.is_centered else &#34;Mesh faces&#34;
        elif self.is_point_cloud:
            type_name = &#34;Point cloud&#34; if self.is_centered else &#34;Point cloud edges&#34;
        elif self.is_graph:
            type_name = &#34;Graph&#34; if self.is_centered else &#34;Graph edges&#34;
        else:
            type_name = self.__class__.__name__
        if self._values is not None:
            return f&#34;{type_name}[{self.values}, ext={self._boundary}]&#34;
        else:
            return f&#34;{type_name}[{self.resolution}, ext={self._boundary}]&#34;

    def grid_scatter(self, *args, **kwargs):
        &#34;&#34;&#34;Deprecated. Use `sample` with `scatter=True` instead.&#34;&#34;&#34;
        warnings.warn(&#34;Field.grid_scatter() is deprecated. Use field.sample() with scatter=True instead.&#34;, DeprecationWarning, stacklevel=2)
        from ._resample import grid_scatter
        return grid_scatter(self, *args, **kwargs)

    def as_boundary(self) -&gt; Extrapolation:
        &#34;&#34;&#34;
        Returns an `Extrapolation` representing this &#39;Field&#39;&#39;s values as a Dirichlet (constant) boundary.
        If this `Field` encloses the required boundaries, its values will be interpolated to the required boundaries.
        If boundaries outside of this `Field`&#39;s sampled domain are required, this `Field`&#39;s boundary conditions will be applied to determine the boundary values.

        Returns:
            `Extrapolation`
        &#34;&#34;&#34;
        from ._embed import FieldEmbedding
        return FieldEmbedding(self)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li>phi.field._mask.HardGeometryMask</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="phi.field.Field.boundary"><code class="name">prop <span class="ident">boundary</span> : phiml.math.extrapolation.Extrapolation</code></dt>
<dd>
<div class="desc"><p>Returns the boundary conditions set for this <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code>.</p>
<h2 id="returns">Returns</h2>
<p>Single <code>Extrapolation</code> instance that encodes the (varying) boundary conditions for all boundaries of this field's <code>elements</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def boundary(self) -&gt; Extrapolation:
    &#34;&#34;&#34;
    Returns the boundary conditions set for this `Field`.

    Returns:
        Single `Extrapolation` instance that encodes the (varying) boundary conditions for all boundaries of this field&#39;s `elements`.
    &#34;&#34;&#34;
    return self._boundary</code></pre>
</details>
</dd>
<dt id="phi.field.Field.bounds"><code class="name">prop <span class="ident">bounds</span> : phi.geom._box.BaseBox</code></dt>
<dd>
<div class="desc"><p>The bounds represent the area inside which the values of this <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> are valid.
The bounds will also be used as axis limits for plots.</p>
<p>The bounds can be set manually in the constructor, otherwise default bounds will be generated.</p>
<p>For fields that are valid without bounds, the lower and upper limit of <code>bounds</code> is set to <code>-inf</code> and <code>inf</code>, respectively.</p>
<p>Fields whose spatial rank is determined only during sampling return an empty <code>Box</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bounds(self) -&gt; BaseBox:
    &#34;&#34;&#34;
    The bounds represent the area inside which the values of this `Field` are valid.
    The bounds will also be used as axis limits for plots.

    The bounds can be set manually in the constructor, otherwise default bounds will be generated.

    For fields that are valid without bounds, the lower and upper limit of `bounds` is set to `-inf` and `inf`, respectively.

    Fields whose spatial rank is determined only during sampling return an empty `Box`.
    &#34;&#34;&#34;
    if isinstance(self._geometry.bounds, BaseBox):
        return self._geometry.bounds
    extent = self._geometry.bounding_half_extent().vector.as_dual(&#39;_extent&#39;)
    points = self._geometry.center + extent
    lower = math.min(points, dim=points.shape.non_batch.non_channel)
    upper = math.max(points, dim=points.shape.non_batch.non_channel)
    return Box(lower, upper)</code></pre>
</details>
</dd>
<dt id="phi.field.Field.box"><code class="name">prop <span class="ident">box</span> : phi.geom._box.BaseBox</code></dt>
<dd>
<div class="desc"><p>The bounds represent the area inside which the values of this <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> are valid.
The bounds will also be used as axis limits for plots.</p>
<p>The bounds can be set manually in the constructor, otherwise default bounds will be generated.</p>
<p>For fields that are valid without bounds, the lower and upper limit of <code>bounds</code> is set to <code>-inf</code> and <code>inf</code>, respectively.</p>
<p>Fields whose spatial rank is determined only during sampling return an empty <code>Box</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bounds(self) -&gt; BaseBox:
    &#34;&#34;&#34;
    The bounds represent the area inside which the values of this `Field` are valid.
    The bounds will also be used as axis limits for plots.

    The bounds can be set manually in the constructor, otherwise default bounds will be generated.

    For fields that are valid without bounds, the lower and upper limit of `bounds` is set to `-inf` and `inf`, respectively.

    Fields whose spatial rank is determined only during sampling return an empty `Box`.
    &#34;&#34;&#34;
    if isinstance(self._geometry.bounds, BaseBox):
        return self._geometry.bounds
    extent = self._geometry.bounding_half_extent().vector.as_dual(&#39;_extent&#39;)
    points = self._geometry.center + extent
    lower = math.min(points, dim=points.shape.non_batch.non_channel)
    upper = math.max(points, dim=points.shape.non_batch.non_channel)
    return Box(lower, upper)</code></pre>
</details>
</dd>
<dt id="phi.field.Field.cells"><code class="name">prop <span class="ident">cells</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cells(self):
    assert isinstance(self._geometry, (UniformGrid, Mesh))
    return self._geometry</code></pre>
</details>
</dd>
<dt id="phi.field.Field.center"><code class="name">prop <span class="ident">center</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p>Returns the center points of the <code>elements</code> of this <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def center(self) -&gt; Tensor:
    &#34;&#34;&#34; Returns the center points of the `elements` of this `Field`. &#34;&#34;&#34;
    all_points = self._geometry.get_points(self.sampled_at)
    boundary = self._geometry.get_boundary(self.sampled_at)
    return slice_off_constant_faces(all_points, boundary, self.extrapolation)</code></pre>
</details>
</dd>
<dt id="phi.field.Field.data"><code class="name">prop <span class="ident">data</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p>Returns the <code>values</code> of this <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def values(self) -&gt; Tensor:
    &#34;&#34;&#34; Returns the `values` of this `Field`. &#34;&#34;&#34;
    return self._values</code></pre>
</details>
</dd>
<dt id="phi.field.Field.dx"><code class="name">prop <span class="ident">dx</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def dx(self) -&gt; Tensor:
    assert spatial(self._geometry), f&#34;dx is only defined for elements with spatial dims but Field has elements {self._geometry.shape}&#34;
    return self.bounds.size / self.resolution</code></pre>
</details>
</dd>
<dt id="phi.field.Field.elements"><code class="name">prop <span class="ident">elements</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def elements(self):
    # raise SyntaxError(&#34;Field.elements is deprecated. Use Field.geometry or Field.sampled_elements instead.&#34;)
    warnings.warn(&#34;Field.elements is deprecated. Use Field.geometry or Field.sampled_elements instead. Field.elements now defaults to Field.geometry.&#34;, DeprecationWarning, stacklevel=2)
    return self._geometry</code></pre>
</details>
</dd>
<dt id="phi.field.Field.extrapolation"><code class="name">prop <span class="ident">extrapolation</span> : phiml.math.extrapolation.Extrapolation</code></dt>
<dd>
<div class="desc"><p>Returns the <code>Extrapolation</code> of this <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def extrapolation(self) -&gt; Extrapolation:
    &#34;&#34;&#34; Returns the `Extrapolation` of this `Field`. &#34;&#34;&#34;
    return self._boundary</code></pre>
</details>
</dd>
<dt id="phi.field.Field.face_areas"><code class="name">prop <span class="ident">face_areas</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_areas(self):
    return self._geometry.face_areas
    # return slice_off_constant_faces(self._geometry.face_areas, self._geometry.boundary_faces, self._boundary)</code></pre>
</details>
</dd>
<dt id="phi.field.Field.face_centers"><code class="name">prop <span class="ident">face_centers</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_centers(self):
    return self._geometry.face_centers
    # return slice_off_constant_faces(self._geometry.face_centers, self._geometry.boundary_faces, self._boundary)</code></pre>
</details>
</dd>
<dt id="phi.field.Field.face_normals"><code class="name">prop <span class="ident">face_normals</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_normals(self):
    return self._geometry.face_normals
    # return slice_off_constant_faces(self._geometry.face_normals, self._geometry.boundary_faces, self._boundary)</code></pre>
</details>
</dd>
<dt id="phi.field.Field.faces"><code class="name">prop <span class="ident">faces</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def faces(self):
    return get_faces(self._geometry, self._boundary)</code></pre>
</details>
</dd>
<dt id="phi.field.Field.geometry"><code class="name">prop <span class="ident">geometry</span> : phi.geom._geom.Geometry</code></dt>
<dd>
<div class="desc"><p>Returns a geometrical representation of the discrete volume elements.
The result is a tuple of Geometry objects, each of which can have additional spatial (but not batch) dimensions.</p>
<p>For grids, the geometries are boxes while particle fields may be represented as spheres.</p>
<p>If this Field has no discrete points, this method returns an empty geometry.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def geometry(self) -&gt; Geometry:
    &#34;&#34;&#34;
    Returns a geometrical representation of the discrete volume elements.
    The result is a tuple of Geometry objects, each of which can have additional spatial (but not batch) dimensions.
    
    For grids, the geometries are boxes while particle fields may be represented as spheres.
    
    If this Field has no discrete points, this method returns an empty geometry.
    &#34;&#34;&#34;
    return self._geometry</code></pre>
</details>
</dd>
<dt id="phi.field.Field.graph"><code class="name">prop <span class="ident">graph</span> : phi.geom._graph.Graph</code></dt>
<dd>
<div class="desc"><p>Cast <code>self.geometry</code> to a <code><a title="phi.geom.Graph" href="../geom/index.html#phi.geom.Graph">Graph</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def graph(self) -&gt; Graph:
    &#34;&#34;&#34;Cast `self.geometry` to a `phi.geom.Graph`.&#34;&#34;&#34;
    assert isinstance(self._geometry, Graph), f&#34;Geometry is not a mesh but {type(self._geometry)}&#34;
    return self._geometry</code></pre>
</details>
</dd>
<dt id="phi.field.Field.is_centered"><code class="name">prop <span class="ident">is_centered</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_centered(self):
    return not self.is_staggered</code></pre>
</details>
</dd>
<dt id="phi.field.Field.is_graph"><code class="name">prop <span class="ident">is_graph</span></code></dt>
<dd>
<div class="desc"><p>A Field represents graph data if its <code>geometry</code> is a <code><a title="phi.geom.Graph" href="../geom/index.html#phi.geom.Graph">Graph</a></code> instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_graph(self):
    &#34;&#34;&#34;A Field represents graph data if its `geometry` is a `phi.geom.Graph` instance.&#34;&#34;&#34;
    return isinstance(self._geometry, Graph)</code></pre>
</details>
</dd>
<dt id="phi.field.Field.is_grid"><code class="name">prop <span class="ident">is_grid</span></code></dt>
<dd>
<div class="desc"><p>A Field represents grid data if its <code>geometry</code> is a <code><a title="phi.geom.UniformGrid" href="../geom/index.html#phi.geom.UniformGrid">UniformGrid</a></code> instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_grid(self):
    &#34;&#34;&#34;A Field represents grid data if its `geometry` is a `phi.geom.UniformGrid` instance.&#34;&#34;&#34;
    return isinstance(self._geometry, UniformGrid)</code></pre>
</details>
</dd>
<dt id="phi.field.Field.is_mesh"><code class="name">prop <span class="ident">is_mesh</span></code></dt>
<dd>
<div class="desc"><p>A Field represents mesh data if its <code>geometry</code> is a <code><a title="phi.geom.Mesh" href="../geom/index.html#phi.geom.Mesh">Mesh</a></code> instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_mesh(self):
    &#34;&#34;&#34;A Field represents mesh data if its `geometry` is a `phi.geom.Mesh` instance.&#34;&#34;&#34;
    return isinstance(self._geometry, Mesh)</code></pre>
</details>
</dd>
<dt id="phi.field.Field.is_point_cloud"><code class="name">prop <span class="ident">is_point_cloud</span></code></dt>
<dd>
<div class="desc"><p>A Field represents graph data if its <code>geometry</code> is not a set of connected elements, but rather individual geometric objects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_point_cloud(self):
    &#34;&#34;&#34;A Field represents graph data if its `geometry` is not a set of connected elements, but rather individual geometric objects.&#34;&#34;&#34;
    if isinstance(self._geometry, (UniformGrid, Mesh, Graph)):
        return False
    if isinstance(self._geometry, (BaseBox, Sphere, Point)):
        return True
    return True</code></pre>
</details>
</dd>
<dt id="phi.field.Field.is_staggered"><code class="name">prop <span class="ident">is_staggered</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_staggered(self):
    return is_staggered(self._values, self._geometry)</code></pre>
</details>
</dd>
<dt id="phi.field.Field.mesh"><code class="name">prop <span class="ident">mesh</span> : phi.geom._mesh.Mesh</code></dt>
<dd>
<div class="desc"><p>Cast <code>self.geometry</code> to a <code><a title="phi.geom.Mesh" href="../geom/index.html#phi.geom.Mesh">Mesh</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mesh(self) -&gt; Mesh:
    &#34;&#34;&#34;Cast `self.geometry` to a `phi.geom.Mesh`.&#34;&#34;&#34;
    assert isinstance(self._geometry, Mesh), f&#34;Geometry is not a mesh but {type(self._geometry)}&#34;
    return self._geometry</code></pre>
</details>
</dd>
<dt id="phi.field.Field.points"><code class="name">prop <span class="ident">points</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def points(self):
    return self.center</code></pre>
</details>
</dd>
<dt id="phi.field.Field.resolution"><code class="name">prop <span class="ident">resolution</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def resolution(self):
    return self._geometry.shape.non_channel.non_dual.non_batch</code></pre>
</details>
</dd>
<dt id="phi.field.Field.sampled_at"><code class="name">prop <span class="ident">sampled_at</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sampled_at(self):
    matching_sets = [s for s, s_shape in self._geometry.sets.items() if s_shape in self._values.shape]
    return matching_sets[-1]</code></pre>
</details>
</dd>
<dt id="phi.field.Field.sampled_elements"><code class="name">prop <span class="ident">sampled_elements</span> : phi.geom._geom.Geometry</code></dt>
<dd>
<div class="desc"><p>If the values represent are sampled at the element centers or represent the whole element, returns <code>self.geometry</code>.
If the values are sampled at the faces, returns <code>self.faces</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sampled_elements(self) -&gt; Geometry:
    &#34;&#34;&#34;
    If the values represent are sampled at the element centers or represent the whole element, returns `self.geometry`.
    If the values are sampled at the faces, returns `self.faces`.
    &#34;&#34;&#34;
    return get_faces(self._geometry, self._boundary) if is_staggered(self._values, self._geometry) else self._geometry</code></pre>
</details>
</dd>
<dt id="phi.field.Field.shape"><code class="name">prop <span class="ident">shape</span> : phiml.math._shape.Shape</code></dt>
<dd>
<div class="desc"><p>Returns a shape with the following properties</p>
<ul>
<li>The spatial dimension names match the dimensions of this Field</li>
<li>The batch dimensions match the batch dimensions of this Field</li>
<li>The channel dimensions match the channels of this Field</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape(self) -&gt; Shape:
    &#34;&#34;&#34;
    Returns a shape with the following properties
    
    * The spatial dimension names match the dimensions of this Field
    * The batch dimensions match the batch dimensions of this Field
    * The channel dimensions match the channels of this Field
    &#34;&#34;&#34;
    if self.is_staggered and self.is_grid:
        return batch(self._geometry) &amp; self.resolution &amp; non_dual(self._values).without(self.resolution) &amp; self._geometry.shape[&#39;vector&#39;]
    set_shape = self._geometry.sets[self.sampled_at]
    return batch(self._geometry) &amp; (channel(self._geometry) - &#39;vector&#39;) &amp; set_shape &amp; self._values</code></pre>
</details>
</dd>
<dt id="phi.field.Field.spatial_rank"><code class="name">prop <span class="ident">spatial_rank</span> : int</code></dt>
<dd>
<div class="desc"><p>Spatial rank of the field (1 for 1D, 2 for 2D, 3 for 3D).
This is equal to the spatial rank of the <code>data</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def spatial_rank(self) -&gt; int:
    &#34;&#34;&#34;
    Spatial rank of the field (1 for 1D, 2 for 2D, 3 for 3D).
    This is equal to the spatial rank of the `data`.
    &#34;&#34;&#34;
    return self._geometry.spatial_rank</code></pre>
</details>
</dd>
<dt id="phi.field.Field.values"><code class="name">prop <span class="ident">values</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p>Returns the <code>values</code> of this <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def values(self) -&gt; Tensor:
    &#34;&#34;&#34; Returns the `values` of this `Field`. &#34;&#34;&#34;
    return self._values</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phi.field.Field.as_boundary"><code class="name flex">
<span>def <span class="ident">as_boundary</span></span>(<span>self) ‑> phiml.math.extrapolation.Extrapolation</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an <code>Extrapolation</code> representing this 'Field''s values as a Dirichlet (constant) boundary.
If this <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> encloses the required boundaries, its values will be interpolated to the required boundaries.
If boundaries outside of this <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code>'s sampled domain are required, this <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code>'s boundary conditions will be applied to determine the boundary values.</p>
<h2 id="returns">Returns</h2>
<p><code>Extrapolation</code></p></div>
</dd>
<dt id="phi.field.Field.as_points"><code class="name flex">
<span>def <span class="ident">as_points</span></span>(<span>self, list_dim: Optional[phiml.math._shape.Shape] = (elementsⁱ=None)) ‑> phi.field._field.Field</span>
</code></dt>
<dd>
<div class="desc"><p>Returns this field as a PointCloud.
This replaces the <code><a title="phi.field.Field.geometry" href="#phi.field.Field.geometry">Field.geometry</a></code> with a <code><a title="phi.geom.Point" href="../geom/index.html#phi.geom.Point">Point</a></code> instance while leaving the sample points unchanged.</p>
<p>See Also:
<code><a title="phi.field.Field.as_spheres" href="#phi.field.Field.as_spheres">Field.as_spheres()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>list_dim</code></strong></dt>
<dd>If not <code>None</code>, packs spatial, instance and dual dims.
Defaults to <code>instance('elements')</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> with same values and boundaries but <code>Point</code> geometry.</p></div>
</dd>
<dt id="phi.field.Field.as_spheres"><code class="name flex">
<span>def <span class="ident">as_spheres</span></span>(<span>self, list_dim: Optional[phiml.math._shape.Shape] = (elementsⁱ=None)) ‑> phi.field._field.Field</span>
</code></dt>
<dd>
<div class="desc"><p>Returns this field as a PointCloud with spherical / circular elements, preserving element volumes.
This replaces the <code><a title="phi.field.Field.geometry" href="#phi.field.Field.geometry">Field.geometry</a></code> with a <code><a title="phi.geom.Sphere" href="../geom/index.html#phi.geom.Sphere">Sphere</a></code> instance while leaving the sample points unchanged.</p>
<p>See Also:
<code><a title="phi.field.Field.as_points" href="#phi.field.Field.as_points">Field.as_points()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>list_dim</code></strong></dt>
<dd>If not <code>None</code>, packs spatial, instance and dual dims.
Defaults to <code>instance('elements')</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> with same values and boundaries but <code>Sphere</code> geometry.</p></div>
</dd>
<dt id="phi.field.Field.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>self, representation: Union[ForwardRef('<a title="phi.field.Field" href="#phi.field.Field">Field</a>'), phi.geom._geom.Geometry], keep_boundary=False, **kwargs) ‑> phi.field._field.Field</span>
</code></dt>
<dd>
<div class="desc"><p>Short for <code><a title="phi.field.resample" href="#phi.field.resample">resample()</a>(self, representation)</code></p>
<p>See Also
<code><a title="phi.field.resample" href="#phi.field.resample">resample()</a></code>.</p>
<h2 id="returns">Returns</h2>
<p>Field object of same type as <code>representation</code></p></div>
</dd>
<dt id="phi.field.Field.at_centers"><code class="name flex">
<span>def <span class="ident">at_centers</span></span>(<span>self, **kwargs) ‑> phi.field._field.Field</span>
</code></dt>
<dd>
<div class="desc"><p>Interpolates the values to the cell centers.</p>
<p>See Also:
<code><a title="phi.field.Field.at_faces" href="#phi.field.Field.at_faces">Field.at_faces()</a></code>, <code><a title="phi.field.Field.at" href="#phi.field.Field.at">Field.at()</a></code>, <code><a title="phi.field.resample" href="#phi.field.resample">resample()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Sampling arguments.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.field.CenteredGrid" href="#phi.field.CenteredGrid">CenteredGrid()</a></code> sampled at cell centers.</p></div>
</dd>
<dt id="phi.field.Field.at_faces"><code class="name flex">
<span>def <span class="ident">at_faces</span></span>(<span>self, boundary=None, **kwargs) ‑> phi.field._field.Field</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="phi.field.Field.closest_values"><code class="name flex">
<span>def <span class="ident">closest_values</span></span>(<span>self, points: phiml.math._tensors.Tensor)</span>
</code></dt>
<dd>
<div class="desc"><p>Sample the closest grid point values of this field at the world-space locations (in physical units) given by <code>points</code>.
Points must have a single channel dimension named <code>vector</code>.
It may additionally contain any number of batch and spatial dimensions, all treated as batch dimensions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>points</code></strong></dt>
<dd>world-space locations</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Closest grid point values as a <code>Tensor</code>.
For each dimension, the grid points immediately left and right of the sample points are evaluated.
For each point in <code>points</code>, a <em>2^d</em> cube of points is determined where <em>d</em> is the number of spatial dimensions of this field.
These values are stacked along the new dimensions <code>'closest_&lt;dim&gt;'</code> where <code>&lt;dim&gt;</code> refers to the name of a spatial dimension.</p></div>
</dd>
<dt id="phi.field.Field.curl"><code class="name flex">
<span>def <span class="ident">curl</span></span>(<span>self, at='corner')</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for <code><a title="phi.field.curl" href="#phi.field.curl">curl()</a></code></p></div>
</dd>
<dt id="phi.field.Field.dimension"><code class="name flex">
<span>def <span class="ident">dimension</span></span>(<span>self, name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a reference to one of the dimensions of this field.</p>
<p>The dimension reference can be used the same way as a <code>Tensor</code> dimension reference.
Notable properties and methods of a dimension reference are:
indexing using <code>[index]</code>, <code><a title="phi.field.unstack" href="#phi.field.unstack">unstack()</a></code>, <code>size</code>, <code>exists</code>, <code>is_batch</code>, <code>is_spatial</code>, <code>is_channel</code>.</p>
<p>A shortcut to calling this function is the syntax <code>field.&lt;dim_name&gt;</code> which calls <code>field.dimension(&lt;dim_name&gt;)</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>dimension name</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>dimension reference</p></div>
</dd>
<dt id="phi.field.Field.divergence"><code class="name flex">
<span>def <span class="ident">divergence</span></span>(<span>self, order=2, implicit: phiml.math._optimize.Solve = None, upwind: <a title="phi.field.Field" href="#phi.field.Field">Field</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for <code><a title="phi.field.divergence" href="#phi.field.divergence">divergence()</a></code></p></div>
</dd>
<dt id="phi.field.Field.downsample"><code class="name flex">
<span>def <span class="ident">downsample</span></span>(<span>self, factor: int)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="phi.field.Field.gradient"><code class="name flex">
<span>def <span class="ident">gradient</span></span>(<span>self, boundary: phiml.math.extrapolation.Extrapolation = None, at: str = 'center', dims: Union[str, tuple, list, set, ForwardRef('Shape'), Callable] = &lt;function spatial&gt;, stack_dim: Union[phiml.math._shape.Shape, str] = (vectorᶜ=None), order=2, implicit: phiml.math._optimize.Solve = None, scheme=None, upwind: <a title="phi.field.Field" href="#phi.field.Field">Field</a> = None, gradient_extrapolation: phiml.math.extrapolation.Extrapolation = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for <code><a title="phi.field.spatial_gradient" href="#phi.field.spatial_gradient">spatial_gradient()</a></code></p></div>
</dd>
<dt id="phi.field.Field.grid_scatter"><code class="name flex">
<span>def <span class="ident">grid_scatter</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Deprecated. Use <code><a title="phi.field.sample" href="#phi.field.sample">sample()</a></code> with <code>scatter=True</code> instead.</p></div>
</dd>
<dt id="phi.field.Field.laplace"><code class="name flex">
<span>def <span class="ident">laplace</span></span>(<span>self, axes: Union[str, tuple, list, set, ForwardRef('Shape'), Callable] = &lt;function spatial&gt;, gradient: <a title="phi.field.Field" href="#phi.field.Field">Field</a> = None, order=2, implicit: phiml.math._optimize.Solve = None, weights: Union[phiml.math._tensors.Tensor, ForwardRef('<a title="phi.field.Field" href="#phi.field.Field">Field</a>')] = None, upwind: <a title="phi.field.Field" href="#phi.field.Field">Field</a> = None, correct_skew=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for <code><a title="phi.field.laplace" href="#phi.field.laplace">laplace()</a></code></p></div>
</dd>
<dt id="phi.field.Field.numpy"><code class="name flex">
<span>def <span class="ident">numpy</span></span>(<span>self, order: Union[str, tuple, list, set, ForwardRef('Shape'), Callable] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the field values as <code>NumPy</code> array(s).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>order</code></strong></dt>
<dd>Dimension order as <code>str</code> or <code>Shape</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A single NumPy array for uniform values, else a list of NumPy arrays.</p></div>
</dd>
<dt id="phi.field.Field.pad"><code class="name flex">
<span>def <span class="ident">pad</span></span>(<span>self, widths: Union[int, tuple, list, dict]) ‑> phi.field._field.Field</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for <code><a title="phi.field.pad" href="#phi.field.pad">pad()</a></code>.</p>
<p>Pads this <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> using its extrapolation.</p>
<p>Unlike padding the values, this function also affects the <code>geometry</code> of the field, changing its size and origin depending on <code>widths</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>widths</code></strong></dt>
<dd>Either <code>int</code> or <code>(lower, upper)</code> to pad the same number of cells in all spatial dimensions
or <code>dict</code> mapping dimension names to <code>(lower, upper)</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Padded <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code></p></div>
</dd>
<dt id="phi.field.Field.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>self, where: Union[phi.geom._geom.Geometry, ForwardRef('<a title="phi.field.Field" href="#phi.field.Field">Field</a>'), phiml.math._tensors.Tensor], at: str = 'center', **kwargs) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Sample the values of this <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> at the given location or geometry.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>where</code></strong></dt>
<dd>Location <code>Tensor</code> or <code>Geometry</code> or</dd>
<dt><strong><code>at</code></strong></dt>
<dd><code>'center'</code> or <code>'face'</code>.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Sampling arguments.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>Tensor</code></p></div>
</dd>
<dt id="phi.field.Field.shifted"><code class="name flex">
<span>def <span class="ident">shifted</span></span>(<span>self, delta: phiml.math._tensors.Tensor) ‑> phi.field._field.Field</span>
</code></dt>
<dd>
<div class="desc"><p>Move the positions of this field's <code>geometry</code> by <code>delta</code>.</p>
<p>See Also:
<code><a title="phi.field.Field.shifted_to" href="#phi.field.Field.shifted_to">Field.shifted_to()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>delta</code></strong></dt>
<dd>Shift amount for each center position of <code>geometry</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>New <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> sampled at <code>geometry.center + delta</code>.</p></div>
</dd>
<dt id="phi.field.Field.shifted_to"><code class="name flex">
<span>def <span class="ident">shifted_to</span></span>(<span>self, position: phiml.math._tensors.Tensor) ‑> phi.field._field.Field</span>
</code></dt>
<dd>
<div class="desc"><p>Move the positions of this field's <code>geometry</code> to <code>positions</code>.</p>
<p>See Also:
<code><a title="phi.field.Field.shifted" href="#phi.field.Field.shifted">Field.shifted()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>position</code></strong></dt>
<dd>New center positions of <code>geometry</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>New <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> sampled at given positions.</p></div>
</dd>
<dt id="phi.field.Field.staggered_tensor"><code class="name flex">
<span>def <span class="ident">staggered_tensor</span></span>(<span>self) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Stacks all component grids into a single uniform <code>phi.math.Tensor</code>.
The individual components are padded to a common (larger) shape before being stacked.
The shape of the returned tensor is exactly one cell larger than the grid <code>resolution</code> in every spatial dimension.</p>
<h2 id="returns">Returns</h2>
<p>Uniform <code>phi.math.Tensor</code>.</p></div>
</dd>
<dt id="phi.field.Field.to_grid"><code class="name flex">
<span>def <span class="ident">to_grid</span></span>(<span>self, resolution=(), bounds=None, **resolution_)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="phi.field.Field.uniform_values"><code class="name flex">
<span>def <span class="ident">uniform_values</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a uniform tensor containing <code>values</code>.</p>
<p>For periodic grids, which always have a uniform value tensor, `values' is returned directly.
If <code>values</code> is not uniform, it is padded as in <code>StaggeredGrid.staggered_tensor()</code>.</p></div>
</dd>
<dt id="phi.field.Field.with_boundary"><code class="name flex">
<span>def <span class="ident">with_boundary</span></span>(<span>self, boundary)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a copy of this field with the <code>boundary</code> replaced.</p></div>
</dd>
<dt id="phi.field.Field.with_bounds"><code class="name flex">
<span>def <span class="ident">with_bounds</span></span>(<span>self, bounds: phi.geom._box.Box)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a copy of this field with <code>bounds</code> replaced.</p></div>
</dd>
<dt id="phi.field.Field.with_elements"><code class="name flex">
<span>def <span class="ident">with_elements</span></span>(<span>self, elements: phi.geom._geom.Geometry)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a copy of this field with <code>elements</code> replaced.</p></div>
</dd>
<dt id="phi.field.Field.with_extrapolation"><code class="name flex">
<span>def <span class="ident">with_extrapolation</span></span>(<span>self, boundary)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a copy of this field with the <code>boundary</code> replaced.</p></div>
</dd>
<dt id="phi.field.Field.with_geometry"><code class="name flex">
<span>def <span class="ident">with_geometry</span></span>(<span>self, elements: phi.geom._geom.Geometry)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a copy of this field with <code>elements</code> replaced.</p></div>
</dd>
<dt id="phi.field.Field.with_values"><code class="name flex">
<span>def <span class="ident">with_values</span></span>(<span>self, values, **sampling_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a copy of this field with <code>values</code> replaced.</p></div>
</dd>
</dl>
</dd>
<dt id="phi.field.Field"><code class="flex name class">
<span>class <span class="ident">Grid</span></span>
</code></dt>
<dd>
<div class="desc"><p>Base class for all fields.</p>
<p>Important implementations:</p>
<ul>
<li>CenteredGrid</li>
<li>StaggeredGrid</li>
<li>PointCloud</li>
<li>Noise</li>
</ul>
<p>See the <code><a title="phi.field" href="#phi.field">phi.field</a></code> module documentation at <a href="https://tum-pbs.github.io/PhiFlow/Fields.html">https://tum-pbs.github.io/PhiFlow/Fields.html</a></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>elements</code></strong></dt>
<dd>Geometry object specifying the sample points and sizes</dd>
<dt><strong><code>values</code></strong></dt>
<dd>values corresponding to elements</dd>
<dt><strong><code>extrapolation</code></strong></dt>
<dd>values outside elements</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Field:
    &#34;&#34;&#34;
    Base class for all fields.
    
    Important implementations:
    
    * CenteredGrid
    * StaggeredGrid
    * PointCloud
    * Noise
    
    See the `phi.field` module documentation at https://tum-pbs.github.io/PhiFlow/Fields.html
    &#34;&#34;&#34;

    def __init__(self,
                 geometry: Union[Geometry, Tensor],
                 values: Union[Tensor, Number, bool, Callable, FieldInitializer, Geometry, &#39;Field&#39;],
                 boundary: Union[Number, Extrapolation, &#39;Field&#39;, dict] = 0,
                 **sampling_kwargs):
        &#34;&#34;&#34;
        Args:
          elements: Geometry object specifying the sample points and sizes
          values: values corresponding to elements
          extrapolation: values outside elements
        &#34;&#34;&#34;
        assert isinstance(geometry, Geometry), f&#34;geometry must be a Geometry object but got {type(geometry).__name__}&#34;
        self._boundary: Extrapolation = as_boundary(boundary, geometry)
        self._geometry: Geometry = geometry
        if isinstance(values, (Tensor, Number, bool)):
            values = wrap(values)
        else:
            from ._resample import sample
            values = sample(values, geometry, &#39;center&#39;, self._boundary, **sampling_kwargs)
        matching_sets = [s for s, s_shape in geometry.sets.items() if s_shape in values.shape]
        if not matching_sets:
            values = expand(wrap(values), non_batch(geometry) - &#39;vector&#39;)
        self._values: Tensor = values
        math.merge_shapes(values, non_batch(self.sampled_elements).non_channel)  # shape check

    @property
    def geometry(self) -&gt; Geometry:
        &#34;&#34;&#34;
        Returns a geometrical representation of the discrete volume elements.
        The result is a tuple of Geometry objects, each of which can have additional spatial (but not batch) dimensions.
        
        For grids, the geometries are boxes while particle fields may be represented as spheres.
        
        If this Field has no discrete points, this method returns an empty geometry.
        &#34;&#34;&#34;
        return self._geometry

    @property
    def mesh(self) -&gt; Mesh:
        &#34;&#34;&#34;Cast `self.geometry` to a `phi.geom.Mesh`.&#34;&#34;&#34;
        assert isinstance(self._geometry, Mesh), f&#34;Geometry is not a mesh but {type(self._geometry)}&#34;
        return self._geometry

    @property
    def graph(self) -&gt; Graph:
        &#34;&#34;&#34;Cast `self.geometry` to a `phi.geom.Graph`.&#34;&#34;&#34;
        assert isinstance(self._geometry, Graph), f&#34;Geometry is not a mesh but {type(self._geometry)}&#34;
        return self._geometry

    @property
    def faces(self):
        return get_faces(self._geometry, self._boundary)

    @property
    def face_centers(self):
        return self._geometry.face_centers
        # return slice_off_constant_faces(self._geometry.face_centers, self._geometry.boundary_faces, self._boundary)

    @property
    def face_normals(self):
        return self._geometry.face_normals
        # return slice_off_constant_faces(self._geometry.face_normals, self._geometry.boundary_faces, self._boundary)

    @property
    def face_areas(self):
        return self._geometry.face_areas
        # return slice_off_constant_faces(self._geometry.face_areas, self._geometry.boundary_faces, self._boundary)

    @property
    def sampled_elements(self) -&gt; Geometry:
        &#34;&#34;&#34;
        If the values represent are sampled at the element centers or represent the whole element, returns `self.geometry`.
        If the values are sampled at the faces, returns `self.faces`.
        &#34;&#34;&#34;
        return get_faces(self._geometry, self._boundary) if is_staggered(self._values, self._geometry) else self._geometry

    @property
    def elements(self):
        # raise SyntaxError(&#34;Field.elements is deprecated. Use Field.geometry or Field.sampled_elements instead.&#34;)
        warnings.warn(&#34;Field.elements is deprecated. Use Field.geometry or Field.sampled_elements instead. Field.elements now defaults to Field.geometry.&#34;, DeprecationWarning, stacklevel=2)
        return self._geometry

    @property
    def is_centered(self):
        return not self.is_staggered

    @property
    def is_staggered(self):
        return is_staggered(self._values, self._geometry)

    @property
    def center(self) -&gt; Tensor:
        &#34;&#34;&#34; Returns the center points of the `elements` of this `Field`. &#34;&#34;&#34;
        all_points = self._geometry.get_points(self.sampled_at)
        boundary = self._geometry.get_boundary(self.sampled_at)
        return slice_off_constant_faces(all_points, boundary, self.extrapolation)

    @property
    def points(self):
        return self.center

    @property
    def values(self) -&gt; Tensor:
        &#34;&#34;&#34; Returns the `values` of this `Field`. &#34;&#34;&#34;
        return self._values

    data = values

    def numpy(self, order: DimFilter = None):
        &#34;&#34;&#34;
        Return the field values as `NumPy` array(s).

        Args:
            order: Dimension order as `str` or `Shape`.

        Returns:
            A single NumPy array for uniform values, else a list of NumPy arrays.
        &#34;&#34;&#34;
        if order is None and self.is_grid:
            axes = self._values.shape.only(self._geometry.vector.item_names, reorder=True)
            order = concat_shapes(self._values.shape.dual, self._values.shape.batch, axes, self._values.shape.channel)
        if self._values.shape.is_uniform:
            return self._values.numpy(order)
        else:
            assert order is not None, f&#34;order must be specified for non-uniform Field values&#34;
            order = self._values.shape.only(order, reorder=True)
            stack_dims = order.non_uniform_shape
            inner_order = order.without(stack_dims)
            return [v.numpy(inner_order) for v in unstack(self._values, stack_dims)]

    def uniform_values(self):
        &#34;&#34;&#34;
        Returns a uniform tensor containing `values`.

        For periodic grids, which always have a uniform value tensor, `values&#39; is returned directly.
        If `values` is not uniform, it is padded as in `StaggeredGrid.staggered_tensor()`.
        &#34;&#34;&#34;
        if self.values.shape.is_uniform:
            return self.values
        else:
            return self.staggered_tensor()

    @property
    def boundary(self) -&gt; Extrapolation:
        &#34;&#34;&#34;
        Returns the boundary conditions set for this `Field`.

        Returns:
            Single `Extrapolation` instance that encodes the (varying) boundary conditions for all boundaries of this field&#39;s `elements`.
        &#34;&#34;&#34;
        return self._boundary

    @property
    def extrapolation(self) -&gt; Extrapolation:
        &#34;&#34;&#34; Returns the `Extrapolation` of this `Field`. &#34;&#34;&#34;
        return self._boundary

    @property
    def shape(self) -&gt; Shape:
        &#34;&#34;&#34;
        Returns a shape with the following properties
        
        * The spatial dimension names match the dimensions of this Field
        * The batch dimensions match the batch dimensions of this Field
        * The channel dimensions match the channels of this Field
        &#34;&#34;&#34;
        if self.is_staggered and self.is_grid:
            return batch(self._geometry) &amp; self.resolution &amp; non_dual(self._values).without(self.resolution) &amp; self._geometry.shape[&#39;vector&#39;]
        set_shape = self._geometry.sets[self.sampled_at]
        return batch(self._geometry) &amp; (channel(self._geometry) - &#39;vector&#39;) &amp; set_shape &amp; self._values

    @property
    def resolution(self):
        return self._geometry.shape.non_channel.non_dual.non_batch

    @property
    def spatial_rank(self) -&gt; int:
        &#34;&#34;&#34;
        Spatial rank of the field (1 for 1D, 2 for 2D, 3 for 3D).
        This is equal to the spatial rank of the `data`.
        &#34;&#34;&#34;
        return self._geometry.spatial_rank

    @property
    def bounds(self) -&gt; BaseBox:
        &#34;&#34;&#34;
        The bounds represent the area inside which the values of this `Field` are valid.
        The bounds will also be used as axis limits for plots.

        The bounds can be set manually in the constructor, otherwise default bounds will be generated.

        For fields that are valid without bounds, the lower and upper limit of `bounds` is set to `-inf` and `inf`, respectively.

        Fields whose spatial rank is determined only during sampling return an empty `Box`.
        &#34;&#34;&#34;
        if isinstance(self._geometry.bounds, BaseBox):
            return self._geometry.bounds
        extent = self._geometry.bounding_half_extent().vector.as_dual(&#39;_extent&#39;)
        points = self._geometry.center + extent
        lower = math.min(points, dim=points.shape.non_batch.non_channel)
        upper = math.max(points, dim=points.shape.non_batch.non_channel)
        return Box(lower, upper)

    box = bounds

    @property
    def is_grid(self):
        &#34;&#34;&#34;A Field represents grid data if its `geometry` is a `phi.geom.UniformGrid` instance.&#34;&#34;&#34;
        return isinstance(self._geometry, UniformGrid)

    @property
    def is_mesh(self):
        &#34;&#34;&#34;A Field represents mesh data if its `geometry` is a `phi.geom.Mesh` instance.&#34;&#34;&#34;
        return isinstance(self._geometry, Mesh)

    @property
    def is_graph(self):
        &#34;&#34;&#34;A Field represents graph data if its `geometry` is a `phi.geom.Graph` instance.&#34;&#34;&#34;
        return isinstance(self._geometry, Graph)

    @property
    def is_point_cloud(self):
        &#34;&#34;&#34;A Field represents graph data if its `geometry` is not a set of connected elements, but rather individual geometric objects.&#34;&#34;&#34;
        if isinstance(self._geometry, (UniformGrid, Mesh, Graph)):
            return False
        if isinstance(self._geometry, (BaseBox, Sphere, Point)):
            return True
        return True

    @property
    def dx(self) -&gt; Tensor:
        assert spatial(self._geometry), f&#34;dx is only defined for elements with spatial dims but Field has elements {self._geometry.shape}&#34;
        return self.bounds.size / self.resolution

    @property
    def cells(self):
        assert isinstance(self._geometry, (UniformGrid, Mesh))
        return self._geometry

    def to_grid(self, resolution=math.EMPTY_SHAPE, bounds=None, **resolution_):
        resolution = resolution.spatial &amp; spatial(**resolution_)
        if self.is_grid and (not resolution or resolution == self.resolution) and (bounds is None or bounds == self.bounds):
            return self
        bounds = self.bounds if bounds is None else bounds
        if not resolution:
            half_sizes = self._geometry.bounding_half_extent()
            if (half_sizes &gt; 0).all:
                size = math.min(2 * half_sizes, non_batch(half_sizes).non_channel)
            else:
                cell_count = non_batch(self._geometry).non_channel.non_dual.volume
                size = (bounds.volume / cell_count) ** (1 / self.spatial_rank)
            res = math.maximum(1, math.round(bounds.size / size))
            resolution = spatial(**res.vector)
        return Field(UniformGrid(resolution, bounds), self, self.boundary)

    def as_points(self, list_dim: Optional[Shape] = instance(&#39;elements&#39;)) -&gt; &#39;Field&#39;:
        &#34;&#34;&#34;
        Returns this field as a PointCloud.
        This replaces the `Field.geometry` with a `phi.geom.Point` instance while leaving the sample points unchanged.

        See Also:
            `Field.as_spheres()`.

        Args:
            list_dim: If not `None`, packs spatial, instance and dual dims.
                Defaults to `instance(&#39;elements&#39;)`.

        Returns:
            `Field` with same values and boundaries but `Point` geometry.
        &#34;&#34;&#34;
        points = self.sampled_elements.center
        values = self._values
        if list_dim:
            dims = non_batch(points).non_channel &amp; non_batch(points).non_channel
            points = pack_dims(points, dims, list_dim)
            values = pack_dims(values, dims, list_dim)
        return Field(Point(points), values, self._boundary)

    def as_spheres(self, list_dim: Optional[Shape] = instance(&#39;elements&#39;)) -&gt; &#39;Field&#39;:
        &#34;&#34;&#34;
        Returns this field as a PointCloud with spherical / circular elements, preserving element volumes.
        This replaces the `Field.geometry` with a `phi.geom.Sphere` instance while leaving the sample points unchanged.

        See Also:
            `Field.as_points()`.

        Args:
            list_dim: If not `None`, packs spatial, instance and dual dims.
                Defaults to `instance(&#39;elements&#39;)`.

        Returns:
            `Field` with same values and boundaries but `Sphere` geometry.
        &#34;&#34;&#34;
        points = self.sampled_elements.center
        volumes = self.sampled_elements.volume
        values = self._values
        if list_dim:
            dims = non_batch(points).non_channel &amp; non_batch(points).non_channel
            points = pack_dims(points, dims, list_dim)
            values = pack_dims(values, dims, list_dim)
            volumes = pack_dims(volumes, dims, list_dim)
        return Field(Sphere(points, volume=volumes), values, self._boundary)

    def at_centers(self, **kwargs) -&gt; &#39;Field&#39;:
        &#34;&#34;&#34;
        Interpolates the values to the cell centers.

        See Also:
            `Field.at_faces()`, `Field.at()`, `resample`.

        Args:
            **kwargs: Sampling arguments.

        Returns:
            `CenteredGrid` sampled at cell centers.
        &#34;&#34;&#34;
        if self.is_centered:
            return self
        from ._resample import sample
        values = sample(self, self._geometry, at=&#39;center&#39;, boundary=self._boundary, **kwargs)
        return Field(self._geometry, values, self._boundary)

    def at_faces(self, boundary=None, **kwargs) -&gt; &#39;Field&#39;:
        if self.is_staggered and not boundary:
            return self
        boundary = as_boundary(boundary, self._geometry) if boundary else self._boundary
        from ._resample import sample
        values = sample(self, self._geometry, at=&#39;face&#39;, boundary=boundary, **kwargs)
        return Field(self._geometry, values, boundary)

    @property
    def sampled_at(self):
        matching_sets = [s for s, s_shape in self._geometry.sets.items() if s_shape in self._values.shape]
        return matching_sets[-1]

    def at(self, representation: Union[&#39;Field&#39;, Geometry], keep_boundary=False, **kwargs) -&gt; &#39;Field&#39;:
        &#34;&#34;&#34;
        Short for `resample(self, representation)`

        See Also
            `resample()`.

        Returns:
            Field object of same type as `representation`
        &#34;&#34;&#34;
        from ._resample import resample
        return resample(self, representation, keep_boundary, **kwargs)

    def sample(self, where: Union[Geometry, &#39;Field&#39;, Tensor], at: str = &#39;center&#39;, **kwargs) -&gt; &#39;Tensor&#39;:
        &#34;&#34;&#34;
        Sample the values of this `Field` at the given location or geometry.

        Args:
            where: Location `Tensor` or `Geometry` or
            at: `&#39;center&#39;` or `&#39;face&#39;`.
            **kwargs: Sampling arguments.

        Returns:
            `Tensor`
        &#34;&#34;&#34;
        from ._resample import sample
        return sample(self, where, at, **kwargs)

    def closest_values(self, points: Tensor):
        &#34;&#34;&#34;
        Sample the closest grid point values of this field at the world-space locations (in physical units) given by `points`.
        Points must have a single channel dimension named `vector`.
        It may additionally contain any number of batch and spatial dimensions, all treated as batch dimensions.

        Args:
            points: world-space locations

        Returns:
            Closest grid point values as a `Tensor`.
            For each dimension, the grid points immediately left and right of the sample points are evaluated.
            For each point in `points`, a *2^d* cube of points is determined where *d* is the number of spatial dimensions of this field.
            These values are stacked along the new dimensions `&#39;closest_&lt;dim&gt;&#39;` where `&lt;dim&gt;` refers to the name of a spatial dimension.
        &#34;&#34;&#34;
        warnings.warn(&#34;Field.closest_values() is deprecated.&#34;, DeprecationWarning, stacklevel=2)
        if isinstance(points, Geometry):
            points = points.center
        # --- CenteredGrid ---
        local_points = self.box.global_to_local(points) * self.resolution - 0.5
        return math.closest_grid_values(self.values, local_points, self.extrapolation)
        # --- StaggeredGrid ---
        if &#39;staggered_direction&#39; in points.shape:
            points_ = math.unstack(points, &#39;~vector&#39;)
            channels = [component.closest_values(p) for p, component in zip(points_, self.vector.unstack())]
        else:
            channels = [component.closest_values(points) for component in self.vector.unstack()]
        return math.stack(channels, points.shape[&#39;~vector&#39;])

    def with_values(self, values, **sampling_kwargs):
        &#34;&#34;&#34; Returns a copy of this field with `values` replaced. &#34;&#34;&#34;
        if not isinstance(values, (Tensor, Number)):
            from ._resample import sample
            values = sample(values, self._geometry, self.sampled_at, self._boundary, dot_face_normal=self._geometry if &#39;vector&#39; not in self._values.shape else None, **sampling_kwargs)
        else:
            if not spatial(values):
                geo_shape = self.sampled_elements.shape if self.is_staggered else self._geometry.shape
                if &#39;~vector&#39; in geo_shape and &#39;vector&#39; in shape(values) and &#39;~vector&#39; not in shape(values):
                    values = values.vector.as_dual()
                values = expand(wrap(values), geo_shape.non_batch.non_channel)
        return Field(self._geometry, values, self._boundary)

    def with_boundary(self, boundary):
        &#34;&#34;&#34; Returns a copy of this field with the `boundary` replaced. &#34;&#34;&#34;
        boundary = as_boundary(boundary, self._geometry)
        boundary_elements = &#39;boundary_faces&#39; if self.is_staggered else &#39;boundary_elements&#39;
        old_determined_slices = {k: s for k, s in getattr(self._geometry, boundary_elements).items() if self._boundary.determines_boundary_values(k)}
        new_determined_slices = {k: s for k, s in getattr(self._geometry, boundary_elements).items() if boundary.determines_boundary_values(k)}
        if old_determined_slices.values() == new_determined_slices.values():
            return Field(self._geometry, self._values, boundary)  # ToDo unnecessary once the rest is implemented
        to_add = {k: sl for k, sl in old_determined_slices.items() if sl not in new_determined_slices.values()}
        to_remove = [sl for sl in new_determined_slices.values() if sl not in old_determined_slices.values()]
        values = math.slice_off(self._values, *to_remove)
        if to_add:
            if self.is_mesh:
                values = self.mesh.pad_boundary(values, to_add, self._boundary)
            elif self.is_grid and self.is_staggered:
                values = self._values.vector.dual.as_channel()
                to_add = {k: {&#39;vector&#39; if dim == &#39;~vector&#39; else dim: v for dim, v in sl.items()} for k, sl in to_add.items()}
                values = math.pad(values, list(to_add.values()), self._boundary, bounds=self.bounds)
                values = values.vector.as_dual()
            else:
                values = math.pad(values, list(to_add.values()), self._boundary, bounds=self.bounds)
        return Field(self._geometry, values, boundary)

    with_extrapolation = with_boundary

    def with_bounds(self, bounds: Box):
        &#34;&#34;&#34; Returns a copy of this field with `bounds` replaced. &#34;&#34;&#34;
        order = list(bounds.vector.item_names)
        geometry = self._geometry.vector[order]
        new_shape = self._values.shape.without(order) &amp; self._values.shape.only(order, reorder=True)
        values = math.transpose(self._values, new_shape)
        return Field(geometry, values, self._boundary)

    def with_geometry(self, elements: Geometry):
        &#34;&#34;&#34; Returns a copy of this field with `elements` replaced. &#34;&#34;&#34;
        assert non_batch(elements) == non_batch(self._geometry), f&#34;Field.with_elements() only accepts elements with equal non-batch dimensions but got {elements.shape} for Field with shape {self._geometry.shape}&#34;
        return Field(elements, self._values, self._boundary)

    with_elements = with_geometry

    def shifted(self, delta: Tensor) -&gt; &#39;Field&#39;:
        &#34;&#34;&#34;
        Move the positions of this field&#39;s `geometry` by `delta`.

        See Also:
            `Field.shifted_to`.

        Args:
            delta: Shift amount for each center position of `geometry`.

        Returns:
            New `Field` sampled at `geometry.center + delta`.
        &#34;&#34;&#34;
        return self.with_geometry(self._geometry.shifted(delta))

    def shifted_to(self, position: Tensor) -&gt; &#39;Field&#39;:
        &#34;&#34;&#34;
        Move the positions of this field&#39;s `geometry` to `positions`.

        See Also:
            `Field.shifted`.

        Args:
            position: New center positions of `geometry`.

        Returns:
            New `Field` sampled at given positions.
        &#34;&#34;&#34;
        return self.with_geometry(self._geometry.at(position))

    def pad(self, widths: Union[int, tuple, list, dict]) -&gt; &#39;Field&#39;:
        &#34;&#34;&#34;
        Alias for `phi.field.pad()`.

        Pads this `Field` using its extrapolation.

        Unlike padding the values, this function also affects the `geometry` of the field, changing its size and origin depending on `widths`.

        Args:
            widths: Either `int` or `(lower, upper)` to pad the same number of cells in all spatial dimensions
                or `dict` mapping dimension names to `(lower, upper)`.

        Returns:
            Padded `Field`
        &#34;&#34;&#34;
        from ._field_math import pad
        return pad(self, widths)

    def gradient(self,
                 boundary: Extrapolation = None,
                 at: str = &#39;center&#39;,
                 dims: math.DimFilter = spatial,
                 stack_dim: Union[Shape, str] = channel(&#39;vector&#39;),
                 order=2,
                 implicit: Solve = None,
                 scheme=None,
                 upwind: &#39;Field&#39; = None,
                 gradient_extrapolation: Extrapolation = None):
        &#34;&#34;&#34;Alias for `phi.field.spatial_gradient`&#34;&#34;&#34;
        from ._field_math import spatial_gradient
        return spatial_gradient(self, boundary=boundary, at=at, dims=dims, stack_dim=stack_dim, order=order, implicit=implicit, scheme=scheme, upwind=upwind, gradient_extrapolation=gradient_extrapolation)

    def divergence(self, order=2, implicit: Solve = None, upwind: &#39;Field&#39; = None):
        &#34;&#34;&#34;Alias for `phi.field.divergence`&#34;&#34;&#34;
        from ._field_math import divergence
        return divergence(self, order=order, implicit=implicit, upwind=upwind)

    def curl(self, at=&#39;corner&#39;):
        &#34;&#34;&#34;Alias for `phi.field.curl`&#34;&#34;&#34;
        from ._field_math import curl
        return curl(self, at=at)

    def laplace(self,
                axes: DimFilter = spatial,
                gradient: &#39;Field&#39; = None,
                order=2,
                implicit: math.Solve = None,
                weights: Union[Tensor, &#39;Field&#39;] = None,
                upwind: &#39;Field&#39; = None,
                correct_skew=True):
        &#34;&#34;&#34;Alias for `phi.field.laplace`&#34;&#34;&#34;
        from ._field_math import laplace
        return laplace(self, axes=axes, gradient=gradient, order=order, implicit=implicit, weights=weights, upwind=upwind, correct_skew=correct_skew)

    def downsample(self, factor: int):
        from ._field_math import downsample2x
        result = self
        while factor &gt;= 2:
            result = downsample2x(result)
            factor /= 2
        if math.close(factor, 1.):
            return result
        from ._resample import resample
        raise NotImplementedError(f&#34;downsample does not support fractional re-sampling. Only 2^n currently supported.&#34;)

    def staggered_tensor(self) -&gt; Tensor:
        &#34;&#34;&#34;
        Stacks all component grids into a single uniform `phi.math.Tensor`.
        The individual components are padded to a common (larger) shape before being stacked.
        The shape of the returned tensor is exactly one cell larger than the grid `resolution` in every spatial dimension.

        Returns:
            Uniform `phi.math.Tensor`.
        &#34;&#34;&#34;
        assert self.resolution.names == self.shape.get_item_names(&#39;vector&#39;), &#34;Field.staggered_tensor() only defined for Fields whose vector components match the resolution&#34;
        padded = []
        for dim, component in zip(self.resolution.names, self.vector):
            widths = {d: (0, 1) for d in self.resolution.names}
            lo_valid, up_valid = self.extrapolation.valid_outer_faces(dim)
            widths[dim] = (int(not lo_valid), int(not up_valid))
            padded.append(math.pad(component.values, widths, self.extrapolation[{&#39;vector&#39;: dim}], bounds=self.bounds))
        result = math.stack(padded, channel(vector=self.resolution))
        assert result.shape.is_uniform
        return result

    @staticmethod
    def __stack__(values: tuple, dim: Shape, **kwargs) -&gt; &#39;Field&#39;:
        from ._field_math import stack
        return stack(values, dim, kwargs.get(&#39;bounds&#39;, None))

    @staticmethod
    def __concat__(values: tuple, dim: str, **kwargs) -&gt; &#39;Field&#39;:
        from ._field_math import concat
        return concat(values, dim)

    def __and__(self, other):
        assert isinstance(other, Field)
        assert instance(self).rank == instance(other).rank == 1, f&#34;Can only use &amp; on PointClouds that have a single instance dimension but got shapes {self.shape} &amp; {other.shape}&#34;
        from ._field_math import concat
        return concat([self, other], instance(self))

    def __matmul__(self, other: &#39;Field&#39;):  # value @ representation
        # Deprecated. Use `resample(value, field)` instead.
        warnings.warn(&#34;value @ field is deprecated. Use resample(value, field) instead.&#34;, DeprecationWarning)
        from ._resample import resample
        return resample(self, to=other, keep_boundary=False)

    def __rmatmul__(self, other):  # values @ representation
        if isinstance(other, (Geometry, Number, tuple, list, FieldInitializer)):
            warnings.warn(&#34;value @ field is deprecated. Use resample(value, field) instead.&#34;, DeprecationWarning)
            from ._resample import resample
            return resample(other, to=self, keep_boundary=False)
        return NotImplemented

    def __rshift__(self, other):
        if isinstance(other, (Field, Geometry)):
            warnings.warn(&#34;&gt;&gt; operator for Fields is deprecated. Use field.at(), the constructor or obj @ field instead.&#34;, SyntaxWarning, stacklevel=2)
            return self.at(other, keep_boundary=False)
        else:
            return NotImplemented

    def __rrshift__(self, other):
        return self.with_values(other)

    def __lshift__(self, other):
        return self.with_values(other)

    def __rrshift__(self, other):
        warnings.warn(&#34;&gt;&gt; operator for Fields is deprecated. Use field.at(), the constructor or obj @ field instead.&#34;, SyntaxWarning, stacklevel=2)
        if not isinstance(self, Field):
            return NotImplemented
        if isinstance(other, (Geometry, float, int, complex, tuple, list, FieldInitializer)):
            from ._resample import resample
            return resample(other, to=self, keep_boundary=False)
        return NotImplemented

    def __getitem__(self, item) -&gt; &#39;Field&#39;:
        &#34;&#34;&#34;
        Access a slice of the Field.
        The returned `Field` may be of a different type than `self`.

        Args:
            item: `dict` mapping dimensions (`str`) to selections (`int` or `slice`) or other supported type, such as `int` or `str`.

        Returns:
            Sliced `Field`.
        &#34;&#34;&#34;
        item = slicing_dict(self, item)
        if not item:
            return self
        boundary = domain_slice(self._boundary, item, self.resolution)
        item_without_vec = {dim: selection for dim, selection in item.items() if dim != &#39;vector&#39;}
        geometry = self._geometry[item_without_vec]
        if self.is_staggered and &#39;vector&#39; in item and &#39;~vector&#39; in self.geometry.face_shape:
            assert isinstance(self._geometry, UniformGrid), f&#34;Vector slicing is only supported for grids&#34;
            dims = item[&#39;vector&#39;]
            dims_ = self._geometry.shape[&#39;vector&#39;].after_gather({&#39;vector&#39;: dims})
            dims = dims_.item_names[0] if dims_ else [dims] if isinstance(dims, str) else [self._geometry.shape[&#39;vector&#39;].item_names[0][dims]]
            proj_dims = set(self.resolution.names) - set(dims)
            if any(dim not in item for dim in proj_dims):
                # warnings.warn(f&#34;Projecting a staggered grid (by slicing &#39;vector&#39; without the corresponding spatial dims) will return a non-staggered grid. The projected dims {proj_dims} were not sliced off.\nFull slice: {item}&#34;)
                item[&#39;~vector&#39;] = item[&#39;vector&#39;]
                del item[&#39;vector&#39;]
                geometry = self.sampled_elements[item]
            else:
                item[&#39;~vector&#39;] = dims
                del item[&#39;vector&#39;]
        values = self._values[item]
        return Field(geometry, values, boundary)

    def __getattr__(self, name: str) -&gt; BoundDim:
        return BoundDim(self, name)

    def dimension(self, name: str):
        &#34;&#34;&#34;
        Returns a reference to one of the dimensions of this field.

        The dimension reference can be used the same way as a `Tensor` dimension reference.
        Notable properties and methods of a dimension reference are:
        indexing using `[index]`, `unstack()`, `size`, `exists`, `is_batch`, `is_spatial`, `is_channel`.

        A shortcut to calling this function is the syntax `field.&lt;dim_name&gt;` which calls `field.dimension(&lt;dim_name&gt;)`.

        Args:
            name: dimension name

        Returns:
            dimension reference

        &#34;&#34;&#34;
        return BoundDim(self, name)

    def __value_attrs__(self):
        return &#39;_values&#39;,

    def __variable_attrs__(self):
        return &#39;_values&#39;, &#39;_geometry&#39;, &#39;_boundary&#39;

    def __expand__(self, dims: Shape, **kwargs) -&gt; &#39;Field&#39;:
        return self.with_values(expand(self.values, dims, **kwargs))

    def __replace_dims__(self, dims: Tuple[str, ...], new_dims: Shape, **kwargs) -&gt; &#39;Field&#39;:
        elements = math.rename_dims(self._geometry, dims, new_dims)
        values = math.rename_dims(self._values, dims, new_dims)
        extrapolation = math.rename_dims(self._boundary, dims, new_dims, **kwargs)
        return Field(elements, values, extrapolation)

    def __eq__(self, other):
        if not isinstance(other, Field):
            return False
        if self._geometry != other._geometry:
            return False
        if self._boundary != other.boundary:
            return False
        return math.always_close(self._values, other._values)

    def __hash__(self):
        return hash((self._geometry, self._boundary))

    def __mul__(self, other):
        return self._op2(other, lambda d1, d2: d1 * d2)

    __rmul__ = __mul__

    def __truediv__(self, other):
        return self._op2(other, lambda d1, d2: d1 / d2)

    def __rtruediv__(self, other):
        return self._op2(other, lambda d1, d2: d2 / d1)

    def __sub__(self, other):
        return self._op2(other, lambda d1, d2: d1 - d2)

    def __rsub__(self, other):
        return self._op2(other, lambda d1, d2: d2 - d1)

    def __add__(self, other):
        return self._op2(other, lambda d1, d2: d1 + d2)

    __radd__ = __add__

    def __pow__(self, power, modulo=None):
        return self._op2(power, lambda f, p: f ** p)

    def __neg__(self):
        return self._op1(lambda x: -x)

    def __gt__(self, other):
        return self._op2(other, lambda x, y: x &gt; y)

    def __ge__(self, other):
        return self._op2(other, lambda x, y: x &gt;= y)

    def __lt__(self, other):
        return self._op2(other, lambda x, y: x &lt; y)

    def __le__(self, other):
        return self._op2(other, lambda x, y: x &lt;= y)

    def __abs__(self):
        return self._op1(lambda x: abs(x))

    def _op1(self: &#39;Field&#39;, operator: Callable) -&gt; &#39;Field&#39;:
        &#34;&#34;&#34;
        Perform an operation on the data of this field.

        Args:
          operator: function that accepts tensors and extrapolations and returns objects of the same type and dimensions

        Returns:
          Field of same type
        &#34;&#34;&#34;
        values = operator(self.values)
        extrapolation_ = operator(self._boundary)
        return self.with_values(values).with_extrapolation(extrapolation_)

    def _op2(self, other, operator) -&gt; &#39;Field&#39;:
        if isinstance(other, Geometry):
            raise ValueError(f&#34;Cannot combine {self.__class__.__name__} with a Geometry, got {type(other)}&#34;)
        if isinstance(other, Field):
            if self._geometry == other._geometry:
                values = operator(self._values, other.values)
                extrapolation_ = operator(self._boundary, other.extrapolation)
                return Field(self._geometry, values, extrapolation_)
            from ._resample import sample
            other_values = sample(other, self._geometry, self.sampled_at, self.boundary, dot_face_normal=self._geometry)
            values = operator(self._values, other_values)
            boundary = operator(self._boundary, other.extrapolation)
            return Field(self._geometry, values, boundary)
        else:
            if isinstance(other, (tuple, list)) and len(other) == self.spatial_rank:
                other = math.wrap(other, self._geometry.shape[&#39;vector&#39;])
            else:
                other = math.wrap(other)
            # try:
            #     boundary = operator(self._boundary, as_boundary(other, self._geometry))
            # except TypeError:  # e.g. ZERO_GRADIENT + constant
            boundary = self._boundary  # constants don&#39;t affect the boundary conditions (legacy reasons)
            if &#39;vector&#39; in self.shape and &#39;vector&#39; not in self.values.shape and &#39;~vector&#39; in self.values.shape:
                other = other.vector.as_dual()
            values = operator(self._values, other)
            return Field(self._geometry, values, boundary)

    def __repr__(self):
        if self.is_grid:
            type_name = &#34;Grid&#34; if self.is_centered else &#34;Grid faces&#34;
        elif self.is_mesh:
            type_name = &#34;Mesh&#34; if self.is_centered else &#34;Mesh faces&#34;
        elif self.is_point_cloud:
            type_name = &#34;Point cloud&#34; if self.is_centered else &#34;Point cloud edges&#34;
        elif self.is_graph:
            type_name = &#34;Graph&#34; if self.is_centered else &#34;Graph edges&#34;
        else:
            type_name = self.__class__.__name__
        if self._values is not None:
            return f&#34;{type_name}[{self.values}, ext={self._boundary}]&#34;
        else:
            return f&#34;{type_name}[{self.resolution}, ext={self._boundary}]&#34;

    def grid_scatter(self, *args, **kwargs):
        &#34;&#34;&#34;Deprecated. Use `sample` with `scatter=True` instead.&#34;&#34;&#34;
        warnings.warn(&#34;Field.grid_scatter() is deprecated. Use field.sample() with scatter=True instead.&#34;, DeprecationWarning, stacklevel=2)
        from ._resample import grid_scatter
        return grid_scatter(self, *args, **kwargs)

    def as_boundary(self) -&gt; Extrapolation:
        &#34;&#34;&#34;
        Returns an `Extrapolation` representing this &#39;Field&#39;&#39;s values as a Dirichlet (constant) boundary.
        If this `Field` encloses the required boundaries, its values will be interpolated to the required boundaries.
        If boundaries outside of this `Field`&#39;s sampled domain are required, this `Field`&#39;s boundary conditions will be applied to determine the boundary values.

        Returns:
            `Extrapolation`
        &#34;&#34;&#34;
        from ._embed import FieldEmbedding
        return FieldEmbedding(self)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li>phi.field._mask.HardGeometryMask</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="phi.field.Field.boundary"><code class="name">prop <span class="ident">boundary</span> : phiml.math.extrapolation.Extrapolation</code></dt>
<dd>
<div class="desc"><p>Returns the boundary conditions set for this <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code>.</p>
<h2 id="returns">Returns</h2>
<p>Single <code>Extrapolation</code> instance that encodes the (varying) boundary conditions for all boundaries of this field's <code>elements</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def boundary(self) -&gt; Extrapolation:
    &#34;&#34;&#34;
    Returns the boundary conditions set for this `Field`.

    Returns:
        Single `Extrapolation` instance that encodes the (varying) boundary conditions for all boundaries of this field&#39;s `elements`.
    &#34;&#34;&#34;
    return self._boundary</code></pre>
</details>
</dd>
<dt id="phi.field.Field.bounds"><code class="name">prop <span class="ident">bounds</span> : phi.geom._box.BaseBox</code></dt>
<dd>
<div class="desc"><p>The bounds represent the area inside which the values of this <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> are valid.
The bounds will also be used as axis limits for plots.</p>
<p>The bounds can be set manually in the constructor, otherwise default bounds will be generated.</p>
<p>For fields that are valid without bounds, the lower and upper limit of <code>bounds</code> is set to <code>-inf</code> and <code>inf</code>, respectively.</p>
<p>Fields whose spatial rank is determined only during sampling return an empty <code>Box</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bounds(self) -&gt; BaseBox:
    &#34;&#34;&#34;
    The bounds represent the area inside which the values of this `Field` are valid.
    The bounds will also be used as axis limits for plots.

    The bounds can be set manually in the constructor, otherwise default bounds will be generated.

    For fields that are valid without bounds, the lower and upper limit of `bounds` is set to `-inf` and `inf`, respectively.

    Fields whose spatial rank is determined only during sampling return an empty `Box`.
    &#34;&#34;&#34;
    if isinstance(self._geometry.bounds, BaseBox):
        return self._geometry.bounds
    extent = self._geometry.bounding_half_extent().vector.as_dual(&#39;_extent&#39;)
    points = self._geometry.center + extent
    lower = math.min(points, dim=points.shape.non_batch.non_channel)
    upper = math.max(points, dim=points.shape.non_batch.non_channel)
    return Box(lower, upper)</code></pre>
</details>
</dd>
<dt id="phi.field.Field.box"><code class="name">prop <span class="ident">box</span> : phi.geom._box.BaseBox</code></dt>
<dd>
<div class="desc"><p>The bounds represent the area inside which the values of this <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> are valid.
The bounds will also be used as axis limits for plots.</p>
<p>The bounds can be set manually in the constructor, otherwise default bounds will be generated.</p>
<p>For fields that are valid without bounds, the lower and upper limit of <code>bounds</code> is set to <code>-inf</code> and <code>inf</code>, respectively.</p>
<p>Fields whose spatial rank is determined only during sampling return an empty <code>Box</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bounds(self) -&gt; BaseBox:
    &#34;&#34;&#34;
    The bounds represent the area inside which the values of this `Field` are valid.
    The bounds will also be used as axis limits for plots.

    The bounds can be set manually in the constructor, otherwise default bounds will be generated.

    For fields that are valid without bounds, the lower and upper limit of `bounds` is set to `-inf` and `inf`, respectively.

    Fields whose spatial rank is determined only during sampling return an empty `Box`.
    &#34;&#34;&#34;
    if isinstance(self._geometry.bounds, BaseBox):
        return self._geometry.bounds
    extent = self._geometry.bounding_half_extent().vector.as_dual(&#39;_extent&#39;)
    points = self._geometry.center + extent
    lower = math.min(points, dim=points.shape.non_batch.non_channel)
    upper = math.max(points, dim=points.shape.non_batch.non_channel)
    return Box(lower, upper)</code></pre>
</details>
</dd>
<dt id="phi.field.Field.cells"><code class="name">prop <span class="ident">cells</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cells(self):
    assert isinstance(self._geometry, (UniformGrid, Mesh))
    return self._geometry</code></pre>
</details>
</dd>
<dt id="phi.field.Field.center"><code class="name">prop <span class="ident">center</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p>Returns the center points of the <code>elements</code> of this <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def center(self) -&gt; Tensor:
    &#34;&#34;&#34; Returns the center points of the `elements` of this `Field`. &#34;&#34;&#34;
    all_points = self._geometry.get_points(self.sampled_at)
    boundary = self._geometry.get_boundary(self.sampled_at)
    return slice_off_constant_faces(all_points, boundary, self.extrapolation)</code></pre>
</details>
</dd>
<dt id="phi.field.Field.data"><code class="name">prop <span class="ident">data</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p>Returns the <code>values</code> of this <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def values(self) -&gt; Tensor:
    &#34;&#34;&#34; Returns the `values` of this `Field`. &#34;&#34;&#34;
    return self._values</code></pre>
</details>
</dd>
<dt id="phi.field.Field.dx"><code class="name">prop <span class="ident">dx</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def dx(self) -&gt; Tensor:
    assert spatial(self._geometry), f&#34;dx is only defined for elements with spatial dims but Field has elements {self._geometry.shape}&#34;
    return self.bounds.size / self.resolution</code></pre>
</details>
</dd>
<dt id="phi.field.Field.elements"><code class="name">prop <span class="ident">elements</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def elements(self):
    # raise SyntaxError(&#34;Field.elements is deprecated. Use Field.geometry or Field.sampled_elements instead.&#34;)
    warnings.warn(&#34;Field.elements is deprecated. Use Field.geometry or Field.sampled_elements instead. Field.elements now defaults to Field.geometry.&#34;, DeprecationWarning, stacklevel=2)
    return self._geometry</code></pre>
</details>
</dd>
<dt id="phi.field.Field.extrapolation"><code class="name">prop <span class="ident">extrapolation</span> : phiml.math.extrapolation.Extrapolation</code></dt>
<dd>
<div class="desc"><p>Returns the <code>Extrapolation</code> of this <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def extrapolation(self) -&gt; Extrapolation:
    &#34;&#34;&#34; Returns the `Extrapolation` of this `Field`. &#34;&#34;&#34;
    return self._boundary</code></pre>
</details>
</dd>
<dt id="phi.field.Field.face_areas"><code class="name">prop <span class="ident">face_areas</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_areas(self):
    return self._geometry.face_areas
    # return slice_off_constant_faces(self._geometry.face_areas, self._geometry.boundary_faces, self._boundary)</code></pre>
</details>
</dd>
<dt id="phi.field.Field.face_centers"><code class="name">prop <span class="ident">face_centers</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_centers(self):
    return self._geometry.face_centers
    # return slice_off_constant_faces(self._geometry.face_centers, self._geometry.boundary_faces, self._boundary)</code></pre>
</details>
</dd>
<dt id="phi.field.Field.face_normals"><code class="name">prop <span class="ident">face_normals</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_normals(self):
    return self._geometry.face_normals
    # return slice_off_constant_faces(self._geometry.face_normals, self._geometry.boundary_faces, self._boundary)</code></pre>
</details>
</dd>
<dt id="phi.field.Field.faces"><code class="name">prop <span class="ident">faces</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def faces(self):
    return get_faces(self._geometry, self._boundary)</code></pre>
</details>
</dd>
<dt id="phi.field.Field.geometry"><code class="name">prop <span class="ident">geometry</span> : phi.geom._geom.Geometry</code></dt>
<dd>
<div class="desc"><p>Returns a geometrical representation of the discrete volume elements.
The result is a tuple of Geometry objects, each of which can have additional spatial (but not batch) dimensions.</p>
<p>For grids, the geometries are boxes while particle fields may be represented as spheres.</p>
<p>If this Field has no discrete points, this method returns an empty geometry.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def geometry(self) -&gt; Geometry:
    &#34;&#34;&#34;
    Returns a geometrical representation of the discrete volume elements.
    The result is a tuple of Geometry objects, each of which can have additional spatial (but not batch) dimensions.
    
    For grids, the geometries are boxes while particle fields may be represented as spheres.
    
    If this Field has no discrete points, this method returns an empty geometry.
    &#34;&#34;&#34;
    return self._geometry</code></pre>
</details>
</dd>
<dt id="phi.field.Field.graph"><code class="name">prop <span class="ident">graph</span> : phi.geom._graph.Graph</code></dt>
<dd>
<div class="desc"><p>Cast <code>self.geometry</code> to a <code><a title="phi.geom.Graph" href="../geom/index.html#phi.geom.Graph">Graph</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def graph(self) -&gt; Graph:
    &#34;&#34;&#34;Cast `self.geometry` to a `phi.geom.Graph`.&#34;&#34;&#34;
    assert isinstance(self._geometry, Graph), f&#34;Geometry is not a mesh but {type(self._geometry)}&#34;
    return self._geometry</code></pre>
</details>
</dd>
<dt id="phi.field.Field.is_centered"><code class="name">prop <span class="ident">is_centered</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_centered(self):
    return not self.is_staggered</code></pre>
</details>
</dd>
<dt id="phi.field.Field.is_graph"><code class="name">prop <span class="ident">is_graph</span></code></dt>
<dd>
<div class="desc"><p>A Field represents graph data if its <code>geometry</code> is a <code><a title="phi.geom.Graph" href="../geom/index.html#phi.geom.Graph">Graph</a></code> instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_graph(self):
    &#34;&#34;&#34;A Field represents graph data if its `geometry` is a `phi.geom.Graph` instance.&#34;&#34;&#34;
    return isinstance(self._geometry, Graph)</code></pre>
</details>
</dd>
<dt id="phi.field.Field.is_grid"><code class="name">prop <span class="ident">is_grid</span></code></dt>
<dd>
<div class="desc"><p>A Field represents grid data if its <code>geometry</code> is a <code><a title="phi.geom.UniformGrid" href="../geom/index.html#phi.geom.UniformGrid">UniformGrid</a></code> instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_grid(self):
    &#34;&#34;&#34;A Field represents grid data if its `geometry` is a `phi.geom.UniformGrid` instance.&#34;&#34;&#34;
    return isinstance(self._geometry, UniformGrid)</code></pre>
</details>
</dd>
<dt id="phi.field.Field.is_mesh"><code class="name">prop <span class="ident">is_mesh</span></code></dt>
<dd>
<div class="desc"><p>A Field represents mesh data if its <code>geometry</code> is a <code><a title="phi.geom.Mesh" href="../geom/index.html#phi.geom.Mesh">Mesh</a></code> instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_mesh(self):
    &#34;&#34;&#34;A Field represents mesh data if its `geometry` is a `phi.geom.Mesh` instance.&#34;&#34;&#34;
    return isinstance(self._geometry, Mesh)</code></pre>
</details>
</dd>
<dt id="phi.field.Field.is_point_cloud"><code class="name">prop <span class="ident">is_point_cloud</span></code></dt>
<dd>
<div class="desc"><p>A Field represents graph data if its <code>geometry</code> is not a set of connected elements, but rather individual geometric objects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_point_cloud(self):
    &#34;&#34;&#34;A Field represents graph data if its `geometry` is not a set of connected elements, but rather individual geometric objects.&#34;&#34;&#34;
    if isinstance(self._geometry, (UniformGrid, Mesh, Graph)):
        return False
    if isinstance(self._geometry, (BaseBox, Sphere, Point)):
        return True
    return True</code></pre>
</details>
</dd>
<dt id="phi.field.Field.is_staggered"><code class="name">prop <span class="ident">is_staggered</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_staggered(self):
    return is_staggered(self._values, self._geometry)</code></pre>
</details>
</dd>
<dt id="phi.field.Field.mesh"><code class="name">prop <span class="ident">mesh</span> : phi.geom._mesh.Mesh</code></dt>
<dd>
<div class="desc"><p>Cast <code>self.geometry</code> to a <code><a title="phi.geom.Mesh" href="../geom/index.html#phi.geom.Mesh">Mesh</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mesh(self) -&gt; Mesh:
    &#34;&#34;&#34;Cast `self.geometry` to a `phi.geom.Mesh`.&#34;&#34;&#34;
    assert isinstance(self._geometry, Mesh), f&#34;Geometry is not a mesh but {type(self._geometry)}&#34;
    return self._geometry</code></pre>
</details>
</dd>
<dt id="phi.field.Field.points"><code class="name">prop <span class="ident">points</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def points(self):
    return self.center</code></pre>
</details>
</dd>
<dt id="phi.field.Field.resolution"><code class="name">prop <span class="ident">resolution</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def resolution(self):
    return self._geometry.shape.non_channel.non_dual.non_batch</code></pre>
</details>
</dd>
<dt id="phi.field.Field.sampled_at"><code class="name">prop <span class="ident">sampled_at</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sampled_at(self):
    matching_sets = [s for s, s_shape in self._geometry.sets.items() if s_shape in self._values.shape]
    return matching_sets[-1]</code></pre>
</details>
</dd>
<dt id="phi.field.Field.sampled_elements"><code class="name">prop <span class="ident">sampled_elements</span> : phi.geom._geom.Geometry</code></dt>
<dd>
<div class="desc"><p>If the values represent are sampled at the element centers or represent the whole element, returns <code>self.geometry</code>.
If the values are sampled at the faces, returns <code>self.faces</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sampled_elements(self) -&gt; Geometry:
    &#34;&#34;&#34;
    If the values represent are sampled at the element centers or represent the whole element, returns `self.geometry`.
    If the values are sampled at the faces, returns `self.faces`.
    &#34;&#34;&#34;
    return get_faces(self._geometry, self._boundary) if is_staggered(self._values, self._geometry) else self._geometry</code></pre>
</details>
</dd>
<dt id="phi.field.Field.shape"><code class="name">prop <span class="ident">shape</span> : phiml.math._shape.Shape</code></dt>
<dd>
<div class="desc"><p>Returns a shape with the following properties</p>
<ul>
<li>The spatial dimension names match the dimensions of this Field</li>
<li>The batch dimensions match the batch dimensions of this Field</li>
<li>The channel dimensions match the channels of this Field</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape(self) -&gt; Shape:
    &#34;&#34;&#34;
    Returns a shape with the following properties
    
    * The spatial dimension names match the dimensions of this Field
    * The batch dimensions match the batch dimensions of this Field
    * The channel dimensions match the channels of this Field
    &#34;&#34;&#34;
    if self.is_staggered and self.is_grid:
        return batch(self._geometry) &amp; self.resolution &amp; non_dual(self._values).without(self.resolution) &amp; self._geometry.shape[&#39;vector&#39;]
    set_shape = self._geometry.sets[self.sampled_at]
    return batch(self._geometry) &amp; (channel(self._geometry) - &#39;vector&#39;) &amp; set_shape &amp; self._values</code></pre>
</details>
</dd>
<dt id="phi.field.Field.spatial_rank"><code class="name">prop <span class="ident">spatial_rank</span> : int</code></dt>
<dd>
<div class="desc"><p>Spatial rank of the field (1 for 1D, 2 for 2D, 3 for 3D).
This is equal to the spatial rank of the <code>data</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def spatial_rank(self) -&gt; int:
    &#34;&#34;&#34;
    Spatial rank of the field (1 for 1D, 2 for 2D, 3 for 3D).
    This is equal to the spatial rank of the `data`.
    &#34;&#34;&#34;
    return self._geometry.spatial_rank</code></pre>
</details>
</dd>
<dt id="phi.field.Field.values"><code class="name">prop <span class="ident">values</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p>Returns the <code>values</code> of this <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def values(self) -&gt; Tensor:
    &#34;&#34;&#34; Returns the `values` of this `Field`. &#34;&#34;&#34;
    return self._values</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phi.field.Field.as_boundary"><code class="name flex">
<span>def <span class="ident">as_boundary</span></span>(<span>self) ‑> phiml.math.extrapolation.Extrapolation</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an <code>Extrapolation</code> representing this 'Field''s values as a Dirichlet (constant) boundary.
If this <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> encloses the required boundaries, its values will be interpolated to the required boundaries.
If boundaries outside of this <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code>'s sampled domain are required, this <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code>'s boundary conditions will be applied to determine the boundary values.</p>
<h2 id="returns">Returns</h2>
<p><code>Extrapolation</code></p></div>
</dd>
<dt id="phi.field.Field.as_points"><code class="name flex">
<span>def <span class="ident">as_points</span></span>(<span>self, list_dim: Optional[phiml.math._shape.Shape] = (elementsⁱ=None)) ‑> phi.field._field.Field</span>
</code></dt>
<dd>
<div class="desc"><p>Returns this field as a PointCloud.
This replaces the <code><a title="phi.field.Field.geometry" href="#phi.field.Field.geometry">Field.geometry</a></code> with a <code><a title="phi.geom.Point" href="../geom/index.html#phi.geom.Point">Point</a></code> instance while leaving the sample points unchanged.</p>
<p>See Also:
<code><a title="phi.field.Field.as_spheres" href="#phi.field.Field.as_spheres">Field.as_spheres()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>list_dim</code></strong></dt>
<dd>If not <code>None</code>, packs spatial, instance and dual dims.
Defaults to <code>instance('elements')</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> with same values and boundaries but <code>Point</code> geometry.</p></div>
</dd>
<dt id="phi.field.Field.as_spheres"><code class="name flex">
<span>def <span class="ident">as_spheres</span></span>(<span>self, list_dim: Optional[phiml.math._shape.Shape] = (elementsⁱ=None)) ‑> phi.field._field.Field</span>
</code></dt>
<dd>
<div class="desc"><p>Returns this field as a PointCloud with spherical / circular elements, preserving element volumes.
This replaces the <code><a title="phi.field.Field.geometry" href="#phi.field.Field.geometry">Field.geometry</a></code> with a <code><a title="phi.geom.Sphere" href="../geom/index.html#phi.geom.Sphere">Sphere</a></code> instance while leaving the sample points unchanged.</p>
<p>See Also:
<code><a title="phi.field.Field.as_points" href="#phi.field.Field.as_points">Field.as_points()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>list_dim</code></strong></dt>
<dd>If not <code>None</code>, packs spatial, instance and dual dims.
Defaults to <code>instance('elements')</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> with same values and boundaries but <code>Sphere</code> geometry.</p></div>
</dd>
<dt id="phi.field.Field.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>self, representation: Union[ForwardRef('<a title="phi.field.Field" href="#phi.field.Field">Field</a>'), phi.geom._geom.Geometry], keep_boundary=False, **kwargs) ‑> phi.field._field.Field</span>
</code></dt>
<dd>
<div class="desc"><p>Short for <code><a title="phi.field.resample" href="#phi.field.resample">resample()</a>(self, representation)</code></p>
<p>See Also
<code><a title="phi.field.resample" href="#phi.field.resample">resample()</a></code>.</p>
<h2 id="returns">Returns</h2>
<p>Field object of same type as <code>representation</code></p></div>
</dd>
<dt id="phi.field.Field.at_centers"><code class="name flex">
<span>def <span class="ident">at_centers</span></span>(<span>self, **kwargs) ‑> phi.field._field.Field</span>
</code></dt>
<dd>
<div class="desc"><p>Interpolates the values to the cell centers.</p>
<p>See Also:
<code><a title="phi.field.Field.at_faces" href="#phi.field.Field.at_faces">Field.at_faces()</a></code>, <code><a title="phi.field.Field.at" href="#phi.field.Field.at">Field.at()</a></code>, <code><a title="phi.field.resample" href="#phi.field.resample">resample()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Sampling arguments.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.field.CenteredGrid" href="#phi.field.CenteredGrid">CenteredGrid()</a></code> sampled at cell centers.</p></div>
</dd>
<dt id="phi.field.Field.at_faces"><code class="name flex">
<span>def <span class="ident">at_faces</span></span>(<span>self, boundary=None, **kwargs) ‑> phi.field._field.Field</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="phi.field.Field.closest_values"><code class="name flex">
<span>def <span class="ident">closest_values</span></span>(<span>self, points: phiml.math._tensors.Tensor)</span>
</code></dt>
<dd>
<div class="desc"><p>Sample the closest grid point values of this field at the world-space locations (in physical units) given by <code>points</code>.
Points must have a single channel dimension named <code>vector</code>.
It may additionally contain any number of batch and spatial dimensions, all treated as batch dimensions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>points</code></strong></dt>
<dd>world-space locations</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Closest grid point values as a <code>Tensor</code>.
For each dimension, the grid points immediately left and right of the sample points are evaluated.
For each point in <code>points</code>, a <em>2^d</em> cube of points is determined where <em>d</em> is the number of spatial dimensions of this field.
These values are stacked along the new dimensions <code>'closest_&lt;dim&gt;'</code> where <code>&lt;dim&gt;</code> refers to the name of a spatial dimension.</p></div>
</dd>
<dt id="phi.field.Field.curl"><code class="name flex">
<span>def <span class="ident">curl</span></span>(<span>self, at='corner')</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for <code><a title="phi.field.curl" href="#phi.field.curl">curl()</a></code></p></div>
</dd>
<dt id="phi.field.Field.dimension"><code class="name flex">
<span>def <span class="ident">dimension</span></span>(<span>self, name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a reference to one of the dimensions of this field.</p>
<p>The dimension reference can be used the same way as a <code>Tensor</code> dimension reference.
Notable properties and methods of a dimension reference are:
indexing using <code>[index]</code>, <code><a title="phi.field.unstack" href="#phi.field.unstack">unstack()</a></code>, <code>size</code>, <code>exists</code>, <code>is_batch</code>, <code>is_spatial</code>, <code>is_channel</code>.</p>
<p>A shortcut to calling this function is the syntax <code>field.&lt;dim_name&gt;</code> which calls <code>field.dimension(&lt;dim_name&gt;)</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>dimension name</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>dimension reference</p></div>
</dd>
<dt id="phi.field.Field.divergence"><code class="name flex">
<span>def <span class="ident">divergence</span></span>(<span>self, order=2, implicit: phiml.math._optimize.Solve = None, upwind: <a title="phi.field.Field" href="#phi.field.Field">Field</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for <code><a title="phi.field.divergence" href="#phi.field.divergence">divergence()</a></code></p></div>
</dd>
<dt id="phi.field.Field.downsample"><code class="name flex">
<span>def <span class="ident">downsample</span></span>(<span>self, factor: int)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="phi.field.Field.gradient"><code class="name flex">
<span>def <span class="ident">gradient</span></span>(<span>self, boundary: phiml.math.extrapolation.Extrapolation = None, at: str = 'center', dims: Union[str, tuple, list, set, ForwardRef('Shape'), Callable] = &lt;function spatial&gt;, stack_dim: Union[phiml.math._shape.Shape, str] = (vectorᶜ=None), order=2, implicit: phiml.math._optimize.Solve = None, scheme=None, upwind: <a title="phi.field.Field" href="#phi.field.Field">Field</a> = None, gradient_extrapolation: phiml.math.extrapolation.Extrapolation = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for <code><a title="phi.field.spatial_gradient" href="#phi.field.spatial_gradient">spatial_gradient()</a></code></p></div>
</dd>
<dt id="phi.field.Field.grid_scatter"><code class="name flex">
<span>def <span class="ident">grid_scatter</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Deprecated. Use <code><a title="phi.field.sample" href="#phi.field.sample">sample()</a></code> with <code>scatter=True</code> instead.</p></div>
</dd>
<dt id="phi.field.Field.laplace"><code class="name flex">
<span>def <span class="ident">laplace</span></span>(<span>self, axes: Union[str, tuple, list, set, ForwardRef('Shape'), Callable] = &lt;function spatial&gt;, gradient: <a title="phi.field.Field" href="#phi.field.Field">Field</a> = None, order=2, implicit: phiml.math._optimize.Solve = None, weights: Union[phiml.math._tensors.Tensor, ForwardRef('<a title="phi.field.Field" href="#phi.field.Field">Field</a>')] = None, upwind: <a title="phi.field.Field" href="#phi.field.Field">Field</a> = None, correct_skew=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for <code><a title="phi.field.laplace" href="#phi.field.laplace">laplace()</a></code></p></div>
</dd>
<dt id="phi.field.Field.numpy"><code class="name flex">
<span>def <span class="ident">numpy</span></span>(<span>self, order: Union[str, tuple, list, set, ForwardRef('Shape'), Callable] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the field values as <code>NumPy</code> array(s).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>order</code></strong></dt>
<dd>Dimension order as <code>str</code> or <code>Shape</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A single NumPy array for uniform values, else a list of NumPy arrays.</p></div>
</dd>
<dt id="phi.field.Field.pad"><code class="name flex">
<span>def <span class="ident">pad</span></span>(<span>self, widths: Union[int, tuple, list, dict]) ‑> phi.field._field.Field</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for <code><a title="phi.field.pad" href="#phi.field.pad">pad()</a></code>.</p>
<p>Pads this <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> using its extrapolation.</p>
<p>Unlike padding the values, this function also affects the <code>geometry</code> of the field, changing its size and origin depending on <code>widths</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>widths</code></strong></dt>
<dd>Either <code>int</code> or <code>(lower, upper)</code> to pad the same number of cells in all spatial dimensions
or <code>dict</code> mapping dimension names to <code>(lower, upper)</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Padded <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code></p></div>
</dd>
<dt id="phi.field.Field.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>self, where: Union[phi.geom._geom.Geometry, ForwardRef('<a title="phi.field.Field" href="#phi.field.Field">Field</a>'), phiml.math._tensors.Tensor], at: str = 'center', **kwargs) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Sample the values of this <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> at the given location or geometry.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>where</code></strong></dt>
<dd>Location <code>Tensor</code> or <code>Geometry</code> or</dd>
<dt><strong><code>at</code></strong></dt>
<dd><code>'center'</code> or <code>'face'</code>.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Sampling arguments.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>Tensor</code></p></div>
</dd>
<dt id="phi.field.Field.shifted"><code class="name flex">
<span>def <span class="ident">shifted</span></span>(<span>self, delta: phiml.math._tensors.Tensor) ‑> phi.field._field.Field</span>
</code></dt>
<dd>
<div class="desc"><p>Move the positions of this field's <code>geometry</code> by <code>delta</code>.</p>
<p>See Also:
<code><a title="phi.field.Field.shifted_to" href="#phi.field.Field.shifted_to">Field.shifted_to()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>delta</code></strong></dt>
<dd>Shift amount for each center position of <code>geometry</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>New <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> sampled at <code>geometry.center + delta</code>.</p></div>
</dd>
<dt id="phi.field.Field.shifted_to"><code class="name flex">
<span>def <span class="ident">shifted_to</span></span>(<span>self, position: phiml.math._tensors.Tensor) ‑> phi.field._field.Field</span>
</code></dt>
<dd>
<div class="desc"><p>Move the positions of this field's <code>geometry</code> to <code>positions</code>.</p>
<p>See Also:
<code><a title="phi.field.Field.shifted" href="#phi.field.Field.shifted">Field.shifted()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>position</code></strong></dt>
<dd>New center positions of <code>geometry</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>New <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> sampled at given positions.</p></div>
</dd>
<dt id="phi.field.Field.staggered_tensor"><code class="name flex">
<span>def <span class="ident">staggered_tensor</span></span>(<span>self) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Stacks all component grids into a single uniform <code>phi.math.Tensor</code>.
The individual components are padded to a common (larger) shape before being stacked.
The shape of the returned tensor is exactly one cell larger than the grid <code>resolution</code> in every spatial dimension.</p>
<h2 id="returns">Returns</h2>
<p>Uniform <code>phi.math.Tensor</code>.</p></div>
</dd>
<dt id="phi.field.Field.to_grid"><code class="name flex">
<span>def <span class="ident">to_grid</span></span>(<span>self, resolution=(), bounds=None, **resolution_)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="phi.field.Field.uniform_values"><code class="name flex">
<span>def <span class="ident">uniform_values</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a uniform tensor containing <code>values</code>.</p>
<p>For periodic grids, which always have a uniform value tensor, `values' is returned directly.
If <code>values</code> is not uniform, it is padded as in <code>StaggeredGrid.staggered_tensor()</code>.</p></div>
</dd>
<dt id="phi.field.Field.with_boundary"><code class="name flex">
<span>def <span class="ident">with_boundary</span></span>(<span>self, boundary)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a copy of this field with the <code>boundary</code> replaced.</p></div>
</dd>
<dt id="phi.field.Field.with_bounds"><code class="name flex">
<span>def <span class="ident">with_bounds</span></span>(<span>self, bounds: phi.geom._box.Box)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a copy of this field with <code>bounds</code> replaced.</p></div>
</dd>
<dt id="phi.field.Field.with_elements"><code class="name flex">
<span>def <span class="ident">with_elements</span></span>(<span>self, elements: phi.geom._geom.Geometry)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a copy of this field with <code>elements</code> replaced.</p></div>
</dd>
<dt id="phi.field.Field.with_extrapolation"><code class="name flex">
<span>def <span class="ident">with_extrapolation</span></span>(<span>self, boundary)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a copy of this field with the <code>boundary</code> replaced.</p></div>
</dd>
<dt id="phi.field.Field.with_geometry"><code class="name flex">
<span>def <span class="ident">with_geometry</span></span>(<span>self, elements: phi.geom._geom.Geometry)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a copy of this field with <code>elements</code> replaced.</p></div>
</dd>
<dt id="phi.field.Field.with_values"><code class="name flex">
<span>def <span class="ident">with_values</span></span>(<span>self, values, **sampling_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a copy of this field with <code>values</code> replaced.</p></div>
</dd>
</dl>
</dd>
<dt id="phi.field.HardGeometryMask"><code class="flex name class">
<span>class <span class="ident">HardGeometryMask</span></span>
<span>(</span><span>geometry: phi.geom._geom.Geometry)</span>
</code></dt>
<dd>
<div class="desc"><p>Deprecated since version 1.3. Use <code><a title="phi.field.mask" href="#phi.field.mask">mask()</a></code> or <code><a title="phi.field.resample" href="#phi.field.resample">resample()</a></code> instead.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>elements</code></strong></dt>
<dd>Geometry object specifying the sample points and sizes</dd>
<dt><strong><code>values</code></strong></dt>
<dd>values corresponding to elements</dd>
<dt><strong><code>extrapolation</code></strong></dt>
<dd>values outside elements</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HardGeometryMask(Field):
    &#34;&#34;&#34;
    Deprecated since version 1.3. Use `phi.field.mask()` or `phi.field.resample()` instead.
    &#34;&#34;&#34;

    def __init__(self, geometry: Geometry):
        super().__init__(geometry, 1, 0)
        warnings.warn(&#34;HardGeometryMask and SoftGeometryMask are deprecated. Use field.mask or field.resample instead.&#34;, DeprecationWarning, stacklevel=2)

    @property
    def shape(self):
        return self.geometry.shape.non_channel

    def _sample(self, geometry: Geometry, **kwargs) -&gt; Tensor:
        return math.to_float(self.geometry.lies_inside(geometry.center))

    def __getitem__(self, item: dict):
        return HardGeometryMask(self.geometry[item])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.field._field.Field</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>phi.field._mask.SoftGeometryMask</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="phi.field.HardGeometryMask.shape"><code class="name">prop <span class="ident">shape</span></code></dt>
<dd>
<div class="desc"><p>Returns a shape with the following properties</p>
<ul>
<li>The spatial dimension names match the dimensions of this Field</li>
<li>The batch dimensions match the batch dimensions of this Field</li>
<li>The channel dimensions match the channels of this Field</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape(self):
    return self.geometry.shape.non_channel</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="phi.field.Noise"><code class="flex name class">
<span>class <span class="ident">Noise</span></span>
<span>(</span><span>*shape: phiml.math._shape.Shape, scale=10.0, smoothness=1.0, **channel_dims)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates random noise fluctuations which can be configured in physical size and smoothness.
Each time values are sampled from a Noise field, a new noise field is generated.</p>
<p>Noise is typically used as an initializer for CenteredGrids or StaggeredGrids.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>shape</code></strong></dt>
<dd>Batch and channel dimensions. Spatial dimensions will be added automatically once sampled on a grid.</dd>
<dt><strong><code>scale</code></strong></dt>
<dd>Size of noise fluctuations in physical units.</dd>
<dt><strong><code>smoothness</code></strong></dt>
<dd>Determines how quickly high frequencies die out.</dd>
<dt><strong><code>**dims</code></strong></dt>
<dd>Additional dimensions, added to <code>shape</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Noise(FieldInitializer):
    &#34;&#34;&#34;
    Generates random noise fluctuations which can be configured in physical size and smoothness.
    Each time values are sampled from a Noise field, a new noise field is generated.

    Noise is typically used as an initializer for CenteredGrids or StaggeredGrids.
    &#34;&#34;&#34;

    def __init__(self, *shape: math.Shape, scale=10., smoothness=1.0, **channel_dims):
        &#34;&#34;&#34;
        Args:
          shape: Batch and channel dimensions. Spatial dimensions will be added automatically once sampled on a grid.
          scale: Size of noise fluctuations in physical units.
          smoothness: Determines how quickly high frequencies die out.
          **dims: Additional dimensions, added to `shape`.
        &#34;&#34;&#34;
        self.scale = scale
        self.smoothness = smoothness
        self._shape = math.concat_shapes(*shape, channel(**channel_dims))

    def _sample(self, geometry: Geometry, at: str, boundaries: Extrapolation, **kwargs) -&gt; Tensor:
        if isinstance(geometry, UniformGrid):
            if at == &#39;center&#39;:
                return self.grid_sample(geometry.resolution, geometry.grid_size)
            elif at == &#39;face&#39;:
                result = {dim: self.grid_sample(grid.resolution, grid.grid_size) for dim, grid in geometry.staggered_cells(boundaries).items()}
                return vec(geometry.face_shape.dual, **result)
        raise NotImplementedError(f&#34;{type(geometry)} not supported. Only UniformGrid allowed.&#34;)

    def grid_sample(self, resolution: math.Shape, size, shape: math.Shape = None):
        shape = (self._shape if shape is None else shape) &amp; resolution
        for dim in channel(self._shape):
            if dim.name == &#39;vector&#39; and dim.item_names[0] is None:
                warnings.warn(f&#34;Please provide item names for Noise dim {dim} using {dim}=&#39;x,y,z&#39;&#34;, FutureWarning)
                shape &amp;= channel(**{dim.name: resolution.names})
        rndj = math.to_complex(random_normal(shape)) + 1j * math.to_complex(random_normal(shape))  # Note: there is no complex32
        # --- Compute 1 / k^2 ---
        k_vec = math.fftfreq(resolution, size) * resolution * math.tensor(self.scale)  # in physical units
        k2 = math.vec_squared(k_vec)
        lowest_frequency = 0.1
        weight_mask = math.to_float(k2 &gt; lowest_frequency)
        inv_k2 = math.divide_no_nan(1, k2)
        # --- Compute result ---
        fft = rndj * inv_k2 ** self.smoothness * weight_mask
        array = math.real(math.ifft(fft))
        array /= math.std(array, dim=array.shape.non_batch)
        array -= math.mean(array, dim=array.shape.non_batch)
        array = math.to_float(array)
        return array

    def __repr__(self):
        return f&#34;{self._shape}, scale={self.scale}, smoothness={self.smoothness}&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.field._field.FieldInitializer</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="phi.field.Noise.grid_sample"><code class="name flex">
<span>def <span class="ident">grid_sample</span></span>(<span>self, resolution: phiml.math._shape.Shape, size, shape: phiml.math._shape.Shape = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="phi.field.Scene"><code class="flex name class">
<span>class <span class="ident">Scene</span></span>
</code></dt>
<dd>
<div class="desc"><p>Provides methods for reading and writing simulation data.</p>
<p>See the format documentation at <a href="https://tum-pbs.github.io/PhiFlow/Scene_Format_Specification.html">https://tum-pbs.github.io/PhiFlow/Scene_Format_Specification.html</a> .</p>
<p>All data of a <code><a title="phi.field.Scene" href="#phi.field.Scene">Scene</a></code> is located inside a single directory with name <code>sim_xxxxxx</code> where <code>xxxxxx</code> is the <code>id</code>.
The data of the scene is organized into NumPy files by <em>name</em> and <em>frame</em>.</p>
<p>To create a new scene, use <code><a title="phi.field.Scene.create" href="#phi.field.Scene.create">Scene.create()</a></code>.
To reference an existing scene, use <code><a title="phi.field.Scene.at" href="#phi.field.Scene.at">Scene.at()</a></code>.
To list all scenes within a directory, use <code><a title="phi.field.Scene.list" href="#phi.field.Scene.list">Scene.list()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Scene:
    &#34;&#34;&#34;
    Provides methods for reading and writing simulation data.

    See the format documentation at https://tum-pbs.github.io/PhiFlow/Scene_Format_Specification.html .

    All data of a `Scene` is located inside a single directory with name `sim_xxxxxx` where `xxxxxx` is the `id`.
    The data of the scene is organized into NumPy files by *name* and *frame*.

    To create a new scene, use `Scene.create()`.
    To reference an existing scene, use `Scene.at()`.
    To list all scenes within a directory, use `Scene.list()`.
    &#34;&#34;&#34;

    def __init__(self, paths: Union[str, math.Tensor]):
        self._paths = math.wrap(paths)
        self._properties: Union[dict, None] = None

    def __getitem__(self, item):
        return Scene(self._paths[item])

    def __getattr__(self, name: str) -&gt; BoundDim:
        return BoundDim(self, name)

    def __variable_attrs__(self) -&gt; Tuple[str, ...]:
        return &#39;paths&#39;,

    def __with_attrs__(self, **attrs):
        if &#39;paths&#39; in attrs:
            return Scene(attrs[&#39;paths&#39;])
        else:
            return Scene(self._paths)

    @property
    def shape(self):
        return self._paths.shape

    @property
    def is_batch(self):
        return self._paths.rank &gt; 0

    @property
    def path(self) -&gt; str:
        &#34;&#34;&#34;
        Relative path of the scene directory.
        This property only exists for single scenes, not scene batches.
        &#34;&#34;&#34;
        assert not self.is_batch, &#34;Scene.path is not defined for scene batches.&#34;
        return self._paths.native()

    @property
    def paths(self) -&gt; math.Tensor:
        return self._paths

    @staticmethod
    def stack(*scenes: &#39;Scene&#39;, dim: Shape = batch(&#39;batch&#39;)) -&gt; &#39;Scene&#39;:
        return Scene(math.stack([s._paths for s in scenes], dim))

    @staticmethod
    def create(parent_directory: str,
               shape: math.Shape = math.EMPTY_SHAPE,
               name=&#39;sim&#39;,
               copy_calling_script=True,
               **dimensions) -&gt; &#39;Scene&#39;:
        &#34;&#34;&#34;
        Creates a new `Scene` or a batch of new scenes inside `parent_directory`.

        See Also:
            `Scene.at()`, `Scene.list()`.

        Args:
            parent_directory: Directory to hold the new `Scene`. If it doesn&#39;t exist, it will be created.
            shape: Determines number of scenes to create. Multiple scenes will be represented by a `Scene` with `is_batch=True`.
            name: Name of the directory (excluding index). Default is `&#39;sim&#39;`.
            copy_calling_script: Whether to copy the Python file that invoked this method into the `src` folder of all created scenes.
                See `Scene.copy_calling_script()`.
            dimensions: Additional batch dimensions

        Returns:
            Single `Scene` object representing the new scene(s).
        &#34;&#34;&#34;
        shape = shape &amp; math.batch(**dimensions)
        parent_directory = expanduser(parent_directory)
        abs_dir = abspath(parent_directory)
        if not isdir(abs_dir):
            os.makedirs(abs_dir)
            next_id = 0
        else:
            indices = [int(f[len(name)+1:]) for f in os.listdir(abs_dir) if f.startswith(f&#34;{name}_&#34;)]
            next_id = max([-1] + indices) + 1
        ids = unpack_dim(wrap(tuple(range(next_id, next_id + shape.volume))), &#39;vector&#39;, shape)
        paths = math.map(lambda id_: join(parent_directory, f&#34;{name}_{id_:06d}&#34;), ids)
        scene = Scene(paths)
        scene.mkdir()
        if copy_calling_script:
            try:
                scene.copy_calling_script()
            except IOError as err:
                warnings.warn(f&#34;Failed to copy calling script to scene during Scene.create(): {err}&#34;, RuntimeWarning)
        return scene

    @staticmethod
    def list(parent_directory: str,
             name=&#39;sim&#39;,
             include_other: bool = False,
             dim: Union[Shape, None] = None) -&gt; Union[&#39;Scene&#39;, tuple]:
        &#34;&#34;&#34;
        Lists all scenes inside the given directory.

        See Also:
            `Scene.at()`, `Scene.create()`.

        Args:
            parent_directory: Directory that contains scene folders.
            name: Name of the directory (excluding index). Default is `&#39;sim&#39;`.
            include_other: Whether folders that do not match the scene format should also be treated as scenes.
            dim: Stack dimension. If None, returns tuple of `Scene` objects. Otherwise, returns a scene batch with this dimension.

        Returns:
            `tuple` of scenes.
        &#34;&#34;&#34;
        parent_directory = expanduser(parent_directory)
        abs_dir = abspath(parent_directory)
        if not isdir(abs_dir):
            return ()
        names = [sim for sim in os.listdir(abs_dir) if sim.startswith(f&#34;{name}_&#34;) or (include_other and isdir(join(abs_dir, sim)))]
        names = list(sorted(names))
        if dim is None:
            return tuple(Scene(join(parent_directory, n)) for n in names)
        else:
            paths = math.wrap([join(parent_directory, n) for n in names], dim)
            return Scene(paths)

    @staticmethod
    def at(directory: Union[str, tuple, typing_list, math.Tensor, &#39;Scene&#39;], id: Union[int, math.Tensor, None] = None) -&gt; &#39;Scene&#39;:
        &#34;&#34;&#34;
        Creates a `Scene` for an existing directory.

        See Also:
            `Scene.create()`, `Scene.list()`.

        Args:
            directory: Either directory containing scene folder if `id` is given, or scene path if `id=None`.
            id: (Optional) Scene `id`, will be determined from `directory` if not specified.

        Returns:
            `Scene` object for existing scene.
        &#34;&#34;&#34;
        if isinstance(directory, Scene):
            assert id is None, f&#34;Got id={id} but directory is already a Scene.&#34;
            return directory
        if isinstance(directory, (tuple, list)):
            directory = math.wrap(directory, batch(&#39;scenes&#39;))
        directory = math.wrap(math.map(lambda d: expanduser(d), directory))
        if isinstance(id, int) and id &lt; 0:
            assert directory.shape.volume == 1
            scenes = Scene.list(directory.native())
            assert len(scenes) &gt;= -id, f&#34;Failed to get scene {id} at {directory}. {len(scenes)} scenes available in that directory.&#34;
            return scenes[id]
        if id is None:
            paths = wrap(directory)
        else:
            id = math.wrap(id)
            paths = wrap(math.map(lambda d, i: join(d, f&#34;sim_{i:06d}&#34;), directory, id))
        # test all exist
        for path in math.flatten(wrap(paths), flatten_batch=True):
            if not isdir(path):
                raise IOError(f&#34;There is no scene at &#39;{path}&#39;&#34;)
        return Scene(paths)

    def subpath(self, name: str, create=False, create_parent=False) -&gt; Union[str, tuple]:
        &#34;&#34;&#34;
        Resolves the relative path `name` with this `Scene` as the root folder.

        Args:
            name: Relative path with this `Scene` as the root folder.
            create: Whether to create a directory of that name.
            create_parent: Whether to create the parent directory.

        Returns:
            Relative path including the path to this `Scene`.
            In batch mode, returns a `tuple`, else a `str`.
        &#34;&#34;&#34;
        def single_subpath(path):
            path = join(path, name)
            if create_parent and not isdir(os.path.dirname(path)):
                os.makedirs(os.path.dirname(path))
            if create and not isdir(path):
                os.mkdir(path)
            return path

        result = math.map(single_subpath, self._paths)
        return result

    def _init_properties(self):
        if self._properties is not None:
            return

        def read_json(path: str) -&gt; dict:
            json_file = join(path, &#34;description.json&#34;)
            if isfile(json_file):
                with open(json_file) as stream:
                    props = json.load(stream)
                if &#39;__tensors__&#39; in props:
                    for key in props[&#39;__tensors__&#39;]:
                        props[key] = math.from_dict(props[key])
                return props
            else:
                return {}

        if self._paths.shape.volume == 1:
            self._properties = read_json(self._paths.native())
        else:
            self._properties = {}
            dicts = [read_json(p) for p in self._paths]
            keys = set(sum([tuple(d.keys()) for d in dicts], ()))
            for key in keys:
                assert all(key in d for d in dicts), f&#34;Failed to create batched Scene because property &#39;{key}&#39; is present in some scenes but not all.&#34;
                if all([math.all(d[key] == dicts[0][key]) for d in dicts]):
                    self._properties[key] = dicts[0][key]
                else:
                    self._properties[key] = stack([d[key] for d in dicts], self._paths.shape)
        if &#39;__tensors__&#39; in self._properties:
            del self._properties[&#39;__tensors__&#39;]

    def exist_properties(self):
        &#34;&#34;&#34;
        Checks whether the file `description.json` exists or has existed.
        &#34;&#34;&#34;
        if self._properties is not None:
            return True  # must have been written or read
        else:
            json_file = join(next(iter(math.flatten(self._paths, flatten_batch=True))), &#34;description.json&#34;)
            return isfile(json_file)

    def exists_config(self):
        &#34;&#34;&#34; Tests if the configuration file *description.json* exists. In batch mode, tests if any configuration exists. &#34;&#34;&#34;
        if isinstance(self.path, str):
            return isfile(join(self.path, &#34;description.json&#34;))
        else:
            return any(isfile(join(p, &#34;description.json&#34;)) for p in self.path)

    @property
    def properties(self):
        self._init_properties()
        return self._properties

    @properties.setter
    def properties(self, dict):
        self._properties = dict
        with open(join(self.path, &#34;description.json&#34;), &#34;w&#34;) as out:
            json.dump(self._properties, out, indent=2)

    def put_property(self, key, value):
        &#34;&#34;&#34; See `Scene.put_properties()`. &#34;&#34;&#34;
        self._init_properties()
        self._properties[key] = value
        self._write_properties()

    def put_properties(self, update: dict = None, **kw_updates):
        &#34;&#34;&#34;
        Updates the properties dictionary and stores it in `description.json` of all scene folders.

        Args:
            update: new values, must be JSON serializable.
            kw_updates: additional update as keyword arguments. This overrides `update`.
        &#34;&#34;&#34;
        self._init_properties()
        if update:
            self._properties.update(update)
        self._properties.update(kw_updates)
        for key, value in self._properties.items():
            if isinstance(value, (np.int64, np.int32)):
                value = int(value)
            elif isinstance(value, (np.float16, np.float32, np.float64, np.float16)) or (hasattr(np, &#39;float128&#39;) and isinstance(value, np.float128)):
                value = float(value)
            self._properties[key] = value
        self._write_properties()

    def _get_properties(self, index: dict):
        result = dict(self._properties)
        tensor_names = []
        for key, value in self._properties.items():
            if isinstance(value, math.Tensor):
                value = value[index]
                if value.rank == 0:
                    value = value.dtype.kind(value)
                else:
                    value = math.to_dict(value)
                    tensor_names.append(key)
                result[key] = value
        if tensor_names:
            result[&#39;__tensors__&#39;] = tuple(tensor_names)
        return result

    def _write_properties(self):
        for instance in self.paths.shape.meshgrid():
            path = self.paths[instance].native()
            instance_properties = self._get_properties(instance)
            with open(join(path, &#34;description.json&#34;), &#34;w&#34;) as out:
                json.dump(instance_properties, out, indent=2)

    def write(self, data: dict = None, frame=0, **kw_data):
        &#34;&#34;&#34;
        Writes fields to this scene.
        One NumPy file will be created for each `phi.field.Field`

        See Also:
            `Scene.read()`.

        Args:
            data: `dict` mapping field names to `Field` objects that can be written using `phi.field.write()`.
            kw_data: Additional data, overrides elements in `data`.
            frame: Frame number.
        &#34;&#34;&#34;
        data = dict(data) if data else {}
        data.update(kw_data)
        for name, field in data.items():
            self.write_field(field, name, frame)

    def write_field(self, field: Field, name: str, frame: int):
        &#34;&#34;&#34;
        Write a `Field` to a file.
        The filenames are created from the provided names and the frame index in accordance with the
        scene format specification at https://tum-pbs.github.io/PhiFlow/Scene_Format_Specification.html .

        Args:
            field: single field or structure of Fields to save.
            name: Base file name.
            frame: Frame number as `int`, typically time step index.
        &#34;&#34;&#34;
        if not isinstance(field, Field):
            raise ValueError(f&#34;Only Field instances can be saved but got {field}&#34;)
        name = _slugify_filename(name)
        files = wrap(math.map(lambda dir_: _filename(dir_, name, frame), self._paths))
        write(field, files)

    def read_field(self, name: str, frame: int, convert_to_backend=True) -&gt; Field:
        &#34;&#34;&#34;
        Reads a single `Field` from files contained in this `Scene` (batch).

        Args:
            name: Base file name.
            frame: Frame number as `int`, typically time step index.
            convert_to_backend: Whether to convert the read data to the data format of the default backend, e.g. TensorFlow tensors.

        Returns:
            `Field`
        &#34;&#34;&#34;
        name = _slugify_filename(name)
        files = math.map(lambda dir_: _filename(dir_, name, frame), self._paths)
        return read(files, convert_to_backend=convert_to_backend)

    read_array = read_field

    def read(self, *names: str, frame=0, convert_to_backend=True):
        &#34;&#34;&#34;
        Reads one or multiple fields from disc.

        See Also:
            `Scene.write()`.

        Args:
            names: Single field name or sequence of field names.
            frame: Frame number.
            convert_to_backend: Whether to convert the read data to the data format of the default backend, e.g. TensorFlow tensors.

        Returns:
            Single `phi.field.Field` or sequence of fields, depending on the type of `names`.
        &#34;&#34;&#34;
        if len(names) == 1 and isinstance(names[0], (tuple, list)):
            names = names[0]
        result = [self.read_array(name, frame, convert_to_backend) for name in names]
        return result[0] if len(names) == 1 else result

    @property
    def fieldnames(self) -&gt; tuple:
        &#34;&#34;&#34; Determines all field names present in this `Scene`, independent of frame. &#34;&#34;&#34;
        return get_fieldnames(self.path)

    @property
    def frames(self):
        &#34;&#34;&#34; Determines all frame numbers present in this `Scene`, independent of field names. See `Scene.complete_frames`. &#34;&#34;&#34;
        return get_frames(self.path, mode=set.union)

    @property
    def complete_frames(self):
        &#34;&#34;&#34;
        Determines all frame number for which all existing fields are available.
        If there are multiple fields stored within this scene, a frame is considered complete only if an entry exists for all fields.

        See Also:
            `Scene.frames`
        &#34;&#34;&#34;
        return get_frames(self.path, mode=set.intersection)

    def __repr__(self):
        return f&#34;{self.paths:no-dtype}&#34;

    def __eq__(self, other):
        return isinstance(other, Scene) and (other._paths == self._paths).all

    def copy_calling_script(self, full_trace=False, include_context_information=True):
        &#34;&#34;&#34;
        Copies the Python file that called this method into the `src` folder of this `Scene`.

        In batch mode, the script is copied to all scenes.

        Args:
            full_trace: Whether to include scripts that indirectly called this method.
            include_context_information: If True, writes the phiflow version and `sys.argv` into `context.json`.
        &#34;&#34;&#34;
        script_paths = [frame.filename for frame in inspect.stack()]
        script_paths = list(filter(lambda path: not _is_phi_file(path), script_paths))
        script_paths = set(script_paths) if full_trace else [script_paths[0]]
        self.subpath(&#39;src&#39;, create=True)
        for script_path in script_paths:
            if script_path.endswith(&#39;.py&#39;):
                self.copy_src(script_path, only_external=False)
            elif &#39;ipython&#39; in script_path:
                from IPython import get_ipython
                cells = get_ipython().user_ns[&#39;In&#39;]
                blocks = [f&#34;#%% In[{i}]\n{cell}&#34; for i, cell in enumerate(cells)]
                text = &#34;\n\n&#34;.join(blocks)
                self.copy_src_text(&#39;ipython.py&#39;, text)
        if include_context_information:
            for path in math.flatten(self._paths, flatten_batch=True):
                with open(join(path, &#39;src&#39;, &#39;context.json&#39;), &#39;w&#39;) as context_file:
                    json.dump({
                        &#39;phi_version&#39;: phi_version,
                        &#39;argv&#39;: sys.argv
                    }, context_file)

    def copy_src(self, script_path, only_external=True):
        for path in math.flatten(self._paths, flatten_batch=True):
            if not only_external or not _is_phi_file(script_path):
                shutil.copy(script_path, join(path, &#39;src&#39;, basename(script_path)))

    def copy_src_text(self, filename, text):
        for path in math.flatten(self._paths, flatten_batch=True):
            target = join(path, &#39;src&#39;, filename)
            with open(target, &#34;w&#34;) as file:
                file.writelines(text)

    def mkdir(self):
        for path in math.flatten(self._paths, flatten_batch=True):
            isdir(path) or os.mkdir(path)

    def remove(self):
        &#34;&#34;&#34; Deletes the scene directory and all contained files. &#34;&#34;&#34;
        for p in math.flatten(self._paths, flatten_batch=True):
            p = abspath(p)
            if isdir(p):
                shutil.rmtree(p)

    def rename(self, name: str):
        &#34;&#34;&#34; Deletes the scene directory and all contained files. &#34;&#34;&#34;
        for p in math.flatten(self._paths, flatten_batch=True):
            p = abspath(p)
            if isdir(p):
                new_path = os.path.join(os.path.dirname(p), name)
                print(f&#34;Renaming {p} to {new_path}&#34;)
                shutil.move(p, new_path)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="phi.field.Scene.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>directory: Union[str, tuple, list, phiml.math._tensors.Tensor, ForwardRef('<a title="phi.field.Scene" href="#phi.field.Scene">Scene</a>')], id: Union[int, phiml.math._tensors.Tensor, ForwardRef(None)] = None) ‑> phi.field._scene.Scene</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a <code><a title="phi.field.Scene" href="#phi.field.Scene">Scene</a></code> for an existing directory.</p>
<p>See Also:
<code><a title="phi.field.Scene.create" href="#phi.field.Scene.create">Scene.create()</a></code>, <code><a title="phi.field.Scene.list" href="#phi.field.Scene.list">Scene.list()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>directory</code></strong></dt>
<dd>Either directory containing scene folder if <code>id</code> is given, or scene path if <code>id=None</code>.</dd>
<dt><strong><code>id</code></strong></dt>
<dd>(Optional) Scene <code>id</code>, will be determined from <code>directory</code> if not specified.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.field.Scene" href="#phi.field.Scene">Scene</a></code> object for existing scene.</p></div>
</dd>
<dt id="phi.field.Scene.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>parent_directory: str, shape: phiml.math._shape.Shape = (), name='sim', copy_calling_script=True, **dimensions) ‑> phi.field._scene.Scene</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new <code><a title="phi.field.Scene" href="#phi.field.Scene">Scene</a></code> or a batch of new scenes inside <code>parent_directory</code>.</p>
<p>See Also:
<code><a title="phi.field.Scene.at" href="#phi.field.Scene.at">Scene.at()</a></code>, <code><a title="phi.field.Scene.list" href="#phi.field.Scene.list">Scene.list()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parent_directory</code></strong></dt>
<dd>Directory to hold the new <code><a title="phi.field.Scene" href="#phi.field.Scene">Scene</a></code>. If it doesn't exist, it will be created.</dd>
<dt><strong><code>shape</code></strong></dt>
<dd>Determines number of scenes to create. Multiple scenes will be represented by a <code><a title="phi.field.Scene" href="#phi.field.Scene">Scene</a></code> with <code>is_batch=True</code>.</dd>
<dt><strong><code>name</code></strong></dt>
<dd>Name of the directory (excluding index). Default is <code>'sim'</code>.</dd>
<dt><strong><code>copy_calling_script</code></strong></dt>
<dd>Whether to copy the Python file that invoked this method into the <code>src</code> folder of all created scenes.
See <code><a title="phi.field.Scene.copy_calling_script" href="#phi.field.Scene.copy_calling_script">Scene.copy_calling_script()</a></code>.</dd>
<dt><strong><code>dimensions</code></strong></dt>
<dd>Additional batch dimensions</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Single <code><a title="phi.field.Scene" href="#phi.field.Scene">Scene</a></code> object representing the new scene(s).</p></div>
</dd>
<dt id="phi.field.Scene.list"><code class="name flex">
<span>def <span class="ident">list</span></span>(<span>parent_directory: str, name='sim', include_other: bool = False, dim: Optional[phiml.math._shape.Shape] = None) ‑> Union[phi.field._scene.Scene, tuple]</span>
</code></dt>
<dd>
<div class="desc"><p>Lists all scenes inside the given directory.</p>
<p>See Also:
<code><a title="phi.field.Scene.at" href="#phi.field.Scene.at">Scene.at()</a></code>, <code><a title="phi.field.Scene.create" href="#phi.field.Scene.create">Scene.create()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parent_directory</code></strong></dt>
<dd>Directory that contains scene folders.</dd>
<dt><strong><code>name</code></strong></dt>
<dd>Name of the directory (excluding index). Default is <code>'sim'</code>.</dd>
<dt><strong><code>include_other</code></strong></dt>
<dd>Whether folders that do not match the scene format should also be treated as scenes.</dd>
<dt><strong><code>dim</code></strong></dt>
<dd>Stack dimension. If None, returns tuple of <code><a title="phi.field.Scene" href="#phi.field.Scene">Scene</a></code> objects. Otherwise, returns a scene batch with this dimension.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>tuple</code> of scenes.</p></div>
</dd>
<dt id="phi.field.Scene.stack"><code class="name flex">
<span>def <span class="ident">stack</span></span>(<span>*scenes: <a title="phi.field.Scene" href="#phi.field.Scene">Scene</a>, dim: phiml.math._shape.Shape = (batchᵇ=None)) ‑> phi.field._scene.Scene</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="phi.field.Scene.complete_frames"><code class="name">prop <span class="ident">complete_frames</span></code></dt>
<dd>
<div class="desc"><p>Determines all frame number for which all existing fields are available.
If there are multiple fields stored within this scene, a frame is considered complete only if an entry exists for all fields.</p>
<p>See Also:
<code><a title="phi.field.Scene.frames" href="#phi.field.Scene.frames">Scene.frames</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def complete_frames(self):
    &#34;&#34;&#34;
    Determines all frame number for which all existing fields are available.
    If there are multiple fields stored within this scene, a frame is considered complete only if an entry exists for all fields.

    See Also:
        `Scene.frames`
    &#34;&#34;&#34;
    return get_frames(self.path, mode=set.intersection)</code></pre>
</details>
</dd>
<dt id="phi.field.Scene.fieldnames"><code class="name">prop <span class="ident">fieldnames</span> : tuple</code></dt>
<dd>
<div class="desc"><p>Determines all field names present in this <code><a title="phi.field.Scene" href="#phi.field.Scene">Scene</a></code>, independent of frame.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def fieldnames(self) -&gt; tuple:
    &#34;&#34;&#34; Determines all field names present in this `Scene`, independent of frame. &#34;&#34;&#34;
    return get_fieldnames(self.path)</code></pre>
</details>
</dd>
<dt id="phi.field.Scene.frames"><code class="name">prop <span class="ident">frames</span></code></dt>
<dd>
<div class="desc"><p>Determines all frame numbers present in this <code><a title="phi.field.Scene" href="#phi.field.Scene">Scene</a></code>, independent of field names. See <code><a title="phi.field.Scene.complete_frames" href="#phi.field.Scene.complete_frames">Scene.complete_frames</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def frames(self):
    &#34;&#34;&#34; Determines all frame numbers present in this `Scene`, independent of field names. See `Scene.complete_frames`. &#34;&#34;&#34;
    return get_frames(self.path, mode=set.union)</code></pre>
</details>
</dd>
<dt id="phi.field.Scene.is_batch"><code class="name">prop <span class="ident">is_batch</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_batch(self):
    return self._paths.rank &gt; 0</code></pre>
</details>
</dd>
<dt id="phi.field.Scene.path"><code class="name">prop <span class="ident">path</span> : str</code></dt>
<dd>
<div class="desc"><p>Relative path of the scene directory.
This property only exists for single scenes, not scene batches.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def path(self) -&gt; str:
    &#34;&#34;&#34;
    Relative path of the scene directory.
    This property only exists for single scenes, not scene batches.
    &#34;&#34;&#34;
    assert not self.is_batch, &#34;Scene.path is not defined for scene batches.&#34;
    return self._paths.native()</code></pre>
</details>
</dd>
<dt id="phi.field.Scene.paths"><code class="name">prop <span class="ident">paths</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def paths(self) -&gt; math.Tensor:
    return self._paths</code></pre>
</details>
</dd>
<dt id="phi.field.Scene.properties"><code class="name">prop <span class="ident">properties</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def properties(self):
    self._init_properties()
    return self._properties</code></pre>
</details>
</dd>
<dt id="phi.field.Scene.shape"><code class="name">prop <span class="ident">shape</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape(self):
    return self._paths.shape</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phi.field.Scene.copy_calling_script"><code class="name flex">
<span>def <span class="ident">copy_calling_script</span></span>(<span>self, full_trace=False, include_context_information=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Copies the Python file that called this method into the <code>src</code> folder of this <code><a title="phi.field.Scene" href="#phi.field.Scene">Scene</a></code>.</p>
<p>In batch mode, the script is copied to all scenes.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>full_trace</code></strong></dt>
<dd>Whether to include scripts that indirectly called this method.</dd>
<dt><strong><code>include_context_information</code></strong></dt>
<dd>If True, writes the phiflow version and <code>sys.argv</code> into <code>context.json</code>.</dd>
</dl></div>
</dd>
<dt id="phi.field.Scene.copy_src"><code class="name flex">
<span>def <span class="ident">copy_src</span></span>(<span>self, script_path, only_external=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="phi.field.Scene.copy_src_text"><code class="name flex">
<span>def <span class="ident">copy_src_text</span></span>(<span>self, filename, text)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="phi.field.Scene.exist_properties"><code class="name flex">
<span>def <span class="ident">exist_properties</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks whether the file <code>description.json</code> exists or has existed.</p></div>
</dd>
<dt id="phi.field.Scene.exists_config"><code class="name flex">
<span>def <span class="ident">exists_config</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Tests if the configuration file <em>description.json</em> exists. In batch mode, tests if any configuration exists.</p></div>
</dd>
<dt id="phi.field.Scene.mkdir"><code class="name flex">
<span>def <span class="ident">mkdir</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="phi.field.Scene.put_properties"><code class="name flex">
<span>def <span class="ident">put_properties</span></span>(<span>self, update: dict = None, **kw_updates)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the properties dictionary and stores it in <code>description.json</code> of all scene folders.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>update</code></strong></dt>
<dd>new values, must be JSON serializable.</dd>
<dt><strong><code>kw_updates</code></strong></dt>
<dd>additional update as keyword arguments. This overrides <code>update</code>.</dd>
</dl></div>
</dd>
<dt id="phi.field.Scene.put_property"><code class="name flex">
<span>def <span class="ident">put_property</span></span>(<span>self, key, value)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="phi.field.Scene.put_properties" href="#phi.field.Scene.put_properties">Scene.put_properties()</a></code>.</p></div>
</dd>
<dt id="phi.field.Scene.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, *names: str, frame=0, convert_to_backend=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Reads one or multiple fields from disc.</p>
<p>See Also:
<code><a title="phi.field.Scene.write" href="#phi.field.Scene.write">Scene.write()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>names</code></strong></dt>
<dd>Single field name or sequence of field names.</dd>
<dt><strong><code>frame</code></strong></dt>
<dd>Frame number.</dd>
<dt><strong><code>convert_to_backend</code></strong></dt>
<dd>Whether to convert the read data to the data format of the default backend, e.g. TensorFlow tensors.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Single <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> or sequence of fields, depending on the type of <code>names</code>.</p></div>
</dd>
<dt id="phi.field.Scene.read_array"><code class="name flex">
<span>def <span class="ident">read_array</span></span>(<span>self, name: str, frame: int, convert_to_backend=True) ‑> phi.field._field.Field</span>
</code></dt>
<dd>
<div class="desc"><p>Reads a single <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> from files contained in this <code><a title="phi.field.Scene" href="#phi.field.Scene">Scene</a></code> (batch).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Base file name.</dd>
<dt><strong><code>frame</code></strong></dt>
<dd>Frame number as <code>int</code>, typically time step index.</dd>
<dt><strong><code>convert_to_backend</code></strong></dt>
<dd>Whether to convert the read data to the data format of the default backend, e.g. TensorFlow tensors.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code></p></div>
</dd>
<dt id="phi.field.Scene.read_field"><code class="name flex">
<span>def <span class="ident">read_field</span></span>(<span>self, name: str, frame: int, convert_to_backend=True) ‑> phi.field._field.Field</span>
</code></dt>
<dd>
<div class="desc"><p>Reads a single <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> from files contained in this <code><a title="phi.field.Scene" href="#phi.field.Scene">Scene</a></code> (batch).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Base file name.</dd>
<dt><strong><code>frame</code></strong></dt>
<dd>Frame number as <code>int</code>, typically time step index.</dd>
<dt><strong><code>convert_to_backend</code></strong></dt>
<dd>Whether to convert the read data to the data format of the default backend, e.g. TensorFlow tensors.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code></p></div>
</dd>
<dt id="phi.field.Scene.remove"><code class="name flex">
<span>def <span class="ident">remove</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes the scene directory and all contained files.</p></div>
</dd>
<dt id="phi.field.Scene.rename"><code class="name flex">
<span>def <span class="ident">rename</span></span>(<span>self, name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes the scene directory and all contained files.</p></div>
</dd>
<dt id="phi.field.Scene.subpath"><code class="name flex">
<span>def <span class="ident">subpath</span></span>(<span>self, name: str, create=False, create_parent=False) ‑> Union[str, tuple]</span>
</code></dt>
<dd>
<div class="desc"><p>Resolves the relative path <code>name</code> with this <code><a title="phi.field.Scene" href="#phi.field.Scene">Scene</a></code> as the root folder.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Relative path with this <code><a title="phi.field.Scene" href="#phi.field.Scene">Scene</a></code> as the root folder.</dd>
<dt><strong><code>create</code></strong></dt>
<dd>Whether to create a directory of that name.</dd>
<dt><strong><code>create_parent</code></strong></dt>
<dd>Whether to create the parent directory.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Relative path including the path to this <code><a title="phi.field.Scene" href="#phi.field.Scene">Scene</a></code>.
In batch mode, returns a <code>tuple</code>, else a <code>str</code>.</p></div>
</dd>
<dt id="phi.field.Scene.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, data: dict = None, frame=0, **kw_data)</span>
</code></dt>
<dd>
<div class="desc"><p>Writes fields to this scene.
One NumPy file will be created for each <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code></p>
<p>See Also:
<code><a title="phi.field.Scene.read" href="#phi.field.Scene.read">Scene.read()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd><code>dict</code> mapping field names to <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> objects that can be written using <code><a title="phi.field.write" href="#phi.field.write">write()</a></code>.</dd>
<dt><strong><code>kw_data</code></strong></dt>
<dd>Additional data, overrides elements in <code>data</code>.</dd>
<dt><strong><code>frame</code></strong></dt>
<dd>Frame number.</dd>
</dl></div>
</dd>
<dt id="phi.field.Scene.write_field"><code class="name flex">
<span>def <span class="ident">write_field</span></span>(<span>self, field: phi.field._field.Field, name: str, frame: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Write a <code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code> to a file.
The filenames are created from the provided names and the frame index in accordance with the
scene format specification at <a href="https://tum-pbs.github.io/PhiFlow/Scene_Format_Specification.html">https://tum-pbs.github.io/PhiFlow/Scene_Format_Specification.html</a> .</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>field</code></strong></dt>
<dd>single field or structure of Fields to save.</dd>
<dt><strong><code>name</code></strong></dt>
<dd>Base file name.</dd>
<dt><strong><code>frame</code></strong></dt>
<dd>Frame number as <code>int</code>, typically time step index.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="phi.field.SoftGeometryMask"><code class="flex name class">
<span>class <span class="ident">GeometryMask</span></span>
<span>(</span><span>geometry: phi.geom._geom.Geometry, balance: Union[phiml.math._tensors.Tensor, float] = 0.5)</span>
</code></dt>
<dd>
<div class="desc"><p>Deprecated since version 1.3. Use <code><a title="phi.field.mask" href="#phi.field.mask">mask()</a></code> or <code><a title="phi.field.resample" href="#phi.field.resample">resample()</a></code> instead.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>elements</code></strong></dt>
<dd>Geometry object specifying the sample points and sizes</dd>
<dt><strong><code>values</code></strong></dt>
<dd>values corresponding to elements</dd>
<dt><strong><code>extrapolation</code></strong></dt>
<dd>values outside elements</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SoftGeometryMask(HardGeometryMask):
    &#34;&#34;&#34;
    Deprecated since version 1.3. Use `phi.field.mask()` or `phi.field.resample()` instead.
    &#34;&#34;&#34;
    def __init__(self, geometry: Geometry, balance: Union[Tensor, float] = 0.5):
        warnings.warn(&#34;HardGeometryMask and SoftGeometryMask are deprecated. Use field.mask or field.resample instead.&#34;, DeprecationWarning, stacklevel=2)
        super().__init__(geometry)
        self.balance = balance

    def _sample(self, geometry: Geometry, **kwargs) -&gt; Tensor:
        return self.geometry.approximate_fraction_inside(geometry, self.balance)

    def __getitem__(self, item: dict):
        return SoftGeometryMask(self.geometry[item], self.balance)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.field._mask.HardGeometryMask</li>
<li>phi.field._field.Field</li>
</ul>
</dd>
<dt id="phi.field.SoftGeometryMask"><code class="flex name class">
<span>class <span class="ident">SoftGeometryMask</span></span>
<span>(</span><span>geometry: phi.geom._geom.Geometry, balance: Union[phiml.math._tensors.Tensor, float] = 0.5)</span>
</code></dt>
<dd>
<div class="desc"><p>Deprecated since version 1.3. Use <code><a title="phi.field.mask" href="#phi.field.mask">mask()</a></code> or <code><a title="phi.field.resample" href="#phi.field.resample">resample()</a></code> instead.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>elements</code></strong></dt>
<dd>Geometry object specifying the sample points and sizes</dd>
<dt><strong><code>values</code></strong></dt>
<dd>values corresponding to elements</dd>
<dt><strong><code>extrapolation</code></strong></dt>
<dd>values outside elements</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SoftGeometryMask(HardGeometryMask):
    &#34;&#34;&#34;
    Deprecated since version 1.3. Use `phi.field.mask()` or `phi.field.resample()` instead.
    &#34;&#34;&#34;
    def __init__(self, geometry: Geometry, balance: Union[Tensor, float] = 0.5):
        warnings.warn(&#34;HardGeometryMask and SoftGeometryMask are deprecated. Use field.mask or field.resample instead.&#34;, DeprecationWarning, stacklevel=2)
        super().__init__(geometry)
        self.balance = balance

    def _sample(self, geometry: Geometry, **kwargs) -&gt; Tensor:
        return self.geometry.approximate_fraction_inside(geometry, self.balance)

    def __getitem__(self, item: dict):
        return SoftGeometryMask(self.geometry[item], self.balance)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.field._mask.HardGeometryMask</li>
<li>phi.field._field.Field</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="phi" href="../index.html">phi</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="phi.field.CenteredGrid" href="#phi.field.CenteredGrid">CenteredGrid</a></code></li>
<li><code><a title="phi.field.PointCloud" href="#phi.field.PointCloud">PointCloud</a></code></li>
<li><code><a title="phi.field.StaggeredGrid" href="#phi.field.StaggeredGrid">StaggeredGrid</a></code></li>
<li><code><a title="phi.field.abs" href="#phi.field.abs">abs</a></code></li>
<li><code><a title="phi.field.as_boundary" href="#phi.field.as_boundary">as_boundary</a></code></li>
<li><code><a title="phi.field.assert_close" href="#phi.field.assert_close">assert_close</a></code></li>
<li><code><a title="phi.field.bake_extrapolation" href="#phi.field.bake_extrapolation">bake_extrapolation</a></code></li>
<li><code><a title="phi.field.cast" href="#phi.field.cast">cast</a></code></li>
<li><code><a title="phi.field.ceil" href="#phi.field.ceil">ceil</a></code></li>
<li><code><a title="phi.field.center_of_mass" href="#phi.field.center_of_mass">center_of_mass</a></code></li>
<li><code><a title="phi.field.concat" href="#phi.field.concat">concat</a></code></li>
<li><code><a title="phi.field.convert" href="#phi.field.convert">convert</a></code></li>
<li><code><a title="phi.field.cos" href="#phi.field.cos">cos</a></code></li>
<li><code><a title="phi.field.curl" href="#phi.field.curl">curl</a></code></li>
<li><code><a title="phi.field.divergence" href="#phi.field.divergence">divergence</a></code></li>
<li><code><a title="phi.field.downsample2x" href="#phi.field.downsample2x">downsample2x</a></code></li>
<li><code><a title="phi.field.exp" href="#phi.field.exp">exp</a></code></li>
<li><code><a title="phi.field.finite_fill" href="#phi.field.finite_fill">finite_fill</a></code></li>
<li><code><a title="phi.field.floor" href="#phi.field.floor">floor</a></code></li>
<li><code><a title="phi.field.fourier_laplace" href="#phi.field.fourier_laplace">fourier_laplace</a></code></li>
<li><code><a title="phi.field.fourier_poisson" href="#phi.field.fourier_poisson">fourier_poisson</a></code></li>
<li><code><a title="phi.field.frequency_loss" href="#phi.field.frequency_loss">frequency_loss</a></code></li>
<li><code><a title="phi.field.functional_gradient" href="#phi.field.functional_gradient">functional_gradient</a></code></li>
<li><code><a title="phi.field.gradient" href="#phi.field.gradient">gradient</a></code></li>
<li><code><a title="phi.field.imag" href="#phi.field.imag">imag</a></code></li>
<li><code><a title="phi.field.integrate" href="#phi.field.integrate">integrate</a></code></li>
<li><code><a title="phi.field.is_finite" href="#phi.field.is_finite">is_finite</a></code></li>
<li><code><a title="phi.field.isfinite" href="#phi.field.isfinite">isfinite</a></code></li>
<li><code><a title="phi.field.jacobian" href="#phi.field.jacobian">jacobian</a></code></li>
<li><code><a title="phi.field.jit_compile" href="#phi.field.jit_compile">jit_compile</a></code></li>
<li><code><a title="phi.field.jit_compile_linear" href="#phi.field.jit_compile_linear">jit_compile_linear</a></code></li>
<li><code><a title="phi.field.l1_loss" href="#phi.field.l1_loss">l1_loss</a></code></li>
<li><code><a title="phi.field.l2_loss" href="#phi.field.l2_loss">l2_loss</a></code></li>
<li><code><a title="phi.field.laplace" href="#phi.field.laplace">laplace</a></code></li>
<li><code><a title="phi.field.mask" href="#phi.field.mask">mask</a></code></li>
<li><code><a title="phi.field.maximum" href="#phi.field.maximum">maximum</a></code></li>
<li><code><a title="phi.field.mean" href="#phi.field.mean">mean</a></code></li>
<li><code><a title="phi.field.minimize" href="#phi.field.minimize">minimize</a></code></li>
<li><code><a title="phi.field.minimum" href="#phi.field.minimum">minimum</a></code></li>
<li><code><a title="phi.field.native_call" href="#phi.field.native_call">native_call</a></code></li>
<li><code><a title="phi.field.normalize" href="#phi.field.normalize">normalize</a></code></li>
<li><code><a title="phi.field.pack_dims" href="#phi.field.pack_dims">pack_dims</a></code></li>
<li><code><a title="phi.field.pad" href="#phi.field.pad">pad</a></code></li>
<li><code><a title="phi.field.read" href="#phi.field.read">read</a></code></li>
<li><code><a title="phi.field.real" href="#phi.field.real">real</a></code></li>
<li><code><a title="phi.field.reduce_sample" href="#phi.field.reduce_sample">reduce_sample</a></code></li>
<li><code><a title="phi.field.resample" href="#phi.field.resample">resample</a></code></li>
<li><code><a title="phi.field.round" href="#phi.field.round">round</a></code></li>
<li><code><a title="phi.field.safe_mul" href="#phi.field.safe_mul">safe_mul</a></code></li>
<li><code><a title="phi.field.sample" href="#phi.field.sample">sample</a></code></li>
<li><code><a title="phi.field.shift" href="#phi.field.shift">shift</a></code></li>
<li><code><a title="phi.field.sign" href="#phi.field.sign">sign</a></code></li>
<li><code><a title="phi.field.sin" href="#phi.field.sin">sin</a></code></li>
<li><code><a title="phi.field.solve_linear" href="#phi.field.solve_linear">solve_linear</a></code></li>
<li><code><a title="phi.field.solve_nonlinear" href="#phi.field.solve_nonlinear">solve_nonlinear</a></code></li>
<li><code><a title="phi.field.spatial_gradient" href="#phi.field.spatial_gradient">spatial_gradient</a></code></li>
<li><code><a title="phi.field.sqrt" href="#phi.field.sqrt">sqrt</a></code></li>
<li><code><a title="phi.field.stack" href="#phi.field.stack">stack</a></code></li>
<li><code><a title="phi.field.stagger" href="#phi.field.stagger">stagger</a></code></li>
<li><code><a title="phi.field.stop_gradient" href="#phi.field.stop_gradient">stop_gradient</a></code></li>
<li><code><a title="phi.field.support" href="#phi.field.support">support</a></code></li>
<li><code><a title="phi.field.to_float" href="#phi.field.to_float">to_float</a></code></li>
<li><code><a title="phi.field.to_int32" href="#phi.field.to_int32">to_int32</a></code></li>
<li><code><a title="phi.field.to_int64" href="#phi.field.to_int64">to_int64</a></code></li>
<li><code><a title="phi.field.unstack" href="#phi.field.unstack">unstack</a></code></li>
<li><code><a title="phi.field.upsample2x" href="#phi.field.upsample2x">upsample2x</a></code></li>
<li><code><a title="phi.field.vec_abs" href="#phi.field.vec_abs">vec_abs</a></code></li>
<li><code><a title="phi.field.vec_length" href="#phi.field.vec_length">vec_length</a></code></li>
<li><code><a title="phi.field.vec_squared" href="#phi.field.vec_squared">vec_squared</a></code></li>
<li><code><a title="phi.field.where" href="#phi.field.where">where</a></code></li>
<li><code><a title="phi.field.write" href="#phi.field.write">write</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="phi.field.AngularVelocity" href="#phi.field.AngularVelocity">AngularVelocity</a></code></h4>
</li>
<li>
<h4><code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code></h4>
<ul class="two-column">
<li><code><a title="phi.field.Field.as_boundary" href="#phi.field.Field.as_boundary">as_boundary</a></code></li>
<li><code><a title="phi.field.Field.as_points" href="#phi.field.Field.as_points">as_points</a></code></li>
<li><code><a title="phi.field.Field.as_spheres" href="#phi.field.Field.as_spheres">as_spheres</a></code></li>
<li><code><a title="phi.field.Field.at" href="#phi.field.Field.at">at</a></code></li>
<li><code><a title="phi.field.Field.at_centers" href="#phi.field.Field.at_centers">at_centers</a></code></li>
<li><code><a title="phi.field.Field.at_faces" href="#phi.field.Field.at_faces">at_faces</a></code></li>
<li><code><a title="phi.field.Field.boundary" href="#phi.field.Field.boundary">boundary</a></code></li>
<li><code><a title="phi.field.Field.bounds" href="#phi.field.Field.bounds">bounds</a></code></li>
<li><code><a title="phi.field.Field.box" href="#phi.field.Field.box">box</a></code></li>
<li><code><a title="phi.field.Field.cells" href="#phi.field.Field.cells">cells</a></code></li>
<li><code><a title="phi.field.Field.center" href="#phi.field.Field.center">center</a></code></li>
<li><code><a title="phi.field.Field.closest_values" href="#phi.field.Field.closest_values">closest_values</a></code></li>
<li><code><a title="phi.field.Field.curl" href="#phi.field.Field.curl">curl</a></code></li>
<li><code><a title="phi.field.Field.data" href="#phi.field.Field.data">data</a></code></li>
<li><code><a title="phi.field.Field.dimension" href="#phi.field.Field.dimension">dimension</a></code></li>
<li><code><a title="phi.field.Field.divergence" href="#phi.field.Field.divergence">divergence</a></code></li>
<li><code><a title="phi.field.Field.downsample" href="#phi.field.Field.downsample">downsample</a></code></li>
<li><code><a title="phi.field.Field.dx" href="#phi.field.Field.dx">dx</a></code></li>
<li><code><a title="phi.field.Field.elements" href="#phi.field.Field.elements">elements</a></code></li>
<li><code><a title="phi.field.Field.extrapolation" href="#phi.field.Field.extrapolation">extrapolation</a></code></li>
<li><code><a title="phi.field.Field.face_areas" href="#phi.field.Field.face_areas">face_areas</a></code></li>
<li><code><a title="phi.field.Field.face_centers" href="#phi.field.Field.face_centers">face_centers</a></code></li>
<li><code><a title="phi.field.Field.face_normals" href="#phi.field.Field.face_normals">face_normals</a></code></li>
<li><code><a title="phi.field.Field.faces" href="#phi.field.Field.faces">faces</a></code></li>
<li><code><a title="phi.field.Field.geometry" href="#phi.field.Field.geometry">geometry</a></code></li>
<li><code><a title="phi.field.Field.gradient" href="#phi.field.Field.gradient">gradient</a></code></li>
<li><code><a title="phi.field.Field.graph" href="#phi.field.Field.graph">graph</a></code></li>
<li><code><a title="phi.field.Field.grid_scatter" href="#phi.field.Field.grid_scatter">grid_scatter</a></code></li>
<li><code><a title="phi.field.Field.is_centered" href="#phi.field.Field.is_centered">is_centered</a></code></li>
<li><code><a title="phi.field.Field.is_graph" href="#phi.field.Field.is_graph">is_graph</a></code></li>
<li><code><a title="phi.field.Field.is_grid" href="#phi.field.Field.is_grid">is_grid</a></code></li>
<li><code><a title="phi.field.Field.is_mesh" href="#phi.field.Field.is_mesh">is_mesh</a></code></li>
<li><code><a title="phi.field.Field.is_point_cloud" href="#phi.field.Field.is_point_cloud">is_point_cloud</a></code></li>
<li><code><a title="phi.field.Field.is_staggered" href="#phi.field.Field.is_staggered">is_staggered</a></code></li>
<li><code><a title="phi.field.Field.laplace" href="#phi.field.Field.laplace">laplace</a></code></li>
<li><code><a title="phi.field.Field.mesh" href="#phi.field.Field.mesh">mesh</a></code></li>
<li><code><a title="phi.field.Field.numpy" href="#phi.field.Field.numpy">numpy</a></code></li>
<li><code><a title="phi.field.Field.pad" href="#phi.field.Field.pad">pad</a></code></li>
<li><code><a title="phi.field.Field.points" href="#phi.field.Field.points">points</a></code></li>
<li><code><a title="phi.field.Field.resolution" href="#phi.field.Field.resolution">resolution</a></code></li>
<li><code><a title="phi.field.Field.sample" href="#phi.field.Field.sample">sample</a></code></li>
<li><code><a title="phi.field.Field.sampled_at" href="#phi.field.Field.sampled_at">sampled_at</a></code></li>
<li><code><a title="phi.field.Field.sampled_elements" href="#phi.field.Field.sampled_elements">sampled_elements</a></code></li>
<li><code><a title="phi.field.Field.shape" href="#phi.field.Field.shape">shape</a></code></li>
<li><code><a title="phi.field.Field.shifted" href="#phi.field.Field.shifted">shifted</a></code></li>
<li><code><a title="phi.field.Field.shifted_to" href="#phi.field.Field.shifted_to">shifted_to</a></code></li>
<li><code><a title="phi.field.Field.spatial_rank" href="#phi.field.Field.spatial_rank">spatial_rank</a></code></li>
<li><code><a title="phi.field.Field.staggered_tensor" href="#phi.field.Field.staggered_tensor">staggered_tensor</a></code></li>
<li><code><a title="phi.field.Field.to_grid" href="#phi.field.Field.to_grid">to_grid</a></code></li>
<li><code><a title="phi.field.Field.uniform_values" href="#phi.field.Field.uniform_values">uniform_values</a></code></li>
<li><code><a title="phi.field.Field.values" href="#phi.field.Field.values">values</a></code></li>
<li><code><a title="phi.field.Field.with_boundary" href="#phi.field.Field.with_boundary">with_boundary</a></code></li>
<li><code><a title="phi.field.Field.with_bounds" href="#phi.field.Field.with_bounds">with_bounds</a></code></li>
<li><code><a title="phi.field.Field.with_elements" href="#phi.field.Field.with_elements">with_elements</a></code></li>
<li><code><a title="phi.field.Field.with_extrapolation" href="#phi.field.Field.with_extrapolation">with_extrapolation</a></code></li>
<li><code><a title="phi.field.Field.with_geometry" href="#phi.field.Field.with_geometry">with_geometry</a></code></li>
<li><code><a title="phi.field.Field.with_values" href="#phi.field.Field.with_values">with_values</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code></h4>
<ul class="two-column">
<li><code><a title="phi.field.Field.as_boundary" href="#phi.field.Field.as_boundary">as_boundary</a></code></li>
<li><code><a title="phi.field.Field.as_points" href="#phi.field.Field.as_points">as_points</a></code></li>
<li><code><a title="phi.field.Field.as_spheres" href="#phi.field.Field.as_spheres">as_spheres</a></code></li>
<li><code><a title="phi.field.Field.at" href="#phi.field.Field.at">at</a></code></li>
<li><code><a title="phi.field.Field.at_centers" href="#phi.field.Field.at_centers">at_centers</a></code></li>
<li><code><a title="phi.field.Field.at_faces" href="#phi.field.Field.at_faces">at_faces</a></code></li>
<li><code><a title="phi.field.Field.boundary" href="#phi.field.Field.boundary">boundary</a></code></li>
<li><code><a title="phi.field.Field.bounds" href="#phi.field.Field.bounds">bounds</a></code></li>
<li><code><a title="phi.field.Field.box" href="#phi.field.Field.box">box</a></code></li>
<li><code><a title="phi.field.Field.cells" href="#phi.field.Field.cells">cells</a></code></li>
<li><code><a title="phi.field.Field.center" href="#phi.field.Field.center">center</a></code></li>
<li><code><a title="phi.field.Field.closest_values" href="#phi.field.Field.closest_values">closest_values</a></code></li>
<li><code><a title="phi.field.Field.curl" href="#phi.field.Field.curl">curl</a></code></li>
<li><code><a title="phi.field.Field.data" href="#phi.field.Field.data">data</a></code></li>
<li><code><a title="phi.field.Field.dimension" href="#phi.field.Field.dimension">dimension</a></code></li>
<li><code><a title="phi.field.Field.divergence" href="#phi.field.Field.divergence">divergence</a></code></li>
<li><code><a title="phi.field.Field.downsample" href="#phi.field.Field.downsample">downsample</a></code></li>
<li><code><a title="phi.field.Field.dx" href="#phi.field.Field.dx">dx</a></code></li>
<li><code><a title="phi.field.Field.elements" href="#phi.field.Field.elements">elements</a></code></li>
<li><code><a title="phi.field.Field.extrapolation" href="#phi.field.Field.extrapolation">extrapolation</a></code></li>
<li><code><a title="phi.field.Field.face_areas" href="#phi.field.Field.face_areas">face_areas</a></code></li>
<li><code><a title="phi.field.Field.face_centers" href="#phi.field.Field.face_centers">face_centers</a></code></li>
<li><code><a title="phi.field.Field.face_normals" href="#phi.field.Field.face_normals">face_normals</a></code></li>
<li><code><a title="phi.field.Field.faces" href="#phi.field.Field.faces">faces</a></code></li>
<li><code><a title="phi.field.Field.geometry" href="#phi.field.Field.geometry">geometry</a></code></li>
<li><code><a title="phi.field.Field.gradient" href="#phi.field.Field.gradient">gradient</a></code></li>
<li><code><a title="phi.field.Field.graph" href="#phi.field.Field.graph">graph</a></code></li>
<li><code><a title="phi.field.Field.grid_scatter" href="#phi.field.Field.grid_scatter">grid_scatter</a></code></li>
<li><code><a title="phi.field.Field.is_centered" href="#phi.field.Field.is_centered">is_centered</a></code></li>
<li><code><a title="phi.field.Field.is_graph" href="#phi.field.Field.is_graph">is_graph</a></code></li>
<li><code><a title="phi.field.Field.is_grid" href="#phi.field.Field.is_grid">is_grid</a></code></li>
<li><code><a title="phi.field.Field.is_mesh" href="#phi.field.Field.is_mesh">is_mesh</a></code></li>
<li><code><a title="phi.field.Field.is_point_cloud" href="#phi.field.Field.is_point_cloud">is_point_cloud</a></code></li>
<li><code><a title="phi.field.Field.is_staggered" href="#phi.field.Field.is_staggered">is_staggered</a></code></li>
<li><code><a title="phi.field.Field.laplace" href="#phi.field.Field.laplace">laplace</a></code></li>
<li><code><a title="phi.field.Field.mesh" href="#phi.field.Field.mesh">mesh</a></code></li>
<li><code><a title="phi.field.Field.numpy" href="#phi.field.Field.numpy">numpy</a></code></li>
<li><code><a title="phi.field.Field.pad" href="#phi.field.Field.pad">pad</a></code></li>
<li><code><a title="phi.field.Field.points" href="#phi.field.Field.points">points</a></code></li>
<li><code><a title="phi.field.Field.resolution" href="#phi.field.Field.resolution">resolution</a></code></li>
<li><code><a title="phi.field.Field.sample" href="#phi.field.Field.sample">sample</a></code></li>
<li><code><a title="phi.field.Field.sampled_at" href="#phi.field.Field.sampled_at">sampled_at</a></code></li>
<li><code><a title="phi.field.Field.sampled_elements" href="#phi.field.Field.sampled_elements">sampled_elements</a></code></li>
<li><code><a title="phi.field.Field.shape" href="#phi.field.Field.shape">shape</a></code></li>
<li><code><a title="phi.field.Field.shifted" href="#phi.field.Field.shifted">shifted</a></code></li>
<li><code><a title="phi.field.Field.shifted_to" href="#phi.field.Field.shifted_to">shifted_to</a></code></li>
<li><code><a title="phi.field.Field.spatial_rank" href="#phi.field.Field.spatial_rank">spatial_rank</a></code></li>
<li><code><a title="phi.field.Field.staggered_tensor" href="#phi.field.Field.staggered_tensor">staggered_tensor</a></code></li>
<li><code><a title="phi.field.Field.to_grid" href="#phi.field.Field.to_grid">to_grid</a></code></li>
<li><code><a title="phi.field.Field.uniform_values" href="#phi.field.Field.uniform_values">uniform_values</a></code></li>
<li><code><a title="phi.field.Field.values" href="#phi.field.Field.values">values</a></code></li>
<li><code><a title="phi.field.Field.with_boundary" href="#phi.field.Field.with_boundary">with_boundary</a></code></li>
<li><code><a title="phi.field.Field.with_bounds" href="#phi.field.Field.with_bounds">with_bounds</a></code></li>
<li><code><a title="phi.field.Field.with_elements" href="#phi.field.Field.with_elements">with_elements</a></code></li>
<li><code><a title="phi.field.Field.with_extrapolation" href="#phi.field.Field.with_extrapolation">with_extrapolation</a></code></li>
<li><code><a title="phi.field.Field.with_geometry" href="#phi.field.Field.with_geometry">with_geometry</a></code></li>
<li><code><a title="phi.field.Field.with_values" href="#phi.field.Field.with_values">with_values</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.field.Field" href="#phi.field.Field">Field</a></code></h4>
<ul class="two-column">
<li><code><a title="phi.field.Field.as_boundary" href="#phi.field.Field.as_boundary">as_boundary</a></code></li>
<li><code><a title="phi.field.Field.as_points" href="#phi.field.Field.as_points">as_points</a></code></li>
<li><code><a title="phi.field.Field.as_spheres" href="#phi.field.Field.as_spheres">as_spheres</a></code></li>
<li><code><a title="phi.field.Field.at" href="#phi.field.Field.at">at</a></code></li>
<li><code><a title="phi.field.Field.at_centers" href="#phi.field.Field.at_centers">at_centers</a></code></li>
<li><code><a title="phi.field.Field.at_faces" href="#phi.field.Field.at_faces">at_faces</a></code></li>
<li><code><a title="phi.field.Field.boundary" href="#phi.field.Field.boundary">boundary</a></code></li>
<li><code><a title="phi.field.Field.bounds" href="#phi.field.Field.bounds">bounds</a></code></li>
<li><code><a title="phi.field.Field.box" href="#phi.field.Field.box">box</a></code></li>
<li><code><a title="phi.field.Field.cells" href="#phi.field.Field.cells">cells</a></code></li>
<li><code><a title="phi.field.Field.center" href="#phi.field.Field.center">center</a></code></li>
<li><code><a title="phi.field.Field.closest_values" href="#phi.field.Field.closest_values">closest_values</a></code></li>
<li><code><a title="phi.field.Field.curl" href="#phi.field.Field.curl">curl</a></code></li>
<li><code><a title="phi.field.Field.data" href="#phi.field.Field.data">data</a></code></li>
<li><code><a title="phi.field.Field.dimension" href="#phi.field.Field.dimension">dimension</a></code></li>
<li><code><a title="phi.field.Field.divergence" href="#phi.field.Field.divergence">divergence</a></code></li>
<li><code><a title="phi.field.Field.downsample" href="#phi.field.Field.downsample">downsample</a></code></li>
<li><code><a title="phi.field.Field.dx" href="#phi.field.Field.dx">dx</a></code></li>
<li><code><a title="phi.field.Field.elements" href="#phi.field.Field.elements">elements</a></code></li>
<li><code><a title="phi.field.Field.extrapolation" href="#phi.field.Field.extrapolation">extrapolation</a></code></li>
<li><code><a title="phi.field.Field.face_areas" href="#phi.field.Field.face_areas">face_areas</a></code></li>
<li><code><a title="phi.field.Field.face_centers" href="#phi.field.Field.face_centers">face_centers</a></code></li>
<li><code><a title="phi.field.Field.face_normals" href="#phi.field.Field.face_normals">face_normals</a></code></li>
<li><code><a title="phi.field.Field.faces" href="#phi.field.Field.faces">faces</a></code></li>
<li><code><a title="phi.field.Field.geometry" href="#phi.field.Field.geometry">geometry</a></code></li>
<li><code><a title="phi.field.Field.gradient" href="#phi.field.Field.gradient">gradient</a></code></li>
<li><code><a title="phi.field.Field.graph" href="#phi.field.Field.graph">graph</a></code></li>
<li><code><a title="phi.field.Field.grid_scatter" href="#phi.field.Field.grid_scatter">grid_scatter</a></code></li>
<li><code><a title="phi.field.Field.is_centered" href="#phi.field.Field.is_centered">is_centered</a></code></li>
<li><code><a title="phi.field.Field.is_graph" href="#phi.field.Field.is_graph">is_graph</a></code></li>
<li><code><a title="phi.field.Field.is_grid" href="#phi.field.Field.is_grid">is_grid</a></code></li>
<li><code><a title="phi.field.Field.is_mesh" href="#phi.field.Field.is_mesh">is_mesh</a></code></li>
<li><code><a title="phi.field.Field.is_point_cloud" href="#phi.field.Field.is_point_cloud">is_point_cloud</a></code></li>
<li><code><a title="phi.field.Field.is_staggered" href="#phi.field.Field.is_staggered">is_staggered</a></code></li>
<li><code><a title="phi.field.Field.laplace" href="#phi.field.Field.laplace">laplace</a></code></li>
<li><code><a title="phi.field.Field.mesh" href="#phi.field.Field.mesh">mesh</a></code></li>
<li><code><a title="phi.field.Field.numpy" href="#phi.field.Field.numpy">numpy</a></code></li>
<li><code><a title="phi.field.Field.pad" href="#phi.field.Field.pad">pad</a></code></li>
<li><code><a title="phi.field.Field.points" href="#phi.field.Field.points">points</a></code></li>
<li><code><a title="phi.field.Field.resolution" href="#phi.field.Field.resolution">resolution</a></code></li>
<li><code><a title="phi.field.Field.sample" href="#phi.field.Field.sample">sample</a></code></li>
<li><code><a title="phi.field.Field.sampled_at" href="#phi.field.Field.sampled_at">sampled_at</a></code></li>
<li><code><a title="phi.field.Field.sampled_elements" href="#phi.field.Field.sampled_elements">sampled_elements</a></code></li>
<li><code><a title="phi.field.Field.shape" href="#phi.field.Field.shape">shape</a></code></li>
<li><code><a title="phi.field.Field.shifted" href="#phi.field.Field.shifted">shifted</a></code></li>
<li><code><a title="phi.field.Field.shifted_to" href="#phi.field.Field.shifted_to">shifted_to</a></code></li>
<li><code><a title="phi.field.Field.spatial_rank" href="#phi.field.Field.spatial_rank">spatial_rank</a></code></li>
<li><code><a title="phi.field.Field.staggered_tensor" href="#phi.field.Field.staggered_tensor">staggered_tensor</a></code></li>
<li><code><a title="phi.field.Field.to_grid" href="#phi.field.Field.to_grid">to_grid</a></code></li>
<li><code><a title="phi.field.Field.uniform_values" href="#phi.field.Field.uniform_values">uniform_values</a></code></li>
<li><code><a title="phi.field.Field.values" href="#phi.field.Field.values">values</a></code></li>
<li><code><a title="phi.field.Field.with_boundary" href="#phi.field.Field.with_boundary">with_boundary</a></code></li>
<li><code><a title="phi.field.Field.with_bounds" href="#phi.field.Field.with_bounds">with_bounds</a></code></li>
<li><code><a title="phi.field.Field.with_elements" href="#phi.field.Field.with_elements">with_elements</a></code></li>
<li><code><a title="phi.field.Field.with_extrapolation" href="#phi.field.Field.with_extrapolation">with_extrapolation</a></code></li>
<li><code><a title="phi.field.Field.with_geometry" href="#phi.field.Field.with_geometry">with_geometry</a></code></li>
<li><code><a title="phi.field.Field.with_values" href="#phi.field.Field.with_values">with_values</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.field.HardGeometryMask" href="#phi.field.HardGeometryMask">HardGeometryMask</a></code></h4>
<ul class="">
<li><code><a title="phi.field.HardGeometryMask.shape" href="#phi.field.HardGeometryMask.shape">shape</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.field.Noise" href="#phi.field.Noise">Noise</a></code></h4>
<ul class="">
<li><code><a title="phi.field.Noise.grid_sample" href="#phi.field.Noise.grid_sample">grid_sample</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.field.Scene" href="#phi.field.Scene">Scene</a></code></h4>
<ul class="two-column">
<li><code><a title="phi.field.Scene.at" href="#phi.field.Scene.at">at</a></code></li>
<li><code><a title="phi.field.Scene.complete_frames" href="#phi.field.Scene.complete_frames">complete_frames</a></code></li>
<li><code><a title="phi.field.Scene.copy_calling_script" href="#phi.field.Scene.copy_calling_script">copy_calling_script</a></code></li>
<li><code><a title="phi.field.Scene.copy_src" href="#phi.field.Scene.copy_src">copy_src</a></code></li>
<li><code><a title="phi.field.Scene.copy_src_text" href="#phi.field.Scene.copy_src_text">copy_src_text</a></code></li>
<li><code><a title="phi.field.Scene.create" href="#phi.field.Scene.create">create</a></code></li>
<li><code><a title="phi.field.Scene.exist_properties" href="#phi.field.Scene.exist_properties">exist_properties</a></code></li>
<li><code><a title="phi.field.Scene.exists_config" href="#phi.field.Scene.exists_config">exists_config</a></code></li>
<li><code><a title="phi.field.Scene.fieldnames" href="#phi.field.Scene.fieldnames">fieldnames</a></code></li>
<li><code><a title="phi.field.Scene.frames" href="#phi.field.Scene.frames">frames</a></code></li>
<li><code><a title="phi.field.Scene.is_batch" href="#phi.field.Scene.is_batch">is_batch</a></code></li>
<li><code><a title="phi.field.Scene.list" href="#phi.field.Scene.list">list</a></code></li>
<li><code><a title="phi.field.Scene.mkdir" href="#phi.field.Scene.mkdir">mkdir</a></code></li>
<li><code><a title="phi.field.Scene.path" href="#phi.field.Scene.path">path</a></code></li>
<li><code><a title="phi.field.Scene.paths" href="#phi.field.Scene.paths">paths</a></code></li>
<li><code><a title="phi.field.Scene.properties" href="#phi.field.Scene.properties">properties</a></code></li>
<li><code><a title="phi.field.Scene.put_properties" href="#phi.field.Scene.put_properties">put_properties</a></code></li>
<li><code><a title="phi.field.Scene.put_property" href="#phi.field.Scene.put_property">put_property</a></code></li>
<li><code><a title="phi.field.Scene.read" href="#phi.field.Scene.read">read</a></code></li>
<li><code><a title="phi.field.Scene.read_array" href="#phi.field.Scene.read_array">read_array</a></code></li>
<li><code><a title="phi.field.Scene.read_field" href="#phi.field.Scene.read_field">read_field</a></code></li>
<li><code><a title="phi.field.Scene.remove" href="#phi.field.Scene.remove">remove</a></code></li>
<li><code><a title="phi.field.Scene.rename" href="#phi.field.Scene.rename">rename</a></code></li>
<li><code><a title="phi.field.Scene.shape" href="#phi.field.Scene.shape">shape</a></code></li>
<li><code><a title="phi.field.Scene.stack" href="#phi.field.Scene.stack">stack</a></code></li>
<li><code><a title="phi.field.Scene.subpath" href="#phi.field.Scene.subpath">subpath</a></code></li>
<li><code><a title="phi.field.Scene.write" href="#phi.field.Scene.write">write</a></code></li>
<li><code><a title="phi.field.Scene.write_field" href="#phi.field.Scene.write_field">write_field</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.field.SoftGeometryMask" href="#phi.field.SoftGeometryMask">SoftGeometryMask</a></code></h4>
</li>
<li>
<h4><code><a title="phi.field.SoftGeometryMask" href="#phi.field.SoftGeometryMask">SoftGeometryMask</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
