<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.1">
<title>phi.geom API documentation</title>
<meta name="description" content="Differentiable geometry package …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>phi.geom</code></h1>
</header>
<section id="section-intro">
<p>Differentiable geometry package.</p>
<p>Classes:</p>
<ul>
<li><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> (base type)</li>
<li><code><a title="phi.geom.Box" href="#phi.geom.Box">Box</a></code></li>
<li><code><a title="phi.geom.Sphere" href="#phi.geom.Sphere">Sphere</a></code></li>
</ul>
<p>See the <code><a title="phi.geom" href="#phi.geom">phi.geom</a></code> module documentation at <a href="https://tum-pbs.github.io/PhiFlow/Geometry.html">https://tum-pbs.github.io/PhiFlow/Geometry.html</a></p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="phi.geom.assert_same_rank"><code class="name flex">
<span>def <span class="ident">assert_same_rank</span></span>(<span>rank1, rank2, error_message)</span>
</code></dt>
<dd>
<div class="desc"><p>Tests that two objects have the same spatial rank. Objects can be of types: <code>int</code>, <code>None</code> (no check), <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>, <code>Shape</code>, <code>Tensor</code></p></div>
</dd>
<dt id="phi.geom.build_mesh"><code class="name flex">
<span>def <span class="ident">build_mesh</span></span>(<span>bounds: phi.geom._box.Box = None, resolution=(), obstacles: Union[phi.geom._geom.Geometry, Dict[str, phi.geom._geom.Geometry]] = None, method='quad', cell_dim: phiml.math._shape.Shape = (cellsⁱ=None), face_format: str = 'csc', max_squish: Optional[float] = 0.5, **resolution_: Union[int, phiml.math._tensors.Tensor, tuple, list, Any]) ‑> phi.geom._mesh.Mesh</span>
</code></dt>
<dd>
<div class="desc"><p>Build a mesh for a given domain, respecting obstacles.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bounds</code></strong></dt>
<dd>Bounds for uniform cells.</dd>
<dt><strong><code>resolution</code></strong></dt>
<dd>Base resolution</dd>
<dt><strong><code>obstacles</code></strong></dt>
<dd>Single <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> or <code>dict</code> mapping boundary name to corresponding <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.</dd>
<dt><strong><code>method</code></strong></dt>
<dd>Meshing algorithm. Only <code>quad</code> is currently supported.</dd>
<dt><strong><code>cell_dim</code></strong></dt>
<dd>Dimension along which to list the cells. This should be an instance dimension.</dd>
<dt><strong><code>face_format</code></strong></dt>
<dd>Sparse storage format for cell connectivity.</dd>
<dt><strong><code>max_squish</code></strong></dt>
<dd>Smallest allowed cell size compared to the smallest regular cell.</dd>
<dt><strong><code>**resolution_</code></strong></dt>
<dd>For uniform grid, pass resolution as <code>int</code> and specify <code>bounds</code>.
Or pass a sequence of floats for each dimension, specifying the vertex positions along each axis.
This allows for variable cell stretching.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.geom.Mesh" href="#phi.geom.Mesh">Mesh</a></code></p></div>
</dd>
<dt id="phi.geom.concat"><code class="name flex">
<span>def <span class="ident">concat</span></span>(<span>values: Union[tuple, list], dim: Union[phiml.math._shape.Shape, str], expand_values=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Concatenates a sequence of <code>phiml.math.magic.Shapable</code> objects, e.g. <code>Tensor</code>, along one dimension.
All values must have the same spatial, instance and channel dimensions and their sizes must be equal, except for <code>dim</code>.
Batch dimensions will be added as needed.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>values</code></strong></dt>
<dd>Tuple or list of <code>phiml.math.magic.Shapable</code>, such as <code>phiml.math.Tensor</code></dd>
<dt><strong><code>dim</code></strong></dt>
<dd>Concatenation dimension, must be present in all <code>values</code>.
The size along <code>dim</code> is determined from <code>values</code> and can be set to undefined (<code>None</code>).</dd>
<dt><strong><code>expand_values</code></strong></dt>
<dd>If <code>True</code>, will first add missing dimensions to all values, not just batch dimensions.
This allows tensors with different dimensions to be concatenated.
The resulting tensor will have all dimensions that are present in <code>values</code>.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Additional keyword arguments required by specific implementations.
Adding spatial dimensions to fields requires the <code>bounds: Box</code> argument specifying the physical extent of the new dimensions.
Adding batch dimensions must always work without keyword arguments.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Concatenated <code>Tensor</code></p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; concat([math.zeros(batch(b=10)), math.ones(batch(b=10))], 'b')
(bᵇ=20) 0.500 ± 0.500 (0e+00...1e+00)
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; concat([vec(x=1, y=0), vec(z=2.)], 'vector')
(x=1.000, y=0.000, z=2.000) float64
</code></pre></div>
</dd>
<dt id="phi.geom.embed"><code class="name flex">
<span>def <span class="ident">embed</span></span>(<span>geometry: phi.geom._geom.Geometry, projected_dims: Union[phiml.math._shape.Shape, str, tuple, list, ForwardRef(None)]) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<div class="desc"><p>Adds fake spatial dimensions to a geometry.
The geometry value will be constant along the added dimensions, as if it had infinite length in these directions.</p>
<p>Dimensions that are already present with <code>geometry</code> are ignored.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>geometry</code></strong></dt>
<dd><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></dd>
<dt><strong><code>projected_dims</code></strong></dt>
<dd>Additional dimensions</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> with spatial rank <code>geometry.spatial_rank + projected_dims.rank</code>.</p></div>
</dd>
<dt id="phi.geom.infinite_cylinder"><code class="name flex">
<span>def <span class="ident">infinite_cylinder</span></span>(<span>center=None, radius=None, inf_dim: Union[str, phiml.math._shape.Shape, tuple, list] = None, **center_) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<div class="desc"><p>Creates an infinite cylinder.
This is equal to embedding an <code>n</code>-dimensional <code><a title="phi.geom.Sphere" href="#phi.geom.Sphere">Sphere</a></code> in <code>n+1</code> dimensions.</p>
<p>See Also:
<code><a title="phi.geom.Sphere" href="#phi.geom.Sphere">Sphere</a></code>, <code><a title="phi.geom.embed" href="#phi.geom.embed">embed()</a></code></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>center</code></strong></dt>
<dd>Center coordinates without <code>inf_dim</code>. Alternatively use keyword arguments.</dd>
<dt><strong><code>radius</code></strong></dt>
<dd>Cylinder radius.</dd>
<dt><strong><code>inf_dim</code></strong></dt>
<dd>Dimension along which the cylinder is infinite.
Use <code><a title="phi.geom.Geometry.rotated" href="#phi.geom.Geometry.rotated">Geometry.rotated()</a></code> if the direction does not align with an axis.</dd>
<dt><strong><code>**center_</code></strong></dt>
<dd>Alternatively specify center coordinates without <code>inf_dim</code> as keyword arguments.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></p></div>
</dd>
<dt id="phi.geom.intersection"><code class="name flex">
<span>def <span class="ident">intersection</span></span>(<span>*geometries, dim=(intersectionⁱ=None)) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<div class="desc"><p>Intersection of the given geometries.
A point lies inside the union if it lies within all of the geometries.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*geometries</code></strong></dt>
<dd>arbitrary geometries with same spatial dims. Arbitrary batch dims are allowed.</dd>
<dt><strong><code>dim</code></strong></dt>
<dd>Intersection dimension. This must be an instance dimension.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>intersection <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></p></div>
</dd>
<dt id="phi.geom.invert"><code class="name flex">
<span>def <span class="ident">invert</span></span>(<span>geometry: phi.geom._geom.Geometry)</span>
</code></dt>
<dd>
<div class="desc"><p>Swaps inside and outside.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>geometry</code></strong></dt>
<dd><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> to swap</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>New <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> object with same surface but swapped normals</p></div>
</dd>
<dt id="phi.geom.load_gmsh"><code class="name flex">
<span>def <span class="ident">load_gmsh</span></span>(<span>file: str, boundary_names: Sequence[str] = None, cell_dim=(cellsⁱ=None), face_format: str = 'csc')</span>
</code></dt>
<dd>
<div class="desc"><p>Load an unstructured mesh from a <code>.msh</code> file.</p>
<p>This requires the package <code>meshio</code> to be installed.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file</code></strong></dt>
<dd>Path to <code>.su2</code> file.</dd>
<dt><strong><code>boundary_names</code></strong></dt>
<dd>Boundary identifiers corresponding to the blocks in the file. If not specified, boundaries will be numbered.</dd>
<dt><strong><code>cell_dim</code></strong></dt>
<dd>Dimension along which to list the cells. This should be an instance dimension.</dd>
<dt><strong><code>face_format</code></strong></dt>
<dd>Sparse storage format for cell connectivity.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.geom.Mesh" href="#phi.geom.Mesh">Mesh</a></code></p></div>
</dd>
<dt id="phi.geom.load_su2"><code class="name flex">
<span>def <span class="ident">load_su2</span></span>(<span>file_or_mesh: str, cell_dim=(cellsⁱ=None), face_format: str = 'csc') ‑> phi.geom._mesh.Mesh</span>
</code></dt>
<dd>
<div class="desc"><p>Load an unstructured mesh from a <code>.su2</code> file.</p>
<p>This requires the package <code>ezmesh</code> to be installed.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_or_mesh</code></strong></dt>
<dd>Path to <code>.su2</code> file or <em>ezmesh</em> <code><a title="phi.geom.Mesh" href="#phi.geom.Mesh">Mesh</a></code> instance.</dd>
<dt><strong><code>cell_dim</code></strong></dt>
<dd>Dimension along which to list the cells. This should be an instance dimension.</dd>
<dt><strong><code>face_format</code></strong></dt>
<dd>Sparse storage format for cell connectivity.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.geom.Mesh" href="#phi.geom.Mesh">Mesh</a></code></p></div>
</dd>
<dt id="phi.geom.mesh"><code class="name flex">
<span>def <span class="ident">mesh</span></span>(<span>vertices: phiml.math._tensors.Tensor, polygons: phiml.math._tensors.Tensor, boundaries: Union[str, Dict[str, List[Sequence]]], face_format: str = 'csc')</span>
</code></dt>
<dd>
<div class="desc"><p>Create a mesh from vertex positions and vertex lists.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>vertices</code></strong></dt>
<dd><code>Tensor</code> with one instance and one channel dimension <code>vector</code>.</dd>
<dt><strong><code>polygons</code></strong></dt>
<dd>Lists of vertex indices as 2D tensor.
The elements must be listed along an instance dimension, and the vertex indices belonging to the same polygon must be listed along a spatial dimension.</dd>
<dt><strong><code>boundaries</code></strong></dt>
<dd>Pass a <code>str</code> to assign one name to all boundary faces.
For multiple boundaries, pass a <code>dict</code> mapping group names <code>str</code> to lists of faces, defined by their vertices.
The last entry can be <code>None</code> to group all boundary faces not explicitly listed before.
The <code>boundaries</code> <code>dict</code> maps boundary names to a list of edges (point pairs) in 2D and faces (3 or more points) in 3D (not yet supported).</dd>
<dt><strong><code>face_format</code></strong></dt>
<dd>Storage format for cell connectivity, must be one of <code>csc</code>, <code>coo</code>, <code>csr</code>, <code>dense</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.geom.Mesh" href="#phi.geom.Mesh">Mesh</a></code></p></div>
</dd>
<dt id="phi.geom.mesh_from_numpy"><code class="name flex">
<span>def <span class="ident">mesh_from_numpy</span></span>(<span>points: Union[list, numpy.ndarray], polygons: list, boundaries: Dict[str, List[Sequence]], cell_dim: phiml.math._shape.Shape = (cellsⁱ=None), face_format: str = 'csc') ‑> phi.geom._mesh.Mesh</span>
</code></dt>
<dd>
<div class="desc"><p>Construct an unstructured mesh from vertices.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>points</code></strong></dt>
<dd>2D numpy array of shape (num_points, point_coord).
The last dimension must have length 2 for 2D meshes and 3 for 3D meshes.</dd>
<dt><strong><code>polygons</code></strong></dt>
<dd>List of elements. Each polygon is defined as a sequence of point indices mapping into `points'.
E.g. <code>[(0, 1, 2)]</code> denotes a single triangle connecting points 0, 1, and 2.</dd>
<dt><strong><code>boundaries</code></strong></dt>
<dd>An unstructured mesh can have multiple boundaries, each defined by a name <code>str</code> and a list of faces, defined by their vertices.
The <code>boundaries</code> <code>dict</code> maps boundary names to a list of edges (point pairs) in 2D and faces (3 or more points) in 3D (not yet supported).</dd>
<dt><strong><code>cell_dim</code></strong></dt>
<dd>Dimension along which to list the cells. This should be an instance dimension.</dd>
<dt><strong><code>face_format</code></strong></dt>
<dd>Storage format for cell connectivity, must be one of <code>csc</code>, <code>coo</code>, <code>csr</code>, <code>dense</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.geom.Mesh" href="#phi.geom.Mesh">Mesh</a></code></p></div>
</dd>
<dt id="phi.geom.normal_from_slope"><code class="name flex">
<span>def <span class="ident">normal_from_slope</span></span>(<span>slope: phiml.math._tensors.Tensor, space: Union[str, phiml.math._shape.Shape, Sequence[str]])</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the normal vector of a line, plane, or hyperplane.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>slope</code></strong></dt>
<dd>Line Slope (2D), plane slope (3D) or hyperplane slope (4+D).
Must have one channel dimension listing the vector components.
The vector must list all but one dimensions of <code>space</code>.</dd>
<dt><strong><code>space</code></strong></dt>
<dd>Ordered spatial dimensions as comma-separated string, sequence of names or <code>Shape</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Normal vector with the channel dimension of <code>slope</code> listing all dimensions of <code>space</code> in that order.</p></div>
</dd>
<dt id="phi.geom.pack_dims"><code class="name flex">
<span>def <span class="ident">pack_dims</span></span>(<span>value, dims: Union[str, tuple, list, set, ForwardRef('Shape'), Callable], packed_dim: phiml.math._shape.Shape, pos: Optional[int] = None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Compresses multiple dimensions into a single dimension by concatenating the elements.
Elements along the new dimensions are laid out according to the order of <code>dims</code>.
If the order of <code>dims</code> differs from the current dimension order, the tensor is transposed accordingly.
This function replaces the traditional <code>reshape</code> for these cases.</p>
<p>The type of the new dimension will be equal to the types of <code>dims</code>.
If <code>dims</code> have varying types, the new dimension will be a batch dimension.</p>
<p>If none of <code>dims</code> exist on <code>value</code>, <code>packed_dim</code> will be added only if it is given with a definite size and <code>value</code> is not a primitive type.</p>
<p>See Also:
<code>unpack_dim()</code></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong></dt>
<dd><code>phiml.math.magic.Shapable</code>, such as <code>phiml.math.Tensor</code>.</dd>
<dt><strong><code>dims</code></strong></dt>
<dd>Dimensions to be compressed in the specified order.</dd>
<dt><strong><code>packed_dim</code></strong></dt>
<dd>Single-dimension <code>Shape</code>.</dd>
<dt><strong><code>pos</code></strong></dt>
<dd>Index of new dimension. <code>None</code> for automatic, <code>-1</code> for last, <code>0</code> for first.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Additional keyword arguments required by specific implementations.
Adding spatial dimensions to fields requires the <code>bounds: Box</code> argument specifying the physical extent of the new dimensions.
Adding batch dimensions must always work without keyword arguments.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Same type as <code>value</code>.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; pack_dims(math.zeros(spatial(x=4, y=3)), spatial, instance('points'))
(pointsⁱ=12) const 0.0
</code></pre></div>
</dd>
<dt id="phi.geom.rotate"><code class="name flex">
<span>def <span class="ident">rotate</span></span>(<span>geometry: phi.geom._geom.Geometry, rot: Union[phiml.math._tensors.Tensor, float], pivot: phiml.math._tensors.Tensor = None) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<div class="desc"><p>Rotate a <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> about an axis given by <code>rot</code> and <code>pivot</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>geometry</code></strong></dt>
<dd><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> to rotate</dd>
<dt><strong><code>rot</code></strong></dt>
<dd>Rotation, either as Euler angles or rotation matrix.</dd>
<dt><strong><code>pivot</code></strong></dt>
<dd>Any point lying on the rotation axis.
If <code>None</code>, rotates about the center point(s).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Rotated <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></p></div>
</dd>
<dt id="phi.geom.sdf_from_geometry"><code class="name flex">
<span>def <span class="ident">sdf_from_geometry</span></span>(<span>geometry: phi.geom._geom.Geometry, bounds: phi.geom._box.Box, resolution: phiml.math._shape.Shape = (), approximate_outside=True, rebuild: Optional[str] = 'auto', valid_dist=None, **resolution_: int) ‑> phi.geom._sdf_grid.SDFGrid</span>
</code></dt>
<dd>
<div class="desc"><p>Build a grid of signed distance values for a given <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>geometry</code></strong></dt>
<dd><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> to capture.</dd>
<dt><strong><code>bounds</code></strong></dt>
<dd>Grid limits in world space.</dd>
<dt><strong><code>resolution</code></strong></dt>
<dd>Grid resolution.</dd>
<dt><strong><code>**resolution_</code></strong></dt>
<dd>Grid resolution as <code>kwargs</code>, e.g. <code>x=64, y=32</code>.</dd>
<dt><strong><code>approximate_outside</code></strong></dt>
<dd>Whether queries outside the SDF grid should return approximate values. This requires additional computations.</dd>
<dt><strong><code>rebuild</code></strong></dt>
<dd>If <code>'from-surface'</code>, SDF values are calculated from a narrow strip above the enclosed surface. This is more accurate but requires additional steps.
If <code>None</code>, SDF values are queried from <code>geometry</code>.
The default <code>'auto'</code> rebuilds when geometry quierying is expected to be in accurate.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>SDF grid as <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.</p></div>
</dd>
<dt id="phi.geom.stack"><code class="name flex">
<span>def <span class="ident">stack</span></span>(<span>values: Union[tuple, list, dict], dim: Union[phiml.math._shape.Shape, str], expand_values=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Stacks <code>values</code> along the new dimension <code>dim</code>.
All values must have the same spatial, instance and channel dimensions. If the dimension sizes vary, the resulting tensor will be non-uniform.
Batch dimensions will be added as needed.</p>
<p>Stacking tensors is performed lazily, i.e. the memory is allocated only when needed.
This makes repeated stacking and slicing along the same dimension very efficient, i.e. jit-compiled functions will not perform these operations.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>values</code></strong></dt>
<dd>Collection of <code>phiml.math.magic.Shapable</code>, such as <code>phiml.math.Tensor</code>
If a <code>dict</code>, keys must be of type <code>str</code> and are used as item names along <code>dim</code>.</dd>
<dt><strong><code>dim</code></strong></dt>
<dd><code>Shape</code> with a least one dimension. None of these dimensions can be present with any of the <code>values</code>.
If <code>dim</code> is a single-dimension shape, its size is determined from <code>len(values)</code> and can be left undefined (<code>None</code>).
If <code>dim</code> is a multi-dimension shape, its volume must be equal to <code>len(values)</code>.</dd>
<dt><strong><code>expand_values</code></strong></dt>
<dd>If <code>True</code>, will first add missing dimensions to all values, not just batch dimensions.
This allows tensors with different dimensions to be stacked.
The resulting tensor will have all dimensions that are present in <code>values</code>.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Additional keyword arguments required by specific implementations.
Adding spatial dimensions to fields requires the <code>bounds: Box</code> argument specifying the physical extent of the new dimensions.
Adding batch dimensions must always work without keyword arguments.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>Tensor</code> containing <code>values</code> stacked along <code>dim</code>.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; stack({'x': 0, 'y': 1}, channel('vector'))
(x=0, y=1)
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; stack([math.zeros(batch(b=2)), math.ones(batch(b=2))], channel(c='x,y'))
(x=0.000, y=1.000); (x=0.000, y=1.000) (bᵇ=2, cᶜ=x,y)
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; stack([vec(x=1, y=0), vec(x=2, y=3.)], batch('b'))
(x=1.000, y=0.000); (x=2.000, y=3.000) (bᵇ=2, vectorᶜ=x,y)
</code></pre></div>
</dd>
<dt id="phi.geom.union"><code class="name flex">
<span>def <span class="ident">union</span></span>(<span>*geometries, dim=(unionⁱ=None)) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<div class="desc"><p>Union of the given geometries.
A point lies inside the union if it lies within at least one of the geometries.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*geometries</code></strong></dt>
<dd>arbitrary geometries with same spatial dims. Arbitrary batch dims are allowed.</dd>
<dt><strong><code>dim</code></strong></dt>
<dd>Union dimension. This must be an instance dimension.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>union <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="phi.geom.BaseBox"><code class="flex name class">
<span>class <span class="ident">BaseBox</span></span>
</code></dt>
<dd>
<div class="desc"><p>Abstract base type for box-like geometries.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseBox(Geometry):  # not a Subwoofer
    &#34;&#34;&#34;
    Abstract base type for box-like geometries.
    &#34;&#34;&#34;

    def __ne__(self, other):
        return not self == other

    @property
    def shape(self):
        raise NotImplementedError()

    @property
    def center(self) -&gt; Tensor:
        raise NotImplementedError()

    @property
    def size(self) -&gt; Tensor:
        raise NotImplementedError(self)

    @property
    def half_size(self) -&gt; Tensor:
        raise NotImplementedError(self)

    @property
    def lower(self) -&gt; Tensor:
        raise NotImplementedError(self)

    @property
    def upper(self) -&gt; Tensor:
        raise NotImplementedError(self)

    @property
    def rotation_matrix(self) -&gt; Optional[Tensor]:
        raise NotImplementedError(self)

    @property
    def is_size_variable(self):
        raise NotImplementedError(self)

    @property
    def volume(self) -&gt; Tensor:
        return math.prod(self.size, &#39;vector&#39;)

    def bounding_radius(self):
        return math.vec_length(self.half_size)

    def global_to_local(self, global_position: Tensor, scale=True, origin=&#39;lower&#39;) -&gt; Tensor:
        &#34;&#34;&#34;
        Transform world-space coordinates into box-space coordinates.

        Args:
            global_position: World-space coordinates.
            scale: Whether to re-scale the output so that [0, 1] or [-1, 1] represent the box for `origin=&#39;lower&#39;` or `origin=&#39;center&#39;`, respectively.
            origin: &#39;lower&#39; or &#39;center&#39;

        Returns:
            Box-space coordinate `Tensor`
        &#34;&#34;&#34;
        assert origin in [&#39;lower&#39;, &#39;center&#39;, &#39;upper&#39;]
        origin_loc = getattr(self, origin)
        pos = global_position if math.always_close(origin_loc, 0) else global_position - origin_loc
        pos = math.rotate_vector(pos, self.rotation_matrix, invert=True)
        if scale:
            pos /= (self.half_size if origin == &#39;center&#39; else self.size)
        return pos

    def local_to_global(self, local_position, scale=True, origin=&#39;lower&#39;):
        assert origin in [&#39;lower&#39;, &#39;center&#39;, &#39;upper&#39;]
        origin_loc = getattr(self, origin)
        pos = local_position * (self.half_size if origin == &#39;center&#39; else self.size) if scale else local_position
        return math.rotate_vector(pos, self.rotation_matrix) + origin_loc

    def lies_inside(self, location):
        assert self.rotation_matrix is None, f&#34;Please override lies_inside() for rotated boxes&#34;
        bool_inside = (location &gt;= self.lower) &amp; (location &lt;= self.upper)
        bool_inside = math.all(bool_inside, &#39;vector&#39;)
        bool_inside = math.any(bool_inside, self.shape.instance)  # union for instance dimensions
        return bool_inside

    def approximate_signed_distance(self, location: Union[Tensor, tuple]):
        &#34;&#34;&#34;
        Computes the signed L-infinity norm (manhattan distance) from the location to the nearest side of the box.
        For an outside location `l` with the closest surface point `s`, the distance is `max(abs(l - s))`.
        For inside locations it is `-max(abs(l - s))`.

        Args:
          location: float tensor of shape (batch_size, ..., rank)

        Returns:
          float tensor of shape (*location.shape[:-1], 1).

        &#34;&#34;&#34;
        location = self.global_to_local(location, scale=False, origin=&#39;center&#39;)
        distance = math.abs(location) - self.half_size
        distance = math.max(distance, &#39;vector&#39;)
        distance = math.min(distance, self.shape.instance)  # union for instance dimensions
        return distance

    def push(self, positions: Tensor, outward: bool = True, shift_amount: float = 0) -&gt; Tensor:
        loc_to_center = self.global_to_local(positions, scale=False, origin=&#39;center&#39;)
        sgn_dist_from_surface = math.abs(loc_to_center) - self.half_size
        rotation_matrix = self.rotation_matrix
        if outward:
            # --- get negative distances (particles are inside) towards the nearest boundary and add shift_amount ---
            distances_of_interest = (sgn_dist_from_surface == math.max(sgn_dist_from_surface, &#39;vector&#39;)) &amp; (sgn_dist_from_surface &lt; 0)
            shift = distances_of_interest * (sgn_dist_from_surface - shift_amount)
            # ToDo reduce instance dim
        else:  # inward
            shift = (sgn_dist_from_surface + shift_amount) * (sgn_dist_from_surface &gt; 0)  # get positive distances (particles are outside) and add shift_amount
            if instance(self):
                shift, loc_to_center, rotation_matrix = math.at_min((shift, loc_to_center, rotation_matrix), key=math.vec_length(shift), dim=instance)
            shift = math.where(abs(shift) &gt; abs(loc_to_center), abs(loc_to_center), shift)  # ensure inward shift ends at center
        shift = math.rotate_vector(shift, rotation_matrix)
        return positions + math.where(loc_to_center &lt; 0, 1, -1) * shift

    def approximate_closest_surface(self, location: Tensor) -&gt; Tuple[Tensor, Tensor, Tensor, Tensor, Tensor]:
        loc_to_center = self.global_to_local(location, scale=False, origin=&#39;center&#39;)
        sgn_surf_delta = math.abs(loc_to_center) - self.half_size
        if instance(self):
            raise NotImplementedError
            self_center, self_radius, sgn_dist, center_delta, center_dist = math.at_min((self.center, self.radius, sgn_dist, center_delta, center_dist), key=abs(sgn_dist), dim=instance)
        # is_inside = math.all(sgn_surf_delta &lt; 0, &#39;vector&#39;)
        # abs_surf_delta = abs(sgn_surf_delta)
        max_sgn_dist = math.max(sgn_surf_delta, &#39;vector&#39;)
        normal_axis = max_sgn_dist == sgn_surf_delta
        normal = math.vec_normalize(normal_axis * math.sign(loc_to_center))
        surf_to_center = math.where(normal_axis, math.sign(loc_to_center) * self.half_size, loc_to_center)
        closest_to_center = math.clip(surf_to_center, -self.half_size, self.half_size)
        surface_pos = self.local_to_global(closest_to_center, scale=False, origin=&#39;center&#39;)
        delta = surface_pos - location
        face_index = expand(0, non_channel(location))
        offset = normal.vector @ surface_pos.vector
        sgn_surf_dist = math.vec_length(delta) * math.sign(max_sgn_dist)
        return sgn_surf_dist, delta, normal, offset, face_index

    def project(self, *dimensions: str):
        &#34;&#34;&#34; Project this box into a lower-dimensional space. &#34;&#34;&#34;
        warnings.warn(&#34;Box.project(dims) is deprecated. Use Box.vector[dims] instead&#34;, DeprecationWarning, stacklevel=2)
        return self.vector[dimensions]

    def sample_uniform(self, *shape: math.Shape) -&gt; Tensor:
        uniform = math.random_uniform(self.shape.non_singleton.without(&#39;vector&#39;), *shape, self.shape[&#39;vector&#39;])
        return self.lower + uniform * self.size

    def corner_representation(self) -&gt; &#39;Box&#39;:
        assert self.rotation_matrix is None, f&#34;corner_representation does not support rotations&#34;
        return Box(self.lower, self.upper)

    box = corner_representation

    def center_representation(self, size_variable=True) -&gt; &#39;Cuboid&#39;:
        return Cuboid(self.center, self.half_size, size_variable=size_variable)

    def contains(self, other: &#39;BaseBox&#39;):
        &#34;&#34;&#34; Tests if the other box lies fully inside this box. &#34;&#34;&#34;
        return np.all(other.lower &gt;= self.lower) and np.all(other.upper &lt;= self.upper)

    def scaled(self, factor: Union[float, Tensor]) -&gt; &#39;Geometry&#39;:
        return Cuboid(self.center, self.half_size * factor, size_variable=True)

    @property
    def boundary_elements(self) -&gt; Dict[Any, Dict[str, slice]]:
        return {}

    @property
    def boundary_faces(self) -&gt; Dict[Any, Dict[str, slice]]:
        return {}

    @property
    def faces(self) -&gt; &#39;Geometry&#39;:
        return Cuboid(self.face_centers, self._half_size, self._rotation_matrix, size_variable=False)

    @property
    def face_centers(self) -&gt; Tensor:
        return self.center + self.face_normals * self.half_size

    @property
    def face_normals(self) -&gt; Tensor:
        unit_vectors = math.to_float(math.range(self.shape[&#39;vector&#39;]) == math.range(dual(**self.shape[&#39;vector&#39;].untyped_dict)))
        vectors = math.rotate_vector(unit_vectors, self.rotation_matrix)
        return vectors * math.vec(dual(&#39;side&#39;), lower=-1, upper=1)

    @property
    def face_areas(self) -&gt; Tensor:
        others_mask = math.range(self.shape[&#39;vector&#39;]) != math.range(dual(**self.shape[&#39;vector&#39;].untyped_dict))
        result = math.exp(math.sum(math.log(self.size) * others_mask, &#39;vector&#39;))
        return result  # ~vector

    @property
    def face_shape(self) -&gt; Shape:
        return self.shape.without(&#39;vector&#39;) &amp; dual(side=&#39;lower,upper&#39;) &amp; dual(**self.shape[&#39;vector&#39;].untyped_dict)

    @property
    def corners(self):
        to_face = self.face_normals[{&#39;~side&#39;: &#39;upper&#39;}] * math.rename_dims(self.half_size, &#39;vector&#39;, dual)
        lower_upper = math.meshgrid(math.dual, **{dim: [-1, 1] for dim in self.vector.item_names}, stack_dim=dual(&#39;vector&#39;))  # (x=2, y=2, ... vector=x,y,...)
        to_corner = math.sum(lower_upper * to_face, &#39;~vector&#39;)
        return self.center + to_corner</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.geom._geom.Geometry</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>phi.geom._box.Box</li>
<li>phi.geom._box.Cuboid</li>
<li>phi.geom._grid.UniformGrid</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="phi.geom.BaseBox.boundary_elements"><code class="name">prop <span class="ident">boundary_elements</span> : Dict[Any, Dict[str, slice]]</code></dt>
<dd>
<div class="desc"><p>Slices on the primal dimensions to mark boundary elements.
Grids and meshes have no boundary elements and return <code>{}</code>.
Dynamic graphs can define boundary elements for obstacles and walls.</p>
<h2 id="returns">Returns</h2>
<p>Map from <code>(name, is_upper)</code> to slicing <code>dict</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def boundary_elements(self) -&gt; Dict[Any, Dict[str, slice]]:
    return {}</code></pre>
</details>
</dd>
<dt id="phi.geom.BaseBox.boundary_faces"><code class="name">prop <span class="ident">boundary_faces</span> : Dict[Any, Dict[str, slice]]</code></dt>
<dd>
<div class="desc"><p>Slices on the dual dimensions to mark boundary faces.</p>
<p>Regular grids use the keys (dim, is_upper) to identify boundaries.
Unstructured meshes use string identifiers for the boundaries.
Dynamic graphs return slices along the dual dimensions.</p>
<h2 id="returns">Returns</h2>
<p>Map from <code>(name, is_upper)</code> to slicing <code>dict</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def boundary_faces(self) -&gt; Dict[Any, Dict[str, slice]]:
    return {}</code></pre>
</details>
</dd>
<dt id="phi.geom.BaseBox.center"><code class="name">prop <span class="ident">center</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p>Center location in single channel dimension.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def center(self) -&gt; Tensor:
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="phi.geom.BaseBox.corners"><code class="name">prop <span class="ident">corners</span></code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<p>Corner locations as <code>phiml.math.Tensor</code>.
Corners belonging to one object or cell are listed along dual dimensions.
If the object has no corners, a size-0 tensor with the correct vector and instance dims is returned.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def corners(self):
    to_face = self.face_normals[{&#39;~side&#39;: &#39;upper&#39;}] * math.rename_dims(self.half_size, &#39;vector&#39;, dual)
    lower_upper = math.meshgrid(math.dual, **{dim: [-1, 1] for dim in self.vector.item_names}, stack_dim=dual(&#39;vector&#39;))  # (x=2, y=2, ... vector=x,y,...)
    to_corner = math.sum(lower_upper * to_face, &#39;~vector&#39;)
    return self.center + to_corner</code></pre>
</details>
</dd>
<dt id="phi.geom.BaseBox.face_areas"><code class="name">prop <span class="ident">face_areas</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p>Area of face connecting a pair of cells. Shape <code>(elements, ~)</code>.
Returns 0 for unconnected cells.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_areas(self) -&gt; Tensor:
    others_mask = math.range(self.shape[&#39;vector&#39;]) != math.range(dual(**self.shape[&#39;vector&#39;].untyped_dict))
    result = math.exp(math.sum(math.log(self.size) * others_mask, &#39;vector&#39;))
    return result  # ~vector</code></pre>
</details>
</dd>
<dt id="phi.geom.BaseBox.face_centers"><code class="name">prop <span class="ident">face_centers</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p>Center of face connecting a pair of cells. Shape <code>(elements, ~, vector)</code>.
Here, <code>~</code> represents arbitrary internal dual dimensions, such as <code>~staggered_direction</code> or <code>~elements</code>.
Returns 0-vectors for unconnected cells.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_centers(self) -&gt; Tensor:
    return self.center + self.face_normals * self.half_size</code></pre>
</details>
</dd>
<dt id="phi.geom.BaseBox.face_normals"><code class="name">prop <span class="ident">face_normals</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p>Normal vectors of cell faces, including boundary faces. Shape <code>(elements, ~, vector)</code>.
For meshes, The vectors point out of the primal cells and into the dual cells.</p>
<p>Instance/spatial dimensions along which the normal does not vary may not be included in the result tensor's shape.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_normals(self) -&gt; Tensor:
    unit_vectors = math.to_float(math.range(self.shape[&#39;vector&#39;]) == math.range(dual(**self.shape[&#39;vector&#39;].untyped_dict)))
    vectors = math.rotate_vector(unit_vectors, self.rotation_matrix)
    return vectors * math.vec(dual(&#39;side&#39;), lower=-1, upper=1)</code></pre>
</details>
</dd>
<dt id="phi.geom.BaseBox.face_shape"><code class="name">prop <span class="ident">face_shape</span> : phiml.math._shape.Shape</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<p>Full Shape to identify each face of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>, including instance/spatial dimensions for the elements and dual dimensions listing the faces per element.
If this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> has no faces, returns an empty <code>Shape</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_shape(self) -&gt; Shape:
    return self.shape.without(&#39;vector&#39;) &amp; dual(side=&#39;lower,upper&#39;) &amp; dual(**self.shape[&#39;vector&#39;].untyped_dict)</code></pre>
</details>
</dd>
<dt id="phi.geom.BaseBox.faces"><code class="name">prop <span class="ident">faces</span> : <a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def faces(self) -&gt; &#39;Geometry&#39;:
    return Cuboid(self.face_centers, self._half_size, self._rotation_matrix, size_variable=False)</code></pre>
</details>
</dd>
<dt id="phi.geom.BaseBox.half_size"><code class="name">prop <span class="ident">half_size</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def half_size(self) -&gt; Tensor:
    raise NotImplementedError(self)</code></pre>
</details>
</dd>
<dt id="phi.geom.BaseBox.is_size_variable"><code class="name">prop <span class="ident">is_size_variable</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_size_variable(self):
    raise NotImplementedError(self)</code></pre>
</details>
</dd>
<dt id="phi.geom.BaseBox.lower"><code class="name">prop <span class="ident">lower</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def lower(self) -&gt; Tensor:
    raise NotImplementedError(self)</code></pre>
</details>
</dd>
<dt id="phi.geom.BaseBox.rotation_matrix"><code class="name">prop <span class="ident">rotation_matrix</span> : Optional[phiml.math._tensors.Tensor]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def rotation_matrix(self) -&gt; Optional[Tensor]:
    raise NotImplementedError(self)</code></pre>
</details>
</dd>
<dt id="phi.geom.BaseBox.shape"><code class="name">prop <span class="ident">shape</span></code></dt>
<dd>
<div class="desc"><p>The <code>shape</code> of a <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> consists of the following dimensions:</p>
<ul>
<li>A single <em>channel</em> dimension called <code>'vector'</code> specifying the physical space</li>
<li>Instance dimensions denote that this geometry consists of multiple copies in the same space</li>
<li>Spatial dimensions denote a crystal (repeating structure) of this geometric primitive in space</li>
<li>Batch dimensions indicate non-interacting versions of this geometry for parallelization only.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape(self):
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="phi.geom.BaseBox.size"><code class="name">prop <span class="ident">size</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; Tensor:
    raise NotImplementedError(self)</code></pre>
</details>
</dd>
<dt id="phi.geom.BaseBox.upper"><code class="name">prop <span class="ident">upper</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def upper(self) -&gt; Tensor:
    raise NotImplementedError(self)</code></pre>
</details>
</dd>
<dt id="phi.geom.BaseBox.volume"><code class="name">prop <span class="ident">volume</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p><code>phi.math.Tensor</code> representing the volume of each element.
The result retains batch, spatial and instance dimensions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def volume(self) -&gt; Tensor:
    return math.prod(self.size, &#39;vector&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phi.geom.BaseBox.approximate_closest_surface"><code class="name flex">
<span>def <span class="ident">approximate_closest_surface</span></span>(<span>self, location: phiml.math._tensors.Tensor) ‑> Tuple[phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor]</span>
</code></dt>
<dd>
<div class="desc"><p>Find the closest surface face of this geometry given a point that can be outside or inside the geometry.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd><code>Tensor</code> with a single channel dimension called vector. Can have arbitrary other dimensions.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>signed_distance</code></dt>
<dd>Scalar signed distance from <code>location</code>
to the closest point on the surface.
Positive values indicate the point lies outside the geometry, negative values indicate the point lies inside the geometry.</dd>
<dt><code>delta</code></dt>
<dd>Vector-valued distance vector from <code>location</code> to the closest point on the surface.</dd>
<dt><code>normal</code></dt>
<dd>Closest surface normal vector.</dd>
<dt><code>offset</code></dt>
<dd>Min distance of a surface-tangential plane from 0 as a scalar.</dd>
<dt><code>face_index</code></dt>
<dd>(Optional) An index vector pointing at the closest face.</dd>
</dl></div>
</dd>
<dt id="phi.geom.BaseBox.approximate_signed_distance"><code class="name flex">
<span>def <span class="ident">approximate_signed_distance</span></span>(<span>self, location: Union[phiml.math._tensors.Tensor, tuple])</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the signed L-infinity norm (manhattan distance) from the location to the nearest side of the box.
For an outside location <code>l</code> with the closest surface point <code>s</code>, the distance is <code>max(abs(l - s))</code>.
For inside locations it is <code>-max(abs(l - s))</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd>float tensor of shape (batch_size, &hellip;, rank)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>float tensor of shape (*location.shape[:-1], 1).</p></div>
</dd>
<dt id="phi.geom.BaseBox.bounding_radius"><code class="name flex">
<span>def <span class="ident">bounding_radius</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the radius of a Sphere object that fully encloses this geometry.
The sphere is centered at the center of this geometry.</p>
<p>:return: radius of type float</p>
<p>Args:</p>
<p>Returns:</p></div>
</dd>
<dt id="phi.geom.BaseBox.box"><code class="name flex">
<span>def <span class="ident">box</span></span>(<span>self) ‑> phi.geom._box.Box</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="phi.geom.BaseBox.center_representation"><code class="name flex">
<span>def <span class="ident">center_representation</span></span>(<span>self, size_variable=True) ‑> phi.geom._box.Cuboid</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="phi.geom.BaseBox.contains"><code class="name flex">
<span>def <span class="ident">contains</span></span>(<span>self, other: <a title="phi.geom.BaseBox" href="#phi.geom.BaseBox">BaseBox</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Tests if the other box lies fully inside this box.</p></div>
</dd>
<dt id="phi.geom.BaseBox.corner_representation"><code class="name flex">
<span>def <span class="ident">corner_representation</span></span>(<span>self) ‑> phi.geom._box.Box</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="phi.geom.BaseBox.global_to_local"><code class="name flex">
<span>def <span class="ident">global_to_local</span></span>(<span>self, global_position: phiml.math._tensors.Tensor, scale=True, origin='lower') ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Transform world-space coordinates into box-space coordinates.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>global_position</code></strong></dt>
<dd>World-space coordinates.</dd>
<dt><strong><code>scale</code></strong></dt>
<dd>Whether to re-scale the output so that [0, 1] or [-1, 1] represent the box for <code>origin='lower'</code> or <code>origin='center'</code>, respectively.</dd>
<dt><strong><code>origin</code></strong></dt>
<dd>'lower' or 'center'</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Box-space coordinate <code>Tensor</code></p></div>
</dd>
<dt id="phi.geom.BaseBox.lies_inside"><code class="name flex">
<span>def <span class="ident">lies_inside</span></span>(<span>self, location)</span>
</code></dt>
<dd>
<div class="desc"><p>Tests whether the given location lies inside or outside of the geometry. Locations on the surface count as inside.</p>
<p>When dealing with unions or collections of geometries (instance dimensions), a point lies inside the geometry if it lies inside any instance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd>float tensor of shape (batch_size, &hellip;, rank)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>bool tensor of shape (*location.shape[:-1], 1).</p></div>
</dd>
<dt id="phi.geom.BaseBox.local_to_global"><code class="name flex">
<span>def <span class="ident">local_to_global</span></span>(<span>self, local_position, scale=True, origin='lower')</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="phi.geom.BaseBox.project"><code class="name flex">
<span>def <span class="ident">project</span></span>(<span>self, *dimensions: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Project this box into a lower-dimensional space.</p></div>
</dd>
<dt id="phi.geom.BaseBox.push"><code class="name flex">
<span>def <span class="ident">push</span></span>(<span>self, positions: phiml.math._tensors.Tensor, outward: bool = True, shift_amount: float = 0) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Shifts positions either into or out of geometry.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>positions</code></strong></dt>
<dd>Tensor holding positions to shift</dd>
<dt><strong><code>outward</code></strong></dt>
<dd>Flag for indicating inward (False) or outward (True) shift</dd>
<dt><strong><code>shift_amount</code></strong></dt>
<dd>Minimum distance between positions and surface after shifting.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Tensor holding shifted positions.</p></div>
</dd>
<dt id="phi.geom.BaseBox.sample_uniform"><code class="name flex">
<span>def <span class="ident">sample_uniform</span></span>(<span>self, *shape: phiml.math._shape.Shape) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Samples uniformly distributed random points inside this volume.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*shape</code></strong></dt>
<dd>How many points to sample per individual geometry.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>Tensor</code> containing all dimensions from <code><a title="phi.geom.Geometry.shape" href="#phi.geom.Geometry.shape">Geometry.shape</a></code>, <code>shape</code> as well as a <code>channel</code> dimension <code>vector</code> matching the dimensionality of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.</p></div>
</dd>
<dt id="phi.geom.BaseBox.scaled"><code class="name flex">
<span>def <span class="ident">scaled</span></span>(<span>self, factor: Union[phiml.math._tensors.Tensor, float]) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<div class="desc"><p>Scales each individual geometry by <code>factor</code>.
The individual <code>center</code> points act as pivots for the operation.</p>
<h2 id="args">Args</h2>
<p>factor:
Returns:</p></div>
</dd>
</dl>
</dd>
<dt id="phi.geom.Box"><code class="flex name class">
<span>class <span class="ident">Box</span></span>
<span>(</span><span>lower: phiml.math._tensors.Tensor = None, upper: phiml.math._tensors.Tensor = None, **size: Union[float, phiml.math._tensors.Tensor, tuple, list, ForwardRef(None)])</span>
</code></dt>
<dd>
<div class="desc"><p>Simple cuboid defined by location of lower and upper corner in physical space.</p>
<p>Boxes can be constructed either from two positional vector arguments <code>(lower, upper)</code> or by specifying the limits by dimension name as <code>kwargs</code>.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; Box(x=1, y=1)  # creates a two-dimensional unit box with `lower=(0, 0)` and `upper=(1, 1)`.
&gt;&gt;&gt; Box(x=(None, 1), y=(0, None)  # creates a Box with `lower=(-inf, 0)` and `upper=(1, inf)`.
</code></pre>
<p>The slicing constructor was updated in version 2.2 and now requires the dimension order as the first argument.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; Box['x,y', 0:1, 0:1]  # creates a two-dimensional unit box with `lower=(0, 0)` and `upper=(1, 1)`.
&gt;&gt;&gt; Box['x,y', :1, 0:]  # creates a Box with `lower=(-inf, 0)` and `upper=(1, inf)`.
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>lower</code></strong></dt>
<dd>physical location of lower corner</dd>
<dt><strong><code>upper</code></strong></dt>
<dd>physical location of upper corner</dd>
<dt><strong><code>**size</code></strong></dt>
<dd>Specify size by dimension, either as <code>int</code> or <code>tuple</code> containing (lower, upper).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Box(BaseBox, metaclass=BoxType):
    &#34;&#34;&#34;
    Simple cuboid defined by location of lower and upper corner in physical space.

    Boxes can be constructed either from two positional vector arguments `(lower, upper)` or by specifying the limits by dimension name as `kwargs`.

    Examples:
        &gt;&gt;&gt; Box(x=1, y=1)  # creates a two-dimensional unit box with `lower=(0, 0)` and `upper=(1, 1)`.
        &gt;&gt;&gt; Box(x=(None, 1), y=(0, None)  # creates a Box with `lower=(-inf, 0)` and `upper=(1, inf)`.

        The slicing constructor was updated in version 2.2 and now requires the dimension order as the first argument.

        &gt;&gt;&gt; Box[&#39;x,y&#39;, 0:1, 0:1]  # creates a two-dimensional unit box with `lower=(0, 0)` and `upper=(1, 1)`.
        &gt;&gt;&gt; Box[&#39;x,y&#39;, :1, 0:]  # creates a Box with `lower=(-inf, 0)` and `upper=(1, inf)`.
    &#34;&#34;&#34;

    def __init__(self, lower: Tensor = None, upper: Tensor = None, **size: Optional[Union[float, Tensor, tuple, list]]):
        &#34;&#34;&#34;
        Args:
          lower: physical location of lower corner
          upper: physical location of upper corner
          **size: Specify size by dimension, either as `int` or `tuple` containing (lower, upper).
        &#34;&#34;&#34;
        if lower is not None:
            assert isinstance(lower, Tensor), f&#34;lower must be a Tensor but got {type(lower)}&#34;
            assert &#39;vector&#39; in lower.shape, &#34;lower must have a vector dimension&#34;
            assert lower.vector.item_names is not None, &#34;vector dimension of lower must list spatial dimension order&#34;
            self._lower = lower
        if upper is not None:
            assert isinstance(upper, Tensor), f&#34;upper must be a Tensor but got {type(upper)}&#34;
            assert &#39;vector&#39; in upper.shape, &#34;lower must have a vector dimension&#34;
            assert upper.vector.item_names is not None, &#34;vector dimension of lower must list spatial dimension order&#34;
            self._upper = upper
        else:
            lower = []
            upper = []
            for item in size.values():
                if isinstance(item, (tuple, list)):
                    assert len(item) == 2, f&#34;Box kwargs must be either dim=upper or dim=(lower,upper) but got {item}&#34;
                    lo, up = item
                    lower.append(lo)
                    upper.append(up)
                elif item is None:
                    lower.append(-INF)
                    upper.append(INF)
                else:
                    lower.append(0)
                    upper.append(item)
            lower = [-INF if l is None else l for l in lower]
            upper = [INF if u is None else u for u in upper]
            self._upper = math.wrap(upper, math.channel(vector=tuple(size.keys())))
            self._lower = math.wrap(lower, math.channel(vector=tuple(size.keys())))
        vector_shape = self._lower.shape &amp; self._upper.shape
        self._lower = math.expand(self._lower, vector_shape)
        self._upper = math.expand(self._upper, vector_shape)
        if self.size.vector.item_names is None:
            warnings.warn(&#34;Creating a Box without item names prevents certain operations like project()&#34;, DeprecationWarning, stacklevel=2)
        self._shape = self._lower.shape &amp; self._upper.shape

    def __getitem__(self, item):
        item = _keep_vector(slicing_dict(self, item))
        return Box(self._lower[item], self._upper[item])

    @staticmethod
    def __stack__(values: tuple, dim: Shape, **kwargs) -&gt; &#39;Geometry&#39;:
        if all(isinstance(v, Box) for v in values):
            return NotImplemented  # stack attributes
        else:
            return Geometry.__stack__(values, dim, **kwargs)

    def without(self, dims: Tuple[str, ...]):
        remaining = list(self.shape.get_item_names(&#39;vector&#39;))
        for dim in dims:
            if dim in remaining:
                remaining.remove(dim)
        return self.vector[remaining]

    def largest(self, dim: DimFilter) -&gt; &#39;Box&#39;:
        dim = self.shape.without(&#39;vector&#39;).only(dim)
        if not dim:
            return self
        return Box(math.min(self._lower, dim), math.max(self._upper, dim))

    def smallest(self, dim: DimFilter) -&gt; &#39;Box&#39;:
        dim = self.shape.without(&#39;vector&#39;).only(dim)
        if not dim:
            return self
        return Box(math.max(self._lower, dim), math.min(self._upper, dim))

    def __variable_attrs__(self):
        return &#39;_lower&#39;, &#39;_upper&#39;

    def __value_attrs__(self):
        return &#39;_lower&#39;, &#39;_upper&#39;

    @property
    def shape(self):
        if self._lower is None or self._upper is None:
            return self._shape
        return self._lower.shape &amp; self._upper.shape

    @property
    def lower(self):
        return self._lower

    @property
    def upper(self):
        return self._upper

    @property
    def size(self):
        return self.upper - self.lower

    @property
    def center(self):
        return 0.5 * (self.lower + self.upper)

    @property
    def half_size(self):
        return self.size * 0.5

    @property
    def rotation_matrix(self) -&gt; Optional[Tensor]:
        return None

    @property
    def is_size_variable(self):
        raise False

    def at(self, center: Tensor) -&gt; &#39;BaseBox&#39;:
        return Cuboid(center, self.half_size, self.rotation_matrix)

    def shifted(self, delta, **delta_by_dim):
        return Box(self.lower + delta, self.upper + delta)

    def rotated(self, angle) -&gt; Geometry:
        return self.center_representation().rotated(angle)

    def __mul__(self, other):
        if not isinstance(other, Box):
            return NotImplemented
        lower = self._lower.vector.unstack(self.spatial_rank) + other._lower.vector.unstack(other.spatial_rank)
        upper = self._upper.vector.unstack(self.spatial_rank) + other._upper.vector.unstack(other.spatial_rank)
        names = self._upper.vector.item_names + other._upper.vector.item_names
        lower = math.stack(lower, math.channel(vector=names))
        upper = math.stack(upper, math.channel(vector=names))
        return Box(lower, upper)

    def bounding_half_extent(self):
        return self.half_size

    def __repr__(self):
        if self._lower is None or self._upper is None:  # traced
            return f&#34;Box[traced, shape={self._shape}]&#34;
        if self.shape.non_channel.volume == 1:
            item_names = self.size.vector.item_names
            if item_names:
                return f&#34;Box({&#39;, &#39;.join([f&#39;{dim}=({lo}, {up})&#39; for dim, lo, up in zip(item_names, self._lower, self._upper)])})&#34;
            else:  # deprecated
                return &#39;Box[%s at %s]&#39; % (&#39;x&#39;.join([str(x) for x in self.size.numpy().flatten()]), &#39;,&#39;.join([str(x) for x in self.lower.numpy().flatten()]))
        else:
            return f&#39;Box[shape={self.shape}]&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.geom._box.BaseBox</li>
<li>phi.geom._geom.Geometry</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="phi.geom.Box.center"><code class="name">prop <span class="ident">center</span></code></dt>
<dd>
<div class="desc"><p>Center location in single channel dimension.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def center(self):
    return 0.5 * (self.lower + self.upper)</code></pre>
</details>
</dd>
<dt id="phi.geom.Box.half_size"><code class="name">prop <span class="ident">half_size</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def half_size(self):
    return self.size * 0.5</code></pre>
</details>
</dd>
<dt id="phi.geom.Box.is_size_variable"><code class="name">prop <span class="ident">is_size_variable</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_size_variable(self):
    raise False</code></pre>
</details>
</dd>
<dt id="phi.geom.Box.lower"><code class="name">prop <span class="ident">lower</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def lower(self):
    return self._lower</code></pre>
</details>
</dd>
<dt id="phi.geom.Box.rotation_matrix"><code class="name">prop <span class="ident">rotation_matrix</span> : Optional[phiml.math._tensors.Tensor]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def rotation_matrix(self) -&gt; Optional[Tensor]:
    return None</code></pre>
</details>
</dd>
<dt id="phi.geom.Box.shape"><code class="name">prop <span class="ident">shape</span></code></dt>
<dd>
<div class="desc"><p>The <code>shape</code> of a <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> consists of the following dimensions:</p>
<ul>
<li>A single <em>channel</em> dimension called <code>'vector'</code> specifying the physical space</li>
<li>Instance dimensions denote that this geometry consists of multiple copies in the same space</li>
<li>Spatial dimensions denote a crystal (repeating structure) of this geometric primitive in space</li>
<li>Batch dimensions indicate non-interacting versions of this geometry for parallelization only.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape(self):
    if self._lower is None or self._upper is None:
        return self._shape
    return self._lower.shape &amp; self._upper.shape</code></pre>
</details>
</dd>
<dt id="phi.geom.Box.size"><code class="name">prop <span class="ident">size</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self):
    return self.upper - self.lower</code></pre>
</details>
</dd>
<dt id="phi.geom.Box.upper"><code class="name">prop <span class="ident">upper</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def upper(self):
    return self._upper</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phi.geom.Box.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>self, center: phiml.math._tensors.Tensor) ‑> phi.geom._box.BaseBox</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a copy of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> with the center at <code>center</code>.
This is equal to calling <code>self @ center</code>.</p>
<p>See Also:
<code><a title="phi.geom.Geometry.shifted" href="#phi.geom.Geometry.shifted">Geometry.shifted()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>center</code></strong></dt>
<dd>New center as <code>Tensor</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.</p></div>
</dd>
<dt id="phi.geom.Box.bounding_half_extent"><code class="name flex">
<span>def <span class="ident">bounding_half_extent</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>The bounding half-extent sets a limit on the outer-most point for each coordinate axis.
Each component is non-negative.</p>
<p>Let the bounding half-extent have value <code>e</code> in dimension <code>d</code> (<code>extent[...,d] = e</code>).
Then, no point of the geometry lies further away from its center point than <code>e</code> along <code>d</code> (in both axis directions).</p>
<p>When this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.
If these dims are not present, all parts are assumed to have the same bounds.</p></div>
</dd>
<dt id="phi.geom.Box.largest"><code class="name flex">
<span>def <span class="ident">largest</span></span>(<span>self, dim: Union[str, tuple, list, set, ForwardRef('Shape'), Callable]) ‑> phi.geom._box.Box</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Box.rotated"><code class="name flex">
<span>def <span class="ident">rotated</span></span>(<span>self, angle) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a rotated version of this geometry.
The geometry is rotated about its center point.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>angle</code></strong></dt>
<dd>
<p>Delta rotation.
Either</p>
<ul>
<li>Angle(s): scalar angle in 2d or euler angles along <code>vector</code> in 3D or higher.</li>
<li>Matrix: d⨯d rotation matrix</li>
</ul>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Rotated <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></p></div>
</dd>
<dt id="phi.geom.Box.shifted"><code class="name flex">
<span>def <span class="ident">shifted</span></span>(<span>self, delta, **delta_by_dim)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a translated version of this geometry.</p>
<p>See Also:
<code><a title="phi.geom.Geometry.at" href="#phi.geom.Geometry.at">Geometry.at()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>delta</code></strong></dt>
<dd>direction vector</dd>
<dt><strong><code>delta</code></strong></dt>
<dd>Tensor:</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></dt>
<dd>shifted geometry</dd>
</dl></div>
</dd>
<dt id="phi.geom.Box.smallest"><code class="name flex">
<span>def <span class="ident">smallest</span></span>(<span>self, dim: Union[str, tuple, list, set, ForwardRef('Shape'), Callable]) ‑> phi.geom._box.Box</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Box.without"><code class="name flex">
<span>def <span class="ident">without</span></span>(<span>self, dims: Tuple[str, ...])</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="phi.geom.Cuboid"><code class="flex name class">
<span>class <span class="ident">Cuboid</span></span>
<span>(</span><span>center: phiml.math._tensors.Tensor = 0, half_size: Union[phiml.math._tensors.Tensor, float] = None, rotation: Optional[phiml.math._tensors.Tensor] = None, size_variable=True, **size: Union[phiml.math._tensors.Tensor, float])</span>
</code></dt>
<dd>
<div class="desc"><p>Box specified by center position and half size.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>center</code></strong></dt>
<dd>Center position</dd>
<dt><strong><code>half_size</code></strong></dt>
<dd>Half-size of the cuboid as vector or scalar</dd>
<dt><strong><code>rotation</code></strong></dt>
<dd>Rotation angle(s) or rotation matrix.</dd>
<dt><strong><code>**size</code></strong></dt>
<dd>Alternative way of specifying the size. If used, <code>half_size</code> must not be specified.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Cuboid(BaseBox):
    &#34;&#34;&#34;Box specified by center position and half size.&#34;&#34;&#34;

    def __init__(self,
                 center: Tensor = 0,
                 half_size: Union[float, Tensor] = None,
                 rotation: Optional[Tensor] = None,
                 size_variable=True,
                 **size: Union[float, Tensor]):
        &#34;&#34;&#34;
        Args:
            center: Center position
            half_size: Half-size of the cuboid as vector or scalar
            rotation: Rotation angle(s) or rotation matrix.
            **size: Alternative way of specifying the size. If used, `half_size` must not be specified.
        &#34;&#34;&#34;
        if half_size is not None:
            assert isinstance(half_size, Tensor), &#34;half_size must be a Tensor&#34;
            assert &#39;vector&#39; in half_size.shape, f&#34;Cuboid size must have a &#39;vector&#39; dimension.&#34;
            assert half_size.shape.get_item_names(&#39;vector&#39;) is not None, f&#34;Vector dimension must list spatial dimensions as item names. Use the syntax Cuboid(x=x, y=y) to assign names.&#34;
            self._half_size = half_size
        else:
            self._half_size = math.wrap(tuple(size.values()), math.channel(vector=tuple(size.keys()))) * 0.5
        center = wrap(center)
        if &#39;vector&#39; not in center.shape or center.shape.get_item_names(&#39;vector&#39;) is None:
            center = math.expand(center, channel(self._half_size))
        self._center = center
        self._rotation_matrix = None if rotation is None else math.rotation_matrix(rotation)
        self._size_variable = size_variable

    def __repr__(self):
        return f&#34;Cuboid(center={self._center}, half_size={self._half_size})&#34;

    def __getitem__(self, item):
        item = _keep_vector(slicing_dict(self, item))
        rotation = self._rotation_matrix[item] if self._rotation_matrix is not None else None
        return Cuboid(self._center[item], self._half_size[item], rotation, size_variable=self._size_variable)

    @staticmethod
    def __stack__(values: tuple, dim: Shape, **kwargs) -&gt; &#39;Geometry&#39;:
        if all(isinstance(v, Cuboid) for v in values):
            size_variable = any([c._size_variable for c in values])
            if any(v._rotation_matrix is not None for v in values):
                matrices = [v._rotation_matrix for v in values]
                if any(m is None for m in matrices):
                    any_angle = math.rotation_angles([m for m in matrices if m is not None][0])
                    unit_matrix = math.rotation_matrix(any_angle * 0)
                    matrices = [unit_matrix if m is None else m for m in matrices]
                rotation = stack(matrices, dim, **kwargs)
            else:
                rotation = None
            return Cuboid(stack([v.center for v in values], dim, **kwargs), stack([v.half_size for v in values], dim, **kwargs), rotation, size_variable=size_variable)
        else:
            return Geometry.__stack__(values, dim, **kwargs)

    def __variable_attrs__(self):
        return (&#39;_center&#39;, &#39;_half_size&#39;, &#39;_rotation_matrix&#39;) if self._size_variable else (&#39;_center&#39;, &#39;_rotation_matrix&#39;)

    def __value_attrs__(self):
        return &#39;_center&#39;,

    @property
    def center(self):
        return self._center

    @property
    def half_size(self):
        return self._half_size

    @property
    def shape(self):
        if self._center is None or self._half_size is None:
            return None
        return self._center.shape &amp; self._half_size.shape

    @property
    def size(self):
        return 2 * self._half_size

    @property
    def lower(self):
        return self._center - self._half_size

    @property
    def upper(self):
        return self._center + self._half_size

    @property
    def rotation_matrix(self) -&gt; Optional[Tensor]:
        return self._rotation_matrix

    @property
    def is_size_variable(self):
        return self._size_variable

    def at(self, center: Tensor) -&gt; &#39;BaseBox&#39;:
        return Cuboid(center, self.half_size, self.rotation_matrix, size_variable=self._size_variable)

    def rotated(self, angle) -&gt; Geometry:
        if self._rotation_matrix is None:
            return Cuboid(self._center, self._half_size, angle, size_variable=self._size_variable)
        else:
            matrix = self._rotation_matrix @ (angle if dual(angle) else math.rotation_matrix(angle))
            return Cuboid(self._center, self._half_size, matrix, size_variable=self._size_variable)

    def bounding_half_extent(self):
        if self._rotation_matrix is not None:
            to_face = self.face_normals[{&#39;~side&#39;: 0}] * math.rename_dims(self._half_size, &#39;vector&#39;, dual)
            return math.sum(abs(to_face), &#39;~vector&#39;)
        return self.half_size

    def lies_inside(self, location):
        location = self.global_to_local(location, scale=False, origin=&#39;center&#39;)  # scale can only be performed for finite sizes
        bool_inside = abs(location) &lt;= self._half_size
        bool_inside = math.all(bool_inside, &#39;vector&#39;)
        bool_inside = math.any(bool_inside, self.shape.instance)  # union for instance dimensions
        return bool_inside</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.geom._box.BaseBox</li>
<li>phi.geom._geom.Geometry</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="phi.geom.Cuboid.center"><code class="name">prop <span class="ident">center</span></code></dt>
<dd>
<div class="desc"><p>Center location in single channel dimension.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def center(self):
    return self._center</code></pre>
</details>
</dd>
<dt id="phi.geom.Cuboid.half_size"><code class="name">prop <span class="ident">half_size</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def half_size(self):
    return self._half_size</code></pre>
</details>
</dd>
<dt id="phi.geom.Cuboid.is_size_variable"><code class="name">prop <span class="ident">is_size_variable</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_size_variable(self):
    return self._size_variable</code></pre>
</details>
</dd>
<dt id="phi.geom.Cuboid.lower"><code class="name">prop <span class="ident">lower</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def lower(self):
    return self._center - self._half_size</code></pre>
</details>
</dd>
<dt id="phi.geom.Cuboid.rotation_matrix"><code class="name">prop <span class="ident">rotation_matrix</span> : Optional[phiml.math._tensors.Tensor]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def rotation_matrix(self) -&gt; Optional[Tensor]:
    return self._rotation_matrix</code></pre>
</details>
</dd>
<dt id="phi.geom.Cuboid.shape"><code class="name">prop <span class="ident">shape</span></code></dt>
<dd>
<div class="desc"><p>The <code>shape</code> of a <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> consists of the following dimensions:</p>
<ul>
<li>A single <em>channel</em> dimension called <code>'vector'</code> specifying the physical space</li>
<li>Instance dimensions denote that this geometry consists of multiple copies in the same space</li>
<li>Spatial dimensions denote a crystal (repeating structure) of this geometric primitive in space</li>
<li>Batch dimensions indicate non-interacting versions of this geometry for parallelization only.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape(self):
    if self._center is None or self._half_size is None:
        return None
    return self._center.shape &amp; self._half_size.shape</code></pre>
</details>
</dd>
<dt id="phi.geom.Cuboid.size"><code class="name">prop <span class="ident">size</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self):
    return 2 * self._half_size</code></pre>
</details>
</dd>
<dt id="phi.geom.Cuboid.upper"><code class="name">prop <span class="ident">upper</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def upper(self):
    return self._center + self._half_size</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phi.geom.Cuboid.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>self, center: phiml.math._tensors.Tensor) ‑> phi.geom._box.BaseBox</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a copy of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> with the center at <code>center</code>.
This is equal to calling <code>self @ center</code>.</p>
<p>See Also:
<code><a title="phi.geom.Geometry.shifted" href="#phi.geom.Geometry.shifted">Geometry.shifted()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>center</code></strong></dt>
<dd>New center as <code>Tensor</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.</p></div>
</dd>
<dt id="phi.geom.Cuboid.bounding_half_extent"><code class="name flex">
<span>def <span class="ident">bounding_half_extent</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>The bounding half-extent sets a limit on the outer-most point for each coordinate axis.
Each component is non-negative.</p>
<p>Let the bounding half-extent have value <code>e</code> in dimension <code>d</code> (<code>extent[...,d] = e</code>).
Then, no point of the geometry lies further away from its center point than <code>e</code> along <code>d</code> (in both axis directions).</p>
<p>When this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.
If these dims are not present, all parts are assumed to have the same bounds.</p></div>
</dd>
<dt id="phi.geom.Cuboid.lies_inside"><code class="name flex">
<span>def <span class="ident">lies_inside</span></span>(<span>self, location)</span>
</code></dt>
<dd>
<div class="desc"><p>Tests whether the given location lies inside or outside of the geometry. Locations on the surface count as inside.</p>
<p>When dealing with unions or collections of geometries (instance dimensions), a point lies inside the geometry if it lies inside any instance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd>float tensor of shape (batch_size, &hellip;, rank)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>bool tensor of shape (*location.shape[:-1], 1).</p></div>
</dd>
<dt id="phi.geom.Cuboid.rotated"><code class="name flex">
<span>def <span class="ident">rotated</span></span>(<span>self, angle) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a rotated version of this geometry.
The geometry is rotated about its center point.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>angle</code></strong></dt>
<dd>
<p>Delta rotation.
Either</p>
<ul>
<li>Angle(s): scalar angle in 2d or euler angles along <code>vector</code> in 3D or higher.</li>
<li>Matrix: d⨯d rotation matrix</li>
</ul>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Rotated <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></p></div>
</dd>
</dl>
</dd>
<dt id="phi.geom.Geometry"><code class="flex name class">
<span>class <span class="ident">Geometry</span></span>
</code></dt>
<dd>
<div class="desc"><p>Abstract base class for N-dimensional shapes.</p>
<p>Main implementing classes:</p>
<ul>
<li>Sphere</li>
<li>box family: box (generator), Box, Cuboid, BaseBox</li>
</ul>
<p>All geometry objects support batching.
Thereby any parameter defining the geometry can be varied along arbitrary batch dims.
All batch dimensions are listed in Geometry.shape.</p>
<p>Property getters (<code>@property</code>, such as <code>shape</code>), save for getters, must not depend on any variables marked as <em>variable</em> via <code>__variable_attrs__()</code> as these may be <code>None</code> during tracing.
Equality checks must also take this into account.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Geometry:
    &#34;&#34;&#34;
    Abstract base class for N-dimensional shapes.

    Main implementing classes:

    * Sphere
    * box family: box (generator), Box, Cuboid, BaseBox

    All geometry objects support batching.
    Thereby any parameter defining the geometry can be varied along arbitrary batch dims.
    All batch dimensions are listed in Geometry.shape.

    Property getters (`@property`, such as `shape`), save for getters, must not depend on any variables marked as *variable* via `__variable_attrs__()` as these may be `None` during tracing.
    Equality checks must also take this into account.
    &#34;&#34;&#34;

    @property
    def center(self) -&gt; Tensor:
        &#34;&#34;&#34;
        Center location in single channel dimension.
        &#34;&#34;&#34;
        raise NotImplementedError(self.__class__)

    @property
    def shape(self) -&gt; Shape:
        &#34;&#34;&#34;
        The `shape` of a `Geometry` consists of the following dimensions:

        * A single *channel* dimension called `&#39;vector&#39;` specifying the physical space
        * Instance dimensions denote that this geometry consists of multiple copies in the same space
        * Spatial dimensions denote a crystal (repeating structure) of this geometric primitive in space
        * Batch dimensions indicate non-interacting versions of this geometry for parallelization only.
        &#34;&#34;&#34;
        raise NotImplementedError(self.__class__)

    @property
    def volume(self) -&gt; Tensor:
        &#34;&#34;&#34;
        `phi.math.Tensor` representing the volume of each element.
        The result retains batch, spatial and instance dimensions.
        &#34;&#34;&#34;
        raise NotImplementedError(self.__class__)

    @property
    def faces(self) -&gt; &#39;Geometry&#39;:
        raise NotImplementedError(self.__class__)

    @property
    def face_centers(self) -&gt; Tensor:
        &#34;&#34;&#34;
        Center of face connecting a pair of cells. Shape `(elements, ~, vector)`.
        Here, `~` represents arbitrary internal dual dimensions, such as `~staggered_direction` or `~elements`.
        Returns 0-vectors for unconnected cells.
        &#34;&#34;&#34;
        raise NotImplementedError(self.__class__)

    @property
    def face_areas(self) -&gt; Tensor:
        &#34;&#34;&#34;
        Area of face connecting a pair of cells. Shape `(elements, ~)`.
        Returns 0 for unconnected cells.
        &#34;&#34;&#34;
        raise NotImplementedError(self.__class__)

    @property
    def face_normals(self) -&gt; Tensor:
        &#34;&#34;&#34;
        Normal vectors of cell faces, including boundary faces. Shape `(elements, ~, vector)`.
        For meshes, The vectors point out of the primal cells and into the dual cells.

        Instance/spatial dimensions along which the normal does not vary may not be included in the result tensor&#39;s shape.
        &#34;&#34;&#34;
        raise NotImplementedError(self.__class__)

    @property
    def boundary_elements(self) -&gt; Dict[Any, Dict[str, slice]]:
        &#34;&#34;&#34;
        Slices on the primal dimensions to mark boundary elements.
        Grids and meshes have no boundary elements and return `{}`.
        Dynamic graphs can define boundary elements for obstacles and walls.

        Returns:
            Map from `(name, is_upper)` to slicing `dict`.
        &#34;&#34;&#34;
        raise NotImplementedError(self.__class__)

    @property
    def boundary_faces(self) -&gt; Dict[Any, Dict[str, slice]]:
        &#34;&#34;&#34;
        Slices on the dual dimensions to mark boundary faces.

        Regular grids use the keys (dim, is_upper) to identify boundaries.
        Unstructured meshes use string identifiers for the boundaries.
        Dynamic graphs return slices along the dual dimensions.

        Returns:
            Map from `(name, is_upper)` to slicing `dict`.
        &#34;&#34;&#34;
        raise NotImplementedError(self.__class__)

    @property
    def face_shape(self) -&gt; Shape:
        &#34;&#34;&#34;
        Returns:
            Full Shape to identify each face of this `Geometry`, including instance/spatial dimensions for the elements and dual dimensions listing the faces per element.
            If this `Geometry` has no faces, returns an empty `Shape`.
        &#34;&#34;&#34;
        raise NotImplementedError(self.__class__)

    @property
    def corners(self) -&gt; Tensor:
        &#34;&#34;&#34;
        Returns:
            Corner locations as `phiml.math.Tensor`.
            Corners belonging to one object or cell are listed along dual dimensions.
            If the object has no corners, a size-0 tensor with the correct vector and instance dims is returned.
        &#34;&#34;&#34;
        raise NotImplementedError(self.__class__)

    def integrate_surface(self, face_values: Tensor, divide_volume=False) -&gt; Tensor:
        &#34;&#34;&#34;
        Multiplies `values´ by the corresponding face area, computes the sum over all faces and divides by the cell volume.
        ∑ values * A.

        Args:
            face_values: Values sampled at the face centers.
            divide_volume: Whether to divide by the cell `volume´

        Returns:
            `Tensor` of values sampled at the centroids.
        &#34;&#34;&#34;
        result = math.sum(face_values * self.face_areas, self.face_shape.dual)
        return result / self.volume if divide_volume else result

    def integrate_flux(self, flux: Tensor, divide_volume=False) -&gt; Tensor:
        assert &#39;vector&#39; in flux.shape, f&#34;flux must have a &#39;vector&#39; dimension but got {flux.shape}&#34;
        result = math.sum(flux.vector @ (self.face_normals * self.face_areas).vector, self.face_shape.dual)
        return result / self.volume if divide_volume else result

    # def resample_to_faces(self, values: Tensor, boundary: Extrapolation, **kwargs):
    #     raise NotImplementedError(self.__class__)
    #
    # def resample_to_centers(self, values: Tensor, boundary: Extrapolation, **kwargs):
    #     raise NotImplementedError(self.__class__)
    #
    # def centered_gradient_of(self, values: Tensor, boundary: Extrapolation, dims=None, **kwargs):
    #     raise NotImplementedError(self.__class__)
    #
    # def staggered_gradient_of(self, values: Tensor, boundary: Extrapolation, dims=None, **kwargs):
    #     raise NotImplementedError(self.__class__)
    #
    # def divergence_of(self, values: Tensor, boundary: Extrapolation, dims=None, **kwargs):
    #     raise NotImplementedError(self.__class__)
    #
    # def laplace_of(self, values: Tensor, boundary: Extrapolation, dims=None, **kwargs):
    #     raise NotImplementedError(self.__class__)
    #
    # def centered_curl_of(self, values: Tensor, boundary: Extrapolation, dims=None, **kwargs):
    #     raise NotImplementedError(self.__class__)
    #
    # def staggered_curl_of(self, values: Tensor, boundary: Extrapolation, dims=None, **kwargs):
    #     raise NotImplementedError(self.__class__)

    def unstack(self, dimension: str) -&gt; tuple:
        &#34;&#34;&#34;
        Unstacks this Geometry along the given dimension.
        The shapes of the returned geometries are reduced by `dimension`.

        Args:
            dimension: dimension along which to unstack

        Returns:
            geometries: tuple of length equal to `geometry.shape.get_size(dimension)`
        &#34;&#34;&#34;
        warnings.warn(f&#34;Geometry.unstack() is deprecated. Use math.unstack(geometry) instead.&#34;, DeprecationWarning)
        return math.unstack(self, dimension)

    @property
    def spatial_rank(self) -&gt; int:
        &#34;&#34;&#34; Number of spatial dimensions of the geometry, 1 = 1D, 2 = 2D, 3 = 3D, etc. &#34;&#34;&#34;
        return self.shape.get_size(&#39;vector&#39;)

    def lies_inside(self, location: Tensor) -&gt; Tensor:
        &#34;&#34;&#34;
        Tests whether the given location lies inside or outside of the geometry. Locations on the surface count as inside.

        When dealing with unions or collections of geometries (instance dimensions), a point lies inside the geometry if it lies inside any instance.

        Args:
          location: float tensor of shape (batch_size, ..., rank)

        Returns:
          bool tensor of shape (*location.shape[:-1], 1).

        &#34;&#34;&#34;
        raise NotImplementedError(self.__class__)

    def approximate_closest_surface(self, location: Tensor) -&gt; Tuple[Tensor, Tensor, Tensor, Tensor, Tensor]:
        &#34;&#34;&#34;
        Find the closest surface face of this geometry given a point that can be outside or inside the geometry.

        Args:
            location: `Tensor` with a single channel dimension called vector. Can have arbitrary other dimensions.

        Returns:
            signed_distance: Scalar signed distance from `location`  to the closest point on the surface.
                Positive values indicate the point lies outside the geometry, negative values indicate the point lies inside the geometry.
            delta: Vector-valued distance vector from `location` to the closest point on the surface.
            normal: Closest surface normal vector.
            offset: Min distance of a surface-tangential plane from 0 as a scalar.
            face_index: (Optional) An index vector pointing at the closest face.
        &#34;&#34;&#34;
        raise NotImplementedError(self.__class__)

    def approximate_signed_distance(self, location: Tensor) -&gt; Tensor:
        &#34;&#34;&#34;
        Computes the approximate distance from location to the surface of the geometry.
        Locations outside return positive values, inside negative values and zero exactly at the boundary.

        The exact distance metric used depends on the geometry.
        The approximation holds close to the surface and the distance grows to infinity as the location is moved infinitely far from the geometry.
        The distance metric is differentiable and its gradients are bounded at every point in space.

        When dealing with unions or collections of geometries (instance dimensions), the shortest distance to any instance is returned.
        This also holds for negative distances.

        Args:
            location: `Tensor` with one channel dim `vector` matching the geometry&#39;s `vector` dim.

        Returns:
            Float `Tensor`
        &#34;&#34;&#34;
        raise NotImplementedError(self.__class__)

    def approximate_fraction_inside(self, other_geometry: &#39;Geometry&#39;, balance: Union[Tensor, Number] = 0.5) -&gt; Tensor:
        &#34;&#34;&#34;
        Computes the approximate overlap between the geometry and a small other geometry.
        Returns 1.0 if `other_geometry` is fully enclosed in this geometry and 0.0 if there is no overlap.
        Close to the surface of this geometry, the fraction filled is differentiable w.r.t. the location and size of `other_geometry`.

        To call this method on batches of geometries of same shape, pass a batched Geometry instance.
        The result tensor will match the batch shape of `other_geometry`.

        The result may only be accurate in special cases.
        The given geometries may be approximated as spheres or boxes using `bounding_radius()` and `bounding_half_extent()`.

        The default implementation of this method approximates other_geometry as a Sphere and computes the fraction using `approximate_signed_distance()`.

        Args:
            other_geometry: `Geometry` or geometry batch for which to compute the overlap with `self`.
            balance: Mid-level between 0 and 1, default 0.5.
                This value is returned when exactly half of `other_geometry` lies inside `self`.
                `0.5 &lt; balance &lt;= 1` makes `self` seem larger while `0 &lt;= balance &lt; 0.5`makes `self` seem smaller.

        Returns:
          fraction of cell volume lying inside the geometry. float tensor of shape (other_geometry.batch_shape, 1).

        &#34;&#34;&#34;
        assert isinstance(other_geometry, Geometry)
        radius = other_geometry.bounding_radius()
        location = other_geometry.center
        distance = self.approximate_signed_distance(location)
        inside_fraction = balance - distance / radius
        inside_fraction = math.clip(inside_fraction, 0, 1)
        return inside_fraction

    def push(self, positions: Tensor, outward: bool = True, shift_amount: float = 0) -&gt; Tensor:
        &#34;&#34;&#34;
        Shifts positions either into or out of geometry.

        Args:
            positions: Tensor holding positions to shift
            outward: Flag for indicating inward (False) or outward (True) shift
            shift_amount: Minimum distance between positions and surface after shifting.

        Returns:
            Tensor holding shifted positions.
        &#34;&#34;&#34;
        from ._geom_ops import expel
        return expel(self, positions, min_separation=shift_amount, invert=not outward)

    def sample_uniform(self, *shape: math.Shape) -&gt; Tensor:
        &#34;&#34;&#34;
        Samples uniformly distributed random points inside this volume.

        Args:
            *shape: How many points to sample per individual geometry.

        Returns:
            `Tensor` containing all dimensions from `Geometry.shape`, `shape` as well as a `channel` dimension `vector` matching the dimensionality of this `Geometry`.
        &#34;&#34;&#34;
        raise NotImplementedError(self.__class__)

    def bounding_radius(self) -&gt; Tensor:
        &#34;&#34;&#34;
        Returns the radius of a Sphere object that fully encloses this geometry.
        The sphere is centered at the center of this geometry.

        :return: radius of type float

        Args:

        Returns:

        &#34;&#34;&#34;
        raise NotImplementedError(self.__class__)

    def bounding_half_extent(self) -&gt; Tensor:
        &#34;&#34;&#34;
        The bounding half-extent sets a limit on the outer-most point for each coordinate axis.
        Each component is non-negative.

        Let the bounding half-extent have value `e` in dimension `d` (`extent[...,d] = e`).
        Then, no point of the geometry lies further away from its center point than `e` along `d` (in both axis directions).

        When this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.
        If these dims are not present, all parts are assumed to have the same bounds.
        &#34;&#34;&#34;
        raise NotImplementedError(self.__class__)

    def bounding_box(self) -&gt; &#39;BaseBox&#39;:
        &#34;&#34;&#34;
        Returns the approximately smallest axis-aligned box that contains this `Geometry`.
        The center of the box may not be equal to `self.center`.

        Returns:
            `Box` or `Cuboid` that fully contains this `Geometry`.
        &#34;&#34;&#34;
        center = self.center
        half = self.bounding_half_extent()
        min_vec = math.min(center - half, dim=center.shape.non_batch.non_channel)
        max_vec = math.max(center + half, dim=center.shape.non_batch.non_channel)
        from ._box import Box
        return Box(min_vec, max_vec)

    def shifted(self, delta: Tensor) -&gt; &#39;Geometry&#39;:
        &#34;&#34;&#34;
        Returns a translated version of this geometry.

        See Also:
            `Geometry.at()`.

        Args:
          delta: direction vector
          delta: Tensor:

        Returns:
          Geometry: shifted geometry

        &#34;&#34;&#34;
        return self.at(self.center + delta)

    def at(self, center: Tensor) -&gt; &#39;Geometry&#39;:
        &#34;&#34;&#34;
        Returns a copy of this `Geometry` with the center at `center`.
        This is equal to calling `self @ center`.

        See Also:
            `Geometry.shifted()`.

        Args:
            center: New center as `Tensor`.

        Returns:
            `Geometry`.
        &#34;&#34;&#34;
        raise NotImplementedError(self.__class__)

    def __matmul__(self, other):
        if isinstance(other, (Tensor, float, int)):
            return self.at(other)
        return NotImplemented

    def rotated(self, angle: Union[float, Tensor]) -&gt; &#39;Geometry&#39;:
        &#34;&#34;&#34;
        Returns a rotated version of this geometry.
        The geometry is rotated about its center point.

        Args:
            angle: Delta rotation.
                Either

                * Angle(s): scalar angle in 2d or euler angles along `vector` in 3D or higher.
                * Matrix: d⨯d rotation matrix

        Returns:
            Rotated `Geometry`
        &#34;&#34;&#34;
        raise NotImplementedError(self.__class__)

    def scaled(self, factor: Union[float, Tensor]) -&gt; &#39;Geometry&#39;:
        &#34;&#34;&#34;
        Scales each individual geometry by `factor`.
        The individual `center` points act as pivots for the operation.

        Args:
            factor:

        Returns:

        &#34;&#34;&#34;
        raise NotImplementedError(self.__class__)

    def __invert__(self):
        return InvertedGeometry(self)

    def __eq__(self, other):
        &#34;&#34;&#34;
        Slow equality check.
        Unlike `==`, this method compares all tensor elements to check whether they are equal.
        Use `==` for a faster check which only checks whether the referenced tensors are the same.

        See Also:
            `shallow_equals()`
        &#34;&#34;&#34;
        def tensor_equality(a, b):
            if a is None or b is None:
                return True  # stored mode, tensors unavailable
            return math.close(a, b, rel_tolerance=1e-5, equal_nan=True)
        differences = find_differences(self, other, attr_type=variable_attributes, tensor_equality=tensor_equality)
        return not differences

    def shallow_equals(self, other):
        &#34;&#34;&#34;
        Quick equality check.
        May return `False` even if `other == self`.
        However, if `True` is returned, the geometries are guaranteed to be equal.

        The `shallow_equals()` check does not compare all tensor elements but merely checks whether the same tensors are referenced.
        &#34;&#34;&#34;
        differences = find_differences(self, other, compare_tensors_by_id=True)
        return not differences

    @staticmethod
    def __stack__(values: tuple, dim: Shape, **kwargs) -&gt; &#39;Geometry&#39;:
        if all(type(v) == type(values[0]) for v in values):
            return NotImplemented  # let attributes be stacked
        else:
            from ._geom_ops import GeometryStack
            set_op = kwargs.get(&#39;set_op&#39;)
            return GeometryStack(math.layout(values, dim), set_op)

    def __flatten__(self, flat_dim: Shape, flatten_batch: bool, **kwargs) -&gt; &#39;Geometry&#39;:
        dims = self.shape.without(&#39;vector&#39;)
        if not flatten_batch:
            dims = dims.non_batch
        return math.pack_dims(self, dims, flat_dim, **kwargs)

    def __ne__(self, other):
        return not self == other

    def __hash__(self):
        return id(self.__class__) + hash(self.shape)

    def __repr__(self):
        return f&#34;{self.__class__.__name__}{self.shape}&#34;

    def __getitem__(self, item):
        raise NotImplementedError
        # assert isinstance(item, dict), &#34;Index must be dict of type {dim: slice/int}.&#34;
        # item = {dim: sel for dim, sel in item.items() if dim != &#39;vector&#39;}
        # attrs = {a: getattr(self, a)[item] for a in variable_attributes(self)}
        # return copy_with(self, **attrs)

    def __getattr__(self, name: str) -&gt; BoundDim:
        return BoundDim(self, name)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li>phi.geom._box.BaseBox</li>
<li>phi.geom._geom.InvertedGeometry</li>
<li>phi.geom._geom.Point</li>
<li>phi.geom._geom._NoGeometry</li>
<li>phi.geom._geom_ops.GeometryStack</li>
<li>phi.geom._graph.Graph</li>
<li>phi.geom._heightmap.Heightmap</li>
<li>phi.geom._mesh.Mesh</li>
<li>phi.geom._sdf_grid.SDFGrid</li>
<li>phi.geom._sphere.Sphere</li>
<li>phi.geom._transform._EmbeddedGeometry</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="phi.geom.Geometry.boundary_elements"><code class="name">prop <span class="ident">boundary_elements</span> : Dict[Any, Dict[str, slice]]</code></dt>
<dd>
<div class="desc"><p>Slices on the primal dimensions to mark boundary elements.
Grids and meshes have no boundary elements and return <code>{}</code>.
Dynamic graphs can define boundary elements for obstacles and walls.</p>
<h2 id="returns">Returns</h2>
<p>Map from <code>(name, is_upper)</code> to slicing <code>dict</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def boundary_elements(self) -&gt; Dict[Any, Dict[str, slice]]:
    &#34;&#34;&#34;
    Slices on the primal dimensions to mark boundary elements.
    Grids and meshes have no boundary elements and return `{}`.
    Dynamic graphs can define boundary elements for obstacles and walls.

    Returns:
        Map from `(name, is_upper)` to slicing `dict`.
    &#34;&#34;&#34;
    raise NotImplementedError(self.__class__)</code></pre>
</details>
</dd>
<dt id="phi.geom.Geometry.boundary_faces"><code class="name">prop <span class="ident">boundary_faces</span> : Dict[Any, Dict[str, slice]]</code></dt>
<dd>
<div class="desc"><p>Slices on the dual dimensions to mark boundary faces.</p>
<p>Regular grids use the keys (dim, is_upper) to identify boundaries.
Unstructured meshes use string identifiers for the boundaries.
Dynamic graphs return slices along the dual dimensions.</p>
<h2 id="returns">Returns</h2>
<p>Map from <code>(name, is_upper)</code> to slicing <code>dict</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def boundary_faces(self) -&gt; Dict[Any, Dict[str, slice]]:
    &#34;&#34;&#34;
    Slices on the dual dimensions to mark boundary faces.

    Regular grids use the keys (dim, is_upper) to identify boundaries.
    Unstructured meshes use string identifiers for the boundaries.
    Dynamic graphs return slices along the dual dimensions.

    Returns:
        Map from `(name, is_upper)` to slicing `dict`.
    &#34;&#34;&#34;
    raise NotImplementedError(self.__class__)</code></pre>
</details>
</dd>
<dt id="phi.geom.Geometry.center"><code class="name">prop <span class="ident">center</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p>Center location in single channel dimension.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def center(self) -&gt; Tensor:
    &#34;&#34;&#34;
    Center location in single channel dimension.
    &#34;&#34;&#34;
    raise NotImplementedError(self.__class__)</code></pre>
</details>
</dd>
<dt id="phi.geom.Geometry.corners"><code class="name">prop <span class="ident">corners</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<p>Corner locations as <code>phiml.math.Tensor</code>.
Corners belonging to one object or cell are listed along dual dimensions.
If the object has no corners, a size-0 tensor with the correct vector and instance dims is returned.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def corners(self) -&gt; Tensor:
    &#34;&#34;&#34;
    Returns:
        Corner locations as `phiml.math.Tensor`.
        Corners belonging to one object or cell are listed along dual dimensions.
        If the object has no corners, a size-0 tensor with the correct vector and instance dims is returned.
    &#34;&#34;&#34;
    raise NotImplementedError(self.__class__)</code></pre>
</details>
</dd>
<dt id="phi.geom.Geometry.face_areas"><code class="name">prop <span class="ident">face_areas</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p>Area of face connecting a pair of cells. Shape <code>(elements, ~)</code>.
Returns 0 for unconnected cells.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_areas(self) -&gt; Tensor:
    &#34;&#34;&#34;
    Area of face connecting a pair of cells. Shape `(elements, ~)`.
    Returns 0 for unconnected cells.
    &#34;&#34;&#34;
    raise NotImplementedError(self.__class__)</code></pre>
</details>
</dd>
<dt id="phi.geom.Geometry.face_centers"><code class="name">prop <span class="ident">face_centers</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p>Center of face connecting a pair of cells. Shape <code>(elements, ~, vector)</code>.
Here, <code>~</code> represents arbitrary internal dual dimensions, such as <code>~staggered_direction</code> or <code>~elements</code>.
Returns 0-vectors for unconnected cells.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_centers(self) -&gt; Tensor:
    &#34;&#34;&#34;
    Center of face connecting a pair of cells. Shape `(elements, ~, vector)`.
    Here, `~` represents arbitrary internal dual dimensions, such as `~staggered_direction` or `~elements`.
    Returns 0-vectors for unconnected cells.
    &#34;&#34;&#34;
    raise NotImplementedError(self.__class__)</code></pre>
</details>
</dd>
<dt id="phi.geom.Geometry.face_normals"><code class="name">prop <span class="ident">face_normals</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p>Normal vectors of cell faces, including boundary faces. Shape <code>(elements, ~, vector)</code>.
For meshes, The vectors point out of the primal cells and into the dual cells.</p>
<p>Instance/spatial dimensions along which the normal does not vary may not be included in the result tensor's shape.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_normals(self) -&gt; Tensor:
    &#34;&#34;&#34;
    Normal vectors of cell faces, including boundary faces. Shape `(elements, ~, vector)`.
    For meshes, The vectors point out of the primal cells and into the dual cells.

    Instance/spatial dimensions along which the normal does not vary may not be included in the result tensor&#39;s shape.
    &#34;&#34;&#34;
    raise NotImplementedError(self.__class__)</code></pre>
</details>
</dd>
<dt id="phi.geom.Geometry.face_shape"><code class="name">prop <span class="ident">face_shape</span> : phiml.math._shape.Shape</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<p>Full Shape to identify each face of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>, including instance/spatial dimensions for the elements and dual dimensions listing the faces per element.
If this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> has no faces, returns an empty <code>Shape</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_shape(self) -&gt; Shape:
    &#34;&#34;&#34;
    Returns:
        Full Shape to identify each face of this `Geometry`, including instance/spatial dimensions for the elements and dual dimensions listing the faces per element.
        If this `Geometry` has no faces, returns an empty `Shape`.
    &#34;&#34;&#34;
    raise NotImplementedError(self.__class__)</code></pre>
</details>
</dd>
<dt id="phi.geom.Geometry.faces"><code class="name">prop <span class="ident">faces</span> : <a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def faces(self) -&gt; &#39;Geometry&#39;:
    raise NotImplementedError(self.__class__)</code></pre>
</details>
</dd>
<dt id="phi.geom.Geometry.shape"><code class="name">prop <span class="ident">shape</span> : phiml.math._shape.Shape</code></dt>
<dd>
<div class="desc"><p>The <code>shape</code> of a <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> consists of the following dimensions:</p>
<ul>
<li>A single <em>channel</em> dimension called <code>'vector'</code> specifying the physical space</li>
<li>Instance dimensions denote that this geometry consists of multiple copies in the same space</li>
<li>Spatial dimensions denote a crystal (repeating structure) of this geometric primitive in space</li>
<li>Batch dimensions indicate non-interacting versions of this geometry for parallelization only.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape(self) -&gt; Shape:
    &#34;&#34;&#34;
    The `shape` of a `Geometry` consists of the following dimensions:

    * A single *channel* dimension called `&#39;vector&#39;` specifying the physical space
    * Instance dimensions denote that this geometry consists of multiple copies in the same space
    * Spatial dimensions denote a crystal (repeating structure) of this geometric primitive in space
    * Batch dimensions indicate non-interacting versions of this geometry for parallelization only.
    &#34;&#34;&#34;
    raise NotImplementedError(self.__class__)</code></pre>
</details>
</dd>
<dt id="phi.geom.Geometry.spatial_rank"><code class="name">prop <span class="ident">spatial_rank</span> : int</code></dt>
<dd>
<div class="desc"><p>Number of spatial dimensions of the geometry, 1 = 1D, 2 = 2D, 3 = 3D, etc.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def spatial_rank(self) -&gt; int:
    &#34;&#34;&#34; Number of spatial dimensions of the geometry, 1 = 1D, 2 = 2D, 3 = 3D, etc. &#34;&#34;&#34;
    return self.shape.get_size(&#39;vector&#39;)</code></pre>
</details>
</dd>
<dt id="phi.geom.Geometry.volume"><code class="name">prop <span class="ident">volume</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p><code>phi.math.Tensor</code> representing the volume of each element.
The result retains batch, spatial and instance dimensions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def volume(self) -&gt; Tensor:
    &#34;&#34;&#34;
    `phi.math.Tensor` representing the volume of each element.
    The result retains batch, spatial and instance dimensions.
    &#34;&#34;&#34;
    raise NotImplementedError(self.__class__)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phi.geom.Geometry.approximate_closest_surface"><code class="name flex">
<span>def <span class="ident">approximate_closest_surface</span></span>(<span>self, location: phiml.math._tensors.Tensor) ‑> Tuple[phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor]</span>
</code></dt>
<dd>
<div class="desc"><p>Find the closest surface face of this geometry given a point that can be outside or inside the geometry.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd><code>Tensor</code> with a single channel dimension called vector. Can have arbitrary other dimensions.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>signed_distance</code></dt>
<dd>Scalar signed distance from <code>location</code>
to the closest point on the surface.
Positive values indicate the point lies outside the geometry, negative values indicate the point lies inside the geometry.</dd>
<dt><code>delta</code></dt>
<dd>Vector-valued distance vector from <code>location</code> to the closest point on the surface.</dd>
<dt><code>normal</code></dt>
<dd>Closest surface normal vector.</dd>
<dt><code>offset</code></dt>
<dd>Min distance of a surface-tangential plane from 0 as a scalar.</dd>
<dt><code>face_index</code></dt>
<dd>(Optional) An index vector pointing at the closest face.</dd>
</dl></div>
</dd>
<dt id="phi.geom.Geometry.approximate_fraction_inside"><code class="name flex">
<span>def <span class="ident">approximate_fraction_inside</span></span>(<span>self, other_geometry: <a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a>, balance: Union[phiml.math._tensors.Tensor, numbers.Number] = 0.5) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the approximate overlap between the geometry and a small other geometry.
Returns 1.0 if <code>other_geometry</code> is fully enclosed in this geometry and 0.0 if there is no overlap.
Close to the surface of this geometry, the fraction filled is differentiable w.r.t. the location and size of <code>other_geometry</code>.</p>
<p>To call this method on batches of geometries of same shape, pass a batched Geometry instance.
The result tensor will match the batch shape of <code>other_geometry</code>.</p>
<p>The result may only be accurate in special cases.
The given geometries may be approximated as spheres or boxes using <code>bounding_radius()</code> and <code>bounding_half_extent()</code>.</p>
<p>The default implementation of this method approximates other_geometry as a Sphere and computes the fraction using <code>approximate_signed_distance()</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>other_geometry</code></strong></dt>
<dd><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> or geometry batch for which to compute the overlap with <code>self</code>.</dd>
<dt><strong><code>balance</code></strong></dt>
<dd>Mid-level between 0 and 1, default 0.5.
This value is returned when exactly half of <code>other_geometry</code> lies inside <code>self</code>.
<code>0.5 &lt; balance &lt;= 1</code> makes <code>self</code> seem larger while <code>0 &lt;= balance &lt; 0.5</code>makes <code>self</code> seem smaller.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>fraction of cell volume lying inside the geometry. float tensor of shape (other_geometry.batch_shape, 1).</p></div>
</dd>
<dt id="phi.geom.Geometry.approximate_signed_distance"><code class="name flex">
<span>def <span class="ident">approximate_signed_distance</span></span>(<span>self, location: phiml.math._tensors.Tensor) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the approximate distance from location to the surface of the geometry.
Locations outside return positive values, inside negative values and zero exactly at the boundary.</p>
<p>The exact distance metric used depends on the geometry.
The approximation holds close to the surface and the distance grows to infinity as the location is moved infinitely far from the geometry.
The distance metric is differentiable and its gradients are bounded at every point in space.</p>
<p>When dealing with unions or collections of geometries (instance dimensions), the shortest distance to any instance is returned.
This also holds for negative distances.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd><code>Tensor</code> with one channel dim <code>vector</code> matching the geometry's <code>vector</code> dim.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Float <code>Tensor</code></p></div>
</dd>
<dt id="phi.geom.Geometry.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>self, center: phiml.math._tensors.Tensor) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a copy of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> with the center at <code>center</code>.
This is equal to calling <code>self @ center</code>.</p>
<p>See Also:
<code><a title="phi.geom.Geometry.shifted" href="#phi.geom.Geometry.shifted">Geometry.shifted()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>center</code></strong></dt>
<dd>New center as <code>Tensor</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.</p></div>
</dd>
<dt id="phi.geom.Geometry.bounding_box"><code class="name flex">
<span>def <span class="ident">bounding_box</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the approximately smallest axis-aligned box that contains this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.
The center of the box may not be equal to <code>self.center</code>.</p>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.geom.Box" href="#phi.geom.Box">Box</a></code> or <code><a title="phi.geom.Cuboid" href="#phi.geom.Cuboid">Cuboid</a></code> that fully contains this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.</p></div>
</dd>
<dt id="phi.geom.Geometry.bounding_half_extent"><code class="name flex">
<span>def <span class="ident">bounding_half_extent</span></span>(<span>self) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>The bounding half-extent sets a limit on the outer-most point for each coordinate axis.
Each component is non-negative.</p>
<p>Let the bounding half-extent have value <code>e</code> in dimension <code>d</code> (<code>extent[...,d] = e</code>).
Then, no point of the geometry lies further away from its center point than <code>e</code> along <code>d</code> (in both axis directions).</p>
<p>When this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.
If these dims are not present, all parts are assumed to have the same bounds.</p></div>
</dd>
<dt id="phi.geom.Geometry.bounding_radius"><code class="name flex">
<span>def <span class="ident">bounding_radius</span></span>(<span>self) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the radius of a Sphere object that fully encloses this geometry.
The sphere is centered at the center of this geometry.</p>
<p>:return: radius of type float</p>
<p>Args:</p>
<p>Returns:</p></div>
</dd>
<dt id="phi.geom.Geometry.integrate_flux"><code class="name flex">
<span>def <span class="ident">integrate_flux</span></span>(<span>self, flux: phiml.math._tensors.Tensor, divide_volume=False) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Geometry.integrate_surface"><code class="name flex">
<span>def <span class="ident">integrate_surface</span></span>(<span>self, face_values: phiml.math._tensors.Tensor, divide_volume=False) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Multiplies `values´ by the corresponding face area, computes the sum over all faces and divides by the cell volume.
∑ values * A.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>face_values</code></strong></dt>
<dd>Values sampled at the face centers.</dd>
<dt><strong><code>divide_volume</code></strong></dt>
<dd>Whether to divide by the cell `volume´</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>Tensor</code> of values sampled at the centroids.</p></div>
</dd>
<dt id="phi.geom.Geometry.lies_inside"><code class="name flex">
<span>def <span class="ident">lies_inside</span></span>(<span>self, location: phiml.math._tensors.Tensor) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Tests whether the given location lies inside or outside of the geometry. Locations on the surface count as inside.</p>
<p>When dealing with unions or collections of geometries (instance dimensions), a point lies inside the geometry if it lies inside any instance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd>float tensor of shape (batch_size, &hellip;, rank)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>bool tensor of shape (*location.shape[:-1], 1).</p></div>
</dd>
<dt id="phi.geom.Geometry.push"><code class="name flex">
<span>def <span class="ident">push</span></span>(<span>self, positions: phiml.math._tensors.Tensor, outward: bool = True, shift_amount: float = 0) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Shifts positions either into or out of geometry.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>positions</code></strong></dt>
<dd>Tensor holding positions to shift</dd>
<dt><strong><code>outward</code></strong></dt>
<dd>Flag for indicating inward (False) or outward (True) shift</dd>
<dt><strong><code>shift_amount</code></strong></dt>
<dd>Minimum distance between positions and surface after shifting.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Tensor holding shifted positions.</p></div>
</dd>
<dt id="phi.geom.Geometry.rotated"><code class="name flex">
<span>def <span class="ident">rotated</span></span>(<span>self, angle: Union[phiml.math._tensors.Tensor, float]) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a rotated version of this geometry.
The geometry is rotated about its center point.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>angle</code></strong></dt>
<dd>
<p>Delta rotation.
Either</p>
<ul>
<li>Angle(s): scalar angle in 2d or euler angles along <code>vector</code> in 3D or higher.</li>
<li>Matrix: d⨯d rotation matrix</li>
</ul>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Rotated <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></p></div>
</dd>
<dt id="phi.geom.Geometry.sample_uniform"><code class="name flex">
<span>def <span class="ident">sample_uniform</span></span>(<span>self, *shape: phiml.math._shape.Shape) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Samples uniformly distributed random points inside this volume.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*shape</code></strong></dt>
<dd>How many points to sample per individual geometry.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>Tensor</code> containing all dimensions from <code><a title="phi.geom.Geometry.shape" href="#phi.geom.Geometry.shape">Geometry.shape</a></code>, <code>shape</code> as well as a <code>channel</code> dimension <code>vector</code> matching the dimensionality of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.</p></div>
</dd>
<dt id="phi.geom.Geometry.scaled"><code class="name flex">
<span>def <span class="ident">scaled</span></span>(<span>self, factor: Union[phiml.math._tensors.Tensor, float]) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<div class="desc"><p>Scales each individual geometry by <code>factor</code>.
The individual <code>center</code> points act as pivots for the operation.</p>
<h2 id="args">Args</h2>
<p>factor:
Returns:</p></div>
</dd>
<dt id="phi.geom.Geometry.shallow_equals"><code class="name flex">
<span>def <span class="ident">shallow_equals</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Quick equality check.
May return <code>False</code> even if <code>other == self</code>.
However, if <code>True</code> is returned, the geometries are guaranteed to be equal.</p>
<p>The <code>shallow_equals()</code> check does not compare all tensor elements but merely checks whether the same tensors are referenced.</p></div>
</dd>
<dt id="phi.geom.Geometry.shifted"><code class="name flex">
<span>def <span class="ident">shifted</span></span>(<span>self, delta: phiml.math._tensors.Tensor) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a translated version of this geometry.</p>
<p>See Also:
<code><a title="phi.geom.Geometry.at" href="#phi.geom.Geometry.at">Geometry.at()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>delta</code></strong></dt>
<dd>direction vector</dd>
<dt><strong><code>delta</code></strong></dt>
<dd>Tensor:</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></dt>
<dd>shifted geometry</dd>
</dl></div>
</dd>
<dt id="phi.geom.Geometry.unstack"><code class="name flex">
<span>def <span class="ident">unstack</span></span>(<span>self, dimension: str) ‑> tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Unstacks this Geometry along the given dimension.
The shapes of the returned geometries are reduced by <code>dimension</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dimension</code></strong></dt>
<dd>dimension along which to unstack</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>geometries</code></dt>
<dd>tuple of length equal to <code>geometry.shape.get_size(dimension)</code></dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="phi.geom.GeometryException"><code class="flex name class">
<span>class <span class="ident">GeometryException</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Raised when an operation is fundamentally not possible for a <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.
Possible causes:</p>
<ul>
<li>Trying to get the interior of a non-surface <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></li>
<li>Trying to get the surface of a point-like <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GeometryException(BaseException):
    &#34;&#34;&#34;
    Raised when an operation is fundamentally not possible for a `Geometry`.
    Possible causes:

    * Trying to get the interior of a non-surface `Geometry`
    * Trying to get the surface of a point-like `Geometry`
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="phi.geom.Graph"><code class="flex name class">
<span>class <span class="ident">Graph</span></span>
<span>(</span><span>nodes: Union[phiml.math._tensors.Tensor, phi.geom._geom.Geometry], edges: phiml.math._tensors.Tensor, boundary: Dict[str, Dict[str, slice]], deltas=None, distances=None, bounding_distance: Union[bool, phiml.math._tensors.Tensor, float, ForwardRef(None)] = False)</span>
</code></dt>
<dd>
<div class="desc"><p>A graph consists of multiple geometry nodes and corresponding edge information.</p>
<p>Edges are stored as a Tensor with the same axes ad <code>geometry</code> plus their dual counterparts.
Additional dimensions can be added to <code>edges</code> to store vector-valued connectivity weights.</p>
<p>Create a graph where <code>nodes</code> are connected by <code>edges</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>nodes</code></strong></dt>
<dd><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> collection or <code>Tensor</code> to denote points.</dd>
<dt><strong><code>edges</code></strong></dt>
<dd>Edge weight matrix. Must have the instance and spatial dims of <code>nodes</code> plus their dual counterparts.</dd>
<dt><strong><code>boundary</code></strong></dt>
<dd>Marks ranges of nodes as boundary elements.</dd>
<dt><strong><code>deltas</code></strong></dt>
<dd>(Optional) Pre-computed position difference matrix.</dd>
<dt><strong><code>distances</code></strong></dt>
<dd>(Optional) Pre-computed distance matrix.</dd>
<dt><strong><code>bounding_distance</code></strong></dt>
<dd>(Optional) Pre-computed distance bounds. No distance is larger than this value. If <code>True</code>, will be computed now, if <code>False</code>, will not be computed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Graph(Geometry):
    &#34;&#34;&#34;
    A graph consists of multiple geometry nodes and corresponding edge information.

    Edges are stored as a Tensor with the same axes ad `geometry` plus their dual counterparts.
    Additional dimensions can be added to `edges` to store vector-valued connectivity weights.
    &#34;&#34;&#34;

    def __init__(self,
                 nodes: Union[Geometry, Tensor],
                 edges: Tensor,
                 boundary: Dict[str, Dict[str, slice]],
                 deltas=None, distances=None, bounding_distance: Union[bool, Tensor, float, None] = False):
        &#34;&#34;&#34;
        Create a graph where `nodes` are connected by `edges`.

        Args:
            nodes: `Geometry` collection or `Tensor` to denote points.
            edges: Edge weight matrix. Must have the instance and spatial dims of `nodes` plus their dual counterparts.
            boundary: Marks ranges of nodes as boundary elements.
            deltas: (Optional) Pre-computed position difference matrix.
            distances: (Optional) Pre-computed distance matrix.
            bounding_distance: (Optional) Pre-computed distance bounds. No distance is larger than this value. If `True`, will be computed now, if `False`, will not be computed.
        &#34;&#34;&#34;
        if isinstance(nodes, Tensor):
            assert &#39;vector&#39; in channel(nodes) and channel(nodes).get_item_names(&#39;vector&#39;) is not None, f&#34;nodes must have a &#39;vector&#39; dim listing the physical dimensions but got {shape(nodes)}&#34;
        node_dims = non_batch(nodes).non_channel
        assert node_dims in edges.shape and edges.shape.dual.rank == node_dims.rank, f&#34;edges must contain all node dims {node_dims} as primal and dual but got {edges.shape}&#34;
        self._nodes: Geometry = nodes if isinstance(nodes, Geometry) else Point(nodes)
        self._edges = edges
        self._boundary = boundary
        self._deltas = math.pairwise_distances(self._nodes.center, format=edges) if deltas is None else deltas
        self._distances = math.vec_length(self._deltas) if distances is None else distances
        self._connectivity = math.tensor_like(edges, 1) if math.is_sparse(edges) else (edges != 0) &amp; ~math.is_nan(edges)
        if isinstance(bounding_distance, bool):
            self._bounding_distance = math.max(self._distances) if bounding_distance else None
        else:
            self._bounding_distance = bounding_distance

    def __variable_attrs__(self):
        return &#39;_nodes&#39;, &#39;_edges&#39;, &#39;_deltas&#39;, &#39;_distances&#39;, &#39;_connectivity&#39;

    def __value_attrs__(self):
        return &#39;_nodes&#39;,

    @property
    def edges(self):
        return self._edges

    @property
    def connectivity(self) -&gt; Tensor:
        return self._connectivity

    @property
    def nodes(self) -&gt; Geometry:
        return self._nodes

    def as_points(self):
        return Graph(self._nodes.center, self._edges, self._boundary, self._deltas, self._distances, self._bounding_distance)

    @property
    def deltas(self):
        return self._deltas

    @property
    def unit_deltas(self):
        return math.safe_div(self._deltas, self._distances)

    @property
    def distances(self):
        return self._distances

    @property
    def bounding_distance(self) -&gt; Optional[Tensor]:
        return self._bounding_distance

    @property
    def center(self) -&gt; Tensor:
        return self._nodes.center

    @property
    def shape(self) -&gt; Shape:
        return self._nodes.shape

    @property
    def volume(self) -&gt; Tensor:
        return self._nodes.volume

    @property
    def faces(self) -&gt; &#39;Geometry&#39;:
        raise NotImplementedError

    @property
    def face_centers(self) -&gt; Tensor:
        raise NotImplementedError

    @property
    def face_areas(self) -&gt; Tensor:
        raise NotImplementedError

    @property
    def face_normals(self) -&gt; Tensor:
        raise NotImplementedError

    @property
    def boundary_elements(self) -&gt; Dict[str, Dict[str, slice]]:
        return self._boundary

    @property
    def boundary_faces(self) -&gt; Dict[Any, Dict[str, slice]]:
        raise NotImplementedError  # connections between boundary elements

    @property
    def face_shape(self) -&gt; Shape:
        return non_batch(self._edges).non_channel

    def lies_inside(self, location: Tensor) -&gt; Tensor:
        raise NotImplementedError

    def approximate_closest_surface(self, location: Tensor) -&gt; Tuple[Tensor, Tensor, Tensor, Tensor, Tensor]:
        raise NotImplementedError

    def approximate_signed_distance(self, location: Tensor) -&gt; Tensor:
        raise NotImplementedError

    def sample_uniform(self, *shape: math.Shape) -&gt; Tensor:
        raise NotImplementedError

    def bounding_radius(self) -&gt; Tensor:
        return self._nodes.bounding_radius()

    def bounding_half_extent(self) -&gt; Tensor:
        return self._nodes.bounding_half_extent()

    def at(self, center: Tensor) -&gt; &#39;Geometry&#39;:
        raise NotImplementedError(&#34;Changing the node positions of a Graph is not supported as it would invalidate distances.&#34;)
        # warnings.warn(&#34;Changing the node positions of a graph triggers re-evaluation of distances.&#34;, RuntimeWarning, stacklevel=2)
        # return Graph(self.nodes.at(center), self._edges, self._boundary, bounding_distance=self._bounding_distance is not None)

    def shifted(self, delta: Tensor) -&gt; &#39;Geometry&#39;:
        if non_batch(delta).non_channel.only(self._nodes.shape):  # shift varies between
            raise NotImplementedError(&#34;Shifting the node positions of a Graph is not supported as it would invalidate distances.&#34;)
        return Graph(self.nodes.shifted(delta), self._edges, self._boundary, deltas=self._deltas, distances=self._distances, bounding_distance=self._bounding_distance is not None)

    def rotated(self, angle: Union[float, Tensor]) -&gt; &#39;Geometry&#39;:
        raise NotImplementedError

    def scaled(self, factor: Union[float, Tensor]) -&gt; &#39;Geometry&#39;:
        raise NotImplementedError

    def __getitem__(self, item):
        item = slicing_dict(self, item)
        node_dims = non_batch(self._nodes).non_channel
        edge_sel = {}
        for i, (dim, sel) in enumerate(item.items()):
            if dim in node_dims:
                dual_dim = &#39;~&#39; + dim
                if dual_dim not in self._edges.shape:
                    dual_dim = dual(self._edges).shape.names[i]
                edge_sel[dim] = edge_sel[dual_dim] = sel
            elif dim in batch(self):
                edge_sel[dim] = sel
        return Graph(self._nodes[item], self._edges[edge_sel], self._boundary)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.geom._geom.Geometry</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="phi.geom.Graph.boundary_elements"><code class="name">prop <span class="ident">boundary_elements</span> : Dict[str, Dict[str, slice]]</code></dt>
<dd>
<div class="desc"><p>Slices on the primal dimensions to mark boundary elements.
Grids and meshes have no boundary elements and return <code>{}</code>.
Dynamic graphs can define boundary elements for obstacles and walls.</p>
<h2 id="returns">Returns</h2>
<p>Map from <code>(name, is_upper)</code> to slicing <code>dict</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def boundary_elements(self) -&gt; Dict[str, Dict[str, slice]]:
    return self._boundary</code></pre>
</details>
</dd>
<dt id="phi.geom.Graph.boundary_faces"><code class="name">prop <span class="ident">boundary_faces</span> : Dict[Any, Dict[str, slice]]</code></dt>
<dd>
<div class="desc"><p>Slices on the dual dimensions to mark boundary faces.</p>
<p>Regular grids use the keys (dim, is_upper) to identify boundaries.
Unstructured meshes use string identifiers for the boundaries.
Dynamic graphs return slices along the dual dimensions.</p>
<h2 id="returns">Returns</h2>
<p>Map from <code>(name, is_upper)</code> to slicing <code>dict</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def boundary_faces(self) -&gt; Dict[Any, Dict[str, slice]]:
    raise NotImplementedError  # connections between boundary elements</code></pre>
</details>
</dd>
<dt id="phi.geom.Graph.bounding_distance"><code class="name">prop <span class="ident">bounding_distance</span> : Optional[phiml.math._tensors.Tensor]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bounding_distance(self) -&gt; Optional[Tensor]:
    return self._bounding_distance</code></pre>
</details>
</dd>
<dt id="phi.geom.Graph.center"><code class="name">prop <span class="ident">center</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p>Center location in single channel dimension.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def center(self) -&gt; Tensor:
    return self._nodes.center</code></pre>
</details>
</dd>
<dt id="phi.geom.Graph.connectivity"><code class="name">prop <span class="ident">connectivity</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def connectivity(self) -&gt; Tensor:
    return self._connectivity</code></pre>
</details>
</dd>
<dt id="phi.geom.Graph.deltas"><code class="name">prop <span class="ident">deltas</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def deltas(self):
    return self._deltas</code></pre>
</details>
</dd>
<dt id="phi.geom.Graph.distances"><code class="name">prop <span class="ident">distances</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def distances(self):
    return self._distances</code></pre>
</details>
</dd>
<dt id="phi.geom.Graph.edges"><code class="name">prop <span class="ident">edges</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def edges(self):
    return self._edges</code></pre>
</details>
</dd>
<dt id="phi.geom.Graph.face_areas"><code class="name">prop <span class="ident">face_areas</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p>Area of face connecting a pair of cells. Shape <code>(elements, ~)</code>.
Returns 0 for unconnected cells.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_areas(self) -&gt; Tensor:
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="phi.geom.Graph.face_centers"><code class="name">prop <span class="ident">face_centers</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p>Center of face connecting a pair of cells. Shape <code>(elements, ~, vector)</code>.
Here, <code>~</code> represents arbitrary internal dual dimensions, such as <code>~staggered_direction</code> or <code>~elements</code>.
Returns 0-vectors for unconnected cells.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_centers(self) -&gt; Tensor:
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="phi.geom.Graph.face_normals"><code class="name">prop <span class="ident">face_normals</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p>Normal vectors of cell faces, including boundary faces. Shape <code>(elements, ~, vector)</code>.
For meshes, The vectors point out of the primal cells and into the dual cells.</p>
<p>Instance/spatial dimensions along which the normal does not vary may not be included in the result tensor's shape.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_normals(self) -&gt; Tensor:
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="phi.geom.Graph.face_shape"><code class="name">prop <span class="ident">face_shape</span> : phiml.math._shape.Shape</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<p>Full Shape to identify each face of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>, including instance/spatial dimensions for the elements and dual dimensions listing the faces per element.
If this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> has no faces, returns an empty <code>Shape</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_shape(self) -&gt; Shape:
    return non_batch(self._edges).non_channel</code></pre>
</details>
</dd>
<dt id="phi.geom.Graph.faces"><code class="name">prop <span class="ident">faces</span> : <a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def faces(self) -&gt; &#39;Geometry&#39;:
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="phi.geom.Graph.nodes"><code class="name">prop <span class="ident">nodes</span> : phi.geom._geom.Geometry</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def nodes(self) -&gt; Geometry:
    return self._nodes</code></pre>
</details>
</dd>
<dt id="phi.geom.Graph.shape"><code class="name">prop <span class="ident">shape</span> : phiml.math._shape.Shape</code></dt>
<dd>
<div class="desc"><p>The <code>shape</code> of a <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> consists of the following dimensions:</p>
<ul>
<li>A single <em>channel</em> dimension called <code>'vector'</code> specifying the physical space</li>
<li>Instance dimensions denote that this geometry consists of multiple copies in the same space</li>
<li>Spatial dimensions denote a crystal (repeating structure) of this geometric primitive in space</li>
<li>Batch dimensions indicate non-interacting versions of this geometry for parallelization only.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape(self) -&gt; Shape:
    return self._nodes.shape</code></pre>
</details>
</dd>
<dt id="phi.geom.Graph.unit_deltas"><code class="name">prop <span class="ident">unit_deltas</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def unit_deltas(self):
    return math.safe_div(self._deltas, self._distances)</code></pre>
</details>
</dd>
<dt id="phi.geom.Graph.volume"><code class="name">prop <span class="ident">volume</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p><code>phi.math.Tensor</code> representing the volume of each element.
The result retains batch, spatial and instance dimensions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def volume(self) -&gt; Tensor:
    return self._nodes.volume</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phi.geom.Graph.approximate_closest_surface"><code class="name flex">
<span>def <span class="ident">approximate_closest_surface</span></span>(<span>self, location: phiml.math._tensors.Tensor) ‑> Tuple[phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor]</span>
</code></dt>
<dd>
<div class="desc"><p>Find the closest surface face of this geometry given a point that can be outside or inside the geometry.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd><code>Tensor</code> with a single channel dimension called vector. Can have arbitrary other dimensions.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>signed_distance</code></dt>
<dd>Scalar signed distance from <code>location</code>
to the closest point on the surface.
Positive values indicate the point lies outside the geometry, negative values indicate the point lies inside the geometry.</dd>
<dt><code>delta</code></dt>
<dd>Vector-valued distance vector from <code>location</code> to the closest point on the surface.</dd>
<dt><code>normal</code></dt>
<dd>Closest surface normal vector.</dd>
<dt><code>offset</code></dt>
<dd>Min distance of a surface-tangential plane from 0 as a scalar.</dd>
<dt><code>face_index</code></dt>
<dd>(Optional) An index vector pointing at the closest face.</dd>
</dl></div>
</dd>
<dt id="phi.geom.Graph.approximate_signed_distance"><code class="name flex">
<span>def <span class="ident">approximate_signed_distance</span></span>(<span>self, location: phiml.math._tensors.Tensor) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the approximate distance from location to the surface of the geometry.
Locations outside return positive values, inside negative values and zero exactly at the boundary.</p>
<p>The exact distance metric used depends on the geometry.
The approximation holds close to the surface and the distance grows to infinity as the location is moved infinitely far from the geometry.
The distance metric is differentiable and its gradients are bounded at every point in space.</p>
<p>When dealing with unions or collections of geometries (instance dimensions), the shortest distance to any instance is returned.
This also holds for negative distances.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd><code>Tensor</code> with one channel dim <code>vector</code> matching the geometry's <code>vector</code> dim.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Float <code>Tensor</code></p></div>
</dd>
<dt id="phi.geom.Graph.as_points"><code class="name flex">
<span>def <span class="ident">as_points</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Graph.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>self, center: phiml.math._tensors.Tensor) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a copy of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> with the center at <code>center</code>.
This is equal to calling <code>self @ center</code>.</p>
<p>See Also:
<code><a title="phi.geom.Geometry.shifted" href="#phi.geom.Geometry.shifted">Geometry.shifted()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>center</code></strong></dt>
<dd>New center as <code>Tensor</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.</p></div>
</dd>
<dt id="phi.geom.Graph.bounding_half_extent"><code class="name flex">
<span>def <span class="ident">bounding_half_extent</span></span>(<span>self) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>The bounding half-extent sets a limit on the outer-most point for each coordinate axis.
Each component is non-negative.</p>
<p>Let the bounding half-extent have value <code>e</code> in dimension <code>d</code> (<code>extent[...,d] = e</code>).
Then, no point of the geometry lies further away from its center point than <code>e</code> along <code>d</code> (in both axis directions).</p>
<p>When this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.
If these dims are not present, all parts are assumed to have the same bounds.</p></div>
</dd>
<dt id="phi.geom.Graph.bounding_radius"><code class="name flex">
<span>def <span class="ident">bounding_radius</span></span>(<span>self) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the radius of a Sphere object that fully encloses this geometry.
The sphere is centered at the center of this geometry.</p>
<p>:return: radius of type float</p>
<p>Args:</p>
<p>Returns:</p></div>
</dd>
<dt id="phi.geom.Graph.lies_inside"><code class="name flex">
<span>def <span class="ident">lies_inside</span></span>(<span>self, location: phiml.math._tensors.Tensor) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Tests whether the given location lies inside or outside of the geometry. Locations on the surface count as inside.</p>
<p>When dealing with unions or collections of geometries (instance dimensions), a point lies inside the geometry if it lies inside any instance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd>float tensor of shape (batch_size, &hellip;, rank)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>bool tensor of shape (*location.shape[:-1], 1).</p></div>
</dd>
<dt id="phi.geom.Graph.rotated"><code class="name flex">
<span>def <span class="ident">rotated</span></span>(<span>self, angle: Union[phiml.math._tensors.Tensor, float]) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a rotated version of this geometry.
The geometry is rotated about its center point.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>angle</code></strong></dt>
<dd>
<p>Delta rotation.
Either</p>
<ul>
<li>Angle(s): scalar angle in 2d or euler angles along <code>vector</code> in 3D or higher.</li>
<li>Matrix: d⨯d rotation matrix</li>
</ul>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Rotated <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></p></div>
</dd>
<dt id="phi.geom.Graph.sample_uniform"><code class="name flex">
<span>def <span class="ident">sample_uniform</span></span>(<span>self, *shape: phiml.math._shape.Shape) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Samples uniformly distributed random points inside this volume.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*shape</code></strong></dt>
<dd>How many points to sample per individual geometry.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>Tensor</code> containing all dimensions from <code><a title="phi.geom.Geometry.shape" href="#phi.geom.Geometry.shape">Geometry.shape</a></code>, <code>shape</code> as well as a <code>channel</code> dimension <code>vector</code> matching the dimensionality of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.</p></div>
</dd>
<dt id="phi.geom.Graph.scaled"><code class="name flex">
<span>def <span class="ident">scaled</span></span>(<span>self, factor: Union[phiml.math._tensors.Tensor, float]) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<div class="desc"><p>Scales each individual geometry by <code>factor</code>.
The individual <code>center</code> points act as pivots for the operation.</p>
<h2 id="args">Args</h2>
<p>factor:
Returns:</p></div>
</dd>
<dt id="phi.geom.Graph.shifted"><code class="name flex">
<span>def <span class="ident">shifted</span></span>(<span>self, delta: phiml.math._tensors.Tensor) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a translated version of this geometry.</p>
<p>See Also:
<code><a title="phi.geom.Geometry.at" href="#phi.geom.Geometry.at">Geometry.at()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>delta</code></strong></dt>
<dd>direction vector</dd>
<dt><strong><code>delta</code></strong></dt>
<dd>Tensor:</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></dt>
<dd>shifted geometry</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="phi.geom.Heightmap"><code class="flex name class">
<span>class <span class="ident">Heightmap</span></span>
<span>(</span><span>height: phiml.math._tensors.Tensor, bounds: phi.geom._box.Box, max_dist: Union[phiml.math._tensors.Tensor, float], fill_below: Union[bool, phiml.math._tensors.Tensor] = True, extrapolation: Union[float, str, phiml.math.extrapolation.Extrapolation] = None, faces=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Abstract base class for N-dimensional shapes.</p>
<p>Main implementing classes:</p>
<ul>
<li>Sphere</li>
<li>box family: box (generator), Box, Cuboid, BaseBox</li>
</ul>
<p>All geometry objects support batching.
Thereby any parameter defining the geometry can be varied along arbitrary batch dims.
All batch dimensions are listed in Geometry.shape.</p>
<p>Property getters (<code>@property</code>, such as <code>shape</code>), save for getters, must not depend on any variables marked as <em>variable</em> via <code>__variable_attrs__()</code> as these may be <code>None</code> during tracing.
Equality checks must also take this into account.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>height</code></strong></dt>
<dd>Heightmap <code>Tensor</code> of absolute (world-space) height values.
Scalar height values on a d-1 dimensional grid.</dd>
<dt><strong><code>bounds</code></strong></dt>
<dd>d-dimensional bounds.
Locations outside <code>bounds' can never lie inside this geometry if</code>extrapolation is None`.
Otherwise, only the height dimension is checked.
The grid dimensions of <code>bounds</code> must be finite but the height dimension may be infinite to count all values above/below <code>height</code> as inside.</dd>
<dt><strong><code>max_dist</code></strong></dt>
<dd>Maximum distance up to which the distance approximations should be valid.
This does not affect the number of computations performed to compute the distance.
Low values increase accuracy close to the surface but trade off possibly very wrong distances further away.</dd>
<dt><strong><code>fill_below</code></strong></dt>
<dd>Whether the inside is below or above the height values.</dd>
<dt><strong><code>extrapolation</code></strong></dt>
<dd>Surface height outside <code>bounds´. Can be any valid</code>phiml.math.Extrapolation`, such as a constant.
If not <code>None</code>, values outside <code>bounds</code> will be checked against the extrapolated <code>height</code> values.
Otherwise, values outside <code>bounds</code> always lie on the outside.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Heightmap(Geometry):

    def __init__(self,
                 height: Tensor,
                 bounds: Box,
                 max_dist: Union[float, Tensor],
                 fill_below: Union[bool, Tensor] = True,
                 extrapolation: Union[float, str, math.Extrapolation] = None,
                 faces=None):
        &#34;&#34;&#34;

        Args:
            height: Heightmap `Tensor` of absolute (world-space) height values.
                Scalar height values on a d-1 dimensional grid.
            bounds: d-dimensional bounds.
                Locations outside `bounds&#39; can never lie inside this geometry if `extrapolation is None`.
                Otherwise, only the height dimension is checked.
                The grid dimensions of `bounds` must be finite but the height dimension may be infinite to count all values above/below `height` as inside.
            max_dist: Maximum distance up to which the distance approximations should be valid.
                This does not affect the number of computations performed to compute the distance.
                Low values increase accuracy close to the surface but trade off possibly very wrong distances further away.
            fill_below: Whether the inside is below or above the height values.
            extrapolation: Surface height outside `bounds´. Can be any valid `phiml.math.Extrapolation`, such as a constant.
                If not `None`, values outside `bounds` will be checked against the extrapolated `height` values.
                Otherwise, values outside `bounds` always lie on the outside.
        &#34;&#34;&#34;
        assert channel(height).is_empty, f&#34;height must be a scalar quantity but got {height.shape}&#34;
        assert spatial(height), f&#34;height field must have at least one spatial dim but got {height}&#34;
        assert bounds.vector.size == spatial(height).rank + 1, f&#34;bounds must include the spatial grid dimensions {spatial(height)} and the height dimension but got {bounds}&#34;
        dims = bounds.vector.item_names
        self._hdim = spatial(*dims).without(height.shape).name
        if math.all_available(height, bounds.lower, bounds.upper):
            assert bounds[self._hdim].lies_inside(height).all, f&#34;All height values should be within the {self._hdim}-range given by bounds but got height={height}&#34;
        self._height = height
        self._fill_below = wrap(fill_below)
        self._bounds = bounds
        self._max_dist = wrap(max_dist)
        self._extrapolation = math.as_extrapolation(extrapolation)
        if faces is None:
            proj_faces = build_faces(self)
            with numpy.errstate(divide=&#39;ignore&#39;, invalid=&#39;ignore&#39;):
                secondary_idx = math.map(find_most_important_neighbor, proj_faces, self.dx, self.resolution, self._hdim, self._fill_below, self._max_dist, dims=instance, unwrap_scalars=False)
                secondary_faces = math.map(math.gather, proj_faces, secondary_idx, dims=instance)
            self._faces: Face = stack([proj_faces, *unstack(secondary_faces, &#39;side&#39;)], batch(consider=&#39;self,outside,inside&#39;), expand_values=True)
            self._faces = cached(self._faces)  # otherwise, this may get expanded during tracing
        else:
            self._faces = faces

    @property
    def height(self):
        return self._height

    @property
    def bounds(self):
        return self._bounds

    @property
    def max_dist(self):
        return self._max_dist

    @property
    def fill_below(self):
        return self._fill_below

    @property
    def extrapolation(self):
        return self._extrapolation

    @property
    def shape(self) -&gt; Shape:
        return self._height.shape &amp; channel(self._bounds)

    @property
    def resolution(self):
        return spatial(self._height) - 1

    @property
    def grid_bounds(self):
        return self._bounds[self.resolution.name_list]

    @property
    def up(self):
        dims = self._bounds.vector.item_names
        height_unit = vec(**{d: 1 if d == self._hdim else 0 for d in dims})
        return math.where(self._fill_below, height_unit, -height_unit)

    @property
    def dx(self):
        return self._bounds.size[self.resolution.name_list] / spatial(self.resolution)

    @property
    def vertices(self):
        hdim = self._hdim
        space = self.vector.item_names
        pos = self.grid_bounds.local_to_global(math.meshgrid(spatial(self._height)) / self.resolution)
        vert = stack({dim: self.height if dim == hdim else pos[dim] for dim in space}, channel(&#39;vector&#39;))
        return vert

    def lies_inside(self, location: Tensor) -&gt; Tensor:
        location = rename_dims(location, self.resolution.names, [&#39;loc_&#39; + n for n in self.resolution.names])
        projected_loc = location[self.resolution.name_list]
        @math.map_i2b
        def lies_inside_(height, grid_bounds, bounds, fill_below, extrapolation):
            float_idx = (projected_loc - grid_bounds.lower) / grid_bounds.size * self.resolution
            if extrapolation is None:
                within_bounds = bounds.lies_inside(location)
            else:
                within_bounds = bounds[self._hdim].lies_inside(location[self._hdim])
            surface_height = math.grid_sample(height, float_idx - 1, math.NAN if extrapolation is None else extrapolation)
            is_below = location[self._hdim] &lt;= surface_height
            inside = is_below == fill_below
            result = math.where(within_bounds, inside, False)
            return rename_dims(result, [&#39;loc_&#39; + n for n in self.resolution.names], self.resolution.names)
        return math.any(lies_inside_(self._height, self.grid_bounds, self._bounds, self._fill_below, self._extrapolation), instance(self))

    def approximate_closest_surface(self, location: Tensor) -&gt; Tuple[Tensor, Tensor, Tensor, Tensor, Tensor]:
        grid_bounds = math.i2b(self.grid_bounds)
        faces = math.i2b(self._faces)
        cell_idx = cell_index(location, grid_bounds, self.resolution, clip=True)
        # --- gather face infos at projected cell ---
        normals = faces.normal[cell_idx]
        offsets = faces.origin_distance[cell_idx]
        face_idx = faces.index[cell_idx]
        # --- test location against all considered faces and boundaries ---
        distances = normals.vector @ location.vector + offsets
        projected_onto_face = location - normals * distances
        projected_idx = cell_index(projected_onto_face, grid_bounds, self.resolution, clip=False)
        projects_onto_face = math.all(projected_idx == face_idx, channel)
        proj_delta = normals * -distances
        # --- if not projected onto face, use distance to highest point instead ---
        delta_highest = faces.extrema_points[cell_idx] - location
        flat_normal = math.vec_normalize(normals[self.resolution.name_list], epsilon=1e-5)
        delta_edge = flat_normal * (delta_highest[self.resolution].vector @ flat_normal.vector)  # project onto flat normal
        delta_edge = concat([delta_edge, delta_highest[[self._hdim]]], &#39;vector&#39;)
        distance_edge = math.vec_length(delta_edge, eps=1e-5)
        delta_highest, distance_edge = math.at_min((delta_highest, distance_edge), distance_edge, &#39;extremum&#39;)
        distance_edge = math.where(distances &lt; 0, -distance_edge, distance_edge)  # copy sign of distances onto distance_edges to always return the signed distance
        distances = math.where(projects_onto_face, distances, distance_edge)
        # --- use closest face from considered ---
        delta = math.where(projects_onto_face, proj_delta, delta_highest)
        return math.at_min((distances, delta, normals, offsets, face_idx), key=abs(distances), dim=batch(&#39;consider&#39;) &amp; instance(self).as_batch())

    def shallow_equals(self, other):
        return self == other

    def __repr__(self):
        return f&#34;Heightmap {self.resolution}, bounds={self._bounds}&#34;

    def __variable_attrs__(self):
        return &#39;_height&#39;, &#39;_bounds&#39;, &#39;_max_dist&#39;, &#39;_fill_below&#39;, &#39;_extrapolation&#39;, &#39;_faces&#39;

    def __value_attrs__(self):
        return ()

    def __getitem__(self, item):
        item = slicing_dict(self, item)
        return Heightmap(self._height[item], self._bounds[item], self._max_dist[item], self._fill_below[item], self._extrapolation[item] if self._extrapolation is not None else None, math.slice(self._faces, item))

    def bounding_half_extent(self) -&gt; Tensor:
        h_min, h_max = self._faces.extrema_points[{&#39;consider&#39;: 0, &#39;vector&#39;: self._hdim}].extremum
        dh = h_max - h_min
        return stack({d: self.dx[d] if d in self.resolution else dh for d in self.vector.item_names}, channel(&#39;vector&#39;), expand_values=True) * .5

    @property
    def center(self) -&gt; Tensor:
        return self._faces.center.consider[0]

    @property
    def volume(self) -&gt; Tensor:
        return math.prod(self.bounding_half_extent() * 2, channel)

    @property
    def faces(self) -&gt; &#39;Geometry&#39;:
        raise NotImplementedError

    @property
    def face_centers(self) -&gt; Tensor:
        return self._faces.center

    @property
    def face_areas(self) -&gt; Tensor:
        raise NotImplementedError

    @property
    def face_normals(self) -&gt; Tensor:
        return self._faces.normal

    @property
    def boundary_elements(self) -&gt; Dict[Any, Dict[str, slice]]:
        return {}

    @property
    def boundary_faces(self) -&gt; Dict[Any, Dict[str, slice]]:
        return {}

    @property
    def face_shape(self) -&gt; Shape:
        return non_channel(self._faces.center)

    def approximate_signed_distance(self, location: Tensor) -&gt; Tensor:
        return self.approximate_closest_surface(location)[0]

    def sample_uniform(self, *shape: math.Shape) -&gt; Tensor:
        raise NotImplementedError

    def bounding_radius(self) -&gt; Tensor:
        return self._bounds.bounding_radius()

    def at(self, center: Tensor) -&gt; &#39;Geometry&#39;:
        raise NotImplementedError

    def rotated(self, angle: Union[float, Tensor]) -&gt; &#39;Geometry&#39;:
        raise NotImplementedError

    def scaled(self, factor: Union[float, Tensor]) -&gt; &#39;Geometry&#39;:
        raise NotImplementedError</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.geom._geom.Geometry</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="phi.geom.Heightmap.boundary_elements"><code class="name">prop <span class="ident">boundary_elements</span> : Dict[Any, Dict[str, slice]]</code></dt>
<dd>
<div class="desc"><p>Slices on the primal dimensions to mark boundary elements.
Grids and meshes have no boundary elements and return <code>{}</code>.
Dynamic graphs can define boundary elements for obstacles and walls.</p>
<h2 id="returns">Returns</h2>
<p>Map from <code>(name, is_upper)</code> to slicing <code>dict</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def boundary_elements(self) -&gt; Dict[Any, Dict[str, slice]]:
    return {}</code></pre>
</details>
</dd>
<dt id="phi.geom.Heightmap.boundary_faces"><code class="name">prop <span class="ident">boundary_faces</span> : Dict[Any, Dict[str, slice]]</code></dt>
<dd>
<div class="desc"><p>Slices on the dual dimensions to mark boundary faces.</p>
<p>Regular grids use the keys (dim, is_upper) to identify boundaries.
Unstructured meshes use string identifiers for the boundaries.
Dynamic graphs return slices along the dual dimensions.</p>
<h2 id="returns">Returns</h2>
<p>Map from <code>(name, is_upper)</code> to slicing <code>dict</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def boundary_faces(self) -&gt; Dict[Any, Dict[str, slice]]:
    return {}</code></pre>
</details>
</dd>
<dt id="phi.geom.Heightmap.bounds"><code class="name">prop <span class="ident">bounds</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bounds(self):
    return self._bounds</code></pre>
</details>
</dd>
<dt id="phi.geom.Heightmap.center"><code class="name">prop <span class="ident">center</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p>Center location in single channel dimension.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def center(self) -&gt; Tensor:
    return self._faces.center.consider[0]</code></pre>
</details>
</dd>
<dt id="phi.geom.Heightmap.dx"><code class="name">prop <span class="ident">dx</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def dx(self):
    return self._bounds.size[self.resolution.name_list] / spatial(self.resolution)</code></pre>
</details>
</dd>
<dt id="phi.geom.Heightmap.extrapolation"><code class="name">prop <span class="ident">extrapolation</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def extrapolation(self):
    return self._extrapolation</code></pre>
</details>
</dd>
<dt id="phi.geom.Heightmap.face_areas"><code class="name">prop <span class="ident">face_areas</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p>Area of face connecting a pair of cells. Shape <code>(elements, ~)</code>.
Returns 0 for unconnected cells.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_areas(self) -&gt; Tensor:
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="phi.geom.Heightmap.face_centers"><code class="name">prop <span class="ident">face_centers</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p>Center of face connecting a pair of cells. Shape <code>(elements, ~, vector)</code>.
Here, <code>~</code> represents arbitrary internal dual dimensions, such as <code>~staggered_direction</code> or <code>~elements</code>.
Returns 0-vectors for unconnected cells.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_centers(self) -&gt; Tensor:
    return self._faces.center</code></pre>
</details>
</dd>
<dt id="phi.geom.Heightmap.face_normals"><code class="name">prop <span class="ident">face_normals</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p>Normal vectors of cell faces, including boundary faces. Shape <code>(elements, ~, vector)</code>.
For meshes, The vectors point out of the primal cells and into the dual cells.</p>
<p>Instance/spatial dimensions along which the normal does not vary may not be included in the result tensor's shape.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_normals(self) -&gt; Tensor:
    return self._faces.normal</code></pre>
</details>
</dd>
<dt id="phi.geom.Heightmap.face_shape"><code class="name">prop <span class="ident">face_shape</span> : phiml.math._shape.Shape</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<p>Full Shape to identify each face of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>, including instance/spatial dimensions for the elements and dual dimensions listing the faces per element.
If this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> has no faces, returns an empty <code>Shape</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_shape(self) -&gt; Shape:
    return non_channel(self._faces.center)</code></pre>
</details>
</dd>
<dt id="phi.geom.Heightmap.faces"><code class="name">prop <span class="ident">faces</span> : <a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def faces(self) -&gt; &#39;Geometry&#39;:
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="phi.geom.Heightmap.fill_below"><code class="name">prop <span class="ident">fill_below</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def fill_below(self):
    return self._fill_below</code></pre>
</details>
</dd>
<dt id="phi.geom.Heightmap.grid_bounds"><code class="name">prop <span class="ident">grid_bounds</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def grid_bounds(self):
    return self._bounds[self.resolution.name_list]</code></pre>
</details>
</dd>
<dt id="phi.geom.Heightmap.height"><code class="name">prop <span class="ident">height</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def height(self):
    return self._height</code></pre>
</details>
</dd>
<dt id="phi.geom.Heightmap.max_dist"><code class="name">prop <span class="ident">max_dist</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def max_dist(self):
    return self._max_dist</code></pre>
</details>
</dd>
<dt id="phi.geom.Heightmap.resolution"><code class="name">prop <span class="ident">resolution</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def resolution(self):
    return spatial(self._height) - 1</code></pre>
</details>
</dd>
<dt id="phi.geom.Heightmap.shape"><code class="name">prop <span class="ident">shape</span> : phiml.math._shape.Shape</code></dt>
<dd>
<div class="desc"><p>The <code>shape</code> of a <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> consists of the following dimensions:</p>
<ul>
<li>A single <em>channel</em> dimension called <code>'vector'</code> specifying the physical space</li>
<li>Instance dimensions denote that this geometry consists of multiple copies in the same space</li>
<li>Spatial dimensions denote a crystal (repeating structure) of this geometric primitive in space</li>
<li>Batch dimensions indicate non-interacting versions of this geometry for parallelization only.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape(self) -&gt; Shape:
    return self._height.shape &amp; channel(self._bounds)</code></pre>
</details>
</dd>
<dt id="phi.geom.Heightmap.up"><code class="name">prop <span class="ident">up</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def up(self):
    dims = self._bounds.vector.item_names
    height_unit = vec(**{d: 1 if d == self._hdim else 0 for d in dims})
    return math.where(self._fill_below, height_unit, -height_unit)</code></pre>
</details>
</dd>
<dt id="phi.geom.Heightmap.vertices"><code class="name">prop <span class="ident">vertices</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def vertices(self):
    hdim = self._hdim
    space = self.vector.item_names
    pos = self.grid_bounds.local_to_global(math.meshgrid(spatial(self._height)) / self.resolution)
    vert = stack({dim: self.height if dim == hdim else pos[dim] for dim in space}, channel(&#39;vector&#39;))
    return vert</code></pre>
</details>
</dd>
<dt id="phi.geom.Heightmap.volume"><code class="name">prop <span class="ident">volume</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p><code>phi.math.Tensor</code> representing the volume of each element.
The result retains batch, spatial and instance dimensions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def volume(self) -&gt; Tensor:
    return math.prod(self.bounding_half_extent() * 2, channel)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phi.geom.Heightmap.approximate_closest_surface"><code class="name flex">
<span>def <span class="ident">approximate_closest_surface</span></span>(<span>self, location: phiml.math._tensors.Tensor) ‑> Tuple[phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor]</span>
</code></dt>
<dd>
<div class="desc"><p>Find the closest surface face of this geometry given a point that can be outside or inside the geometry.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd><code>Tensor</code> with a single channel dimension called vector. Can have arbitrary other dimensions.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>signed_distance</code></dt>
<dd>Scalar signed distance from <code>location</code>
to the closest point on the surface.
Positive values indicate the point lies outside the geometry, negative values indicate the point lies inside the geometry.</dd>
<dt><code>delta</code></dt>
<dd>Vector-valued distance vector from <code>location</code> to the closest point on the surface.</dd>
<dt><code>normal</code></dt>
<dd>Closest surface normal vector.</dd>
<dt><code>offset</code></dt>
<dd>Min distance of a surface-tangential plane from 0 as a scalar.</dd>
<dt><code>face_index</code></dt>
<dd>(Optional) An index vector pointing at the closest face.</dd>
</dl></div>
</dd>
<dt id="phi.geom.Heightmap.approximate_signed_distance"><code class="name flex">
<span>def <span class="ident">approximate_signed_distance</span></span>(<span>self, location: phiml.math._tensors.Tensor) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the approximate distance from location to the surface of the geometry.
Locations outside return positive values, inside negative values and zero exactly at the boundary.</p>
<p>The exact distance metric used depends on the geometry.
The approximation holds close to the surface and the distance grows to infinity as the location is moved infinitely far from the geometry.
The distance metric is differentiable and its gradients are bounded at every point in space.</p>
<p>When dealing with unions or collections of geometries (instance dimensions), the shortest distance to any instance is returned.
This also holds for negative distances.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd><code>Tensor</code> with one channel dim <code>vector</code> matching the geometry's <code>vector</code> dim.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Float <code>Tensor</code></p></div>
</dd>
<dt id="phi.geom.Heightmap.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>self, center: phiml.math._tensors.Tensor) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a copy of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> with the center at <code>center</code>.
This is equal to calling <code>self @ center</code>.</p>
<p>See Also:
<code><a title="phi.geom.Geometry.shifted" href="#phi.geom.Geometry.shifted">Geometry.shifted()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>center</code></strong></dt>
<dd>New center as <code>Tensor</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.</p></div>
</dd>
<dt id="phi.geom.Heightmap.bounding_half_extent"><code class="name flex">
<span>def <span class="ident">bounding_half_extent</span></span>(<span>self) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>The bounding half-extent sets a limit on the outer-most point for each coordinate axis.
Each component is non-negative.</p>
<p>Let the bounding half-extent have value <code>e</code> in dimension <code>d</code> (<code>extent[...,d] = e</code>).
Then, no point of the geometry lies further away from its center point than <code>e</code> along <code>d</code> (in both axis directions).</p>
<p>When this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.
If these dims are not present, all parts are assumed to have the same bounds.</p></div>
</dd>
<dt id="phi.geom.Heightmap.bounding_radius"><code class="name flex">
<span>def <span class="ident">bounding_radius</span></span>(<span>self) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the radius of a Sphere object that fully encloses this geometry.
The sphere is centered at the center of this geometry.</p>
<p>:return: radius of type float</p>
<p>Args:</p>
<p>Returns:</p></div>
</dd>
<dt id="phi.geom.Heightmap.lies_inside"><code class="name flex">
<span>def <span class="ident">lies_inside</span></span>(<span>self, location: phiml.math._tensors.Tensor) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Tests whether the given location lies inside or outside of the geometry. Locations on the surface count as inside.</p>
<p>When dealing with unions or collections of geometries (instance dimensions), a point lies inside the geometry if it lies inside any instance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd>float tensor of shape (batch_size, &hellip;, rank)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>bool tensor of shape (*location.shape[:-1], 1).</p></div>
</dd>
<dt id="phi.geom.Heightmap.rotated"><code class="name flex">
<span>def <span class="ident">rotated</span></span>(<span>self, angle: Union[phiml.math._tensors.Tensor, float]) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a rotated version of this geometry.
The geometry is rotated about its center point.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>angle</code></strong></dt>
<dd>
<p>Delta rotation.
Either</p>
<ul>
<li>Angle(s): scalar angle in 2d or euler angles along <code>vector</code> in 3D or higher.</li>
<li>Matrix: d⨯d rotation matrix</li>
</ul>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Rotated <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></p></div>
</dd>
<dt id="phi.geom.Heightmap.sample_uniform"><code class="name flex">
<span>def <span class="ident">sample_uniform</span></span>(<span>self, *shape: phiml.math._shape.Shape) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Samples uniformly distributed random points inside this volume.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*shape</code></strong></dt>
<dd>How many points to sample per individual geometry.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>Tensor</code> containing all dimensions from <code><a title="phi.geom.Geometry.shape" href="#phi.geom.Geometry.shape">Geometry.shape</a></code>, <code>shape</code> as well as a <code>channel</code> dimension <code>vector</code> matching the dimensionality of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.</p></div>
</dd>
<dt id="phi.geom.Heightmap.scaled"><code class="name flex">
<span>def <span class="ident">scaled</span></span>(<span>self, factor: Union[phiml.math._tensors.Tensor, float]) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<div class="desc"><p>Scales each individual geometry by <code>factor</code>.
The individual <code>center</code> points act as pivots for the operation.</p>
<h2 id="args">Args</h2>
<p>factor:
Returns:</p></div>
</dd>
<dt id="phi.geom.Heightmap.shallow_equals"><code class="name flex">
<span>def <span class="ident">shallow_equals</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Quick equality check.
May return <code>False</code> even if <code>other == self</code>.
However, if <code>True</code> is returned, the geometries are guaranteed to be equal.</p>
<p>The <code>shallow_equals()</code> check does not compare all tensor elements but merely checks whether the same tensors are referenced.</p></div>
</dd>
</dl>
</dd>
<dt id="phi.geom.Mesh"><code class="flex name class">
<span>class <span class="ident">Mesh</span></span>
<span>(</span><span>vertices: phi.geom._graph.Graph, elements: phiml.math._tensors.Tensor, element_rank: int, boundaries: Dict[str, Dict[str, slice]], center: phiml.math._tensors.Tensor, volume: phiml.math._tensors.Tensor, face_centers: phiml.math._tensors.Tensor, face_normals: phiml.math._tensors.Tensor, face_areas: phiml.math._tensors.Tensor, face_vertices: phiml.math._tensors.Tensor, max_cell_walk: int = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Unstructured mesh.
Use <code><a title="phi.geom.mesh" href="#phi.geom.mesh">mesh()</a></code> or <code><a title="phi.geom.mesh_from_numpy" href="#phi.geom.mesh_from_numpy">mesh_from_numpy()</a></code> to construct a mesh manually or <code><a title="phi.geom.load_su2" href="#phi.geom.load_su2">load_su2()</a></code> to load one from a file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>vertices</code></strong></dt>
<dd>Vertex positions, shape (vertices:i, vector:c)
Vertex 0 must be at position 0.</dd>
<dt><strong><code>elements</code></strong></dt>
<dd>Sparse <code>Tensor</code> listing ordered vertex indices per cell. (cells, vertices).
The vertex count is equal to the number of elements per row.</dd>
<dt><strong><code>face_vertices</code></strong></dt>
<dd>(cells, ~neighbors, face_vertices)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Mesh(Geometry):
    &#34;&#34;&#34;
    Unstructured mesh.
    Use `phi.geom.mesh()` or `phi.geom.mesh_from_numpy()` to construct a mesh manually or `phi.geom.load_su2()` to load one from a file.
    &#34;&#34;&#34;

    def __init__(self,
                 vertices: Graph,
                 elements: Tensor,
                 element_rank: int,
                 boundaries: Dict[str, Dict[str, slice]],
                 center: Tensor,
                 volume: Tensor,
                 face_centers: Tensor,
                 face_normals: Tensor,
                 face_areas: Tensor,
                 face_vertices: Tensor,
                 max_cell_walk: int = None):
        &#34;&#34;&#34;
        Args:
            vertices: Vertex positions, shape (vertices:i, vector:c)
                Vertex 0 must be at position 0.
            elements: Sparse `Tensor` listing ordered vertex indices per cell. (cells, vertices).
                The vertex count is equal to the number of elements per row.
            face_vertices: (cells, ~neighbors, face_vertices)
        &#34;&#34;&#34;
        assert elements.dtype.kind == int, f&#34;elements must be integer lists but got dtype {elements.dtype}&#34;
        assert isinstance(vertices, Graph), f&#34;vertices must be a Graph&#34;
        self._vertices = vertices
        self._elements = elements
        self._element_rank = element_rank
        self._boundaries = boundaries
        self._center = center
        self._volume = volume
        self._face_centers = face_centers
        self._face_normals = face_normals
        self._face_areas = face_areas
        self._face_vertices = face_vertices
        cell_deltas = pairwise_distances(self.center, format=self.cell_connectivity, default=None)
        cell_distances = math.vec_length(cell_deltas)
        neighbors_dim = dual(face_areas)
        assert (cell_distances &gt; 0).all, f&#34;All cells must have distance &gt; 0 but found 0 distance at {math.nonzero(cell_distances == 0)}&#34;
        face_distances = math.vec_length(self.face_centers[self.interior_faces] - self.center)
        self._relative_face_distance = math.concat([face_distances / cell_distances, self.boundary_connectivity], neighbors_dim)
        boundary_deltas = (self.face_centers - self.center)[self.all_boundary_faces]
        assert (math.vec_length(boundary_deltas) &gt; 0).all, f&#34;All boundary faces must be separated from the cell centers but 0 distance at the following {channel(math.stored_indices(boundary_deltas)).item_names[0]}:\n{math.nonzero(math.vec_length(boundary_deltas) == 0):full}&#34;
        self._neighbor_offsets = math.concat([cell_deltas, boundary_deltas], neighbors_dim)
        if max_cell_walk is None:
            max_cell_walk = 2 if instance(elements).volume &gt; 1 else 1
        self._max_cell_walk = max_cell_walk

    def __variable_attrs__(self):
        return &#39;_vertices&#39;, &#39;_elements&#39;, &#39;_center&#39;, &#39;_volume&#39;, &#39;_face_centers&#39;, &#39;_face_normals&#39;, &#39;_face_areas&#39;, &#39;_face_vertices&#39;, &#39;_relative_face_distance&#39;, &#39;_neighbor_offsets&#39;

    def __value_attrs__(self):
        return &#39;_vertices&#39;,

    @property
    def shape(self) -&gt; Shape:
        return shape(self._elements).non_dual &amp; channel(self._vertices)

    @property
    def cell_count(self):
        return instance(self._elements).size

    @property
    def center(self) -&gt; Tensor:
        return self._center

    @property
    def face_centers(self) -&gt; Tensor:
        return self._face_centers

    @property
    def face_areas(self) -&gt; Tensor:
        return self._face_areas

    @property
    def face_normals(self) -&gt; Tensor:
        return self._face_normals

    @property
    def face_shape(self) -&gt; Shape:
        return self.face_areas.shape

    @property
    def boundary_elements(self) -&gt; Dict[str, Dict[str, slice]]:
        return {}

    @property
    def boundary_faces(self) -&gt; Dict[str, Dict[str, slice]]:
        return self._boundaries

    @property
    def _nb(self):
        return dual(self._face_areas)

    @property
    def all_boundary_faces(self) -&gt; Dict[str, slice]:
        return {self._nb: slice(instance(self).volume, None)}
    
    @property
    def interior_faces(self) -&gt; Dict[str, slice]:
        return {self._nb: slice(0, instance(self).volume)}

    def pad_boundary(self, value: Tensor, widths: Dict[str, Dict[str, slice]] = None, mode: Extrapolation or Tensor or Number = 0, **kwargs) -&gt; Tensor:
        mode = as_extrapolation(mode)
        if self._nb not in value.shape:
            value = math.replace_dims(value, instance, self._nb)
        else:
            raise NotImplementedError
        if widths is None:
            widths = self.boundary_faces
        if isinstance(widths, (tuple, list)):
            if len(widths) == 0 or isinstance(widths[0], dict):  # add sliced-off slices
                pass
        dim = next(iter(next(iter(widths.values()))))
        slices = [slice(0, value.shape.get_size(dim))]
        values = [value]
        connectivity = self.connectivity
        for name, b_slice in widths.items():
            if b_slice[dim].stop - b_slice[dim].start &gt; 0:
                slices.append(b_slice[dim])
                values.append(mode.sparse_pad_values(value, connectivity[b_slice], name, mesh=self, **kwargs))
        perm = np.argsort([s.start for s in slices])
        ordered_pieces = [values[i] for i in perm]
        return concat(ordered_pieces, dim, expand_values=True)

    @property
    def cell_connectivity(self) -&gt; Tensor:
        &#34;&#34;&#34;
        Returns a bool-like matrix whose non-zero entries denote connected elements.
        In meshes or grids, elements are connected if they share a face in 3D, an edge in 2D, or a vertex in 1D.

        Returns:
            `Tensor` of shape (elements, ~elements)
        &#34;&#34;&#34;
        return self.connectivity[self.interior_faces]

    @property
    def boundary_connectivity(self) -&gt; Tensor:
        return self.connectivity[self.all_boundary_faces]

    @property
    def connectivity(self) -&gt; Tensor:
        if is_sparse(self._face_areas):
            return tensor_like(self._face_areas, True)
        else:
            return self._face_areas &gt; 0

    @property
    def distance_matrix(self):
        return math.vec_length(math.pairwise_distances(self.center, edges=self.cell_connectivity, format=&#39;as edges&#39;, default=None))

    def faces_to_vertices(self, values: Tensor, reduce=sum):
        v = math.stored_values(values, invalid=&#39;keep&#39;)  # ToDo replace this once PhiML has support for dense instance dims and sparse scatter
        i = math.stored_values(self._face_vertices, invalid=&#39;keep&#39;)
        i = rename_dims(i, channel, instance)
        out_shape = non_channel(self._vertices) &amp; shape(values).without(self.face_shape)
        return math.scatter(out_shape, i, v, mode=reduce, outside_handling=&#39;undefined&#39;)

    @property
    def relative_face_distance(self):
        &#34;&#34;&#34;|face_center - center| / |neighbor_center - center|&#34;&#34;&#34;
        return self._relative_face_distance

    @property
    def neighbor_offsets(self):
        &#34;&#34;&#34;Returns shift vector to neighbor centroids and boundary faces.&#34;&#34;&#34;
        return self._neighbor_offsets

    @property
    def neighbor_distances(self):
        return vec_length(self._neighbor_offsets)

    @property
    def faces(self) -&gt; &#39;Geometry&#39;:
        &#34;&#34;&#34;
        Assembles information about the boundaries of the elements that make up the surface.
        For 2D elements, the faces are edges, for 3D elements, the faces are planar elements.

        Returns:
            center: Center of face connecting a pair of elements. Shape (~elements, elements, vector).
                Returns 0-vectors for unconnected elements.
            area: Area of face connecting a pair of elements. Shape (~elements, elements).
                Returns 0 for unconnected elements.
            normal: Normal vector of face connecting a pair of elements. Shape (~elements, elements, vector).
                Unconnected elements are assigned the vector 0.
                The vector points out of polygon and into ~polygon.
        &#34;&#34;&#34;
        return Point(self.face_centers)

    @property
    def vertices(self) -&gt; Graph:
        return self._vertices

    @property
    def elements(self):
        return self._elements

    @property
    def polygons(self):
        raise NotImplementedError  # ToDo return Tensor (elements, vertex_list:spatial)

    @property
    def volume(self) -&gt; Tensor:
        return self._volume

    @property
    def element_rank(self):
        return self._element_rank

    def lies_inside(self, location: Tensor) -&gt; Tensor:
        idx = math.find_closest(self._center, location)
        for i in range(self._max_cell_walk):
            idx, leaves_mesh, is_outside, *_ = self.cell_walk_towards(location, idx, allow_exit=i == self._max_cell_walk - 1)
        return ~(leaves_mesh &amp; is_outside)

    def approximate_signed_distance(self, location: Union[Tensor, tuple]) -&gt; Tensor:
        idx = math.find_closest(self._center, location)
        for i in range(self._max_cell_walk):
            idx, leaves_mesh, is_outside, distances, nb_idx = self.cell_walk_towards(location, idx, allow_exit=False)
        return math.max(distances, dual)

    def approximate_closest_surface(self, location: Tensor) -&gt; Tuple[Tensor, Tensor, Tensor, Tensor, Tensor]:
        # idx = math.find_closest(self._center, location)
        # for i in range(self._max_cell_walk):
        #     idx, leaves_mesh, is_outside, distances, nb_idx = self.cell_walk_towards(location, idx, allow_exit=False)
        # sgn_dist = math.max(distances, dual)
        # cell_normals = self.face_normals[idx]
        # normal = cell_normals[{dual: nb_idx}]
        # return sgn_dist, delta, normal, offset, face_index
        raise NotImplementedError

    def cell_walk_towards(self, location: Tensor, start_cell_idx: Tensor, allow_exit=False):
        &#34;&#34;&#34;
        If `location` is not within the cell at index `from_cell_idx`, moves to a closer neighbor cell.

        Args:
            location: Target location as `Tensor`.
            start_cell_idx: Index of starting cell. Must be a valid cell index.
            allow_exit: If `True`, returns an invalid index for points outside the mesh, otherwise keeps the current index.

        Returns:
            index: Index of the neighbor cell or starting cell.
            leaves_mesh: Whether the walk crossed the mesh boundary. Then `index` is invalid. This is only possible if `allow_exit` is true.
            is_outside: Whether `location` was outside the cell at index `start_cell_idx`.
        &#34;&#34;&#34;
        closest_normals = self.face_normals[start_cell_idx]
        closest_face_centers = self.face_centers[start_cell_idx]
        offsets = closest_normals.vector @ closest_face_centers.vector  # this dot product could be cashed in the mesh
        distances = closest_normals.vector @ location.vector - offsets
        is_outside = math.any(distances &gt; 0, dual)
        nb_idx = math.argmax(distances, dual).index[0]  # cell index or boundary face index
        leaves_mesh = nb_idx &gt;= instance(self).volume
        next_idx = math.where(is_outside &amp; (~leaves_mesh | allow_exit), nb_idx, start_cell_idx)
        return next_idx, leaves_mesh, is_outside, distances, nb_idx

    def sample_uniform(self, *shape: math.Shape) -&gt; Tensor:
        raise NotImplementedError

    def bounding_radius(self) -&gt; Tensor:
        center = self._elements * self.center
        vert_pos = rename_dims(self._vertices.center, instance, dual)
        dist_to_vert = math.vec_length(vert_pos - center)
        max_dist = math.max(dist_to_vert, dual)
        return max_dist

    def bounding_half_extent(self) -&gt; Tensor:
        center = self._elements * self.center
        vert_pos = rename_dims(self._vertices.center, instance, dual)
        max_delta = math.max(abs(vert_pos - center), dual)
        return max_delta

    @property
    def bounds(self):
        return Box(math.min(self._vertices.center, instance), math.max(self._vertices.center, instance))

    def at(self, center: Tensor) -&gt; &#39;Geometry&#39;:
        raise NotImplementedError

    def rotated(self, angle: Union[float, Tensor]) -&gt; &#39;Geometry&#39;:
        raise NotImplementedError

    def scaled(self, factor: Union[float, Tensor]) -&gt; &#39;Geometry&#39;:
        raise NotImplementedError

    def __getitem__(self, item):
        item: dict = slicing_dict(self, item)
        assert not spatial(self._elements).only(tuple(item)), f&#34;Cannot slice vertex lists (&#39;{spatial(self._elements)}&#39;) but got slicing dict {item}&#34;
        assert not instance(self._vertices).only(tuple(item)), f&#34;Slicing by vertex indices (&#39;{instance(self._vertices)}&#39;) not supported but got slicing dict {item}&#34;
        cells = instance(self.shape).name
        if cells in item and isinstance(item[&#39;cells&#39;], int):
            item[cells] = slice(item[cells], item[cells] + 1)
        vertices = self._vertices[item]
        polygons = self._elements[item]
        return Mesh(vertices, polygons, self._element_rank, self._boundaries, self._center[item], self._volume[item],
                    self._face_centers[item], self._face_normals[item], self._face_areas[item], self._face_vertices[item])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.geom._geom.Geometry</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="phi.geom.Mesh.all_boundary_faces"><code class="name">prop <span class="ident">all_boundary_faces</span> : Dict[str, slice]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def all_boundary_faces(self) -&gt; Dict[str, slice]:
    return {self._nb: slice(instance(self).volume, None)}</code></pre>
</details>
</dd>
<dt id="phi.geom.Mesh.boundary_connectivity"><code class="name">prop <span class="ident">boundary_connectivity</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def boundary_connectivity(self) -&gt; Tensor:
    return self.connectivity[self.all_boundary_faces]</code></pre>
</details>
</dd>
<dt id="phi.geom.Mesh.boundary_elements"><code class="name">prop <span class="ident">boundary_elements</span> : Dict[str, Dict[str, slice]]</code></dt>
<dd>
<div class="desc"><p>Slices on the primal dimensions to mark boundary elements.
Grids and meshes have no boundary elements and return <code>{}</code>.
Dynamic graphs can define boundary elements for obstacles and walls.</p>
<h2 id="returns">Returns</h2>
<p>Map from <code>(name, is_upper)</code> to slicing <code>dict</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def boundary_elements(self) -&gt; Dict[str, Dict[str, slice]]:
    return {}</code></pre>
</details>
</dd>
<dt id="phi.geom.Mesh.boundary_faces"><code class="name">prop <span class="ident">boundary_faces</span> : Dict[str, Dict[str, slice]]</code></dt>
<dd>
<div class="desc"><p>Slices on the dual dimensions to mark boundary faces.</p>
<p>Regular grids use the keys (dim, is_upper) to identify boundaries.
Unstructured meshes use string identifiers for the boundaries.
Dynamic graphs return slices along the dual dimensions.</p>
<h2 id="returns">Returns</h2>
<p>Map from <code>(name, is_upper)</code> to slicing <code>dict</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def boundary_faces(self) -&gt; Dict[str, Dict[str, slice]]:
    return self._boundaries</code></pre>
</details>
</dd>
<dt id="phi.geom.Mesh.bounds"><code class="name">prop <span class="ident">bounds</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bounds(self):
    return Box(math.min(self._vertices.center, instance), math.max(self._vertices.center, instance))</code></pre>
</details>
</dd>
<dt id="phi.geom.Mesh.cell_connectivity"><code class="name">prop <span class="ident">cell_connectivity</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p>Returns a bool-like matrix whose non-zero entries denote connected elements.
In meshes or grids, elements are connected if they share a face in 3D, an edge in 2D, or a vertex in 1D.</p>
<h2 id="returns">Returns</h2>
<p><code>Tensor</code> of shape (elements, ~elements)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cell_connectivity(self) -&gt; Tensor:
    &#34;&#34;&#34;
    Returns a bool-like matrix whose non-zero entries denote connected elements.
    In meshes or grids, elements are connected if they share a face in 3D, an edge in 2D, or a vertex in 1D.

    Returns:
        `Tensor` of shape (elements, ~elements)
    &#34;&#34;&#34;
    return self.connectivity[self.interior_faces]</code></pre>
</details>
</dd>
<dt id="phi.geom.Mesh.cell_count"><code class="name">prop <span class="ident">cell_count</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cell_count(self):
    return instance(self._elements).size</code></pre>
</details>
</dd>
<dt id="phi.geom.Mesh.center"><code class="name">prop <span class="ident">center</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p>Center location in single channel dimension.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def center(self) -&gt; Tensor:
    return self._center</code></pre>
</details>
</dd>
<dt id="phi.geom.Mesh.connectivity"><code class="name">prop <span class="ident">connectivity</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def connectivity(self) -&gt; Tensor:
    if is_sparse(self._face_areas):
        return tensor_like(self._face_areas, True)
    else:
        return self._face_areas &gt; 0</code></pre>
</details>
</dd>
<dt id="phi.geom.Mesh.distance_matrix"><code class="name">prop <span class="ident">distance_matrix</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def distance_matrix(self):
    return math.vec_length(math.pairwise_distances(self.center, edges=self.cell_connectivity, format=&#39;as edges&#39;, default=None))</code></pre>
</details>
</dd>
<dt id="phi.geom.Mesh.element_rank"><code class="name">prop <span class="ident">element_rank</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def element_rank(self):
    return self._element_rank</code></pre>
</details>
</dd>
<dt id="phi.geom.Mesh.elements"><code class="name">prop <span class="ident">elements</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def elements(self):
    return self._elements</code></pre>
</details>
</dd>
<dt id="phi.geom.Mesh.face_areas"><code class="name">prop <span class="ident">face_areas</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p>Area of face connecting a pair of cells. Shape <code>(elements, ~)</code>.
Returns 0 for unconnected cells.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_areas(self) -&gt; Tensor:
    return self._face_areas</code></pre>
</details>
</dd>
<dt id="phi.geom.Mesh.face_centers"><code class="name">prop <span class="ident">face_centers</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p>Center of face connecting a pair of cells. Shape <code>(elements, ~, vector)</code>.
Here, <code>~</code> represents arbitrary internal dual dimensions, such as <code>~staggered_direction</code> or <code>~elements</code>.
Returns 0-vectors for unconnected cells.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_centers(self) -&gt; Tensor:
    return self._face_centers</code></pre>
</details>
</dd>
<dt id="phi.geom.Mesh.face_normals"><code class="name">prop <span class="ident">face_normals</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p>Normal vectors of cell faces, including boundary faces. Shape <code>(elements, ~, vector)</code>.
For meshes, The vectors point out of the primal cells and into the dual cells.</p>
<p>Instance/spatial dimensions along which the normal does not vary may not be included in the result tensor's shape.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_normals(self) -&gt; Tensor:
    return self._face_normals</code></pre>
</details>
</dd>
<dt id="phi.geom.Mesh.face_shape"><code class="name">prop <span class="ident">face_shape</span> : phiml.math._shape.Shape</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<p>Full Shape to identify each face of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>, including instance/spatial dimensions for the elements and dual dimensions listing the faces per element.
If this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> has no faces, returns an empty <code>Shape</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_shape(self) -&gt; Shape:
    return self.face_areas.shape</code></pre>
</details>
</dd>
<dt id="phi.geom.Mesh.faces"><code class="name">prop <span class="ident">faces</span> : <a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></dt>
<dd>
<div class="desc"><p>Assembles information about the boundaries of the elements that make up the surface.
For 2D elements, the faces are edges, for 3D elements, the faces are planar elements.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>center</code></dt>
<dd>Center of face connecting a pair of elements. Shape (~elements, elements, vector).
Returns 0-vectors for unconnected elements.</dd>
<dt><code>area</code></dt>
<dd>Area of face connecting a pair of elements. Shape (~elements, elements).
Returns 0 for unconnected elements.</dd>
<dt><code>normal</code></dt>
<dd>Normal vector of face connecting a pair of elements. Shape (~elements, elements, vector).
Unconnected elements are assigned the vector 0.
The vector points out of polygon and into ~polygon.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def faces(self) -&gt; &#39;Geometry&#39;:
    &#34;&#34;&#34;
    Assembles information about the boundaries of the elements that make up the surface.
    For 2D elements, the faces are edges, for 3D elements, the faces are planar elements.

    Returns:
        center: Center of face connecting a pair of elements. Shape (~elements, elements, vector).
            Returns 0-vectors for unconnected elements.
        area: Area of face connecting a pair of elements. Shape (~elements, elements).
            Returns 0 for unconnected elements.
        normal: Normal vector of face connecting a pair of elements. Shape (~elements, elements, vector).
            Unconnected elements are assigned the vector 0.
            The vector points out of polygon and into ~polygon.
    &#34;&#34;&#34;
    return Point(self.face_centers)</code></pre>
</details>
</dd>
<dt id="phi.geom.Mesh.interior_faces"><code class="name">prop <span class="ident">interior_faces</span> : Dict[str, slice]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def interior_faces(self) -&gt; Dict[str, slice]:
    return {self._nb: slice(0, instance(self).volume)}</code></pre>
</details>
</dd>
<dt id="phi.geom.Mesh.neighbor_distances"><code class="name">prop <span class="ident">neighbor_distances</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def neighbor_distances(self):
    return vec_length(self._neighbor_offsets)</code></pre>
</details>
</dd>
<dt id="phi.geom.Mesh.neighbor_offsets"><code class="name">prop <span class="ident">neighbor_offsets</span></code></dt>
<dd>
<div class="desc"><p>Returns shift vector to neighbor centroids and boundary faces.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def neighbor_offsets(self):
    &#34;&#34;&#34;Returns shift vector to neighbor centroids and boundary faces.&#34;&#34;&#34;
    return self._neighbor_offsets</code></pre>
</details>
</dd>
<dt id="phi.geom.Mesh.polygons"><code class="name">prop <span class="ident">polygons</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def polygons(self):
    raise NotImplementedError  # ToDo return Tensor (elements, vertex_list:spatial)</code></pre>
</details>
</dd>
<dt id="phi.geom.Mesh.relative_face_distance"><code class="name">prop <span class="ident">relative_face_distance</span></code></dt>
<dd>
<div class="desc"><p>|face_center - center| / |neighbor_center - center|</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def relative_face_distance(self):
    &#34;&#34;&#34;|face_center - center| / |neighbor_center - center|&#34;&#34;&#34;
    return self._relative_face_distance</code></pre>
</details>
</dd>
<dt id="phi.geom.Mesh.shape"><code class="name">prop <span class="ident">shape</span> : phiml.math._shape.Shape</code></dt>
<dd>
<div class="desc"><p>The <code>shape</code> of a <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> consists of the following dimensions:</p>
<ul>
<li>A single <em>channel</em> dimension called <code>'vector'</code> specifying the physical space</li>
<li>Instance dimensions denote that this geometry consists of multiple copies in the same space</li>
<li>Spatial dimensions denote a crystal (repeating structure) of this geometric primitive in space</li>
<li>Batch dimensions indicate non-interacting versions of this geometry for parallelization only.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape(self) -&gt; Shape:
    return shape(self._elements).non_dual &amp; channel(self._vertices)</code></pre>
</details>
</dd>
<dt id="phi.geom.Mesh.vertices"><code class="name">prop <span class="ident">vertices</span> : phi.geom._graph.Graph</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def vertices(self) -&gt; Graph:
    return self._vertices</code></pre>
</details>
</dd>
<dt id="phi.geom.Mesh.volume"><code class="name">prop <span class="ident">volume</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p><code>phi.math.Tensor</code> representing the volume of each element.
The result retains batch, spatial and instance dimensions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def volume(self) -&gt; Tensor:
    return self._volume</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phi.geom.Mesh.approximate_closest_surface"><code class="name flex">
<span>def <span class="ident">approximate_closest_surface</span></span>(<span>self, location: phiml.math._tensors.Tensor) ‑> Tuple[phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor]</span>
</code></dt>
<dd>
<div class="desc"><p>Find the closest surface face of this geometry given a point that can be outside or inside the geometry.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd><code>Tensor</code> with a single channel dimension called vector. Can have arbitrary other dimensions.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>signed_distance</code></dt>
<dd>Scalar signed distance from <code>location</code>
to the closest point on the surface.
Positive values indicate the point lies outside the geometry, negative values indicate the point lies inside the geometry.</dd>
<dt><code>delta</code></dt>
<dd>Vector-valued distance vector from <code>location</code> to the closest point on the surface.</dd>
<dt><code>normal</code></dt>
<dd>Closest surface normal vector.</dd>
<dt><code>offset</code></dt>
<dd>Min distance of a surface-tangential plane from 0 as a scalar.</dd>
<dt><code>face_index</code></dt>
<dd>(Optional) An index vector pointing at the closest face.</dd>
</dl></div>
</dd>
<dt id="phi.geom.Mesh.approximate_signed_distance"><code class="name flex">
<span>def <span class="ident">approximate_signed_distance</span></span>(<span>self, location: Union[phiml.math._tensors.Tensor, tuple]) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the approximate distance from location to the surface of the geometry.
Locations outside return positive values, inside negative values and zero exactly at the boundary.</p>
<p>The exact distance metric used depends on the geometry.
The approximation holds close to the surface and the distance grows to infinity as the location is moved infinitely far from the geometry.
The distance metric is differentiable and its gradients are bounded at every point in space.</p>
<p>When dealing with unions or collections of geometries (instance dimensions), the shortest distance to any instance is returned.
This also holds for negative distances.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd><code>Tensor</code> with one channel dim <code>vector</code> matching the geometry's <code>vector</code> dim.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Float <code>Tensor</code></p></div>
</dd>
<dt id="phi.geom.Mesh.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>self, center: phiml.math._tensors.Tensor) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a copy of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> with the center at <code>center</code>.
This is equal to calling <code>self @ center</code>.</p>
<p>See Also:
<code><a title="phi.geom.Geometry.shifted" href="#phi.geom.Geometry.shifted">Geometry.shifted()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>center</code></strong></dt>
<dd>New center as <code>Tensor</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.</p></div>
</dd>
<dt id="phi.geom.Mesh.bounding_half_extent"><code class="name flex">
<span>def <span class="ident">bounding_half_extent</span></span>(<span>self) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>The bounding half-extent sets a limit on the outer-most point for each coordinate axis.
Each component is non-negative.</p>
<p>Let the bounding half-extent have value <code>e</code> in dimension <code>d</code> (<code>extent[...,d] = e</code>).
Then, no point of the geometry lies further away from its center point than <code>e</code> along <code>d</code> (in both axis directions).</p>
<p>When this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.
If these dims are not present, all parts are assumed to have the same bounds.</p></div>
</dd>
<dt id="phi.geom.Mesh.bounding_radius"><code class="name flex">
<span>def <span class="ident">bounding_radius</span></span>(<span>self) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the radius of a Sphere object that fully encloses this geometry.
The sphere is centered at the center of this geometry.</p>
<p>:return: radius of type float</p>
<p>Args:</p>
<p>Returns:</p></div>
</dd>
<dt id="phi.geom.Mesh.cell_walk_towards"><code class="name flex">
<span>def <span class="ident">cell_walk_towards</span></span>(<span>self, location: phiml.math._tensors.Tensor, start_cell_idx: phiml.math._tensors.Tensor, allow_exit=False)</span>
</code></dt>
<dd>
<div class="desc"><p>If <code>location</code> is not within the cell at index <code>from_cell_idx</code>, moves to a closer neighbor cell.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd>Target location as <code>Tensor</code>.</dd>
<dt><strong><code>start_cell_idx</code></strong></dt>
<dd>Index of starting cell. Must be a valid cell index.</dd>
<dt><strong><code>allow_exit</code></strong></dt>
<dd>If <code>True</code>, returns an invalid index for points outside the mesh, otherwise keeps the current index.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>index</code></dt>
<dd>Index of the neighbor cell or starting cell.</dd>
<dt><code>leaves_mesh</code></dt>
<dd>Whether the walk crossed the mesh boundary. Then <code>index</code> is invalid. This is only possible if <code>allow_exit</code> is true.</dd>
<dt><code>is_outside</code></dt>
<dd>Whether <code>location</code> was outside the cell at index <code>start_cell_idx</code>.</dd>
</dl></div>
</dd>
<dt id="phi.geom.Mesh.faces_to_vertices"><code class="name flex">
<span>def <span class="ident">faces_to_vertices</span></span>(<span>self, values: phiml.math._tensors.Tensor, reduce=&lt;built-in function sum&gt;)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Mesh.lies_inside"><code class="name flex">
<span>def <span class="ident">lies_inside</span></span>(<span>self, location: phiml.math._tensors.Tensor) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Tests whether the given location lies inside or outside of the geometry. Locations on the surface count as inside.</p>
<p>When dealing with unions or collections of geometries (instance dimensions), a point lies inside the geometry if it lies inside any instance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd>float tensor of shape (batch_size, &hellip;, rank)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>bool tensor of shape (*location.shape[:-1], 1).</p></div>
</dd>
<dt id="phi.geom.Mesh.pad_boundary"><code class="name flex">
<span>def <span class="ident">pad_boundary</span></span>(<span>self, value: phiml.math._tensors.Tensor, widths: Dict[str, Dict[str, slice]] = None, mode: phiml.math.extrapolation.Extrapolation = 0, **kwargs) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Mesh.rotated"><code class="name flex">
<span>def <span class="ident">rotated</span></span>(<span>self, angle: Union[phiml.math._tensors.Tensor, float]) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a rotated version of this geometry.
The geometry is rotated about its center point.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>angle</code></strong></dt>
<dd>
<p>Delta rotation.
Either</p>
<ul>
<li>Angle(s): scalar angle in 2d or euler angles along <code>vector</code> in 3D or higher.</li>
<li>Matrix: d⨯d rotation matrix</li>
</ul>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Rotated <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></p></div>
</dd>
<dt id="phi.geom.Mesh.sample_uniform"><code class="name flex">
<span>def <span class="ident">sample_uniform</span></span>(<span>self, *shape: phiml.math._shape.Shape) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Samples uniformly distributed random points inside this volume.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*shape</code></strong></dt>
<dd>How many points to sample per individual geometry.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>Tensor</code> containing all dimensions from <code><a title="phi.geom.Geometry.shape" href="#phi.geom.Geometry.shape">Geometry.shape</a></code>, <code>shape</code> as well as a <code>channel</code> dimension <code>vector</code> matching the dimensionality of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.</p></div>
</dd>
<dt id="phi.geom.Mesh.scaled"><code class="name flex">
<span>def <span class="ident">scaled</span></span>(<span>self, factor: Union[phiml.math._tensors.Tensor, float]) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<div class="desc"><p>Scales each individual geometry by <code>factor</code>.
The individual <code>center</code> points act as pivots for the operation.</p>
<h2 id="args">Args</h2>
<p>factor:
Returns:</p></div>
</dd>
</dl>
</dd>
<dt id="phi.geom.Point"><code class="flex name class">
<span>class <span class="ident">Point</span></span>
<span>(</span><span>location: phiml.math._tensors.Tensor)</span>
</code></dt>
<dd>
<div class="desc"><p>Points have zero volume and are determined by a single location.
An instance of <code><a title="phi.geom.Point" href="#phi.geom.Point">Point</a></code> represents a single n-dimensional point or a batch of points.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Point(Geometry):
    &#34;&#34;&#34;
    Points have zero volume and are determined by a single location.
    An instance of `Point` represents a single n-dimensional point or a batch of points.
    &#34;&#34;&#34;

    def __init__(self, location: math.Tensor):
        assert &#39;vector&#39; in location.shape, &#34;location must have a vector dimension&#34;
        assert location.shape.get_item_names(&#39;vector&#39;) is not None, &#34;Vector dimension needs to list spatial dimension as item names.&#34;
        self._location = location
        self._shape = self._location.shape

    def __variable_attrs__(self):
        return &#39;_location&#39;,

    def __value_attrs__(self):
        return &#39;_location&#39;,

    def __with_attrs__(self, **updates):
        if &#39;_location&#39; in updates:
            result = Point.__new__(Point)
            result._location = updates[&#39;_location&#39;]
            result._shape = result._location.shape if result._location is not None else self._shape
            return result
        else:
            return self

    @property
    def center(self) -&gt; Tensor:
        return self._location

    @property
    def shape(self) -&gt; Shape:
        return self._shape

    @property
    def faces(self) -&gt; &#39;Geometry&#39;:
        return self

    def unstack(self, dimension: str) -&gt; tuple:
        return tuple(Point(loc) for loc in math.unstack(self._location, dimension))

    def lies_inside(self, location: Tensor) -&gt; Tensor:
        return expand(math.wrap(False), shape(location).without(&#39;vector&#39;))

    def approximate_signed_distance(self, location: Union[Tensor, tuple]) -&gt; Tensor:
        return math.vec_abs(location - self._location)

    def bounding_radius(self) -&gt; Tensor:
        return math.zeros()

    def bounding_half_extent(self) -&gt; Tensor:
        return expand(0, self._shape)

    def at(self, center: Tensor) -&gt; &#39;Geometry&#39;:
        return Point(center)

    def rotated(self, angle) -&gt; &#39;Geometry&#39;:
        return self

    @property
    def volume(self) -&gt; Tensor:
        return math.wrap(0)

    def sample_uniform(self, *shape: math.Shape) -&gt; Tensor:
        raise NotImplementedError

    def scaled(self, factor: Union[float, Tensor]) -&gt; &#39;Geometry&#39;:
        return self

    @property
    def face_centers(self) -&gt; Tensor:
        return self._location

    @property
    def face_areas(self) -&gt; Tensor:
        return expand(0, self.face_shape)

    @property
    def face_normals(self) -&gt; Tensor:
        raise AssertionError(f&#34;Points have no normals&#34;)

    @property
    def boundary_elements(self) -&gt; Dict[str, Tuple[Dict[str, slice], Dict[str, slice]]]:
        return {}

    @property
    def boundary_faces(self) -&gt; Dict[str, Tuple[Dict[str, slice], Dict[str, slice]]]:
        return {}

    @property
    def face_shape(self) -&gt; Shape:
        return self.shape

    @property
    def corners(self):
        return self._location

    def __getitem__(self, item):
        return Point(self._location[_keep_vector(slicing_dict(self, item))])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.geom._geom.Geometry</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="phi.geom.Point.boundary_elements"><code class="name">prop <span class="ident">boundary_elements</span> : Dict[str, Tuple[Dict[str, slice], Dict[str, slice]]]</code></dt>
<dd>
<div class="desc"><p>Slices on the primal dimensions to mark boundary elements.
Grids and meshes have no boundary elements and return <code>{}</code>.
Dynamic graphs can define boundary elements for obstacles and walls.</p>
<h2 id="returns">Returns</h2>
<p>Map from <code>(name, is_upper)</code> to slicing <code>dict</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def boundary_elements(self) -&gt; Dict[str, Tuple[Dict[str, slice], Dict[str, slice]]]:
    return {}</code></pre>
</details>
</dd>
<dt id="phi.geom.Point.boundary_faces"><code class="name">prop <span class="ident">boundary_faces</span> : Dict[str, Tuple[Dict[str, slice], Dict[str, slice]]]</code></dt>
<dd>
<div class="desc"><p>Slices on the dual dimensions to mark boundary faces.</p>
<p>Regular grids use the keys (dim, is_upper) to identify boundaries.
Unstructured meshes use string identifiers for the boundaries.
Dynamic graphs return slices along the dual dimensions.</p>
<h2 id="returns">Returns</h2>
<p>Map from <code>(name, is_upper)</code> to slicing <code>dict</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def boundary_faces(self) -&gt; Dict[str, Tuple[Dict[str, slice], Dict[str, slice]]]:
    return {}</code></pre>
</details>
</dd>
<dt id="phi.geom.Point.center"><code class="name">prop <span class="ident">center</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p>Center location in single channel dimension.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def center(self) -&gt; Tensor:
    return self._location</code></pre>
</details>
</dd>
<dt id="phi.geom.Point.corners"><code class="name">prop <span class="ident">corners</span></code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<p>Corner locations as <code>phiml.math.Tensor</code>.
Corners belonging to one object or cell are listed along dual dimensions.
If the object has no corners, a size-0 tensor with the correct vector and instance dims is returned.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def corners(self):
    return self._location</code></pre>
</details>
</dd>
<dt id="phi.geom.Point.face_areas"><code class="name">prop <span class="ident">face_areas</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p>Area of face connecting a pair of cells. Shape <code>(elements, ~)</code>.
Returns 0 for unconnected cells.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_areas(self) -&gt; Tensor:
    return expand(0, self.face_shape)</code></pre>
</details>
</dd>
<dt id="phi.geom.Point.face_centers"><code class="name">prop <span class="ident">face_centers</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p>Center of face connecting a pair of cells. Shape <code>(elements, ~, vector)</code>.
Here, <code>~</code> represents arbitrary internal dual dimensions, such as <code>~staggered_direction</code> or <code>~elements</code>.
Returns 0-vectors for unconnected cells.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_centers(self) -&gt; Tensor:
    return self._location</code></pre>
</details>
</dd>
<dt id="phi.geom.Point.face_normals"><code class="name">prop <span class="ident">face_normals</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p>Normal vectors of cell faces, including boundary faces. Shape <code>(elements, ~, vector)</code>.
For meshes, The vectors point out of the primal cells and into the dual cells.</p>
<p>Instance/spatial dimensions along which the normal does not vary may not be included in the result tensor's shape.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_normals(self) -&gt; Tensor:
    raise AssertionError(f&#34;Points have no normals&#34;)</code></pre>
</details>
</dd>
<dt id="phi.geom.Point.face_shape"><code class="name">prop <span class="ident">face_shape</span> : phiml.math._shape.Shape</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<p>Full Shape to identify each face of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>, including instance/spatial dimensions for the elements and dual dimensions listing the faces per element.
If this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> has no faces, returns an empty <code>Shape</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_shape(self) -&gt; Shape:
    return self.shape</code></pre>
</details>
</dd>
<dt id="phi.geom.Point.faces"><code class="name">prop <span class="ident">faces</span> : <a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def faces(self) -&gt; &#39;Geometry&#39;:
    return self</code></pre>
</details>
</dd>
<dt id="phi.geom.Point.shape"><code class="name">prop <span class="ident">shape</span> : phiml.math._shape.Shape</code></dt>
<dd>
<div class="desc"><p>The <code>shape</code> of a <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> consists of the following dimensions:</p>
<ul>
<li>A single <em>channel</em> dimension called <code>'vector'</code> specifying the physical space</li>
<li>Instance dimensions denote that this geometry consists of multiple copies in the same space</li>
<li>Spatial dimensions denote a crystal (repeating structure) of this geometric primitive in space</li>
<li>Batch dimensions indicate non-interacting versions of this geometry for parallelization only.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape(self) -&gt; Shape:
    return self._shape</code></pre>
</details>
</dd>
<dt id="phi.geom.Point.volume"><code class="name">prop <span class="ident">volume</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p><code>phi.math.Tensor</code> representing the volume of each element.
The result retains batch, spatial and instance dimensions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def volume(self) -&gt; Tensor:
    return math.wrap(0)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phi.geom.Point.approximate_signed_distance"><code class="name flex">
<span>def <span class="ident">approximate_signed_distance</span></span>(<span>self, location: Union[phiml.math._tensors.Tensor, tuple]) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the approximate distance from location to the surface of the geometry.
Locations outside return positive values, inside negative values and zero exactly at the boundary.</p>
<p>The exact distance metric used depends on the geometry.
The approximation holds close to the surface and the distance grows to infinity as the location is moved infinitely far from the geometry.
The distance metric is differentiable and its gradients are bounded at every point in space.</p>
<p>When dealing with unions or collections of geometries (instance dimensions), the shortest distance to any instance is returned.
This also holds for negative distances.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd><code>Tensor</code> with one channel dim <code>vector</code> matching the geometry's <code>vector</code> dim.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Float <code>Tensor</code></p></div>
</dd>
<dt id="phi.geom.Point.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>self, center: phiml.math._tensors.Tensor) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a copy of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> with the center at <code>center</code>.
This is equal to calling <code>self @ center</code>.</p>
<p>See Also:
<code><a title="phi.geom.Geometry.shifted" href="#phi.geom.Geometry.shifted">Geometry.shifted()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>center</code></strong></dt>
<dd>New center as <code>Tensor</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.</p></div>
</dd>
<dt id="phi.geom.Point.bounding_half_extent"><code class="name flex">
<span>def <span class="ident">bounding_half_extent</span></span>(<span>self) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>The bounding half-extent sets a limit on the outer-most point for each coordinate axis.
Each component is non-negative.</p>
<p>Let the bounding half-extent have value <code>e</code> in dimension <code>d</code> (<code>extent[...,d] = e</code>).
Then, no point of the geometry lies further away from its center point than <code>e</code> along <code>d</code> (in both axis directions).</p>
<p>When this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.
If these dims are not present, all parts are assumed to have the same bounds.</p></div>
</dd>
<dt id="phi.geom.Point.bounding_radius"><code class="name flex">
<span>def <span class="ident">bounding_radius</span></span>(<span>self) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the radius of a Sphere object that fully encloses this geometry.
The sphere is centered at the center of this geometry.</p>
<p>:return: radius of type float</p>
<p>Args:</p>
<p>Returns:</p></div>
</dd>
<dt id="phi.geom.Point.lies_inside"><code class="name flex">
<span>def <span class="ident">lies_inside</span></span>(<span>self, location: phiml.math._tensors.Tensor) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Tests whether the given location lies inside or outside of the geometry. Locations on the surface count as inside.</p>
<p>When dealing with unions or collections of geometries (instance dimensions), a point lies inside the geometry if it lies inside any instance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd>float tensor of shape (batch_size, &hellip;, rank)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>bool tensor of shape (*location.shape[:-1], 1).</p></div>
</dd>
<dt id="phi.geom.Point.rotated"><code class="name flex">
<span>def <span class="ident">rotated</span></span>(<span>self, angle) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a rotated version of this geometry.
The geometry is rotated about its center point.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>angle</code></strong></dt>
<dd>
<p>Delta rotation.
Either</p>
<ul>
<li>Angle(s): scalar angle in 2d or euler angles along <code>vector</code> in 3D or higher.</li>
<li>Matrix: d⨯d rotation matrix</li>
</ul>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Rotated <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></p></div>
</dd>
<dt id="phi.geom.Point.sample_uniform"><code class="name flex">
<span>def <span class="ident">sample_uniform</span></span>(<span>self, *shape: phiml.math._shape.Shape) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Samples uniformly distributed random points inside this volume.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*shape</code></strong></dt>
<dd>How many points to sample per individual geometry.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>Tensor</code> containing all dimensions from <code><a title="phi.geom.Geometry.shape" href="#phi.geom.Geometry.shape">Geometry.shape</a></code>, <code>shape</code> as well as a <code>channel</code> dimension <code>vector</code> matching the dimensionality of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.</p></div>
</dd>
<dt id="phi.geom.Point.scaled"><code class="name flex">
<span>def <span class="ident">scaled</span></span>(<span>self, factor: Union[phiml.math._tensors.Tensor, float]) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<div class="desc"><p>Scales each individual geometry by <code>factor</code>.
The individual <code>center</code> points act as pivots for the operation.</p>
<h2 id="args">Args</h2>
<p>factor:
Returns:</p></div>
</dd>
<dt id="phi.geom.Point.unstack"><code class="name flex">
<span>def <span class="ident">unstack</span></span>(<span>self, dimension: str) ‑> tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Unstacks this Geometry along the given dimension.
The shapes of the returned geometries are reduced by <code>dimension</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dimension</code></strong></dt>
<dd>dimension along which to unstack</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>geometries</code></dt>
<dd>tuple of length equal to <code>geometry.shape.get_size(dimension)</code></dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="phi.geom.SDFGrid"><code class="flex name class">
<span>class <span class="ident">SDFGrid</span></span>
<span>(</span><span>sdf: phiml.math._tensors.Tensor, bounds: phi.geom._box.Box, approximate_outside=True, gradient: phiml.math._tensors.Tensor = None, center: phiml.math._tensors.Tensor = None, volume: phiml.math._tensors.Tensor = None, bounding_radius: phiml.math._tensors.Tensor = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Grid-based signed distance field.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sdf</code></strong></dt>
<dd>Signed distance values. <code>Tensor</code> with spatial dimensions corresponding to the physical space.
Each value samples the SDF value at the center of a virtual cell.</dd>
<dt><strong><code>bounds</code></strong></dt>
<dd>Grid limits. The bounds fully enclose all virtual cells.</dd>
<dt><strong><code>approximate_outside</code></strong></dt>
<dd>Whether queries outside the SDF grid should return approximate values. This requires additional computations.</dd>
<dt><strong><code>gradient</code></strong></dt>
<dd>(Optional) Pre-computed gradient grid. Will be computed otherwise.</dd>
<dt><strong><code>center</code></strong></dt>
<dd>(Optional) Geometry center point. Will be computed otherwise.</dd>
<dt><strong><code>volume</code></strong></dt>
<dd>(Optional) Geometry volume. Will be computed otherwise.</dd>
<dt><strong><code>bounding_radius</code></strong></dt>
<dd>(Optional) Geometry bounding radius around center. Will be computed otherwise.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SDFGrid(Geometry):
    &#34;&#34;&#34;
    Grid-based signed distance field.
    &#34;&#34;&#34;
    def __init__(self, sdf: Tensor, bounds: Box, approximate_outside=True, gradient: Tensor = None, center: Tensor = None, volume: Tensor = None, bounding_radius: Tensor = None):
        &#34;&#34;&#34;
        Args:
            sdf: Signed distance values. `Tensor` with spatial dimensions corresponding to the physical space.
                Each value samples the SDF value at the center of a virtual cell.
            bounds: Grid limits. The bounds fully enclose all virtual cells.
            approximate_outside: Whether queries outside the SDF grid should return approximate values. This requires additional computations.
            gradient: (Optional) Pre-computed gradient grid. Will be computed otherwise.
            center: (Optional) Geometry center point. Will be computed otherwise.
            volume: (Optional) Geometry volume. Will be computed otherwise.
            bounding_radius: (Optional) Geometry bounding radius around center. Will be computed otherwise.
        &#34;&#34;&#34;
        super().__init__()
        self._sdf = sdf
        self._bounds = bounds
        self._approximate_outside = approximate_outside
        dx = bounds.size / spatial(sdf)
        if gradient is not None:
            self._grad = gradient
        else:
            grad = math.spatial_gradient(sdf, dx=dx, difference=&#39;forward&#39;, padding=math.extrapolation.ZERO_GRADIENT, stack_dim=channel(&#39;vector&#39;))
            self._grad = grad[{dim: slice(0, -1) for dim in spatial(sdf).names}]
        if center is not None:
            self._center = center
        else:
            min_index = math.argmin(self._sdf, spatial, index_dim=channel(&#39;vector&#39;))
            self._center = bounds.local_to_global(min_index / spatial(sdf))
        if volume is not None:
            self._volume = volume
        else:
            filled = math.sum(sdf &lt; 0)
            self._volume = filled * math.prod(dx)
        if bounding_radius is not None:
            self._bounding_radius = bounding_radius
        else:
            points = UniformGrid(spatial(sdf), self._bounds).center
            dist = math.vec_length(points - self._center)
            dist = math.where(self._sdf &lt;= 0, dist, 0)
            self._bounding_radius = math.max(dist)

    @property
    def values(self):
        &#34;&#34;&#34;Signed distance grid.&#34;&#34;&#34;
        return self._sdf

    @property
    def bounds(self):
        return self._bounds

    @property
    def size(self):
        return self._bounds.size

    @property
    def resolution(self):
        return spatial(self._sdf)

    @property
    def points(self):
        return UniformGrid(spatial(self._sdf), self._bounds).center

    @property
    def center(self) -&gt; Tensor:
        return self._center

    @property
    def shape(self) -&gt; Shape:
        return non_spatial(self._sdf) &amp; channel(vector=spatial(self._sdf))

    @property
    def volume(self) -&gt; Tensor:
        return self._volume

    @property
    def faces(self) -&gt; &#39;Geometry&#39;:
        raise NotImplementedError(f&#34;SDF does not support faces&#34;)

    @property
    def face_centers(self) -&gt; Tensor:
        raise NotImplementedError(f&#34;SDF does not support faces&#34;)

    @property
    def face_areas(self) -&gt; Tensor:
        raise NotImplementedError(f&#34;SDF does not support faces&#34;)

    @property
    def face_normals(self) -&gt; Tensor:
        raise NotImplementedError(f&#34;SDF does not support faces&#34;)

    @property
    def boundary_elements(self) -&gt; Dict[Any, Dict[str, slice]]:
        return {}

    @property
    def boundary_faces(self) -&gt; Dict[Any, Dict[str, slice]]:
        return {}

    @property
    def face_shape(self) -&gt; Shape:
        raise NotImplementedError(f&#34;SDF does not support boundaries&#34;)

    @property
    def corners(self) -&gt; Tensor:
        raise NotImplementedError(f&#34;SDF does not support corners&#34;)

    def lies_inside(self, location: Tensor) -&gt; Tensor:
        float_idx = (location - self._bounds.lower) / self.size * self.resolution
        sdf_val = math.grid_sample(self._sdf, float_idx - .5, math.extrapolation.ZERO_GRADIENT)
        if self._approximate_outside:
            within_bounds = self._bounds.lies_inside(location)
            return within_bounds &amp; (sdf_val &lt;= 0)
        else:
            return sdf_val &lt;= 0

    def approximate_closest_surface(self, location: Tensor) -&gt; Tuple[Tensor, Tensor, Tensor, Tensor, Tensor]:
        float_idx = (location - self._bounds.lower) / self.size * self.resolution
        sdf_val = math.grid_sample(self._sdf, float_idx - .5, math.extrapolation.ZERO_GRADIENT)
        sdf_grad = math.grid_sample(self._grad, float_idx - 1, math.extrapolation.ZERO_GRADIENT)
        sdf_grad = math.vec_normalize(sdf_grad)  # theoretically not necessary
        sgn_dist = sdf_val
        if self._approximate_outside:
            within_bounds = self._bounds.lies_inside(location)
            from_center = location - self._center
            dist_from_center = math.vec_length(from_center) - self._bounding_radius
            sgn_dist = math.where(within_bounds, sdf_val, dist_from_center)
            sdf_grad = math.where(within_bounds, sdf_grad, math.vec_normalize(from_center))
        delta = sgn_dist * -sdf_grad
        surface_pos = location + delta
        surf_float_idx = (surface_pos - self._bounds.lower) / self.size * self.resolution
        normal = math.grid_sample(self._grad, surf_float_idx - 1, math.extrapolation.ZERO_GRADIENT)
        normal = math.where(self._bounds.lies_inside(surface_pos), normal, sdf_grad)  # use current normal if surface point is outside SDF grid
        normal = math.vec_normalize(normal)
        face_index = expand(0, non_channel(location))
        offset = normal.vector @ surface_pos.vector
        return sgn_dist, delta, normal, offset, face_index

    def approximate_signed_distance(self, location: Tensor) -&gt; Tensor:
        float_idx = (location - self._bounds.lower) / self.size * self.resolution
        sdf_val = math.grid_sample(self._sdf, float_idx - .5, math.extrapolation.ZERO_GRADIENT)
        if self._approximate_outside:
            within_bounds = self._bounds.lies_inside(location)
            dist_from_center = math.vec_length(location - self._center) - self._bounding_radius
            return math.where(within_bounds, sdf_val, dist_from_center)
        else:
            return sdf_val

    def sample_uniform(self, *shape: math.Shape) -&gt; Tensor:
        raise NotImplementedError

    def bounding_radius(self) -&gt; Tensor:
        return self._bounding_radius

    def bounding_half_extent(self) -&gt; Tensor:
        return self._bounds.half_size  # this could be too small if the center is not in the middle of the bounds

    def shifted(self, delta: Tensor) -&gt; &#39;Geometry&#39;:
        return SDFGrid(self._sdf, self._bounds.shifted(delta), self._approximate_outside, self._grad, self._center + delta, self._volume, self._bounding_radius)

    def at(self, center: Tensor) -&gt; &#39;Geometry&#39;:
        return self.shifted(center - self._center)

    def rotated(self, angle: Union[float, Tensor]) -&gt; &#39;Geometry&#39;:
        raise NotImplementedError(&#34;SDF does not yet support rotation&#34;)

    def scaled(self, factor: Union[float, Tensor]) -&gt; &#39;Geometry&#39;:
        off_center = self._center - self._bounds.center
        volume = self._volume * factor ** self.spatial_rank
        bounds = self._bounds.scaled(factor).shifted(off_center * (factor - 1)).corner_representation()
        return SDFGrid(self._sdf, bounds, self._approximate_outside, self._grad, self._center, volume, self._bounding_radius * factor)

    def __getitem__(self, item):
        if &#39;vector&#39; in item:
            raise NotImplementedError(&#34;SDF projection not yet supported&#34;)
        return SDFGrid(self._sdf[item], self._bounds[item], self._approximate_outside, self._grad[item], self._center[item], self._volume[item], self._bounding_radius[item])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.geom._geom.Geometry</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="phi.geom.SDFGrid.boundary_elements"><code class="name">prop <span class="ident">boundary_elements</span> : Dict[Any, Dict[str, slice]]</code></dt>
<dd>
<div class="desc"><p>Slices on the primal dimensions to mark boundary elements.
Grids and meshes have no boundary elements and return <code>{}</code>.
Dynamic graphs can define boundary elements for obstacles and walls.</p>
<h2 id="returns">Returns</h2>
<p>Map from <code>(name, is_upper)</code> to slicing <code>dict</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def boundary_elements(self) -&gt; Dict[Any, Dict[str, slice]]:
    return {}</code></pre>
</details>
</dd>
<dt id="phi.geom.SDFGrid.boundary_faces"><code class="name">prop <span class="ident">boundary_faces</span> : Dict[Any, Dict[str, slice]]</code></dt>
<dd>
<div class="desc"><p>Slices on the dual dimensions to mark boundary faces.</p>
<p>Regular grids use the keys (dim, is_upper) to identify boundaries.
Unstructured meshes use string identifiers for the boundaries.
Dynamic graphs return slices along the dual dimensions.</p>
<h2 id="returns">Returns</h2>
<p>Map from <code>(name, is_upper)</code> to slicing <code>dict</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def boundary_faces(self) -&gt; Dict[Any, Dict[str, slice]]:
    return {}</code></pre>
</details>
</dd>
<dt id="phi.geom.SDFGrid.bounds"><code class="name">prop <span class="ident">bounds</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bounds(self):
    return self._bounds</code></pre>
</details>
</dd>
<dt id="phi.geom.SDFGrid.center"><code class="name">prop <span class="ident">center</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p>Center location in single channel dimension.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def center(self) -&gt; Tensor:
    return self._center</code></pre>
</details>
</dd>
<dt id="phi.geom.SDFGrid.corners"><code class="name">prop <span class="ident">corners</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<p>Corner locations as <code>phiml.math.Tensor</code>.
Corners belonging to one object or cell are listed along dual dimensions.
If the object has no corners, a size-0 tensor with the correct vector and instance dims is returned.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def corners(self) -&gt; Tensor:
    raise NotImplementedError(f&#34;SDF does not support corners&#34;)</code></pre>
</details>
</dd>
<dt id="phi.geom.SDFGrid.face_areas"><code class="name">prop <span class="ident">face_areas</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p>Area of face connecting a pair of cells. Shape <code>(elements, ~)</code>.
Returns 0 for unconnected cells.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_areas(self) -&gt; Tensor:
    raise NotImplementedError(f&#34;SDF does not support faces&#34;)</code></pre>
</details>
</dd>
<dt id="phi.geom.SDFGrid.face_centers"><code class="name">prop <span class="ident">face_centers</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p>Center of face connecting a pair of cells. Shape <code>(elements, ~, vector)</code>.
Here, <code>~</code> represents arbitrary internal dual dimensions, such as <code>~staggered_direction</code> or <code>~elements</code>.
Returns 0-vectors for unconnected cells.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_centers(self) -&gt; Tensor:
    raise NotImplementedError(f&#34;SDF does not support faces&#34;)</code></pre>
</details>
</dd>
<dt id="phi.geom.SDFGrid.face_normals"><code class="name">prop <span class="ident">face_normals</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p>Normal vectors of cell faces, including boundary faces. Shape <code>(elements, ~, vector)</code>.
For meshes, The vectors point out of the primal cells and into the dual cells.</p>
<p>Instance/spatial dimensions along which the normal does not vary may not be included in the result tensor's shape.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_normals(self) -&gt; Tensor:
    raise NotImplementedError(f&#34;SDF does not support faces&#34;)</code></pre>
</details>
</dd>
<dt id="phi.geom.SDFGrid.face_shape"><code class="name">prop <span class="ident">face_shape</span> : phiml.math._shape.Shape</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<p>Full Shape to identify each face of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>, including instance/spatial dimensions for the elements and dual dimensions listing the faces per element.
If this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> has no faces, returns an empty <code>Shape</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_shape(self) -&gt; Shape:
    raise NotImplementedError(f&#34;SDF does not support boundaries&#34;)</code></pre>
</details>
</dd>
<dt id="phi.geom.SDFGrid.faces"><code class="name">prop <span class="ident">faces</span> : <a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def faces(self) -&gt; &#39;Geometry&#39;:
    raise NotImplementedError(f&#34;SDF does not support faces&#34;)</code></pre>
</details>
</dd>
<dt id="phi.geom.SDFGrid.points"><code class="name">prop <span class="ident">points</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def points(self):
    return UniformGrid(spatial(self._sdf), self._bounds).center</code></pre>
</details>
</dd>
<dt id="phi.geom.SDFGrid.resolution"><code class="name">prop <span class="ident">resolution</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def resolution(self):
    return spatial(self._sdf)</code></pre>
</details>
</dd>
<dt id="phi.geom.SDFGrid.shape"><code class="name">prop <span class="ident">shape</span> : phiml.math._shape.Shape</code></dt>
<dd>
<div class="desc"><p>The <code>shape</code> of a <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> consists of the following dimensions:</p>
<ul>
<li>A single <em>channel</em> dimension called <code>'vector'</code> specifying the physical space</li>
<li>Instance dimensions denote that this geometry consists of multiple copies in the same space</li>
<li>Spatial dimensions denote a crystal (repeating structure) of this geometric primitive in space</li>
<li>Batch dimensions indicate non-interacting versions of this geometry for parallelization only.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape(self) -&gt; Shape:
    return non_spatial(self._sdf) &amp; channel(vector=spatial(self._sdf))</code></pre>
</details>
</dd>
<dt id="phi.geom.SDFGrid.size"><code class="name">prop <span class="ident">size</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self):
    return self._bounds.size</code></pre>
</details>
</dd>
<dt id="phi.geom.SDFGrid.values"><code class="name">prop <span class="ident">values</span></code></dt>
<dd>
<div class="desc"><p>Signed distance grid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def values(self):
    &#34;&#34;&#34;Signed distance grid.&#34;&#34;&#34;
    return self._sdf</code></pre>
</details>
</dd>
<dt id="phi.geom.SDFGrid.volume"><code class="name">prop <span class="ident">volume</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p><code>phi.math.Tensor</code> representing the volume of each element.
The result retains batch, spatial and instance dimensions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def volume(self) -&gt; Tensor:
    return self._volume</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phi.geom.SDFGrid.approximate_closest_surface"><code class="name flex">
<span>def <span class="ident">approximate_closest_surface</span></span>(<span>self, location: phiml.math._tensors.Tensor) ‑> Tuple[phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor]</span>
</code></dt>
<dd>
<div class="desc"><p>Find the closest surface face of this geometry given a point that can be outside or inside the geometry.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd><code>Tensor</code> with a single channel dimension called vector. Can have arbitrary other dimensions.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>signed_distance</code></dt>
<dd>Scalar signed distance from <code>location</code>
to the closest point on the surface.
Positive values indicate the point lies outside the geometry, negative values indicate the point lies inside the geometry.</dd>
<dt><code>delta</code></dt>
<dd>Vector-valued distance vector from <code>location</code> to the closest point on the surface.</dd>
<dt><code>normal</code></dt>
<dd>Closest surface normal vector.</dd>
<dt><code>offset</code></dt>
<dd>Min distance of a surface-tangential plane from 0 as a scalar.</dd>
<dt><code>face_index</code></dt>
<dd>(Optional) An index vector pointing at the closest face.</dd>
</dl></div>
</dd>
<dt id="phi.geom.SDFGrid.approximate_signed_distance"><code class="name flex">
<span>def <span class="ident">approximate_signed_distance</span></span>(<span>self, location: phiml.math._tensors.Tensor) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the approximate distance from location to the surface of the geometry.
Locations outside return positive values, inside negative values and zero exactly at the boundary.</p>
<p>The exact distance metric used depends on the geometry.
The approximation holds close to the surface and the distance grows to infinity as the location is moved infinitely far from the geometry.
The distance metric is differentiable and its gradients are bounded at every point in space.</p>
<p>When dealing with unions or collections of geometries (instance dimensions), the shortest distance to any instance is returned.
This also holds for negative distances.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd><code>Tensor</code> with one channel dim <code>vector</code> matching the geometry's <code>vector</code> dim.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Float <code>Tensor</code></p></div>
</dd>
<dt id="phi.geom.SDFGrid.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>self, center: phiml.math._tensors.Tensor) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a copy of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> with the center at <code>center</code>.
This is equal to calling <code>self @ center</code>.</p>
<p>See Also:
<code><a title="phi.geom.Geometry.shifted" href="#phi.geom.Geometry.shifted">Geometry.shifted()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>center</code></strong></dt>
<dd>New center as <code>Tensor</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.</p></div>
</dd>
<dt id="phi.geom.SDFGrid.bounding_half_extent"><code class="name flex">
<span>def <span class="ident">bounding_half_extent</span></span>(<span>self) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>The bounding half-extent sets a limit on the outer-most point for each coordinate axis.
Each component is non-negative.</p>
<p>Let the bounding half-extent have value <code>e</code> in dimension <code>d</code> (<code>extent[...,d] = e</code>).
Then, no point of the geometry lies further away from its center point than <code>e</code> along <code>d</code> (in both axis directions).</p>
<p>When this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.
If these dims are not present, all parts are assumed to have the same bounds.</p></div>
</dd>
<dt id="phi.geom.SDFGrid.bounding_radius"><code class="name flex">
<span>def <span class="ident">bounding_radius</span></span>(<span>self) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the radius of a Sphere object that fully encloses this geometry.
The sphere is centered at the center of this geometry.</p>
<p>:return: radius of type float</p>
<p>Args:</p>
<p>Returns:</p></div>
</dd>
<dt id="phi.geom.SDFGrid.lies_inside"><code class="name flex">
<span>def <span class="ident">lies_inside</span></span>(<span>self, location: phiml.math._tensors.Tensor) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Tests whether the given location lies inside or outside of the geometry. Locations on the surface count as inside.</p>
<p>When dealing with unions or collections of geometries (instance dimensions), a point lies inside the geometry if it lies inside any instance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd>float tensor of shape (batch_size, &hellip;, rank)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>bool tensor of shape (*location.shape[:-1], 1).</p></div>
</dd>
<dt id="phi.geom.SDFGrid.rotated"><code class="name flex">
<span>def <span class="ident">rotated</span></span>(<span>self, angle: Union[phiml.math._tensors.Tensor, float]) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a rotated version of this geometry.
The geometry is rotated about its center point.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>angle</code></strong></dt>
<dd>
<p>Delta rotation.
Either</p>
<ul>
<li>Angle(s): scalar angle in 2d or euler angles along <code>vector</code> in 3D or higher.</li>
<li>Matrix: d⨯d rotation matrix</li>
</ul>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Rotated <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></p></div>
</dd>
<dt id="phi.geom.SDFGrid.sample_uniform"><code class="name flex">
<span>def <span class="ident">sample_uniform</span></span>(<span>self, *shape: phiml.math._shape.Shape) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Samples uniformly distributed random points inside this volume.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*shape</code></strong></dt>
<dd>How many points to sample per individual geometry.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>Tensor</code> containing all dimensions from <code><a title="phi.geom.Geometry.shape" href="#phi.geom.Geometry.shape">Geometry.shape</a></code>, <code>shape</code> as well as a <code>channel</code> dimension <code>vector</code> matching the dimensionality of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.</p></div>
</dd>
<dt id="phi.geom.SDFGrid.scaled"><code class="name flex">
<span>def <span class="ident">scaled</span></span>(<span>self, factor: Union[phiml.math._tensors.Tensor, float]) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<div class="desc"><p>Scales each individual geometry by <code>factor</code>.
The individual <code>center</code> points act as pivots for the operation.</p>
<h2 id="args">Args</h2>
<p>factor:
Returns:</p></div>
</dd>
<dt id="phi.geom.SDFGrid.shifted"><code class="name flex">
<span>def <span class="ident">shifted</span></span>(<span>self, delta: phiml.math._tensors.Tensor) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a translated version of this geometry.</p>
<p>See Also:
<code><a title="phi.geom.Geometry.at" href="#phi.geom.Geometry.at">Geometry.at()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>delta</code></strong></dt>
<dd>direction vector</dd>
<dt><strong><code>delta</code></strong></dt>
<dd>Tensor:</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></dt>
<dd>shifted geometry</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="phi.geom.Sphere"><code class="flex name class">
<span>class <span class="ident">Sphere</span></span>
<span>(</span><span>center: phiml.math._tensors.Tensor = None, radius: Union[phiml.math._tensors.Tensor, float] = None, volume: Union[phiml.math._tensors.Tensor, float] = None, radius_variable=True, **center_: Union[phiml.math._tensors.Tensor, float])</span>
</code></dt>
<dd>
<div class="desc"><p>N-dimensional sphere.
Defined through center position and radius.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>center</code></strong></dt>
<dd>Sphere center as <code>Tensor</code> with <code>vector</code> dimension.
The spatial dimension order should be specified in the <code>vector</code> dimension via item names.</dd>
<dt><strong><code>radius</code></strong></dt>
<dd>Sphere radius as <code>float</code> or <code>Tensor</code></dd>
<dt><strong><code>**center_</code></strong></dt>
<dd>Specifies center when the <code>center</code> argument is not given. Center position by dimension, e.g. <code>x=0.5, y=0.2</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Sphere(Geometry):
    &#34;&#34;&#34;
    N-dimensional sphere.
    Defined through center position and radius.
    &#34;&#34;&#34;

    def __init__(self,
                 center: Tensor = None,
                 radius: Union[float, Tensor] = None,
                 volume: Union[float, Tensor] = None,
                 radius_variable=True,
                 **center_: Union[float, Tensor]):
        &#34;&#34;&#34;
        Args:
            center: Sphere center as `Tensor` with `vector` dimension.
                The spatial dimension order should be specified in the `vector` dimension via item names.
            radius: Sphere radius as `float` or `Tensor`
            **center_: Specifies center when the `center` argument is not given. Center position by dimension, e.g. `x=0.5, y=0.2`.
        &#34;&#34;&#34;
        if center is not None:
            assert isinstance(center, Tensor), f&#34;center must be a Tensor but got {type(center).__name__}&#34;
            assert &#39;vector&#39; in center.shape, f&#34;Sphere center must have a &#39;vector&#39; dimension.&#34;
            assert center.shape.get_item_names(&#39;vector&#39;) is not None, f&#34;Vector dimension must list spatial dimensions as item names. Use the syntax Sphere(x=x, y=y) to assign names.&#34;
            self._center = center
        else:
            self._center = wrap(tuple(center_.values()), math.channel(vector=tuple(center_.keys())))
        if radius is None:
            assert volume is not None, f&#34;Either radius or volume must be specified but got neither.&#34;
            self._radius = Sphere.radius_from_volume(wrap(volume), self._center.vector.size)
        else:
            self._radius = wrap(radius)
        self._radius_variable = radius_variable
        assert &#39;vector&#39; not in self._radius.shape, f&#34;Sphere radius must not vary along vector but got {radius}&#34;

    @property
    def shape(self):
        if self._center is None or self._radius is None:
            return None
        return self._center.shape &amp; self._radius.shape

    @property
    def radius(self):
        return self._radius

    @property
    def center(self):
        return self._center

    @property
    def volume(self) -&gt; math.Tensor:
        return Sphere.volume_from_radius(self._radius, self.spatial_rank)

    @staticmethod
    def volume_from_radius(radius: Union[float, Tensor], spatial_rank: int):
        if spatial_rank == 1:
            return 2 * radius
        elif spatial_rank == 2:
            return PI * radius ** 2
        elif spatial_rank == 3:
            return 4/3 * PI * radius ** 3
        else:
            raise NotImplementedError(f&#34;spatial_rank&gt;3 not supported, got {spatial_rank}&#34;)
            # n = self.spatial_rank
            # return math.pi ** (n // 2) / math.faculty(math.ceil(n / 2)) * self._radius ** n

    @staticmethod
    def radius_from_volume(volume: Union[float, Tensor], spatial_rank: int):
        if spatial_rank == 1:
            return volume / 2
        elif spatial_rank == 2:
            return math.sqrt(volume / PI)
        elif spatial_rank == 3:
            return (.75 / PI * volume) ** (1/3)
        else:
            raise NotImplementedError(f&#34;spatial_rank&gt;3 not supported, got {spatial_rank}&#34;)

    def lies_inside(self, location):
        distance_squared = math.sum((location - self.center) ** 2, dim=&#39;vector&#39;)
        return math.any(distance_squared &lt;= self.radius ** 2, self.shape.instance)  # union for instance dimensions

    def approximate_signed_distance(self, location: Union[Tensor, tuple]):
        &#34;&#34;&#34;
        Computes the exact distance from location to the closest point on the sphere.
        Very close to the sphere center, the distance takes a constant value.

        Args:
          location: float tensor of shape (batch_size, ..., rank)

        Returns:
          float tensor of shape (*location.shape[:-1], 1).

        &#34;&#34;&#34;
        distance = math.vec_length(location - self._center, eps=1e-3)
        return math.min(distance - self.radius, self.shape.instance)  # union for instance dimensions

    def approximate_closest_surface(self, location: Tensor) -&gt; Tuple[Tensor, Tensor, Tensor, Tensor, Tensor]:
        self_center = self.center
        self_radius = self.radius
        center_delta = location - self_center
        center_dist = math.vec_length(center_delta)
        sgn_dist = center_dist - self_radius
        if instance(self):
            self_center, self_radius, sgn_dist, center_delta, center_dist = math.at_min((self.center, self.radius, sgn_dist, center_delta, center_dist), key=abs(sgn_dist), dim=instance)
        normal = math.safe_div(center_delta, center_dist)
        default_normal = wrap([1] + [0] * (self.spatial_rank-1), self.shape[&#39;vector&#39;])
        normal = math.where(center_dist == 0, default_normal, normal)
        surface_pos = self_center + self_radius * normal
        delta = surface_pos - location
        face_index = expand(0, non_channel(location))
        offset = normal.vector @ surface_pos.vector
        return sgn_dist, delta, normal, offset, face_index

    def sample_uniform(self, *shape: math.Shape):
        # --- Choose a distance from the center of the sphere, equally weighted by mass ---
        uniform = math.random_uniform(self.shape.non_singleton.without(&#39;vector&#39;), *shape)
        if self.spatial_rank == 1:
            r = self.radius * uniform
        else:
            r = self.radius * (uniform ** (1 / self.spatial_rank))
        # --- Uniformly sample a unit vector for direction over the surface of the sphere (Muller 1959, Marsaglia 1972) ---
        unit_vector = math.random_normal(self.shape.non_singleton.without(&#39;vector&#39;), *shape, self.shape[&#39;vector&#39;])
        unit_vector /= math.vec_length(unit_vector, vec_dim=&#39;vector&#39;)
        return self.center + r * unit_vector

    def bounding_radius(self):
        return self.radius

    def bounding_half_extent(self):
        return expand(self.radius, self._center.shape.only(&#39;vector&#39;))

    def at(self, center: Tensor) -&gt; &#39;Geometry&#39;:
        return Sphere(center, self._radius, radius_variable=self._radius_variable)

    def rotated(self, angle):
        return self

    def scaled(self, factor: Union[float, Tensor]) -&gt; &#39;Geometry&#39;:
        return Sphere(self.center, self.radius * factor, radius_variable=self._radius_variable)

    def __variable_attrs__(self):
        return (&#39;_center&#39;, &#39;_radius&#39;) if self._radius_variable else (&#39;_center&#39;,)

    def __value_attrs__(self):
        return &#39;_center&#39;,

    def __value_attrs__(self):
        return &#39;_center&#39;, &#39;_radius&#39;

    def __value_attrs__(self):
        return &#39;_center&#39;, &#39;_radius&#39;

    def __getitem__(self, item):
        item = slicing_dict(self, item)
        return Sphere(self._center[_keep_vector(item)], self._radius[item], radius_variable=self._radius_variable)

    @property
    def faces(self) -&gt; &#39;Geometry&#39;:
        raise NotImplementedError(f&#34;Sphere.faces not implemented.&#34;)

    @property
    def face_centers(self) -&gt; Tensor:
        return math.zeros(self.shape &amp; dual(shell=0))

    @property
    def face_areas(self) -&gt; Tensor:
        return math.zeros(self.face_shape)

    @property
    def face_normals(self) -&gt; Tensor:
        return math.zeros(self.shape &amp; dual(shell=0))

    @property
    def boundary_elements(self) -&gt; Dict[str, Tuple[Dict[str, slice], Dict[str, slice]]]:
        return {}

    @property
    def boundary_faces(self) -&gt; Dict[str, Tuple[Dict[str, slice], Dict[str, slice]]]:
        return {}

    @property
    def face_shape(self) -&gt; Shape:
        return self.shape.without(&#39;vector&#39;) &amp; dual(shell=0)

    @property
    def corners(self) -&gt; Tensor:
        return math.zeros(self.shape &amp; dual(corners=0))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.geom._geom.Geometry</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="phi.geom.Sphere.radius_from_volume"><code class="name flex">
<span>def <span class="ident">radius_from_volume</span></span>(<span>volume: Union[phiml.math._tensors.Tensor, float], spatial_rank: int)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Sphere.volume_from_radius"><code class="name flex">
<span>def <span class="ident">volume_from_radius</span></span>(<span>radius: Union[phiml.math._tensors.Tensor, float], spatial_rank: int)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="phi.geom.Sphere.boundary_elements"><code class="name">prop <span class="ident">boundary_elements</span> : Dict[str, Tuple[Dict[str, slice], Dict[str, slice]]]</code></dt>
<dd>
<div class="desc"><p>Slices on the primal dimensions to mark boundary elements.
Grids and meshes have no boundary elements and return <code>{}</code>.
Dynamic graphs can define boundary elements for obstacles and walls.</p>
<h2 id="returns">Returns</h2>
<p>Map from <code>(name, is_upper)</code> to slicing <code>dict</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def boundary_elements(self) -&gt; Dict[str, Tuple[Dict[str, slice], Dict[str, slice]]]:
    return {}</code></pre>
</details>
</dd>
<dt id="phi.geom.Sphere.boundary_faces"><code class="name">prop <span class="ident">boundary_faces</span> : Dict[str, Tuple[Dict[str, slice], Dict[str, slice]]]</code></dt>
<dd>
<div class="desc"><p>Slices on the dual dimensions to mark boundary faces.</p>
<p>Regular grids use the keys (dim, is_upper) to identify boundaries.
Unstructured meshes use string identifiers for the boundaries.
Dynamic graphs return slices along the dual dimensions.</p>
<h2 id="returns">Returns</h2>
<p>Map from <code>(name, is_upper)</code> to slicing <code>dict</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def boundary_faces(self) -&gt; Dict[str, Tuple[Dict[str, slice], Dict[str, slice]]]:
    return {}</code></pre>
</details>
</dd>
<dt id="phi.geom.Sphere.center"><code class="name">prop <span class="ident">center</span></code></dt>
<dd>
<div class="desc"><p>Center location in single channel dimension.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def center(self):
    return self._center</code></pre>
</details>
</dd>
<dt id="phi.geom.Sphere.corners"><code class="name">prop <span class="ident">corners</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<p>Corner locations as <code>phiml.math.Tensor</code>.
Corners belonging to one object or cell are listed along dual dimensions.
If the object has no corners, a size-0 tensor with the correct vector and instance dims is returned.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def corners(self) -&gt; Tensor:
    return math.zeros(self.shape &amp; dual(corners=0))</code></pre>
</details>
</dd>
<dt id="phi.geom.Sphere.face_areas"><code class="name">prop <span class="ident">face_areas</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p>Area of face connecting a pair of cells. Shape <code>(elements, ~)</code>.
Returns 0 for unconnected cells.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_areas(self) -&gt; Tensor:
    return math.zeros(self.face_shape)</code></pre>
</details>
</dd>
<dt id="phi.geom.Sphere.face_centers"><code class="name">prop <span class="ident">face_centers</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p>Center of face connecting a pair of cells. Shape <code>(elements, ~, vector)</code>.
Here, <code>~</code> represents arbitrary internal dual dimensions, such as <code>~staggered_direction</code> or <code>~elements</code>.
Returns 0-vectors for unconnected cells.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_centers(self) -&gt; Tensor:
    return math.zeros(self.shape &amp; dual(shell=0))</code></pre>
</details>
</dd>
<dt id="phi.geom.Sphere.face_normals"><code class="name">prop <span class="ident">face_normals</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p>Normal vectors of cell faces, including boundary faces. Shape <code>(elements, ~, vector)</code>.
For meshes, The vectors point out of the primal cells and into the dual cells.</p>
<p>Instance/spatial dimensions along which the normal does not vary may not be included in the result tensor's shape.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_normals(self) -&gt; Tensor:
    return math.zeros(self.shape &amp; dual(shell=0))</code></pre>
</details>
</dd>
<dt id="phi.geom.Sphere.face_shape"><code class="name">prop <span class="ident">face_shape</span> : phiml.math._shape.Shape</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<p>Full Shape to identify each face of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>, including instance/spatial dimensions for the elements and dual dimensions listing the faces per element.
If this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> has no faces, returns an empty <code>Shape</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_shape(self) -&gt; Shape:
    return self.shape.without(&#39;vector&#39;) &amp; dual(shell=0)</code></pre>
</details>
</dd>
<dt id="phi.geom.Sphere.faces"><code class="name">prop <span class="ident">faces</span> : <a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def faces(self) -&gt; &#39;Geometry&#39;:
    raise NotImplementedError(f&#34;Sphere.faces not implemented.&#34;)</code></pre>
</details>
</dd>
<dt id="phi.geom.Sphere.radius"><code class="name">prop <span class="ident">radius</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def radius(self):
    return self._radius</code></pre>
</details>
</dd>
<dt id="phi.geom.Sphere.shape"><code class="name">prop <span class="ident">shape</span></code></dt>
<dd>
<div class="desc"><p>The <code>shape</code> of a <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> consists of the following dimensions:</p>
<ul>
<li>A single <em>channel</em> dimension called <code>'vector'</code> specifying the physical space</li>
<li>Instance dimensions denote that this geometry consists of multiple copies in the same space</li>
<li>Spatial dimensions denote a crystal (repeating structure) of this geometric primitive in space</li>
<li>Batch dimensions indicate non-interacting versions of this geometry for parallelization only.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape(self):
    if self._center is None or self._radius is None:
        return None
    return self._center.shape &amp; self._radius.shape</code></pre>
</details>
</dd>
<dt id="phi.geom.Sphere.volume"><code class="name">prop <span class="ident">volume</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p><code>phi.math.Tensor</code> representing the volume of each element.
The result retains batch, spatial and instance dimensions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def volume(self) -&gt; math.Tensor:
    return Sphere.volume_from_radius(self._radius, self.spatial_rank)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phi.geom.Sphere.approximate_closest_surface"><code class="name flex">
<span>def <span class="ident">approximate_closest_surface</span></span>(<span>self, location: phiml.math._tensors.Tensor) ‑> Tuple[phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor]</span>
</code></dt>
<dd>
<div class="desc"><p>Find the closest surface face of this geometry given a point that can be outside or inside the geometry.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd><code>Tensor</code> with a single channel dimension called vector. Can have arbitrary other dimensions.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>signed_distance</code></dt>
<dd>Scalar signed distance from <code>location</code>
to the closest point on the surface.
Positive values indicate the point lies outside the geometry, negative values indicate the point lies inside the geometry.</dd>
<dt><code>delta</code></dt>
<dd>Vector-valued distance vector from <code>location</code> to the closest point on the surface.</dd>
<dt><code>normal</code></dt>
<dd>Closest surface normal vector.</dd>
<dt><code>offset</code></dt>
<dd>Min distance of a surface-tangential plane from 0 as a scalar.</dd>
<dt><code>face_index</code></dt>
<dd>(Optional) An index vector pointing at the closest face.</dd>
</dl></div>
</dd>
<dt id="phi.geom.Sphere.approximate_signed_distance"><code class="name flex">
<span>def <span class="ident">approximate_signed_distance</span></span>(<span>self, location: Union[phiml.math._tensors.Tensor, tuple])</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the exact distance from location to the closest point on the sphere.
Very close to the sphere center, the distance takes a constant value.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd>float tensor of shape (batch_size, &hellip;, rank)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>float tensor of shape (*location.shape[:-1], 1).</p></div>
</dd>
<dt id="phi.geom.Sphere.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>self, center: phiml.math._tensors.Tensor) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a copy of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> with the center at <code>center</code>.
This is equal to calling <code>self @ center</code>.</p>
<p>See Also:
<code><a title="phi.geom.Geometry.shifted" href="#phi.geom.Geometry.shifted">Geometry.shifted()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>center</code></strong></dt>
<dd>New center as <code>Tensor</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.</p></div>
</dd>
<dt id="phi.geom.Sphere.bounding_half_extent"><code class="name flex">
<span>def <span class="ident">bounding_half_extent</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>The bounding half-extent sets a limit on the outer-most point for each coordinate axis.
Each component is non-negative.</p>
<p>Let the bounding half-extent have value <code>e</code> in dimension <code>d</code> (<code>extent[...,d] = e</code>).
Then, no point of the geometry lies further away from its center point than <code>e</code> along <code>d</code> (in both axis directions).</p>
<p>When this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.
If these dims are not present, all parts are assumed to have the same bounds.</p></div>
</dd>
<dt id="phi.geom.Sphere.bounding_radius"><code class="name flex">
<span>def <span class="ident">bounding_radius</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the radius of a Sphere object that fully encloses this geometry.
The sphere is centered at the center of this geometry.</p>
<p>:return: radius of type float</p>
<p>Args:</p>
<p>Returns:</p></div>
</dd>
<dt id="phi.geom.Sphere.lies_inside"><code class="name flex">
<span>def <span class="ident">lies_inside</span></span>(<span>self, location)</span>
</code></dt>
<dd>
<div class="desc"><p>Tests whether the given location lies inside or outside of the geometry. Locations on the surface count as inside.</p>
<p>When dealing with unions or collections of geometries (instance dimensions), a point lies inside the geometry if it lies inside any instance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd>float tensor of shape (batch_size, &hellip;, rank)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>bool tensor of shape (*location.shape[:-1], 1).</p></div>
</dd>
<dt id="phi.geom.Sphere.rotated"><code class="name flex">
<span>def <span class="ident">rotated</span></span>(<span>self, angle)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a rotated version of this geometry.
The geometry is rotated about its center point.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>angle</code></strong></dt>
<dd>
<p>Delta rotation.
Either</p>
<ul>
<li>Angle(s): scalar angle in 2d or euler angles along <code>vector</code> in 3D or higher.</li>
<li>Matrix: d⨯d rotation matrix</li>
</ul>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Rotated <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></p></div>
</dd>
<dt id="phi.geom.Sphere.sample_uniform"><code class="name flex">
<span>def <span class="ident">sample_uniform</span></span>(<span>self, *shape: phiml.math._shape.Shape)</span>
</code></dt>
<dd>
<div class="desc"><p>Samples uniformly distributed random points inside this volume.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*shape</code></strong></dt>
<dd>How many points to sample per individual geometry.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>Tensor</code> containing all dimensions from <code><a title="phi.geom.Geometry.shape" href="#phi.geom.Geometry.shape">Geometry.shape</a></code>, <code>shape</code> as well as a <code>channel</code> dimension <code>vector</code> matching the dimensionality of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.</p></div>
</dd>
<dt id="phi.geom.Sphere.scaled"><code class="name flex">
<span>def <span class="ident">scaled</span></span>(<span>self, factor: Union[phiml.math._tensors.Tensor, float]) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<div class="desc"><p>Scales each individual geometry by <code>factor</code>.
The individual <code>center</code> points act as pivots for the operation.</p>
<h2 id="args">Args</h2>
<p>factor:
Returns:</p></div>
</dd>
</dl>
</dd>
<dt id="phi.geom.UniformGrid"><code class="flex name class">
<span>class <span class="ident">UniformGrid</span></span>
<span>(</span><span>resolution: phiml.math._shape.Shape = None, bounds: phi.geom._box.BaseBox = None, **resolution_)</span>
</code></dt>
<dd>
<div class="desc"><p>An instance of UniformGrid represents all cells of a regular grid as a batch of boxes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UniformGrid(BaseBox):
    &#34;&#34;&#34;
    An instance of UniformGrid represents all cells of a regular grid as a batch of boxes.
    &#34;&#34;&#34;

    def __init__(self, resolution: Shape = None, bounds: BaseBox = None, **resolution_):
        assert resolution is None or resolution.is_uniform, f&#34;spatial dimensions must form a uniform grid but got {resolution}&#34;
        resolution = (resolution or EMPTY_SHAPE).spatial &amp; spatial(**resolution_)
        bounds = _get_bounds(bounds, resolution)
        assert set(bounds.vector.item_names) == set(resolution.names)
        self._resolution = resolution.only(bounds.vector.item_names, reorder=True)  # reorder only
        self._bounds = bounds
        self._shape = self._resolution &amp; bounds.shape.non_spatial

    @property
    def resolution(self):
        return self._resolution

    @property
    def bounds(self):
        return self._bounds

    @property
    def spatial_rank(self) -&gt; int:
        return self._resolution.spatial_rank

    @property
    def center(self):
        local_coords = math.meshgrid(**{dim.name: math.linspace(0.5 / dim.size, 1 - 0.5 / dim.size, dim) for dim in self.resolution})
        points = self.bounds.local_to_global(local_coords)
        return points

    @property
    def boundary_elements(self) -&gt; Dict[Any, Dict[str, slice]]:
        return {}

    @property
    def boundary_faces(self) -&gt; Dict[Any, Dict[str, slice]]:
        result = {}
        for dim in self.vector.item_names:
            result[dim+&#39;-&#39;] = {&#39;~vector&#39;: dim, dim: slice(1)}
            result[dim+&#39;+&#39;] = {&#39;~vector&#39;: dim, dim: slice(-1, None)}
        return result

    @property
    def face_centers(self) -&gt; Tensor:
        centers = [self.stagger(dim, True, True).center for dim in self.vector.item_names]
        return stack(centers, dual(vector=self.vector.item_names))

    @property
    def faces(self) -&gt; Geometry:
        slices = [self.stagger(d, True, True) for d in self.resolution.names]
        return stack(slices, dual(vector=self.vector.item_names))

    @property
    def face_normals(self) -&gt; Tensor:
        normals = [vec(**{d: float(d == dim) for d in self.vector.item_names}) for dim in self.vector.item_names]
        return stack(normals, dual(vector=self.vector.item_names))

    @property
    def face_areas(self) -&gt; Tensor:
        areas = [math.prod(self.dx.vector[[d for d in self.vector.item_names if d != dim]], &#39;vector&#39;) for dim in self.vector.item_names]
        return stack(areas, dual(vector=self.vector.item_names))

    @property
    def face_shape(self) -&gt; Shape:
        shapes = [self._shape.spatial.with_dim_size(dim, self._shape.get_size(dim) + 1) for dim in self.vector.item_names]
        return shape_stack(dual(vector=self.vector.item_names), *shapes)

    def interior(self) -&gt; &#39;Geometry&#39;:
        raise GeometryException(&#34;Regular grid does not have an interior&#34;)

    @property
    def grid_size(self):
        return self._bounds.size

    @property
    def size(self):
        return self.bounds.size / math.wrap(self.resolution.sizes)

    @property
    def dx(self):
        return self.bounds.size / self.resolution

    @property
    def lower(self):
        return self.center - self.half_size

    @property
    def upper(self):
        return self.center + self.half_size

    @property
    def half_size(self):
        return self.bounds.size / self.resolution.sizes / 2

    @property
    def rotation_matrix(self) -&gt; Optional[Tensor]:
        return None

    def __getitem__(self, item):
        item = slicing_dict(self, item)
        resolution = self._resolution.after_gather(item)
        bounds = self._bounds[{d: s for d, s in item.items() if d != &#39;vector&#39;}]
        if &#39;vector&#39; in item:
            resolution = resolution.only(item[&#39;vector&#39;], reorder=True)
            bounds = bounds.vector[item[&#39;vector&#39;]]
        bounds = bounds.vector[resolution.name_list]
        dx = self.size
        for dim, selection in item.items():
            if dim in resolution:
                if isinstance(selection, slice):
                    start = selection.start or 0
                    if start &lt; 0:
                        start += self.resolution.get_size(dim)
                    stop = selection.stop or self.resolution.get_size(dim)
                    if stop &lt; 0:
                        stop += self.resolution.get_size(dim)
                    assert selection.step is None or selection.step == 1
                else:  # int slices are not contained in resolution anymore
                    raise ValueError(f&#34;Illegal selection: {item}&#34;)
                dim_mask = math.wrap(self.resolution.mask(dim))
                lower = bounds.lower + start * dim_mask * dx
                upper = bounds.upper + (stop - self.resolution.get_size(dim)) * dim_mask * dx
                bounds = Box(lower, upper)
        return UniformGrid(resolution, bounds)

    def __pack_dims__(self, dims: Tuple[str, ...], packed_dim: Shape, pos: Optional[int], **kwargs) -&gt; &#39;Cuboid&#39;:
        return math.pack_dims(self.center_representation(size_variable=False), dims, packed_dim, pos, **kwargs)

    @staticmethod
    def __stack__(values: tuple, dim: Shape, **kwargs) -&gt; &#39;Geometry&#39;:
        from ._geom_ops import GeometryStack
        set_op = kwargs.get(&#39;set_op&#39;)
        return GeometryStack(math.layout(values, dim), set_op)

    def __replace_dims__(self, dims: Tuple[str, ...], new_dims: Shape, **kwargs) -&gt; &#39;UniformGrid&#39;:
        resolution = math.rename_dims(self._resolution, dims, new_dims).spatial
        bounds = math.rename_dims(self._bounds, dims, new_dims, **kwargs)[resolution.name_list]
        return UniformGrid(resolution, bounds)

    def list_cells(self, dim_name):
        center = math.pack_dims(self.center, self._shape.spatial.names, dim_name)
        return Cuboid(center, self.half_size, size_variable=False)

    def stagger(self, dim: str, lower: bool, upper: bool):
        dim_mask = np.array(self.resolution.mask(dim))
        unit = self.bounds.size / self.resolution * dim_mask
        bounds = Box(self.bounds.lower + unit * (-0.5 if lower else 0.5), self.bounds.upper + unit * (0.5 if upper else -0.5))
        ext_res = self.resolution.sizes + dim_mask * (int(lower) + int(upper) - 1)
        return UniformGrid(self.resolution.with_sizes(ext_res), bounds)

    def staggered_cells(self, boundaries: Extrapolation) -&gt; Dict[str, &#39;UniformGrid&#39;]:
        grids = {}
        for dim in self.vector.item_names:
            grids[dim] = self.stagger(dim, *boundaries.valid_outer_faces(dim))
        return grids

    def padded(self, widths: dict):
        resolution, bounds = self.resolution, self.bounds
        for dim, (lower, upper) in widths.items():
            masked_dx = self.dx * math.dim_mask(self.resolution, dim)
            resolution = resolution.with_dim_size(dim, self.resolution.get_size(dim) + lower + upper)
            bounds = Box(bounds.lower - masked_dx * lower, bounds.upper + masked_dx * upper)
        return UniformGrid(resolution, bounds)

    @property
    def shape(self):
        return self._shape

    def shifted(self, delta: Tensor, **delta_by_dim) -&gt; BaseBox:
        # delta += math.padded_stack()
        if delta.shape.spatial_rank == 0:
            return UniformGrid(self.resolution, self.bounds.shifted(delta))
        else:
            center = self.center + delta
            return Cuboid(center, self.half_size, size_variable=False)

    def rotated(self, angle) -&gt; Geometry:
        raise NotImplementedError(&#34;Grids cannot be rotated. Use center_representation() to convert it to Cuboids first.&#34;)

    def shallow_equals(self, other):
        return self == other

    def __repr__(self):
        return f&#34;{self._resolution}, bounds={self._bounds}&#34;

    def __variable_attrs__(self):
        return ()

    def __value_attrs__(self):
        return ()

    def __eq__(self, other):
        if not isinstance(other, UniformGrid):
            return False
        return self._resolution == other._resolution and self._bounds == other._bounds

    def __hash__(self):
        return hash(self._resolution) + hash(self._bounds)

    @property
    def _center(self):
        return self.center

    @property
    def _half_size(self):
        return self.half_size

    @property
    def normal(self) -&gt; Tensor:
        raise GeometryException(&#34;UniformGrid does not have normals&#34;)

    def bounding_half_extent(self) -&gt; Tensor:
        return self.half_size</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.geom._box.BaseBox</li>
<li>phi.geom._geom.Geometry</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="phi.geom.UniformGrid.boundary_elements"><code class="name">prop <span class="ident">boundary_elements</span> : Dict[Any, Dict[str, slice]]</code></dt>
<dd>
<div class="desc"><p>Slices on the primal dimensions to mark boundary elements.
Grids and meshes have no boundary elements and return <code>{}</code>.
Dynamic graphs can define boundary elements for obstacles and walls.</p>
<h2 id="returns">Returns</h2>
<p>Map from <code>(name, is_upper)</code> to slicing <code>dict</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def boundary_elements(self) -&gt; Dict[Any, Dict[str, slice]]:
    return {}</code></pre>
</details>
</dd>
<dt id="phi.geom.UniformGrid.boundary_faces"><code class="name">prop <span class="ident">boundary_faces</span> : Dict[Any, Dict[str, slice]]</code></dt>
<dd>
<div class="desc"><p>Slices on the dual dimensions to mark boundary faces.</p>
<p>Regular grids use the keys (dim, is_upper) to identify boundaries.
Unstructured meshes use string identifiers for the boundaries.
Dynamic graphs return slices along the dual dimensions.</p>
<h2 id="returns">Returns</h2>
<p>Map from <code>(name, is_upper)</code> to slicing <code>dict</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def boundary_faces(self) -&gt; Dict[Any, Dict[str, slice]]:
    result = {}
    for dim in self.vector.item_names:
        result[dim+&#39;-&#39;] = {&#39;~vector&#39;: dim, dim: slice(1)}
        result[dim+&#39;+&#39;] = {&#39;~vector&#39;: dim, dim: slice(-1, None)}
    return result</code></pre>
</details>
</dd>
<dt id="phi.geom.UniformGrid.bounds"><code class="name">prop <span class="ident">bounds</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bounds(self):
    return self._bounds</code></pre>
</details>
</dd>
<dt id="phi.geom.UniformGrid.center"><code class="name">prop <span class="ident">center</span></code></dt>
<dd>
<div class="desc"><p>Center location in single channel dimension.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def center(self):
    local_coords = math.meshgrid(**{dim.name: math.linspace(0.5 / dim.size, 1 - 0.5 / dim.size, dim) for dim in self.resolution})
    points = self.bounds.local_to_global(local_coords)
    return points</code></pre>
</details>
</dd>
<dt id="phi.geom.UniformGrid.dx"><code class="name">prop <span class="ident">dx</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def dx(self):
    return self.bounds.size / self.resolution</code></pre>
</details>
</dd>
<dt id="phi.geom.UniformGrid.face_areas"><code class="name">prop <span class="ident">face_areas</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p>Area of face connecting a pair of cells. Shape <code>(elements, ~)</code>.
Returns 0 for unconnected cells.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_areas(self) -&gt; Tensor:
    areas = [math.prod(self.dx.vector[[d for d in self.vector.item_names if d != dim]], &#39;vector&#39;) for dim in self.vector.item_names]
    return stack(areas, dual(vector=self.vector.item_names))</code></pre>
</details>
</dd>
<dt id="phi.geom.UniformGrid.face_centers"><code class="name">prop <span class="ident">face_centers</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p>Center of face connecting a pair of cells. Shape <code>(elements, ~, vector)</code>.
Here, <code>~</code> represents arbitrary internal dual dimensions, such as <code>~staggered_direction</code> or <code>~elements</code>.
Returns 0-vectors for unconnected cells.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_centers(self) -&gt; Tensor:
    centers = [self.stagger(dim, True, True).center for dim in self.vector.item_names]
    return stack(centers, dual(vector=self.vector.item_names))</code></pre>
</details>
</dd>
<dt id="phi.geom.UniformGrid.face_normals"><code class="name">prop <span class="ident">face_normals</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p>Normal vectors of cell faces, including boundary faces. Shape <code>(elements, ~, vector)</code>.
For meshes, The vectors point out of the primal cells and into the dual cells.</p>
<p>Instance/spatial dimensions along which the normal does not vary may not be included in the result tensor's shape.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_normals(self) -&gt; Tensor:
    normals = [vec(**{d: float(d == dim) for d in self.vector.item_names}) for dim in self.vector.item_names]
    return stack(normals, dual(vector=self.vector.item_names))</code></pre>
</details>
</dd>
<dt id="phi.geom.UniformGrid.face_shape"><code class="name">prop <span class="ident">face_shape</span> : phiml.math._shape.Shape</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<p>Full Shape to identify each face of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>, including instance/spatial dimensions for the elements and dual dimensions listing the faces per element.
If this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> has no faces, returns an empty <code>Shape</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_shape(self) -&gt; Shape:
    shapes = [self._shape.spatial.with_dim_size(dim, self._shape.get_size(dim) + 1) for dim in self.vector.item_names]
    return shape_stack(dual(vector=self.vector.item_names), *shapes)</code></pre>
</details>
</dd>
<dt id="phi.geom.UniformGrid.faces"><code class="name">prop <span class="ident">faces</span> : phi.geom._geom.Geometry</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def faces(self) -&gt; Geometry:
    slices = [self.stagger(d, True, True) for d in self.resolution.names]
    return stack(slices, dual(vector=self.vector.item_names))</code></pre>
</details>
</dd>
<dt id="phi.geom.UniformGrid.grid_size"><code class="name">prop <span class="ident">grid_size</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def grid_size(self):
    return self._bounds.size</code></pre>
</details>
</dd>
<dt id="phi.geom.UniformGrid.half_size"><code class="name">prop <span class="ident">half_size</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def half_size(self):
    return self.bounds.size / self.resolution.sizes / 2</code></pre>
</details>
</dd>
<dt id="phi.geom.UniformGrid.lower"><code class="name">prop <span class="ident">lower</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def lower(self):
    return self.center - self.half_size</code></pre>
</details>
</dd>
<dt id="phi.geom.UniformGrid.normal"><code class="name">prop <span class="ident">normal</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def normal(self) -&gt; Tensor:
    raise GeometryException(&#34;UniformGrid does not have normals&#34;)</code></pre>
</details>
</dd>
<dt id="phi.geom.UniformGrid.resolution"><code class="name">prop <span class="ident">resolution</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def resolution(self):
    return self._resolution</code></pre>
</details>
</dd>
<dt id="phi.geom.UniformGrid.rotation_matrix"><code class="name">prop <span class="ident">rotation_matrix</span> : Optional[phiml.math._tensors.Tensor]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def rotation_matrix(self) -&gt; Optional[Tensor]:
    return None</code></pre>
</details>
</dd>
<dt id="phi.geom.UniformGrid.shape"><code class="name">prop <span class="ident">shape</span></code></dt>
<dd>
<div class="desc"><p>The <code>shape</code> of a <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> consists of the following dimensions:</p>
<ul>
<li>A single <em>channel</em> dimension called <code>'vector'</code> specifying the physical space</li>
<li>Instance dimensions denote that this geometry consists of multiple copies in the same space</li>
<li>Spatial dimensions denote a crystal (repeating structure) of this geometric primitive in space</li>
<li>Batch dimensions indicate non-interacting versions of this geometry for parallelization only.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape(self):
    return self._shape</code></pre>
</details>
</dd>
<dt id="phi.geom.UniformGrid.size"><code class="name">prop <span class="ident">size</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self):
    return self.bounds.size / math.wrap(self.resolution.sizes)</code></pre>
</details>
</dd>
<dt id="phi.geom.UniformGrid.spatial_rank"><code class="name">prop <span class="ident">spatial_rank</span> : int</code></dt>
<dd>
<div class="desc"><p>Number of spatial dimensions of the geometry, 1 = 1D, 2 = 2D, 3 = 3D, etc.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def spatial_rank(self) -&gt; int:
    return self._resolution.spatial_rank</code></pre>
</details>
</dd>
<dt id="phi.geom.UniformGrid.upper"><code class="name">prop <span class="ident">upper</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def upper(self):
    return self.center + self.half_size</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phi.geom.UniformGrid.bounding_half_extent"><code class="name flex">
<span>def <span class="ident">bounding_half_extent</span></span>(<span>self) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>The bounding half-extent sets a limit on the outer-most point for each coordinate axis.
Each component is non-negative.</p>
<p>Let the bounding half-extent have value <code>e</code> in dimension <code>d</code> (<code>extent[...,d] = e</code>).
Then, no point of the geometry lies further away from its center point than <code>e</code> along <code>d</code> (in both axis directions).</p>
<p>When this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.
If these dims are not present, all parts are assumed to have the same bounds.</p></div>
</dd>
<dt id="phi.geom.UniformGrid.interior"><code class="name flex">
<span>def <span class="ident">interior</span></span>(<span>self) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="phi.geom.UniformGrid.list_cells"><code class="name flex">
<span>def <span class="ident">list_cells</span></span>(<span>self, dim_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="phi.geom.UniformGrid.padded"><code class="name flex">
<span>def <span class="ident">padded</span></span>(<span>self, widths: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="phi.geom.UniformGrid.rotated"><code class="name flex">
<span>def <span class="ident">rotated</span></span>(<span>self, angle) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a rotated version of this geometry.
The geometry is rotated about its center point.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>angle</code></strong></dt>
<dd>
<p>Delta rotation.
Either</p>
<ul>
<li>Angle(s): scalar angle in 2d or euler angles along <code>vector</code> in 3D or higher.</li>
<li>Matrix: d⨯d rotation matrix</li>
</ul>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Rotated <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></p></div>
</dd>
<dt id="phi.geom.UniformGrid.shallow_equals"><code class="name flex">
<span>def <span class="ident">shallow_equals</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Quick equality check.
May return <code>False</code> even if <code>other == self</code>.
However, if <code>True</code> is returned, the geometries are guaranteed to be equal.</p>
<p>The <code>shallow_equals()</code> check does not compare all tensor elements but merely checks whether the same tensors are referenced.</p></div>
</dd>
<dt id="phi.geom.UniformGrid.shifted"><code class="name flex">
<span>def <span class="ident">shifted</span></span>(<span>self, delta: phiml.math._tensors.Tensor, **delta_by_dim) ‑> phi.geom._box.BaseBox</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a translated version of this geometry.</p>
<p>See Also:
<code><a title="phi.geom.Geometry.at" href="#phi.geom.Geometry.at">Geometry.at()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>delta</code></strong></dt>
<dd>direction vector</dd>
<dt><strong><code>delta</code></strong></dt>
<dd>Tensor:</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></dt>
<dd>shifted geometry</dd>
</dl></div>
</dd>
<dt id="phi.geom.UniformGrid.stagger"><code class="name flex">
<span>def <span class="ident">stagger</span></span>(<span>self, dim: str, lower: bool, upper: bool)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="phi.geom.UniformGrid.staggered_cells"><code class="name flex">
<span>def <span class="ident">staggered_cells</span></span>(<span>self, boundaries: phiml.math.extrapolation.Extrapolation) ‑> Dict[str, phi.geom._grid.UniformGrid]</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="phi" href="../index.html">phi</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="phi.geom.assert_same_rank" href="#phi.geom.assert_same_rank">assert_same_rank</a></code></li>
<li><code><a title="phi.geom.build_mesh" href="#phi.geom.build_mesh">build_mesh</a></code></li>
<li><code><a title="phi.geom.concat" href="#phi.geom.concat">concat</a></code></li>
<li><code><a title="phi.geom.embed" href="#phi.geom.embed">embed</a></code></li>
<li><code><a title="phi.geom.infinite_cylinder" href="#phi.geom.infinite_cylinder">infinite_cylinder</a></code></li>
<li><code><a title="phi.geom.intersection" href="#phi.geom.intersection">intersection</a></code></li>
<li><code><a title="phi.geom.invert" href="#phi.geom.invert">invert</a></code></li>
<li><code><a title="phi.geom.load_gmsh" href="#phi.geom.load_gmsh">load_gmsh</a></code></li>
<li><code><a title="phi.geom.load_su2" href="#phi.geom.load_su2">load_su2</a></code></li>
<li><code><a title="phi.geom.mesh" href="#phi.geom.mesh">mesh</a></code></li>
<li><code><a title="phi.geom.mesh_from_numpy" href="#phi.geom.mesh_from_numpy">mesh_from_numpy</a></code></li>
<li><code><a title="phi.geom.normal_from_slope" href="#phi.geom.normal_from_slope">normal_from_slope</a></code></li>
<li><code><a title="phi.geom.pack_dims" href="#phi.geom.pack_dims">pack_dims</a></code></li>
<li><code><a title="phi.geom.rotate" href="#phi.geom.rotate">rotate</a></code></li>
<li><code><a title="phi.geom.sdf_from_geometry" href="#phi.geom.sdf_from_geometry">sdf_from_geometry</a></code></li>
<li><code><a title="phi.geom.stack" href="#phi.geom.stack">stack</a></code></li>
<li><code><a title="phi.geom.union" href="#phi.geom.union">union</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="phi.geom.BaseBox" href="#phi.geom.BaseBox">BaseBox</a></code></h4>
<ul class="">
<li><code><a title="phi.geom.BaseBox.approximate_closest_surface" href="#phi.geom.BaseBox.approximate_closest_surface">approximate_closest_surface</a></code></li>
<li><code><a title="phi.geom.BaseBox.approximate_signed_distance" href="#phi.geom.BaseBox.approximate_signed_distance">approximate_signed_distance</a></code></li>
<li><code><a title="phi.geom.BaseBox.boundary_elements" href="#phi.geom.BaseBox.boundary_elements">boundary_elements</a></code></li>
<li><code><a title="phi.geom.BaseBox.boundary_faces" href="#phi.geom.BaseBox.boundary_faces">boundary_faces</a></code></li>
<li><code><a title="phi.geom.BaseBox.bounding_radius" href="#phi.geom.BaseBox.bounding_radius">bounding_radius</a></code></li>
<li><code><a title="phi.geom.BaseBox.box" href="#phi.geom.BaseBox.box">box</a></code></li>
<li><code><a title="phi.geom.BaseBox.center" href="#phi.geom.BaseBox.center">center</a></code></li>
<li><code><a title="phi.geom.BaseBox.center_representation" href="#phi.geom.BaseBox.center_representation">center_representation</a></code></li>
<li><code><a title="phi.geom.BaseBox.contains" href="#phi.geom.BaseBox.contains">contains</a></code></li>
<li><code><a title="phi.geom.BaseBox.corner_representation" href="#phi.geom.BaseBox.corner_representation">corner_representation</a></code></li>
<li><code><a title="phi.geom.BaseBox.corners" href="#phi.geom.BaseBox.corners">corners</a></code></li>
<li><code><a title="phi.geom.BaseBox.face_areas" href="#phi.geom.BaseBox.face_areas">face_areas</a></code></li>
<li><code><a title="phi.geom.BaseBox.face_centers" href="#phi.geom.BaseBox.face_centers">face_centers</a></code></li>
<li><code><a title="phi.geom.BaseBox.face_normals" href="#phi.geom.BaseBox.face_normals">face_normals</a></code></li>
<li><code><a title="phi.geom.BaseBox.face_shape" href="#phi.geom.BaseBox.face_shape">face_shape</a></code></li>
<li><code><a title="phi.geom.BaseBox.faces" href="#phi.geom.BaseBox.faces">faces</a></code></li>
<li><code><a title="phi.geom.BaseBox.global_to_local" href="#phi.geom.BaseBox.global_to_local">global_to_local</a></code></li>
<li><code><a title="phi.geom.BaseBox.half_size" href="#phi.geom.BaseBox.half_size">half_size</a></code></li>
<li><code><a title="phi.geom.BaseBox.is_size_variable" href="#phi.geom.BaseBox.is_size_variable">is_size_variable</a></code></li>
<li><code><a title="phi.geom.BaseBox.lies_inside" href="#phi.geom.BaseBox.lies_inside">lies_inside</a></code></li>
<li><code><a title="phi.geom.BaseBox.local_to_global" href="#phi.geom.BaseBox.local_to_global">local_to_global</a></code></li>
<li><code><a title="phi.geom.BaseBox.lower" href="#phi.geom.BaseBox.lower">lower</a></code></li>
<li><code><a title="phi.geom.BaseBox.project" href="#phi.geom.BaseBox.project">project</a></code></li>
<li><code><a title="phi.geom.BaseBox.push" href="#phi.geom.BaseBox.push">push</a></code></li>
<li><code><a title="phi.geom.BaseBox.rotation_matrix" href="#phi.geom.BaseBox.rotation_matrix">rotation_matrix</a></code></li>
<li><code><a title="phi.geom.BaseBox.sample_uniform" href="#phi.geom.BaseBox.sample_uniform">sample_uniform</a></code></li>
<li><code><a title="phi.geom.BaseBox.scaled" href="#phi.geom.BaseBox.scaled">scaled</a></code></li>
<li><code><a title="phi.geom.BaseBox.shape" href="#phi.geom.BaseBox.shape">shape</a></code></li>
<li><code><a title="phi.geom.BaseBox.size" href="#phi.geom.BaseBox.size">size</a></code></li>
<li><code><a title="phi.geom.BaseBox.upper" href="#phi.geom.BaseBox.upper">upper</a></code></li>
<li><code><a title="phi.geom.BaseBox.volume" href="#phi.geom.BaseBox.volume">volume</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.geom.Box" href="#phi.geom.Box">Box</a></code></h4>
<ul class="">
<li><code><a title="phi.geom.Box.at" href="#phi.geom.Box.at">at</a></code></li>
<li><code><a title="phi.geom.Box.bounding_half_extent" href="#phi.geom.Box.bounding_half_extent">bounding_half_extent</a></code></li>
<li><code><a title="phi.geom.Box.center" href="#phi.geom.Box.center">center</a></code></li>
<li><code><a title="phi.geom.Box.half_size" href="#phi.geom.Box.half_size">half_size</a></code></li>
<li><code><a title="phi.geom.Box.is_size_variable" href="#phi.geom.Box.is_size_variable">is_size_variable</a></code></li>
<li><code><a title="phi.geom.Box.largest" href="#phi.geom.Box.largest">largest</a></code></li>
<li><code><a title="phi.geom.Box.lower" href="#phi.geom.Box.lower">lower</a></code></li>
<li><code><a title="phi.geom.Box.rotated" href="#phi.geom.Box.rotated">rotated</a></code></li>
<li><code><a title="phi.geom.Box.rotation_matrix" href="#phi.geom.Box.rotation_matrix">rotation_matrix</a></code></li>
<li><code><a title="phi.geom.Box.shape" href="#phi.geom.Box.shape">shape</a></code></li>
<li><code><a title="phi.geom.Box.shifted" href="#phi.geom.Box.shifted">shifted</a></code></li>
<li><code><a title="phi.geom.Box.size" href="#phi.geom.Box.size">size</a></code></li>
<li><code><a title="phi.geom.Box.smallest" href="#phi.geom.Box.smallest">smallest</a></code></li>
<li><code><a title="phi.geom.Box.upper" href="#phi.geom.Box.upper">upper</a></code></li>
<li><code><a title="phi.geom.Box.without" href="#phi.geom.Box.without">without</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.geom.Cuboid" href="#phi.geom.Cuboid">Cuboid</a></code></h4>
<ul class="">
<li><code><a title="phi.geom.Cuboid.at" href="#phi.geom.Cuboid.at">at</a></code></li>
<li><code><a title="phi.geom.Cuboid.bounding_half_extent" href="#phi.geom.Cuboid.bounding_half_extent">bounding_half_extent</a></code></li>
<li><code><a title="phi.geom.Cuboid.center" href="#phi.geom.Cuboid.center">center</a></code></li>
<li><code><a title="phi.geom.Cuboid.half_size" href="#phi.geom.Cuboid.half_size">half_size</a></code></li>
<li><code><a title="phi.geom.Cuboid.is_size_variable" href="#phi.geom.Cuboid.is_size_variable">is_size_variable</a></code></li>
<li><code><a title="phi.geom.Cuboid.lies_inside" href="#phi.geom.Cuboid.lies_inside">lies_inside</a></code></li>
<li><code><a title="phi.geom.Cuboid.lower" href="#phi.geom.Cuboid.lower">lower</a></code></li>
<li><code><a title="phi.geom.Cuboid.rotated" href="#phi.geom.Cuboid.rotated">rotated</a></code></li>
<li><code><a title="phi.geom.Cuboid.rotation_matrix" href="#phi.geom.Cuboid.rotation_matrix">rotation_matrix</a></code></li>
<li><code><a title="phi.geom.Cuboid.shape" href="#phi.geom.Cuboid.shape">shape</a></code></li>
<li><code><a title="phi.geom.Cuboid.size" href="#phi.geom.Cuboid.size">size</a></code></li>
<li><code><a title="phi.geom.Cuboid.upper" href="#phi.geom.Cuboid.upper">upper</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></h4>
<ul class="">
<li><code><a title="phi.geom.Geometry.approximate_closest_surface" href="#phi.geom.Geometry.approximate_closest_surface">approximate_closest_surface</a></code></li>
<li><code><a title="phi.geom.Geometry.approximate_fraction_inside" href="#phi.geom.Geometry.approximate_fraction_inside">approximate_fraction_inside</a></code></li>
<li><code><a title="phi.geom.Geometry.approximate_signed_distance" href="#phi.geom.Geometry.approximate_signed_distance">approximate_signed_distance</a></code></li>
<li><code><a title="phi.geom.Geometry.at" href="#phi.geom.Geometry.at">at</a></code></li>
<li><code><a title="phi.geom.Geometry.boundary_elements" href="#phi.geom.Geometry.boundary_elements">boundary_elements</a></code></li>
<li><code><a title="phi.geom.Geometry.boundary_faces" href="#phi.geom.Geometry.boundary_faces">boundary_faces</a></code></li>
<li><code><a title="phi.geom.Geometry.bounding_box" href="#phi.geom.Geometry.bounding_box">bounding_box</a></code></li>
<li><code><a title="phi.geom.Geometry.bounding_half_extent" href="#phi.geom.Geometry.bounding_half_extent">bounding_half_extent</a></code></li>
<li><code><a title="phi.geom.Geometry.bounding_radius" href="#phi.geom.Geometry.bounding_radius">bounding_radius</a></code></li>
<li><code><a title="phi.geom.Geometry.center" href="#phi.geom.Geometry.center">center</a></code></li>
<li><code><a title="phi.geom.Geometry.corners" href="#phi.geom.Geometry.corners">corners</a></code></li>
<li><code><a title="phi.geom.Geometry.face_areas" href="#phi.geom.Geometry.face_areas">face_areas</a></code></li>
<li><code><a title="phi.geom.Geometry.face_centers" href="#phi.geom.Geometry.face_centers">face_centers</a></code></li>
<li><code><a title="phi.geom.Geometry.face_normals" href="#phi.geom.Geometry.face_normals">face_normals</a></code></li>
<li><code><a title="phi.geom.Geometry.face_shape" href="#phi.geom.Geometry.face_shape">face_shape</a></code></li>
<li><code><a title="phi.geom.Geometry.faces" href="#phi.geom.Geometry.faces">faces</a></code></li>
<li><code><a title="phi.geom.Geometry.integrate_flux" href="#phi.geom.Geometry.integrate_flux">integrate_flux</a></code></li>
<li><code><a title="phi.geom.Geometry.integrate_surface" href="#phi.geom.Geometry.integrate_surface">integrate_surface</a></code></li>
<li><code><a title="phi.geom.Geometry.lies_inside" href="#phi.geom.Geometry.lies_inside">lies_inside</a></code></li>
<li><code><a title="phi.geom.Geometry.push" href="#phi.geom.Geometry.push">push</a></code></li>
<li><code><a title="phi.geom.Geometry.rotated" href="#phi.geom.Geometry.rotated">rotated</a></code></li>
<li><code><a title="phi.geom.Geometry.sample_uniform" href="#phi.geom.Geometry.sample_uniform">sample_uniform</a></code></li>
<li><code><a title="phi.geom.Geometry.scaled" href="#phi.geom.Geometry.scaled">scaled</a></code></li>
<li><code><a title="phi.geom.Geometry.shallow_equals" href="#phi.geom.Geometry.shallow_equals">shallow_equals</a></code></li>
<li><code><a title="phi.geom.Geometry.shape" href="#phi.geom.Geometry.shape">shape</a></code></li>
<li><code><a title="phi.geom.Geometry.shifted" href="#phi.geom.Geometry.shifted">shifted</a></code></li>
<li><code><a title="phi.geom.Geometry.spatial_rank" href="#phi.geom.Geometry.spatial_rank">spatial_rank</a></code></li>
<li><code><a title="phi.geom.Geometry.unstack" href="#phi.geom.Geometry.unstack">unstack</a></code></li>
<li><code><a title="phi.geom.Geometry.volume" href="#phi.geom.Geometry.volume">volume</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.geom.GeometryException" href="#phi.geom.GeometryException">GeometryException</a></code></h4>
</li>
<li>
<h4><code><a title="phi.geom.Graph" href="#phi.geom.Graph">Graph</a></code></h4>
<ul class="">
<li><code><a title="phi.geom.Graph.approximate_closest_surface" href="#phi.geom.Graph.approximate_closest_surface">approximate_closest_surface</a></code></li>
<li><code><a title="phi.geom.Graph.approximate_signed_distance" href="#phi.geom.Graph.approximate_signed_distance">approximate_signed_distance</a></code></li>
<li><code><a title="phi.geom.Graph.as_points" href="#phi.geom.Graph.as_points">as_points</a></code></li>
<li><code><a title="phi.geom.Graph.at" href="#phi.geom.Graph.at">at</a></code></li>
<li><code><a title="phi.geom.Graph.boundary_elements" href="#phi.geom.Graph.boundary_elements">boundary_elements</a></code></li>
<li><code><a title="phi.geom.Graph.boundary_faces" href="#phi.geom.Graph.boundary_faces">boundary_faces</a></code></li>
<li><code><a title="phi.geom.Graph.bounding_distance" href="#phi.geom.Graph.bounding_distance">bounding_distance</a></code></li>
<li><code><a title="phi.geom.Graph.bounding_half_extent" href="#phi.geom.Graph.bounding_half_extent">bounding_half_extent</a></code></li>
<li><code><a title="phi.geom.Graph.bounding_radius" href="#phi.geom.Graph.bounding_radius">bounding_radius</a></code></li>
<li><code><a title="phi.geom.Graph.center" href="#phi.geom.Graph.center">center</a></code></li>
<li><code><a title="phi.geom.Graph.connectivity" href="#phi.geom.Graph.connectivity">connectivity</a></code></li>
<li><code><a title="phi.geom.Graph.deltas" href="#phi.geom.Graph.deltas">deltas</a></code></li>
<li><code><a title="phi.geom.Graph.distances" href="#phi.geom.Graph.distances">distances</a></code></li>
<li><code><a title="phi.geom.Graph.edges" href="#phi.geom.Graph.edges">edges</a></code></li>
<li><code><a title="phi.geom.Graph.face_areas" href="#phi.geom.Graph.face_areas">face_areas</a></code></li>
<li><code><a title="phi.geom.Graph.face_centers" href="#phi.geom.Graph.face_centers">face_centers</a></code></li>
<li><code><a title="phi.geom.Graph.face_normals" href="#phi.geom.Graph.face_normals">face_normals</a></code></li>
<li><code><a title="phi.geom.Graph.face_shape" href="#phi.geom.Graph.face_shape">face_shape</a></code></li>
<li><code><a title="phi.geom.Graph.faces" href="#phi.geom.Graph.faces">faces</a></code></li>
<li><code><a title="phi.geom.Graph.lies_inside" href="#phi.geom.Graph.lies_inside">lies_inside</a></code></li>
<li><code><a title="phi.geom.Graph.nodes" href="#phi.geom.Graph.nodes">nodes</a></code></li>
<li><code><a title="phi.geom.Graph.rotated" href="#phi.geom.Graph.rotated">rotated</a></code></li>
<li><code><a title="phi.geom.Graph.sample_uniform" href="#phi.geom.Graph.sample_uniform">sample_uniform</a></code></li>
<li><code><a title="phi.geom.Graph.scaled" href="#phi.geom.Graph.scaled">scaled</a></code></li>
<li><code><a title="phi.geom.Graph.shape" href="#phi.geom.Graph.shape">shape</a></code></li>
<li><code><a title="phi.geom.Graph.shifted" href="#phi.geom.Graph.shifted">shifted</a></code></li>
<li><code><a title="phi.geom.Graph.unit_deltas" href="#phi.geom.Graph.unit_deltas">unit_deltas</a></code></li>
<li><code><a title="phi.geom.Graph.volume" href="#phi.geom.Graph.volume">volume</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.geom.Heightmap" href="#phi.geom.Heightmap">Heightmap</a></code></h4>
<ul class="">
<li><code><a title="phi.geom.Heightmap.approximate_closest_surface" href="#phi.geom.Heightmap.approximate_closest_surface">approximate_closest_surface</a></code></li>
<li><code><a title="phi.geom.Heightmap.approximate_signed_distance" href="#phi.geom.Heightmap.approximate_signed_distance">approximate_signed_distance</a></code></li>
<li><code><a title="phi.geom.Heightmap.at" href="#phi.geom.Heightmap.at">at</a></code></li>
<li><code><a title="phi.geom.Heightmap.boundary_elements" href="#phi.geom.Heightmap.boundary_elements">boundary_elements</a></code></li>
<li><code><a title="phi.geom.Heightmap.boundary_faces" href="#phi.geom.Heightmap.boundary_faces">boundary_faces</a></code></li>
<li><code><a title="phi.geom.Heightmap.bounding_half_extent" href="#phi.geom.Heightmap.bounding_half_extent">bounding_half_extent</a></code></li>
<li><code><a title="phi.geom.Heightmap.bounding_radius" href="#phi.geom.Heightmap.bounding_radius">bounding_radius</a></code></li>
<li><code><a title="phi.geom.Heightmap.bounds" href="#phi.geom.Heightmap.bounds">bounds</a></code></li>
<li><code><a title="phi.geom.Heightmap.center" href="#phi.geom.Heightmap.center">center</a></code></li>
<li><code><a title="phi.geom.Heightmap.dx" href="#phi.geom.Heightmap.dx">dx</a></code></li>
<li><code><a title="phi.geom.Heightmap.extrapolation" href="#phi.geom.Heightmap.extrapolation">extrapolation</a></code></li>
<li><code><a title="phi.geom.Heightmap.face_areas" href="#phi.geom.Heightmap.face_areas">face_areas</a></code></li>
<li><code><a title="phi.geom.Heightmap.face_centers" href="#phi.geom.Heightmap.face_centers">face_centers</a></code></li>
<li><code><a title="phi.geom.Heightmap.face_normals" href="#phi.geom.Heightmap.face_normals">face_normals</a></code></li>
<li><code><a title="phi.geom.Heightmap.face_shape" href="#phi.geom.Heightmap.face_shape">face_shape</a></code></li>
<li><code><a title="phi.geom.Heightmap.faces" href="#phi.geom.Heightmap.faces">faces</a></code></li>
<li><code><a title="phi.geom.Heightmap.fill_below" href="#phi.geom.Heightmap.fill_below">fill_below</a></code></li>
<li><code><a title="phi.geom.Heightmap.grid_bounds" href="#phi.geom.Heightmap.grid_bounds">grid_bounds</a></code></li>
<li><code><a title="phi.geom.Heightmap.height" href="#phi.geom.Heightmap.height">height</a></code></li>
<li><code><a title="phi.geom.Heightmap.lies_inside" href="#phi.geom.Heightmap.lies_inside">lies_inside</a></code></li>
<li><code><a title="phi.geom.Heightmap.max_dist" href="#phi.geom.Heightmap.max_dist">max_dist</a></code></li>
<li><code><a title="phi.geom.Heightmap.resolution" href="#phi.geom.Heightmap.resolution">resolution</a></code></li>
<li><code><a title="phi.geom.Heightmap.rotated" href="#phi.geom.Heightmap.rotated">rotated</a></code></li>
<li><code><a title="phi.geom.Heightmap.sample_uniform" href="#phi.geom.Heightmap.sample_uniform">sample_uniform</a></code></li>
<li><code><a title="phi.geom.Heightmap.scaled" href="#phi.geom.Heightmap.scaled">scaled</a></code></li>
<li><code><a title="phi.geom.Heightmap.shallow_equals" href="#phi.geom.Heightmap.shallow_equals">shallow_equals</a></code></li>
<li><code><a title="phi.geom.Heightmap.shape" href="#phi.geom.Heightmap.shape">shape</a></code></li>
<li><code><a title="phi.geom.Heightmap.up" href="#phi.geom.Heightmap.up">up</a></code></li>
<li><code><a title="phi.geom.Heightmap.vertices" href="#phi.geom.Heightmap.vertices">vertices</a></code></li>
<li><code><a title="phi.geom.Heightmap.volume" href="#phi.geom.Heightmap.volume">volume</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.geom.Mesh" href="#phi.geom.Mesh">Mesh</a></code></h4>
<ul class="">
<li><code><a title="phi.geom.Mesh.all_boundary_faces" href="#phi.geom.Mesh.all_boundary_faces">all_boundary_faces</a></code></li>
<li><code><a title="phi.geom.Mesh.approximate_closest_surface" href="#phi.geom.Mesh.approximate_closest_surface">approximate_closest_surface</a></code></li>
<li><code><a title="phi.geom.Mesh.approximate_signed_distance" href="#phi.geom.Mesh.approximate_signed_distance">approximate_signed_distance</a></code></li>
<li><code><a title="phi.geom.Mesh.at" href="#phi.geom.Mesh.at">at</a></code></li>
<li><code><a title="phi.geom.Mesh.boundary_connectivity" href="#phi.geom.Mesh.boundary_connectivity">boundary_connectivity</a></code></li>
<li><code><a title="phi.geom.Mesh.boundary_elements" href="#phi.geom.Mesh.boundary_elements">boundary_elements</a></code></li>
<li><code><a title="phi.geom.Mesh.boundary_faces" href="#phi.geom.Mesh.boundary_faces">boundary_faces</a></code></li>
<li><code><a title="phi.geom.Mesh.bounding_half_extent" href="#phi.geom.Mesh.bounding_half_extent">bounding_half_extent</a></code></li>
<li><code><a title="phi.geom.Mesh.bounding_radius" href="#phi.geom.Mesh.bounding_radius">bounding_radius</a></code></li>
<li><code><a title="phi.geom.Mesh.bounds" href="#phi.geom.Mesh.bounds">bounds</a></code></li>
<li><code><a title="phi.geom.Mesh.cell_connectivity" href="#phi.geom.Mesh.cell_connectivity">cell_connectivity</a></code></li>
<li><code><a title="phi.geom.Mesh.cell_count" href="#phi.geom.Mesh.cell_count">cell_count</a></code></li>
<li><code><a title="phi.geom.Mesh.cell_walk_towards" href="#phi.geom.Mesh.cell_walk_towards">cell_walk_towards</a></code></li>
<li><code><a title="phi.geom.Mesh.center" href="#phi.geom.Mesh.center">center</a></code></li>
<li><code><a title="phi.geom.Mesh.connectivity" href="#phi.geom.Mesh.connectivity">connectivity</a></code></li>
<li><code><a title="phi.geom.Mesh.distance_matrix" href="#phi.geom.Mesh.distance_matrix">distance_matrix</a></code></li>
<li><code><a title="phi.geom.Mesh.element_rank" href="#phi.geom.Mesh.element_rank">element_rank</a></code></li>
<li><code><a title="phi.geom.Mesh.elements" href="#phi.geom.Mesh.elements">elements</a></code></li>
<li><code><a title="phi.geom.Mesh.face_areas" href="#phi.geom.Mesh.face_areas">face_areas</a></code></li>
<li><code><a title="phi.geom.Mesh.face_centers" href="#phi.geom.Mesh.face_centers">face_centers</a></code></li>
<li><code><a title="phi.geom.Mesh.face_normals" href="#phi.geom.Mesh.face_normals">face_normals</a></code></li>
<li><code><a title="phi.geom.Mesh.face_shape" href="#phi.geom.Mesh.face_shape">face_shape</a></code></li>
<li><code><a title="phi.geom.Mesh.faces" href="#phi.geom.Mesh.faces">faces</a></code></li>
<li><code><a title="phi.geom.Mesh.faces_to_vertices" href="#phi.geom.Mesh.faces_to_vertices">faces_to_vertices</a></code></li>
<li><code><a title="phi.geom.Mesh.interior_faces" href="#phi.geom.Mesh.interior_faces">interior_faces</a></code></li>
<li><code><a title="phi.geom.Mesh.lies_inside" href="#phi.geom.Mesh.lies_inside">lies_inside</a></code></li>
<li><code><a title="phi.geom.Mesh.neighbor_distances" href="#phi.geom.Mesh.neighbor_distances">neighbor_distances</a></code></li>
<li><code><a title="phi.geom.Mesh.neighbor_offsets" href="#phi.geom.Mesh.neighbor_offsets">neighbor_offsets</a></code></li>
<li><code><a title="phi.geom.Mesh.pad_boundary" href="#phi.geom.Mesh.pad_boundary">pad_boundary</a></code></li>
<li><code><a title="phi.geom.Mesh.polygons" href="#phi.geom.Mesh.polygons">polygons</a></code></li>
<li><code><a title="phi.geom.Mesh.relative_face_distance" href="#phi.geom.Mesh.relative_face_distance">relative_face_distance</a></code></li>
<li><code><a title="phi.geom.Mesh.rotated" href="#phi.geom.Mesh.rotated">rotated</a></code></li>
<li><code><a title="phi.geom.Mesh.sample_uniform" href="#phi.geom.Mesh.sample_uniform">sample_uniform</a></code></li>
<li><code><a title="phi.geom.Mesh.scaled" href="#phi.geom.Mesh.scaled">scaled</a></code></li>
<li><code><a title="phi.geom.Mesh.shape" href="#phi.geom.Mesh.shape">shape</a></code></li>
<li><code><a title="phi.geom.Mesh.vertices" href="#phi.geom.Mesh.vertices">vertices</a></code></li>
<li><code><a title="phi.geom.Mesh.volume" href="#phi.geom.Mesh.volume">volume</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.geom.Point" href="#phi.geom.Point">Point</a></code></h4>
<ul class="">
<li><code><a title="phi.geom.Point.approximate_signed_distance" href="#phi.geom.Point.approximate_signed_distance">approximate_signed_distance</a></code></li>
<li><code><a title="phi.geom.Point.at" href="#phi.geom.Point.at">at</a></code></li>
<li><code><a title="phi.geom.Point.boundary_elements" href="#phi.geom.Point.boundary_elements">boundary_elements</a></code></li>
<li><code><a title="phi.geom.Point.boundary_faces" href="#phi.geom.Point.boundary_faces">boundary_faces</a></code></li>
<li><code><a title="phi.geom.Point.bounding_half_extent" href="#phi.geom.Point.bounding_half_extent">bounding_half_extent</a></code></li>
<li><code><a title="phi.geom.Point.bounding_radius" href="#phi.geom.Point.bounding_radius">bounding_radius</a></code></li>
<li><code><a title="phi.geom.Point.center" href="#phi.geom.Point.center">center</a></code></li>
<li><code><a title="phi.geom.Point.corners" href="#phi.geom.Point.corners">corners</a></code></li>
<li><code><a title="phi.geom.Point.face_areas" href="#phi.geom.Point.face_areas">face_areas</a></code></li>
<li><code><a title="phi.geom.Point.face_centers" href="#phi.geom.Point.face_centers">face_centers</a></code></li>
<li><code><a title="phi.geom.Point.face_normals" href="#phi.geom.Point.face_normals">face_normals</a></code></li>
<li><code><a title="phi.geom.Point.face_shape" href="#phi.geom.Point.face_shape">face_shape</a></code></li>
<li><code><a title="phi.geom.Point.faces" href="#phi.geom.Point.faces">faces</a></code></li>
<li><code><a title="phi.geom.Point.lies_inside" href="#phi.geom.Point.lies_inside">lies_inside</a></code></li>
<li><code><a title="phi.geom.Point.rotated" href="#phi.geom.Point.rotated">rotated</a></code></li>
<li><code><a title="phi.geom.Point.sample_uniform" href="#phi.geom.Point.sample_uniform">sample_uniform</a></code></li>
<li><code><a title="phi.geom.Point.scaled" href="#phi.geom.Point.scaled">scaled</a></code></li>
<li><code><a title="phi.geom.Point.shape" href="#phi.geom.Point.shape">shape</a></code></li>
<li><code><a title="phi.geom.Point.unstack" href="#phi.geom.Point.unstack">unstack</a></code></li>
<li><code><a title="phi.geom.Point.volume" href="#phi.geom.Point.volume">volume</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.geom.SDFGrid" href="#phi.geom.SDFGrid">SDFGrid</a></code></h4>
<ul class="">
<li><code><a title="phi.geom.SDFGrid.approximate_closest_surface" href="#phi.geom.SDFGrid.approximate_closest_surface">approximate_closest_surface</a></code></li>
<li><code><a title="phi.geom.SDFGrid.approximate_signed_distance" href="#phi.geom.SDFGrid.approximate_signed_distance">approximate_signed_distance</a></code></li>
<li><code><a title="phi.geom.SDFGrid.at" href="#phi.geom.SDFGrid.at">at</a></code></li>
<li><code><a title="phi.geom.SDFGrid.boundary_elements" href="#phi.geom.SDFGrid.boundary_elements">boundary_elements</a></code></li>
<li><code><a title="phi.geom.SDFGrid.boundary_faces" href="#phi.geom.SDFGrid.boundary_faces">boundary_faces</a></code></li>
<li><code><a title="phi.geom.SDFGrid.bounding_half_extent" href="#phi.geom.SDFGrid.bounding_half_extent">bounding_half_extent</a></code></li>
<li><code><a title="phi.geom.SDFGrid.bounding_radius" href="#phi.geom.SDFGrid.bounding_radius">bounding_radius</a></code></li>
<li><code><a title="phi.geom.SDFGrid.bounds" href="#phi.geom.SDFGrid.bounds">bounds</a></code></li>
<li><code><a title="phi.geom.SDFGrid.center" href="#phi.geom.SDFGrid.center">center</a></code></li>
<li><code><a title="phi.geom.SDFGrid.corners" href="#phi.geom.SDFGrid.corners">corners</a></code></li>
<li><code><a title="phi.geom.SDFGrid.face_areas" href="#phi.geom.SDFGrid.face_areas">face_areas</a></code></li>
<li><code><a title="phi.geom.SDFGrid.face_centers" href="#phi.geom.SDFGrid.face_centers">face_centers</a></code></li>
<li><code><a title="phi.geom.SDFGrid.face_normals" href="#phi.geom.SDFGrid.face_normals">face_normals</a></code></li>
<li><code><a title="phi.geom.SDFGrid.face_shape" href="#phi.geom.SDFGrid.face_shape">face_shape</a></code></li>
<li><code><a title="phi.geom.SDFGrid.faces" href="#phi.geom.SDFGrid.faces">faces</a></code></li>
<li><code><a title="phi.geom.SDFGrid.lies_inside" href="#phi.geom.SDFGrid.lies_inside">lies_inside</a></code></li>
<li><code><a title="phi.geom.SDFGrid.points" href="#phi.geom.SDFGrid.points">points</a></code></li>
<li><code><a title="phi.geom.SDFGrid.resolution" href="#phi.geom.SDFGrid.resolution">resolution</a></code></li>
<li><code><a title="phi.geom.SDFGrid.rotated" href="#phi.geom.SDFGrid.rotated">rotated</a></code></li>
<li><code><a title="phi.geom.SDFGrid.sample_uniform" href="#phi.geom.SDFGrid.sample_uniform">sample_uniform</a></code></li>
<li><code><a title="phi.geom.SDFGrid.scaled" href="#phi.geom.SDFGrid.scaled">scaled</a></code></li>
<li><code><a title="phi.geom.SDFGrid.shape" href="#phi.geom.SDFGrid.shape">shape</a></code></li>
<li><code><a title="phi.geom.SDFGrid.shifted" href="#phi.geom.SDFGrid.shifted">shifted</a></code></li>
<li><code><a title="phi.geom.SDFGrid.size" href="#phi.geom.SDFGrid.size">size</a></code></li>
<li><code><a title="phi.geom.SDFGrid.values" href="#phi.geom.SDFGrid.values">values</a></code></li>
<li><code><a title="phi.geom.SDFGrid.volume" href="#phi.geom.SDFGrid.volume">volume</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.geom.Sphere" href="#phi.geom.Sphere">Sphere</a></code></h4>
<ul class="">
<li><code><a title="phi.geom.Sphere.approximate_closest_surface" href="#phi.geom.Sphere.approximate_closest_surface">approximate_closest_surface</a></code></li>
<li><code><a title="phi.geom.Sphere.approximate_signed_distance" href="#phi.geom.Sphere.approximate_signed_distance">approximate_signed_distance</a></code></li>
<li><code><a title="phi.geom.Sphere.at" href="#phi.geom.Sphere.at">at</a></code></li>
<li><code><a title="phi.geom.Sphere.boundary_elements" href="#phi.geom.Sphere.boundary_elements">boundary_elements</a></code></li>
<li><code><a title="phi.geom.Sphere.boundary_faces" href="#phi.geom.Sphere.boundary_faces">boundary_faces</a></code></li>
<li><code><a title="phi.geom.Sphere.bounding_half_extent" href="#phi.geom.Sphere.bounding_half_extent">bounding_half_extent</a></code></li>
<li><code><a title="phi.geom.Sphere.bounding_radius" href="#phi.geom.Sphere.bounding_radius">bounding_radius</a></code></li>
<li><code><a title="phi.geom.Sphere.center" href="#phi.geom.Sphere.center">center</a></code></li>
<li><code><a title="phi.geom.Sphere.corners" href="#phi.geom.Sphere.corners">corners</a></code></li>
<li><code><a title="phi.geom.Sphere.face_areas" href="#phi.geom.Sphere.face_areas">face_areas</a></code></li>
<li><code><a title="phi.geom.Sphere.face_centers" href="#phi.geom.Sphere.face_centers">face_centers</a></code></li>
<li><code><a title="phi.geom.Sphere.face_normals" href="#phi.geom.Sphere.face_normals">face_normals</a></code></li>
<li><code><a title="phi.geom.Sphere.face_shape" href="#phi.geom.Sphere.face_shape">face_shape</a></code></li>
<li><code><a title="phi.geom.Sphere.faces" href="#phi.geom.Sphere.faces">faces</a></code></li>
<li><code><a title="phi.geom.Sphere.lies_inside" href="#phi.geom.Sphere.lies_inside">lies_inside</a></code></li>
<li><code><a title="phi.geom.Sphere.radius" href="#phi.geom.Sphere.radius">radius</a></code></li>
<li><code><a title="phi.geom.Sphere.radius_from_volume" href="#phi.geom.Sphere.radius_from_volume">radius_from_volume</a></code></li>
<li><code><a title="phi.geom.Sphere.rotated" href="#phi.geom.Sphere.rotated">rotated</a></code></li>
<li><code><a title="phi.geom.Sphere.sample_uniform" href="#phi.geom.Sphere.sample_uniform">sample_uniform</a></code></li>
<li><code><a title="phi.geom.Sphere.scaled" href="#phi.geom.Sphere.scaled">scaled</a></code></li>
<li><code><a title="phi.geom.Sphere.shape" href="#phi.geom.Sphere.shape">shape</a></code></li>
<li><code><a title="phi.geom.Sphere.volume" href="#phi.geom.Sphere.volume">volume</a></code></li>
<li><code><a title="phi.geom.Sphere.volume_from_radius" href="#phi.geom.Sphere.volume_from_radius">volume_from_radius</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.geom.UniformGrid" href="#phi.geom.UniformGrid">UniformGrid</a></code></h4>
<ul class="">
<li><code><a title="phi.geom.UniformGrid.boundary_elements" href="#phi.geom.UniformGrid.boundary_elements">boundary_elements</a></code></li>
<li><code><a title="phi.geom.UniformGrid.boundary_faces" href="#phi.geom.UniformGrid.boundary_faces">boundary_faces</a></code></li>
<li><code><a title="phi.geom.UniformGrid.bounding_half_extent" href="#phi.geom.UniformGrid.bounding_half_extent">bounding_half_extent</a></code></li>
<li><code><a title="phi.geom.UniformGrid.bounds" href="#phi.geom.UniformGrid.bounds">bounds</a></code></li>
<li><code><a title="phi.geom.UniformGrid.center" href="#phi.geom.UniformGrid.center">center</a></code></li>
<li><code><a title="phi.geom.UniformGrid.dx" href="#phi.geom.UniformGrid.dx">dx</a></code></li>
<li><code><a title="phi.geom.UniformGrid.face_areas" href="#phi.geom.UniformGrid.face_areas">face_areas</a></code></li>
<li><code><a title="phi.geom.UniformGrid.face_centers" href="#phi.geom.UniformGrid.face_centers">face_centers</a></code></li>
<li><code><a title="phi.geom.UniformGrid.face_normals" href="#phi.geom.UniformGrid.face_normals">face_normals</a></code></li>
<li><code><a title="phi.geom.UniformGrid.face_shape" href="#phi.geom.UniformGrid.face_shape">face_shape</a></code></li>
<li><code><a title="phi.geom.UniformGrid.faces" href="#phi.geom.UniformGrid.faces">faces</a></code></li>
<li><code><a title="phi.geom.UniformGrid.grid_size" href="#phi.geom.UniformGrid.grid_size">grid_size</a></code></li>
<li><code><a title="phi.geom.UniformGrid.half_size" href="#phi.geom.UniformGrid.half_size">half_size</a></code></li>
<li><code><a title="phi.geom.UniformGrid.interior" href="#phi.geom.UniformGrid.interior">interior</a></code></li>
<li><code><a title="phi.geom.UniformGrid.list_cells" href="#phi.geom.UniformGrid.list_cells">list_cells</a></code></li>
<li><code><a title="phi.geom.UniformGrid.lower" href="#phi.geom.UniformGrid.lower">lower</a></code></li>
<li><code><a title="phi.geom.UniformGrid.normal" href="#phi.geom.UniformGrid.normal">normal</a></code></li>
<li><code><a title="phi.geom.UniformGrid.padded" href="#phi.geom.UniformGrid.padded">padded</a></code></li>
<li><code><a title="phi.geom.UniformGrid.resolution" href="#phi.geom.UniformGrid.resolution">resolution</a></code></li>
<li><code><a title="phi.geom.UniformGrid.rotated" href="#phi.geom.UniformGrid.rotated">rotated</a></code></li>
<li><code><a title="phi.geom.UniformGrid.rotation_matrix" href="#phi.geom.UniformGrid.rotation_matrix">rotation_matrix</a></code></li>
<li><code><a title="phi.geom.UniformGrid.shallow_equals" href="#phi.geom.UniformGrid.shallow_equals">shallow_equals</a></code></li>
<li><code><a title="phi.geom.UniformGrid.shape" href="#phi.geom.UniformGrid.shape">shape</a></code></li>
<li><code><a title="phi.geom.UniformGrid.shifted" href="#phi.geom.UniformGrid.shifted">shifted</a></code></li>
<li><code><a title="phi.geom.UniformGrid.size" href="#phi.geom.UniformGrid.size">size</a></code></li>
<li><code><a title="phi.geom.UniformGrid.spatial_rank" href="#phi.geom.UniformGrid.spatial_rank">spatial_rank</a></code></li>
<li><code><a title="phi.geom.UniformGrid.stagger" href="#phi.geom.UniformGrid.stagger">stagger</a></code></li>
<li><code><a title="phi.geom.UniformGrid.staggered_cells" href="#phi.geom.UniformGrid.staggered_cells">staggered_cells</a></code></li>
<li><code><a title="phi.geom.UniformGrid.upper" href="#phi.geom.UniformGrid.upper">upper</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
