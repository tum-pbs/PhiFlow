<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>phi.geom API documentation</title>
<meta name="description" content="Differentiable geometry package …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>phi.geom</code></h1>
</header>
<section id="section-intro">
<p>Differentiable geometry package.</p>
<p>Classes:</p>
<ul>
<li><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> (base type)</li>
<li><code><a title="phi.geom.Box" href="#phi.geom.Box">Box</a></code></li>
<li><code><a title="phi.geom.Sphere" href="#phi.geom.Sphere">Sphere</a></code></li>
</ul>
<p>See the <code><a title="phi.geom" href="#phi.geom">phi.geom</a></code> module documentation at <a href="https://tum-pbs.github.io/PhiFlow/Geometry.html">https://tum-pbs.github.io/PhiFlow/Geometry.html</a></p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="phi.geom.Cuboid"><code class="name flex">
<span>def <span class="ident">Cuboid</span></span>(<span>center: phiml.math._tensors.Tensor = 0,<br>half_size: phiml.math._tensors.Tensor | float = None,<br>rotation: phiml.math._tensors.Tensor | None = None,<br>is_open: phiml.math._tensors.Tensor = False,<br>variable_attrs=('pos', 'size', 'rot'),<br>**size: phiml.math._tensors.Tensor | float) ‑> phi.geom._box.Box</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Cuboid(center: Tensor = 0,
           half_size: Union[float, Tensor] = None,
           rotation: Optional[Tensor] = None,
           is_open: Tensor = wrap(False),
           variable_attrs=(&#39;pos&#39;, &#39;size&#39;, &#39;rot&#39;),
           **size: Union[float, Tensor]) -&gt; Box:
    &#34;&#34;&#34;
    Args:
        center: Center position
        half_size: Half-size of the cuboid as vector or scalar
        rotation: Rotation angle(s) or rotation matrix.
        is_open: Specify which faces are open, i.e. have infinite extent.
        variable_attrs: Which properties of the box are treated as variable.
        **size: Alternative way of specifying the size. If used, `half_size` must not be specified.
    &#34;&#34;&#34;
    if half_size is not None:
        assert isinstance(half_size, Tensor), &#34;half_size must be a Tensor&#34;
        assert &#39;vector&#39; in half_size.shape, f&#34;Cuboid size must have a &#39;vector&#39; dimension.&#34;
        assert half_size.shape.get_item_names(&#39;vector&#39;) is not None, f&#34;Vector dimension must list spatial dimensions as item names. Use the syntax Cuboid(x=x, y=y) to assign names.&#34;
        size = wrap(2 * half_size)
    else:
        size = wrap(tuple(size.values()), math.channel(vector=tuple(size)))
    center = wrap(center)
    if &#39;vector&#39; not in center.shape or center.shape.get_item_names(&#39;vector&#39;) is None:
        center = math.expand(center, channel(size))
    rotation = wrap(rotation)
    result = Box(center, size, rotation, is_open, variable_attrs)
    if half_size is not None:
        result.__dict__[&#39;half_size&#39;] = half_size
    return result</code></pre>
</details>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>center</code></strong></dt>
<dd>Center position</dd>
<dt><strong><code>half_size</code></strong></dt>
<dd>Half-size of the cuboid as vector or scalar</dd>
<dt><strong><code>rotation</code></strong></dt>
<dd>Rotation angle(s) or rotation matrix.</dd>
<dt><strong><code>is_open</code></strong></dt>
<dd>Specify which faces are open, i.e. have infinite extent.</dd>
<dt><strong><code>variable_attrs</code></strong></dt>
<dd>Which properties of the box are treated as variable.</dd>
<dt><strong><code>**size</code></strong></dt>
<dd>Alternative way of specifying the size. If used, <code>half_size</code> must not be specified.</dd>
</dl></div>
</dd>
<dt id="phi.geom.as_sdf"><code class="name flex">
<span>def <span class="ident">as_sdf</span></span>(<span>geo: phi.geom._geom.Geometry,<br>bounds=None,<br>rel_margin=None,<br>abs_margin=0.0,<br>separate: str | Sequence | set | phiml.math._shape.Shape | Callable | None = None,<br>method='auto') ‑> phi.geom._sdf.SDF</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_sdf(geo: Geometry, bounds=None, rel_margin=None, abs_margin=0., separate: DimFilter = None, method=&#39;auto&#39;) -&gt; SDF:
    &#34;&#34;&#34;
    Represent existing geometry as a signed distance function.

    Args:
        geo: `Geometry` to represent as a signed distance function.
            Must implement `Geometry.approximate_signed_distance()`.
        bounds: Bounds of the SDF. If `None` will be determined from bounds of `geo` and `rel_margin`/`abs_margin`.
        rel_margin: Relative size to pad the domain on all sides around the bounds of `geo`.
            For example, 0.1 will pad 10% of `geo`&#39;s size in each axis on both sides.
        abs_margin: World-space size to pad the domain on all sides around the bounds of `geo`.
        separate: Dimensions along which to unstack `geo` and return individual SDFs.
            Once created, SDFs cannot be unstacked.

    Returns:
        `SDF` representation of `geo`.
    &#34;&#34;&#34;
    separate = geo.shape.only(separate)
    if separate:
        return math.map(as_sdf, geo, bounds, rel_margin, abs_margin, separate=None, dims=separate, unwrap_scalars=True)
    if bounds is None:
        bounds: Box = geo.bounding_box()
        rel_margin = .1 if rel_margin is None else rel_margin
    rel_margin = 0 if rel_margin is None else rel_margin
    bounds = Cuboid(bounds.center, half_size=bounds.half_size * (1 + 2 * rel_margin) + 2 * abs_margin)
    if isinstance(geo, SDF):
        return SDF(geo._sdf, geo._out_shape, bounds, geo._center, geo._volume, geo._bounding_radius)
    elif isinstance(geo, Mesh) and geo.spatial_rank == 3 and geo.element_rank == 2:  # 3D surface mesh
        method = &#39;closest-face&#39; if method == &#39;auto&#39; else method
        if method == &#39;pysdf&#39;:
            from pysdf import SDF as PySDF  # https://github.com/sxyu/sdf    https://github.com/sxyu/sdf/blob/master/src/sdf.cpp
            np_verts = geo.vertices.center.numpy(&#39;vertices,vector&#39;)
            np_tris = geo.elements._indices.numpy(&#39;cells,~vertices&#39;)
            np_sdf = PySDF(np_verts, np_tris)  # (num_vertices, 3) and (num_faces, 3)
            np_sdf_c = lambda x: np.clip(np_sdf(x), -float(bounds.size.min) / 2, float(bounds.size.max))
            return numpy_sdf(np_sdf_c, bounds, geo.bounding_box().center)
        elif method == &#39;closest-face&#39;:
            def sdf_closest_face(location):
                closest_elem = math.find_closest(geo.center, location)
                center = geo.center[closest_elem]
                normal = geo.normals[closest_elem]
                return plane_sgn_dist(center, normal, location)
            def sdf_and_grad(location):  # for close distances &lt; face_size use normal vector, for far distances use distance from center
                closest_elem = math.find_closest(geo.center, location)
                center = geo.center[closest_elem]
                normal = geo.normals[closest_elem]
                face_size = math.sqrt(geo.volume) * 4
                size = face_size[closest_elem]
                sgn_dist = plane_sgn_dist(center, normal, location)
                outward = math.where(abs(sgn_dist) &lt; size, normal, math.vec_normalize(location - center))
                return sgn_dist, outward
            return SDF(sdf_closest_face, math.EMPTY_SHAPE, bounds, geo.bounding_box().center, sdf_and_grad=sdf_and_grad)
        elif method == &#39;mesh-to-sdf&#39;:
            from mesh_to_sdf import mesh_to_sdf
            from trimesh import Trimesh
            np_verts = geo.vertices.center.numpy(&#39;vertices,vector&#39;)
            np_tris = geo.elements._indices.numpy(&#39;cells,~vertices&#39;)
            trimesh = Trimesh(np_verts, np_tris)
            def np_sdf(points):
                return mesh_to_sdf(trimesh, points, surface_point_method=&#39;scan&#39;, sign_method=&#39;normal&#39;)
            return numpy_sdf(np_sdf, bounds, geo.bounding_box().center)
        else:
            raise ValueError(f&#34;Method &#39;{method}&#39; not implemented for Mesh SDF&#34;)
    def sdf_and_grad(x: Tensor):
        sgn_dist, delta, *_ = geo.approximate_closest_surface(x)
        return sgn_dist, math.vec_normalize(-delta)
    return SDF(geo.approximate_signed_distance, geo.shape.non_instance.without(&#39;vector&#39;), bounds, geo.center, geo.volume, geo.bounding_radius(), sdf_and_grad)</code></pre>
</details>
<div class="desc"><p>Represent existing geometry as a signed distance function.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>geo</code></strong></dt>
<dd><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> to represent as a signed distance function.
Must implement <code><a title="phi.geom.Geometry.approximate_signed_distance" href="#phi.geom.Geometry.approximate_signed_distance">Geometry.approximate_signed_distance()</a></code>.</dd>
<dt><strong><code>bounds</code></strong></dt>
<dd>Bounds of the SDF. If <code>None</code> will be determined from bounds of <code>geo</code> and <code>rel_margin</code>/<code>abs_margin</code>.</dd>
<dt><strong><code>rel_margin</code></strong></dt>
<dd>Relative size to pad the domain on all sides around the bounds of <code>geo</code>.
For example, 0.1 will pad 10% of <code>geo</code>'s size in each axis on both sides.</dd>
<dt><strong><code>abs_margin</code></strong></dt>
<dd>World-space size to pad the domain on all sides around the bounds of <code>geo</code>.</dd>
<dt><strong><code>separate</code></strong></dt>
<dd>Dimensions along which to unstack <code>geo</code> and return individual SDFs.
Once created, SDFs cannot be unstacked.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.geom.SDF" href="#phi.geom.SDF">SDF</a></code> representation of <code>geo</code>.</p></div>
</dd>
<dt id="phi.geom.assert_same_rank"><code class="name flex">
<span>def <span class="ident">assert_same_rank</span></span>(<span>rank1, rank2, error_message)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assert_same_rank(rank1, rank2, error_message):
    &#34;&#34;&#34; Tests that two objects have the same spatial rank. Objects can be of types: `int`, `None` (no check), `Geometry`, `Shape`, `Tensor` &#34;&#34;&#34;
    rank1_, rank2_ = _rank(rank1), _rank(rank2)
    if rank1_ is not None and rank2_ is not None:
        assert rank1_ == rank2_, &#39;Ranks do not match: %s and %s. %s&#39; % (rank1_, rank2_, error_message)</code></pre>
</details>
<div class="desc"><p>Tests that two objects have the same spatial rank. Objects can be of types: <code>int</code>, <code>None</code> (no check), <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>, <code>Shape</code>, <code>Tensor</code></p></div>
</dd>
<dt id="phi.geom.bounding_box"><code class="name flex">
<span>def <span class="ident">bounding_box</span></span>(<span>geometry: phi.geom._geom.Geometry | phiml.math._tensors.Tensor,<br>reduce=&lt;function non_batch&gt;) ‑> phi.geom._box.Box</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bounding_box(geometry: Union[Geometry, Tensor], reduce=non_batch) -&gt; Box:
    &#34;&#34;&#34;
    Builds a bounding box around `geometry` or a collection of points.

    Args:
        geometry: `Geometry` object or `Tensor` of points.
        reduce: Which objects to includes in each bounding box. Non-reduced dims will be part of the returned box.

    Returns:
        Bounding `Box` containing only batch dims and `vector`.
    &#34;&#34;&#34;
    if isinstance(geometry, Tensor):
        assert &#39;vector&#39; in geometry.shape, f&#34;When passing a Tensor to bounding_box, it needs to have a vector dimension but got {geometry.shape}&#34;
        reduce = geometry.shape.only(reduce) - &#39;vector&#39;
        return Box(math.min(geometry, reduce), math.max(geometry, reduce))
    center = geometry.center
    extent = geometry.bounding_half_extent()
    boxes = Box(center - extent, center + extent)
    return boxes.largest(boxes.shape.only(reduce)-&#39;vector&#39;)</code></pre>
</details>
<div class="desc"><p>Builds a bounding box around <code>geometry</code> or a collection of points.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>geometry</code></strong></dt>
<dd><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> object or <code>Tensor</code> of points.</dd>
<dt><strong><code>reduce</code></strong></dt>
<dd>Which objects to includes in each bounding box. Non-reduced dims will be part of the returned box.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Bounding <code><a title="phi.geom.Box" href="#phi.geom.Box">Box</a></code> containing only batch dims and <code>vector</code>.</p></div>
</dd>
<dt id="phi.geom.build_mesh"><code class="name flex">
<span>def <span class="ident">build_mesh</span></span>(<span>bounds: phi.geom._box.Box = None,<br>resolution=(),<br>obstacles: phi.geom._geom.Geometry | Dict[str, phi.geom._geom.Geometry] = None,<br>method='quad',<br>cell_dim: phiml.math._shape.Shape = (cellsⁱ=None),<br>face_format: str = 'csc',<br>max_squish: float | None = 0.5,<br>**resolution_: int | phiml.math._tensors.Tensor | tuple | list | Any) ‑> phi.geom._mesh.Mesh</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_mesh(bounds: Box = None,
               resolution=EMPTY_SHAPE,
               obstacles: Union[Geometry, Dict[str, Geometry]] = None,
               method=&#39;quad&#39;,
               cell_dim: Shape = instance(&#39;cells&#39;),
               face_format: str = &#39;csc&#39;,
               max_squish: Optional[float] = .5,
               **resolution_: Union[int, Tensor, tuple, list, Any]) -&gt; Mesh:
    &#34;&#34;&#34;
    Build a mesh for a given domain, respecting obstacles.

    Args:
        bounds: Bounds for uniform cells.
        resolution: Base resolution
        obstacles: Single `Geometry` or `dict` mapping boundary name to corresponding `Geometry`.
        method: Meshing algorithm. Only `quad` is currently supported.
        cell_dim: Dimension along which to list the cells. This should be an instance dimension.
        face_format: Sparse storage format for cell connectivity.
        max_squish: Smallest allowed cell size compared to the smallest regular cell.
        **resolution_: For uniform grid, pass resolution as `int` and specify `bounds`.
            Or pass a sequence of floats for each dimension, specifying the vertex positions along each axis.
            This allows for variable cell stretching.

    Returns:
        `Mesh`
    &#34;&#34;&#34;
    if obstacles is None:
        obstacles = {}
    elif isinstance(obstacles, Geometry):
        obstacles = {&#39;obstacle&#39;: obstacles}
    assert isinstance(obstacles, dict), f&#34;obstacles needs to be a Geometry or dict&#34;
    if method == &#39;quad&#39;:
        if bounds is None:  # **resolution_ specifies points
            assert not resolution, f&#34;When specifying vertex positions, bounds and resolution will be inferred and must not be specified.&#34;
            resolution = spatial(**{dim: non_batch(x).volume for dim, x in resolution_.items()}) - 1
            vert_pos = meshgrid(**resolution_)
            bounds = Box(**{dim: (x[0], x[-1]) for dim, x in resolution_.items()})
            # centroid_x = {dim: .5 * (wrap(x[:-1]) + wrap(x[1:])) for dim, x in resolution_.items()}
            # centroids = meshgrid(**centroid_x)
        else:  # uniform grid from bounds, resolution
            resolution = resolution &amp; spatial(**resolution_)
            vert_pos = meshgrid(resolution + 1) / resolution * bounds.size + bounds.lower
            # centroids = UniformGrid(resolution, bounds).center
        dx = bounds.size / resolution
        regular_size = math.min(dx, channel)
        vert_pos, polygons, boundaries = build_quadrilaterals(vert_pos, resolution, obstacles, bounds, regular_size * max_squish)
        if max_squish is not None:
            lin_vert_pos = pack_dims(vert_pos, spatial, instance(&#39;polygon&#39;))
            corner_pos = lin_vert_pos[polygons]
            min_pos = math.min(corner_pos, &#39;~polygon&#39;)
            max_pos = math.max(corner_pos, &#39;~polygon&#39;)
            cell_sizes = math.min(max_pos - min_pos, &#39;vector&#39;)
            too_small = cell_sizes &lt; regular_size * max_squish
            # --- remove too small cells ---
            removed = polygons[too_small]
            removed_centers = mean(lin_vert_pos[removed], &#39;~polygon&#39;)
            kept_vert = removed[{&#39;~polygon&#39;: 0}]
            vert_pos = scatter(lin_vert_pos, kept_vert, removed_centers)
            vertex_map = math.range(non_channel(lin_vert_pos))
            vertex_map = scatter(vertex_map, rename_dims(removed, &#39;~polygon&#39;, instance(&#39;poly_list&#39;)), expand(kept_vert, instance(poly_list=4)))
            polygons = polygons[~too_small]
            polygons = vertex_map[polygons]
            boundaries = {boundary: vertex_map[edge_list] for boundary, edge_list in boundaries.items()}
            boundaries = {boundary: edge_list[edge_list[{&#39;~vert&#39;: &#39;start&#39;}] != edge_list[{&#39;~vert&#39;: &#39;end&#39;}]] for boundary, edge_list in boundaries.items()}
            # ToDo remove edges which now point to the same vertex
        def build_single_mesh(vert_pos, polygons, boundaries):
            points_np = reshaped_numpy(vert_pos, [..., channel])
            polygon_list = reshaped_numpy(polygons, [..., dual])
            boundaries = {b: edges.numpy(&#39;edges,~vert&#39;) for b, edges in boundaries.items()}
            return mesh_from_numpy(points_np, polygon_list, boundaries, cell_dim=cell_dim, face_format=face_format)
        return math.map(build_single_mesh, vert_pos, polygons, boundaries, dims=batch)</code></pre>
</details>
<div class="desc"><p>Build a mesh for a given domain, respecting obstacles.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bounds</code></strong></dt>
<dd>Bounds for uniform cells.</dd>
<dt><strong><code>resolution</code></strong></dt>
<dd>Base resolution</dd>
<dt><strong><code>obstacles</code></strong></dt>
<dd>Single <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> or <code>dict</code> mapping boundary name to corresponding <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.</dd>
<dt><strong><code>method</code></strong></dt>
<dd>Meshing algorithm. Only <code>quad</code> is currently supported.</dd>
<dt><strong><code>cell_dim</code></strong></dt>
<dd>Dimension along which to list the cells. This should be an instance dimension.</dd>
<dt><strong><code>face_format</code></strong></dt>
<dd>Sparse storage format for cell connectivity.</dd>
<dt><strong><code>max_squish</code></strong></dt>
<dd>Smallest allowed cell size compared to the smallest regular cell.</dd>
<dt><strong><code>**resolution_</code></strong></dt>
<dd>For uniform grid, pass resolution as <code>int</code> and specify <code>bounds</code>.
Or pass a sequence of floats for each dimension, specifying the vertex positions along each axis.
This allows for variable cell stretching.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.geom.Mesh" href="#phi.geom.Mesh">Mesh</a></code></p></div>
</dd>
<dt id="phi.geom.clip_length"><code class="name flex">
<span>def <span class="ident">clip_length</span></span>(<span>vec: phiml.math._tensors.Tensor,<br>min_len=0,<br>max_len=1,<br>vec_dim: str | Sequence | set | phiml.math._shape.Shape | Callable | None = 'vector',<br>eps: phiml.math._tensors.Tensor | float = 1e-05)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clip_length(vec: Tensor, min_len=0, max_len=1, vec_dim: DimFilter = &#39;vector&#39;, eps: Union[float, Tensor] = 1e-5):
    &#34;&#34;&#34;
    Clips the length of a vector to the interval `[min_len, max_len]` while keeping the direction.
    Zero-vectors remain zero-vectors.

    Args:
        vec: `Tensor`
        min_len: Lower clipping threshold.
        max_len: Upper clipping threshold.
        vec_dim: Dimensions to compute the length over. By default, all channel dimensions are used to compute the vector length.
        eps: Minimum vector length. Use to avoid `inf` gradients for zero-length vectors.

    Returns:
        `Tensor` with same shape as `vec`.
    &#34;&#34;&#34;
    le = math.length(vec, vec_dim, eps)
    new_length = clip(le, min_len, max_len)
    return vec * safe_div(new_length, le)</code></pre>
</details>
<div class="desc"><p>Clips the length of a vector to the interval <code>[min_len, max_len]</code> while keeping the direction.
Zero-vectors remain zero-vectors.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>vec</code></strong></dt>
<dd><code>Tensor</code></dd>
<dt><strong><code>min_len</code></strong></dt>
<dd>Lower clipping threshold.</dd>
<dt><strong><code>max_len</code></strong></dt>
<dd>Upper clipping threshold.</dd>
<dt><strong><code>vec_dim</code></strong></dt>
<dd>Dimensions to compute the length over. By default, all channel dimensions are used to compute the vector length.</dd>
<dt><strong><code>eps</code></strong></dt>
<dd>Minimum vector length. Use to avoid <code>inf</code> gradients for zero-length vectors.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>Tensor</code> with same shape as <code>vec</code>.</p></div>
</dd>
<dt id="phi.geom.concat"><code class="name flex">
<span>def <span class="ident">concat</span></span>(<span>values: Sequence[~PhiTreeNodeType],<br>dim: phiml.math._shape.Shape | str,<br>expand_values=False,<br>**kwargs) ‑> ~PhiTreeNodeType</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def concat(values: Sequence[PhiTreeNodeType], dim: Union[str, Shape], expand_values=False, **kwargs) -&gt; PhiTreeNodeType:
    &#34;&#34;&#34;
    Concatenates a sequence of `phiml.math.magic.Shapable` objects, e.g. `Tensor`, along one dimension.
    All values must have the same spatial, instance and channel dims and their sizes must be equal, except for `dim`.
    Batch dims will be added as needed.

    Args:
        values: Tuple or list of `phiml.math.magic.Shapable`, such as `phiml.math.Tensor`
        dim: Concatenation dimension, must be present in all `values`.
            The size along `dim` is determined from `values` and can be set to undefined (`None`).
            Alternatively, a `str` of the form `&#39;t-&gt;name:t&#39;` can be specified, where `t` is on of `b d i s c` denoting the dimension type.
            This first packs all dims of the input into a new dim with given name and type, then concatenates the values along this dim.
        expand_values: If `True`, will first add missing dims to all values, not just batch dimensions.
            This allows tensors with different dims to be concatenated.
            The resulting tensor will have all dims that are present in `values`.
        **kwargs: Additional keyword arguments required by specific implementations.
            Adding spatial dims to fields requires the `bounds: Box` argument specifying the physical extent of the new dimensions.
            Adding batch dims must always work without keyword arguments.

    Returns:
        Concatenated `Tensor`

    Examples:
        &gt;&gt;&gt; concat([math.zeros(batch(b=10)), math.ones(batch(b=10))], &#39;b&#39;)
        (bᵇ=20) 0.500 ± 0.500 (0e+00...1e+00)

        &gt;&gt;&gt; concat([vec(x=1, y=0), vec(z=2.)], &#39;vector&#39;)
        (x=1.000, y=0.000, z=2.000) float64
    &#34;&#34;&#34;
    assert len(values) &gt; 0, f&#34;concat() got empty sequence {values}&#34;
    if isinstance(dim, SHAPE_TYPES):
        dim = dim.name
    assert isinstance(dim, str), f&#34;dim must be a str or Shape but got &#39;{dim}&#39; of type {type(dim)}&#34;
    if &#39;-&gt;&#39; in dim:
        dim_type, dim = [s.strip() for s in dim.split(&#39;-&gt;&#39;, 1)]
        dim_type = DIM_FUNCTIONS[INV_CHAR[dim_type]]
        dim = auto(dim, dim_type)
        values = [pack_dims(v, dim_type, dim) for v in values]
        dim = dim.name
    else:
        dim = auto(dim, channel).name
    # --- Filter 0-length values ---
    shapes = [shape(v) for v in values]
    def is_non_zero(s: Shape):
        if dim not in s:
            return True
        size = s.get_size(dim)
        if isinstance(size, int):
            return size &gt; 0
        return True
    filtered_values = [v for v, s in zip(values, shapes) if is_non_zero(s)]
    if not filtered_values:
        return values[0]
    values = filtered_values
    if len(values) == 1:
        return values[0]
    shapes = [s for s in shapes if is_non_zero(s)]
    #  --- Add missing dimensions ---
    if expand_values:
        all_dims = merge_shapes(*shapes, allow_varying_sizes=True)
        all_dims = all_dims.with_dim_size(dim, 1, keep_item_names=False)
        values = [expand(v, all_dims - s) for v, s in zip(values, shapes)]
    else:
        for v, s in zip(values, shapes):
            assert dim in s, f&#34;concat dim &#39;{dim}&#39; must be present in the shapes of all values bot got value {type(v).__name__} with shape {s}&#34;
        for v in values[1:]:
            assert set(non_batch(v).names) == set(non_batch(values[0]).names), f&#34;Concatenated values must have the same non-batch dims but got {non_batch(values[0])} and {non_batch(v)}&#34;
        all_batch_dims = merge_shapes(*[s.batch - dim for s in shapes])
        values = [expand(v, all_batch_dims) for v in values]
    # --- First try __concat__ ---
    for v in values:
        if isinstance(v, Shapable):
            if hasattr(v, &#39;__concat__&#39;):
                result = v.__concat__(values, dim, **kwargs)
                if result is not NotImplemented:
                    assert isinstance(result, Shapable), f&#34;__concat__ must return a Shapable object but got {type(result).__name__} from {type(v).__name__} {v}&#34;
                    return result
    # --- Next: try concat attributes for tree nodes ---
    if all(isinstance(v, PhiTreeNode) for v in values):
        attributes = all_attributes(values[0])
        if attributes and all(all_attributes(v) == attributes for v in values):
            new_attrs = {}
            for a in attributes:
                common_shape = merge_shapes(*[shape(getattr(v, a)).without(dim) for v in values])
                a_values = [expand(getattr(v, a), common_shape &amp; shape(v).only(dim)) for v in values]  # expand by dim if missing, and dims of others
                new_attrs[a] = concat(a_values, dim, expand_values=expand_values, **kwargs)
            return copy_with(values[0], **new_attrs)
        else:
            warnings.warn(f&#34;Failed to concat values using value attributes because attributes differ among values {values}&#34;)
    # --- Fallback: slice and stack ---
    try:
        unstacked = sum([unstack(v, dim) for v in values], ())
    except MagicNotImplemented:
        raise MagicNotImplemented(f&#34;concat: No value implemented __concat__ and not all values were Sliceable along {dim}. values = {[type(v) for v in values]}&#34;)
    if len(unstacked) &gt; 8:
        warnings.warn(f&#34;concat() default implementation is slow on large dims ({dim}={len(unstacked)}). Please implement __concat__()&#34;, RuntimeWarning, stacklevel=2)
    dim = shapes[0][dim].with_size(None)
    try:
        return stack(unstacked, dim, **kwargs)
    except MagicNotImplemented:
        raise MagicNotImplemented(f&#34;concat: No value implemented __concat__ and slices could not be stacked. values = {[type(v) for v in values]}&#34;)</code></pre>
</details>
<div class="desc"><p>Concatenates a sequence of <code>phiml.math.magic.Shapable</code> objects, e.g. <code>Tensor</code>, along one dimension.
All values must have the same spatial, instance and channel dims and their sizes must be equal, except for <code>dim</code>.
Batch dims will be added as needed.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>values</code></strong></dt>
<dd>Tuple or list of <code>phiml.math.magic.Shapable</code>, such as <code>phiml.math.Tensor</code></dd>
<dt><strong><code>dim</code></strong></dt>
<dd>Concatenation dimension, must be present in all <code>values</code>.
The size along <code>dim</code> is determined from <code>values</code> and can be set to undefined (<code>None</code>).
Alternatively, a <code>str</code> of the form <code>'t-&gt;name:t'</code> can be specified, where <code>t</code> is on of <code>b d i s c</code> denoting the dimension type.
This first packs all dims of the input into a new dim with given name and type, then concatenates the values along this dim.</dd>
<dt><strong><code>expand_values</code></strong></dt>
<dd>If <code>True</code>, will first add missing dims to all values, not just batch dimensions.
This allows tensors with different dims to be concatenated.
The resulting tensor will have all dims that are present in <code>values</code>.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Additional keyword arguments required by specific implementations.
Adding spatial dims to fields requires the <code>bounds: Box</code> argument specifying the physical extent of the new dimensions.
Adding batch dims must always work without keyword arguments.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Concatenated <code>Tensor</code></p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; concat([math.zeros(batch(b=10)), math.ones(batch(b=10))], 'b')
(bᵇ=20) 0.500 ± 0.500 (0e+00...1e+00)
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; concat([vec(x=1, y=0), vec(z=2.)], 'vector')
(x=1.000, y=0.000, z=2.000) float64
</code></pre></div>
</dd>
<dt id="phi.geom.cross"><code class="name flex">
<span>def <span class="ident">cross</span></span>(<span>vec1: phiml.math._tensors.Tensor, vec2: phiml.math._tensors.Tensor) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cross(vec1: Tensor, vec2: Tensor) -&gt; Tensor:
    &#34;&#34;&#34;
    Computes the cross product of two vectors in 2D.

    Args:
        vec1: `Tensor` with a single channel dimension called `&#39;vector&#39;`
        vec2: `Tensor` with a single channel dimension called `&#39;vector&#39;`

    Returns:
        `Tensor`
    &#34;&#34;&#34;
    vec1 = math.tensor(vec1)
    vec2 = math.tensor(vec2)
    spatial_rank = vec1.vector.size if &#39;vector&#39; in vec1.shape else vec2.vector.size
    if spatial_rank == 2:  # Curl in 2D
        assert &#39;vector&#39; in vec2.shape
        if &#39;vector&#39; in vec1.shape:
            v1_x, v1_y = vec1.vector
            v2_x, v2_y = vec2.vector
            return v1_x * v2_y - v1_y * v2_x
        else:
            v2_x, v2_y = vec2.vector
            return vec1 * stack([-v2_y, v2_x], channel(vec2))
    elif spatial_rank == 3:  # Curl in 3D
        assert &#39;vector&#39; in vec1.shape and &#39;vector&#39; in vec2.shape, f&#34;Both vectors must have a &#39;vector&#39; dimension but got shapes {vec1.shape}, {vec2.shape}&#34;
        v1_x, v1_y, v1_z = vec1.vector
        v2_x, v2_y, v2_z = vec2.vector
        return math.stack([
            v1_y * v2_z - v1_z * v2_y,
            v1_z * v2_x - v1_x * v2_z,
            v1_x * v2_y - v1_y * v2_x,
        ], vec1.shape[&#39;vector&#39;])
    else:
        raise AssertionError(f&#39;dims = {spatial_rank}. Vector product not available in &gt; 3 dimensions&#39;)</code></pre>
</details>
<div class="desc"><p>Computes the cross product of two vectors in 2D.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>vec1</code></strong></dt>
<dd><code>Tensor</code> with a single channel dimension called <code>'vector'</code></dd>
<dt><strong><code>vec2</code></strong></dt>
<dd><code>Tensor</code> with a single channel dimension called <code>'vector'</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>Tensor</code></p></div>
</dd>
<dt id="phi.geom.cylinder"><code class="name flex">
<span>def <span class="ident">cylinder</span></span>(<span>center: phiml.math._tensors.Tensor | float = None,<br>radius: phiml.math._tensors.Tensor | float = None,<br>depth: phiml.math._tensors.Tensor | float = None,<br>rotation: phiml.math._tensors.Tensor | None = None,<br>axis: int | str | phiml.math._tensors.Tensor = -1,<br>variables=('center', 'radius', 'depth', 'rotation'),<br>**center_: phiml.math._tensors.Tensor | float) ‑> phi.geom._cylinder.Cylinder</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cylinder(center: Union[Tensor, float] = None,
             radius: Union[float, Tensor] = None,
             depth: Union[float, Tensor] = None,
             rotation: Optional[Tensor] = None,
             axis: Union[int, str, Tensor] = -1,
             variables=(&#39;center&#39;, &#39;radius&#39;, &#39;depth&#39;, &#39;rotation&#39;),
             **center_: Union[float, Tensor]) -&gt; Cylinder:
    &#34;&#34;&#34;
    Args:
        center: Cylinder center as `Tensor` with `vector` dimension.
            The spatial dimension order should be specified in the `vector` dimension via item names.
            Can be left empty to specify dimensions via kwargs.
        radius: Cylinder radius as `float` or `Tensor`.
        depth: Cylinder length as `float` or `Tensor`.
        rotation: Rotation angle(s) or rotation matrix.
        axis: The cylinder is aligned along this axis, perturbed by `rotation`.
            Specified either as the dim along which the cylinder is aligned or as a vector.
        variables: Which properties of the cylinder are variable, i.e. traced and optimizable. All by default.
        **center_: Specifies center when the `center` argument is not given. Center position by dimension, e.g. `x=0.5, y=0.2`.
    &#34;&#34;&#34;
    if center is not None:
        if not isinstance(center, Tensor):
            assert center == 0 and isinstance(axis, Tensor)
            center = expand(0, axis.shape[&#39;vector&#39;])
        assert isinstance(center, Tensor), f&#34;center must be a Tensor but got {type(center).__name__}&#34;
        assert &#39;vector&#39; in center.shape, f&#34;Sphere center must have a &#39;vector&#39; dimension.&#34;
        assert center.shape.get_item_names(&#39;vector&#39;) is not None, f&#34;Vector dimension must list spatial dimensions as item names. Use the syntax Sphere(x=x, y=y) to assign names.&#34;
        center = center
    else:
        center = wrap(tuple(center_.values()), channel(vector=tuple(center_.keys())))
    assert radius is not None, &#34;radius must be specified&#34;
    radius = wrap(radius)
    if depth is None:
        assert isinstance(axis, Tensor)
        depth = 2 * length(axis, &#39;vector&#39;)
    else:
        depth = wrap(depth)
    axis = center.vector.item_names[axis] if isinstance(axis, int) else axis
    if isinstance(axis, Tensor):  # specify cylinder axis as vector
        assert &#39;vector&#39; in axis.shape, f&#34;When specifying axis a Tensor, it must have a &#39;vector&#39; dimension.&#34;
        assert rotation is None, f&#34;When specifying axis as a &#34;
        axis_ = center.vector.item_names[-1]
        unit_vec = vec(**{d: 1 if d == axis_ else 0 for d in center.vector.item_names})
        rotation = rotation_matrix_from_directions(unit_vec, axis, epsilon=1e-5)
        axis = axis_
    else:
        rotation = rotation_matrix(rotation)
    variables = [{&#39;center&#39;: &#39;_center&#39;}.get(v, v) for v in variables]
    assert &#39;vector&#39; not in radius.shape, f&#34;Cylinder radius must not vary along vector but got {radius}&#34;
    assert set(variables).issubset(set(all_attributes(Cylinder))), f&#34;Invalid variables: {variables}&#34;
    assert axis in center.vector.item_names, f&#34;Cylinder axis {axis} not part of vector dim {center.vector}&#34;
    return Cylinder(center, radius, depth, rotation, axis, tuple(variables), ())</code></pre>
</details>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>center</code></strong></dt>
<dd>Cylinder center as <code>Tensor</code> with <code>vector</code> dimension.
The spatial dimension order should be specified in the <code>vector</code> dimension via item names.
Can be left empty to specify dimensions via kwargs.</dd>
<dt><strong><code>radius</code></strong></dt>
<dd>Cylinder radius as <code>float</code> or <code>Tensor</code>.</dd>
<dt><strong><code>depth</code></strong></dt>
<dd>Cylinder length as <code>float</code> or <code>Tensor</code>.</dd>
<dt><strong><code>rotation</code></strong></dt>
<dd>Rotation angle(s) or rotation matrix.</dd>
<dt><strong><code>axis</code></strong></dt>
<dd>The cylinder is aligned along this axis, perturbed by <code>rotation</code>.
Specified either as the dim along which the cylinder is aligned or as a vector.</dd>
<dt><strong><code>variables</code></strong></dt>
<dd>Which properties of the cylinder are variable, i.e. traced and optimizable. All by default.</dd>
<dt><strong><code>**center_</code></strong></dt>
<dd>Specifies center when the <code>center</code> argument is not given. Center position by dimension, e.g. <code>x=0.5, y=0.2</code>.</dd>
</dl></div>
</dd>
<dt id="phi.geom.embed"><code class="name flex">
<span>def <span class="ident">embed</span></span>(<span>geometry: phi.geom._geom.Geometry,<br>projected_dims: phiml.math._shape.Shape | str | tuple | list | None) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def embed(geometry: Geometry, projected_dims: Union[math.Shape, str, tuple, list, None]) -&gt; Geometry:
    &#34;&#34;&#34;
    Adds fake spatial dimensions to a geometry.
    The geometry value will be constant along the added dimensions, as if it had infinite length in these directions.

    Dimensions that are already present with `geometry` are ignored.

    Args:
        geometry: `Geometry`
        projected_dims: Additional dimensions

    Returns:
        `Geometry` with spatial rank `geometry.spatial_rank + projected_dims.rank`.
    &#34;&#34;&#34;
    if projected_dims is None:
        return geometry
    axes = parse_dim_order(projected_dims)
    embedded_axes = [a for a in axes if a not in geometry.shape.get_item_names(&#39;vector&#39;)]
    if not embedded_axes:
        return geometry[axes]
    # --- add dims from geometry to axes ---
    for name in reversed(geometry.shape.get_item_names(&#39;vector&#39;)):
        if name not in projected_dims:
            axes = (name,) + axes
    if isinstance(geometry, Box):
        box = geometry.corner_representation()
        embedded = box * Box(**{dim: None for dim in embedded_axes})
        return embedded[axes]
    return _EmbeddedGeometry(geometry, axes)</code></pre>
</details>
<div class="desc"><p>Adds fake spatial dimensions to a geometry.
The geometry value will be constant along the added dimensions, as if it had infinite length in these directions.</p>
<p>Dimensions that are already present with <code>geometry</code> are ignored.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>geometry</code></strong></dt>
<dd><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></dd>
<dt><strong><code>projected_dims</code></strong></dt>
<dd>Additional dimensions</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> with spatial rank <code>geometry.spatial_rank + projected_dims.rank</code>.</p></div>
</dd>
<dt id="phi.geom.enclosing_grid"><code class="name flex">
<span>def <span class="ident">enclosing_grid</span></span>(<span>*geometries: phi.geom._geom.Geometry | phiml.math._tensors.Tensor,<br>voxel_count: int,<br>rel_margin=0.0,<br>abs_margin=0.0,<br>margin_cells=0) ‑> phi.geom._grid.UniformGrid</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enclosing_grid(*geometries: Union[Geometry, Tensor], voxel_count: int, rel_margin=0., abs_margin=0., margin_cells=0) -&gt; UniformGrid:
    &#34;&#34;&#34;
    Constructs a `UniformGrid` which fully encloses the `geometries`.
    The grid voxels are chosen to have approximately the same size along each axis.

    Args:
        *geometries: `Geometry` objects `Tensor` of points which should lie within the grid.
        voxel_count: Approximate number of total voxels.
        rel_margin: Relative margin, i.e. empty space on each side as a fraction of the bounding box size of `geometries`.
        abs_margin: Absolute margin, i.e. empty space on each side.
        margin_cells: Number of cell layers to fit outside the bounding box around `geometries`. This is cumulative with `rel_margin` and `abs_margin`.

    Returns:
        `UniformGrid`
    &#34;&#34;&#34;
    bounds = stack([g.bounding_box() if isinstance(g, Geometry) else bounding_box(g) for g in geometries], batch(&#39;_geometries&#39;))
    bounds = bounds.largest(shape).scaled(1+rel_margin)
    bounds = Box(bounds.lower - abs_margin, bounds.upper + abs_margin)
    if not margin_cells:
        voxel_vol = bounds.volume / voxel_count
        voxel_size = voxel_vol ** (1/bounds.spatial_rank)
        resolution = math.to_int32(math.round(bounds.size / voxel_size))
        resolution = spatial(**resolution.vector)
    else:
        inner_res, outer_res = solve_resolution_with_margin_cells(*bounds.size.vector, voxel_count, margin_cells)
        dx = bounds.size / inner_res
        bounds = Box(bounds.lower - dx*margin_cells, bounds.upper + dx*margin_cells)
        resolution = spatial(**{d: r for d, r in zip(bounds.size.vector.labels, outer_res)})
    return UniformGrid(resolution, bounds)</code></pre>
</details>
<div class="desc"><p>Constructs a <code><a title="phi.geom.UniformGrid" href="#phi.geom.UniformGrid">UniformGrid</a></code> which fully encloses the <code>geometries</code>.
The grid voxels are chosen to have approximately the same size along each axis.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*geometries</code></strong></dt>
<dd><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> objects <code>Tensor</code> of points which should lie within the grid.</dd>
<dt><strong><code>voxel_count</code></strong></dt>
<dd>Approximate number of total voxels.</dd>
<dt><strong><code>rel_margin</code></strong></dt>
<dd>Relative margin, i.e. empty space on each side as a fraction of the bounding box size of <code>geometries</code>.</dd>
<dt><strong><code>abs_margin</code></strong></dt>
<dd>Absolute margin, i.e. empty space on each side.</dd>
<dt><strong><code>margin_cells</code></strong></dt>
<dd>Number of cell layers to fit outside the bounding box around <code>geometries</code>. This is cumulative with <code>rel_margin</code> and <code>abs_margin</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.geom.UniformGrid" href="#phi.geom.UniformGrid">UniformGrid</a></code></p></div>
</dd>
<dt id="phi.geom.farthest_points"><code class="name flex">
<span>def <span class="ident">farthest_points</span></span>(<span>points: phiml.math._tensors.Tensor,<br>list_dim: phiml.math._shape.Shape,<br>must_contain: phiml.math._tensors.Tensor = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def farthest_points(points: Tensor, list_dim: Shape, must_contain: Tensor = None):
    &#34;&#34;&#34;
    Perform farthest point sampling (FPS) on a set of 3D points.

    Parameters:
        points (numpy.ndarray): (N, 3) array of 3D points.
        list_dim: Number of points to sample and dimension along which to list the sampled points.
        must_contain: (Optional) Indices of points that must be contained in the sample. Duplicate indices will only be sampled once.

    Returns:
        numpy.ndarray: (M, 3) array of sampled points.
    &#34;&#34;&#34;
    points_np = points.numpy([..., &#39;vector&#39;])
    sampled_indices = np.zeros(list_dim.volume, dtype=int)
    if must_contain is not None:
        must_contain_np = must_contain.numpy([shape])
        must_contain_np = np.unique(must_contain_np)
        sampled_indices[:must_contain_np.size] = must_contain_np
        distances = np.min(np.linalg.norm(points_np - points_np[must_contain_np, None, :], axis=-1), 0)
        i0 = must_contain_np.size
    else:
        distances = np.full(points_np.shape[0], np.inf)  # Initialize distances as infinity
        sampled_indices[0] = np.random.randint(points_np.shape[0])  # Start with a random point
        i0 = 1
    for i in range(i0, list_dim.volume):
        last_selected = points_np[sampled_indices[i - 1]]  # Compute distances from the last selected point to all points
        distances = np.minimum(distances, np.linalg.norm(points_np - last_selected, axis=1))  # Update the minimum distance to the set of selected points
        sampled_indices[i] = np.argmax(distances)  # Select the farthest point
    sampled_indices = expand(wrap(sampled_indices, list_dim), channel(index=(points.shape-&#39;vector&#39;).name_list))
    return sampled_indices, points[sampled_indices]</code></pre>
</details>
<div class="desc"><p>Perform farthest point sampling (FPS) on a set of 3D points.</p>
<h2 id="parameters">Parameters</h2>
<p>points (numpy.ndarray): (N, 3) array of 3D points.
list_dim: Number of points to sample and dimension along which to list the sampled points.
must_contain: (Optional) Indices of points that must be contained in the sample. Duplicate indices will only be sampled once.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>numpy.ndarray</code></dt>
<dd>(M, 3) array of sampled points.</dd>
</dl></div>
</dd>
<dt id="phi.geom.graph"><code class="name flex">
<span>def <span class="ident">graph</span></span>(<span>nodes: phi.geom._geom.Geometry | phiml.math._tensors.Tensor,<br>edges: phiml.math._tensors.Tensor,<br>boundary: Dict[str, Dict[str, slice]] = None,<br>build_distances=True,<br>build_bounding_distance=False) ‑> phi.geom._graph.Graph</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def graph(nodes: Union[Geometry, Tensor],
          edges: Tensor,
          boundary: Dict[str, Dict[str, slice]] = None,
          build_distances=True,  # remaining for legacy reasons. Now evaluated on demand.
          build_bounding_distance=False) -&gt; Graph:
    &#34;&#34;&#34;
    Construct a `Graph`.

    Args:
        nodes: Location `Tensor` or `Geometry` objects representing the nodes.
        edges: Connectivity and edge value `Tensor`.
        boundary: Named boundary sets.

    Returns:
        `Graph`
    &#34;&#34;&#34;
    if isinstance(nodes, Tensor):
        assert &#39;vector&#39; in channel(nodes) and channel(nodes).get_item_names(&#39;vector&#39;) is not None, f&#34;nodes must have a &#39;vector&#39; dim listing the physical dimensions but got {shape(nodes)}&#34;
        nodes = Point(nodes)
    boundary = {} if boundary is None else boundary
    return Graph(nodes, edges, boundary)</code></pre>
</details>
<div class="desc"><p>Construct a <code><a title="phi.geom.Graph" href="#phi.geom.Graph">Graph</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>nodes</code></strong></dt>
<dd>Location <code>Tensor</code> or <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> objects representing the nodes.</dd>
<dt><strong><code>edges</code></strong></dt>
<dd>Connectivity and edge value <code>Tensor</code>.</dd>
<dt><strong><code>boundary</code></strong></dt>
<dd>Named boundary sets.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.geom.Graph" href="#phi.geom.Graph">Graph</a></code></p></div>
</dd>
<dt id="phi.geom.infinite_cylinder"><code class="name flex">
<span>def <span class="ident">infinite_cylinder</span></span>(<span>center=None,<br>radius=None,<br>inf_dim: str | phiml.math._shape.Shape | tuple | list = None,<br>**center_) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def infinite_cylinder(center=None, radius=None, inf_dim: Union[str, Shape, tuple, list] = None, **center_) -&gt; Geometry:
    &#34;&#34;&#34;
    Creates an infinite cylinder.
    This is equal to embedding an `n`-dimensional `Sphere` in `n+1` dimensions.

    See Also:
        `Sphere`, `embed`

    Args:
        center: Center coordinates without `inf_dim`. Alternatively use keyword arguments.
        radius: Cylinder radius.
        inf_dim: Dimension along which the cylinder is infinite.
            Use `Geometry.rotated()` if the direction does not align with an axis.
        **center_: Alternatively specify center coordinates without `inf_dim` as keyword arguments.

    Returns:
        `Geometry`
    &#34;&#34;&#34;
    sphere = Sphere(center, radius, **center_)
    return embed(sphere, inf_dim)</code></pre>
</details>
<div class="desc"><p>Creates an infinite cylinder.
This is equal to embedding an <code>n</code>-dimensional <code><a title="phi.geom.Sphere" href="#phi.geom.Sphere">Sphere</a></code> in <code>n+1</code> dimensions.</p>
<p>See Also:
<code><a title="phi.geom.Sphere" href="#phi.geom.Sphere">Sphere</a></code>, <code><a title="phi.geom.embed" href="#phi.geom.embed">embed()</a></code></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>center</code></strong></dt>
<dd>Center coordinates without <code>inf_dim</code>. Alternatively use keyword arguments.</dd>
<dt><strong><code>radius</code></strong></dt>
<dd>Cylinder radius.</dd>
<dt><strong><code>inf_dim</code></strong></dt>
<dd>Dimension along which the cylinder is infinite.
Use <code><a title="phi.geom.Geometry.rotated" href="#phi.geom.Geometry.rotated">Geometry.rotated()</a></code> if the direction does not align with an axis.</dd>
<dt><strong><code>**center_</code></strong></dt>
<dd>Alternatively specify center coordinates without <code>inf_dim</code> as keyword arguments.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></p></div>
</dd>
<dt id="phi.geom.intersection"><code class="name flex">
<span>def <span class="ident">intersection</span></span>(<span>*geometries: phi.geom._geom.Geometry, dim=(intersectionⁱ=None)) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def intersection(*geometries: Geometry, dim=instance(&#39;intersection&#39;)) -&gt; Geometry:
    &#34;&#34;&#34;
    Intersection of the given geometries.
    A point lies inside the union if it lies within all of the geometries.

    Args:
        *geometries: arbitrary geometries with same spatial dims. Arbitrary batch dims are allowed.
        dim: Intersection dimension. This must be an instance dimension.

    Returns:
        intersection `Geometry`
    &#34;&#34;&#34;
    return _stack_geometries(geometries, &#39;intersection&#39;, dim)</code></pre>
</details>
<div class="desc"><p>Intersection of the given geometries.
A point lies inside the union if it lies within all of the geometries.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*geometries</code></strong></dt>
<dd>arbitrary geometries with same spatial dims. Arbitrary batch dims are allowed.</dd>
<dt><strong><code>dim</code></strong></dt>
<dd>Intersection dimension. This must be an instance dimension.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>intersection <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></p></div>
</dd>
<dt id="phi.geom.invert"><code class="name flex">
<span>def <span class="ident">invert</span></span>(<span>geometry: phi.geom._geom.Geometry)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def invert(geometry: Geometry):
    &#34;&#34;&#34;
    Swaps inside and outside.

    Args:
        geometry: `phi.geom.Geometry` to swap

    Returns:
        New `phi.geom.Geometry` object with same surface but swapped normals
    &#34;&#34;&#34;
    return ~geometry</code></pre>
</details>
<div class="desc"><p>Swaps inside and outside.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>geometry</code></strong></dt>
<dd><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> to swap</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>New <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> object with same surface but swapped normals</p></div>
</dd>
<dt id="phi.geom.join_meshes"><code class="name flex">
<span>def <span class="ident">join_meshes</span></span>(<span>meshes: Sequence[phi.geom._mesh.Mesh]) ‑> phi.geom._mesh.Mesh</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def join_meshes(meshes: Sequence[Mesh]) -&gt; Mesh:
    same_vertices = all(mesh.vertices is meshes[0].vertices for mesh in meshes)
    e_name = instance(meshes[0]).name
    v_name = dual(meshes[0].elements).name
    v_offset = 0
    e_offset = 0
    vertices = []
    indices = []
    compact_sizes = [dual(m.elements._indices).size if math.get_format(m.elements) == &#39;compact-cols&#39; else -1 for m in meshes]
    compatible_compact = compact_sizes[0] &gt; 0 and all(s == compact_sizes[0] for s in compact_sizes)
    for mesh in meshes:
        vertices.append(mesh.vertices)
        if compatible_compact:
            indices.append(mesh.elements._indices + v_offset)
        else:
            idx = math.stored_indices(mesh.elements)# + (e_offset, v_offset)  # ToDo order
            idx += vec(&#39;index&#39;, **{e_name: e_offset, v_name: v_offset})[channel(idx).item_names[0]]
            indices.append(idx)
        if not same_vertices:
            v_offset += instance(mesh.vertices).size
        e_offset += instance(mesh).size
    vertices = icat(vertices)
    indices = icat(indices)
    e_dim = instance(meshes[0]).with_size(e_offset)
    v_dim = instance(vertices).as_dual()
    if compatible_compact:
        elements = CompactSparseTensor(indices, wrap(True), v_dim, True, -1)
    else:
        elements = sparse_tensor(indices, True, e_dim + v_dim)
    return replace(meshes[0], vertices=vertices, elements=elements)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.length"><code class="name flex">
<span>def <span class="ident">length</span></span>(<span>obj: phi.geom._geom.Geometry | phiml.math._tensors.Tensor, epsilon=None) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def length(obj: Union[Geometry, Tensor], epsilon=None) -&gt; Tensor:
    &#34;&#34;&#34;
    Returns the length of a vector `Tensor` or geometric object with a length-like property.

    Args:
        obj: `Tensor` with &#39;vector&#39; dim or `Geometry` with a length-like property.
        epsilon: Minimum valid vector length. Use to avoid `inf` gradients for zero-length vectors.
            Lengths shorter than `eps` are set to 0.

    Returns:
        Length as `Tensor`
    &#34;&#34;&#34;
    if isinstance(obj, Tensor):
        assert &#39;vector&#39; in obj.shape, f&#34;length() requires &#39;vector&#39; dim but got {type(obj)} with shape {shape(obj)}.&#34;
        return math.norm(obj, &#39;vector&#39;, epsilon)
    elif isinstance(obj, Cylinder):
        return obj.depth
    raise ValueError(obj)</code></pre>
</details>
<div class="desc"><p>Returns the length of a vector <code>Tensor</code> or geometric object with a length-like property.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>obj</code></strong></dt>
<dd><code>Tensor</code> with 'vector' dim or <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> with a length-like property.</dd>
<dt><strong><code>epsilon</code></strong></dt>
<dd>Minimum valid vector length. Use to avoid <code>inf</code> gradients for zero-length vectors.
Lengths shorter than <code>eps</code> are set to 0.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Length as <code>Tensor</code></p></div>
</dd>
<dt id="phi.geom.line_trace"><code class="name flex">
<span>def <span class="ident">line_trace</span></span>(<span>geo: phi.geom._geom.Geometry,<br>origin: phiml.math._tensors.Tensor,<br>direction: phiml.math._tensors.Tensor,<br>side='both',<br>tolerance=None,<br>max_iter=64,<br>step_size=0.9,<br>max_line_length=None) ‑> Tuple[phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor | None]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def line_trace(geo: Geometry, origin: Tensor, direction: Tensor, side=&#39;both&#39;, tolerance=None, max_iter=64, step_size=.9, max_line_length=None) -&gt; Tuple[Tensor, Tensor, Tensor, Tensor, Optional[Tensor]]:
    &#34;&#34;&#34;
    Trace a line until it hits the surface of `geo`.
    The surface can be hit either from the outside or the inside.

    Args:
        geo: `Geometry` that implements `approximate_closest_surface`.
        origin: Line start location.
        direction: Unit vector pointing in the line direction.
        side: &#39;outside&#39; or &#39;inside&#39; or &#39;both&#39;.
        tolerance: Surface distance tolerance.
        max_iter: Maximum number of steps per line.
        step_size: Step size factor. This can be set to `1` if the signed distance values of `geo` are exact.
            For inexact SDFs, smaller step sizes prevent skipping over surfaces.

    Returns:
        hit: Whether a surface intersection was found for the line.
        distance: Distance between the line and the surface.
        position: Hit location or point until which the line was traced.
        normal: Surface normal at hit location
        hit_index: Geometry face index at hit location
    &#34;&#34;&#34;
    assert side in [&#39;outside&#39;, &#39;inside&#39;, &#39;both&#39;], f&#34;{side} is not a valid side&#34;
    if tolerance is None:
        tolerance = 1e-4 * geo.bounding_box().size.min
    walked = 0
    has_hit = False
    initial_sdf = None
    last_sdf = None
    has_crossed = wrap(False)
    for i in range(max_iter):
        sgn_dist, delta, normal, _, face_index = geo.approximate_closest_surface(origin + walked * direction)
        initial_sdf = sgn_dist if initial_sdf is None else initial_sdf
        normal_dot_direction = normal.vector @ direction.vector
        intersection = (normal.vector @ delta.vector) / normal_dot_direction
        intersection = math.where(math.is_nan(intersection), math.INF, intersection)
        if side == &#39;both&#39;:
            can_hit_surface = True
        elif side == &#39;outside&#39;:
            can_hit_surface = normal_dot_direction &lt;= 0
        else:
            can_hit_surface = normal_dot_direction &gt;= 0
        intersection = math.where(intersection &lt; math.where(can_hit_surface, -tolerance, 0), math.INF, intersection)  # surface behind us
        if last_sdf is not None:
            if side == &#39;both&#39;:
                has_crossed = (sgn_dist * last_sdf &lt; 0) | (abs(sgn_dist) &lt;= tolerance)
            elif side == &#39;outside&#39;:
                has_crossed = (last_sdf &gt; tolerance) &amp; (sgn_dist &lt;= tolerance)
                has_crossed |= (last_sdf &gt; 0) &amp; (sgn_dist &lt;= 0)
            else:
                has_crossed = (last_sdf &lt; -tolerance) &amp; (sgn_dist &gt;= -tolerance)
                has_crossed |= (last_sdf &lt; 0) &amp; (sgn_dist &gt;= 0)
        has_hit |= has_crossed
        max_walk = math.minimum(abs(sgn_dist), intersection)
        max_walk = math.where(can_hit_surface, step_size * max_walk, max_walk + tolerance)  # jump over surface if we can&#39;t hit it
        max_walk = math.where(has_hit, 0, max_walk)
        walked += max_walk
        is_done = has_hit.all if max_line_length is None else (has_hit | walked &gt; max_line_length).all
        if is_done:
            break
        last_sdf = sgn_dist
        # trj.append(walked)
        # if i == 15:
        #     from phi.vis import show
        #     trj = stack(trj, instance(&#39;trj&#39;))
        #     show(geo, trj, overlay=&#39;args&#39;)
    else:
        warnings.warn(f&#34;thickness reached maximum iterations {max_iter}&#34;, RuntimeWarning, stacklevel=2)
    return has_hit, walked, origin + walked * direction, normal, face_index</code></pre>
</details>
<div class="desc"><p>Trace a line until it hits the surface of <code>geo</code>.
The surface can be hit either from the outside or the inside.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>geo</code></strong></dt>
<dd><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> that implements <code>approximate_closest_surface</code>.</dd>
<dt><strong><code>origin</code></strong></dt>
<dd>Line start location.</dd>
<dt><strong><code>direction</code></strong></dt>
<dd>Unit vector pointing in the line direction.</dd>
<dt><strong><code>side</code></strong></dt>
<dd>'outside' or 'inside' or 'both'.</dd>
<dt><strong><code>tolerance</code></strong></dt>
<dd>Surface distance tolerance.</dd>
<dt><strong><code>max_iter</code></strong></dt>
<dd>Maximum number of steps per line.</dd>
<dt><strong><code>step_size</code></strong></dt>
<dd>Step size factor. This can be set to <code>1</code> if the signed distance values of <code>geo</code> are exact.
For inexact SDFs, smaller step sizes prevent skipping over surfaces.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>hit</code></dt>
<dd>Whether a surface intersection was found for the line.</dd>
<dt><code>distance</code></dt>
<dd>Distance between the line and the surface.</dd>
<dt><code>position</code></dt>
<dd>Hit location or point until which the line was traced.</dd>
<dt><code>normal</code></dt>
<dd>Surface normal at hit location</dd>
<dt><code>hit_index</code></dt>
<dd>Geometry face index at hit location</dd>
</dl></div>
</dd>
<dt id="phi.geom.load_gmsh"><code class="name flex">
<span>def <span class="ident">load_gmsh</span></span>(<span>file: str,<br>boundary_names: Sequence[str] = None,<br>periodic: str = None,<br>cell_dim=(cellsⁱ=None),<br>face_format: str = 'csc')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@broadcast
def load_gmsh(file: str, boundary_names: Sequence[str] = None, periodic: str = None, cell_dim=instance(&#39;cells&#39;), face_format: str = &#39;csc&#39;):
    &#34;&#34;&#34;
    Load an unstructured mesh from a `.msh` file.

    This requires the package `meshio` to be installed.

    Args:
        file: Path to `.su2` file.
        boundary_names: Boundary identifiers corresponding to the blocks in the file. If not specified, boundaries will be numbered.
        periodic:
        cell_dim: Dimension along which to list the cells. This should be an instance dimension.
        face_format: Sparse storage format for cell connectivity.

    Returns:
        `Mesh`
    &#34;&#34;&#34;
    import meshio
    from meshio import Mesh
    mesh: Mesh = meshio.read(file)
    dim = max([c.dim for c in mesh.cells])
    if dim == 2 and mesh.points.shape[-1] == 3:
        points = mesh.points[..., :2]
    else:
        assert dim == 3, f&#34;Only 2D and 3D meshes are supported but got {dim} in {file}&#34;
        points = mesh.points
    elements = []
    boundaries = {}
    for cell_block in mesh.cells:
        if cell_block.dim == dim:  # cells
            elements.extend(cell_block.data)
        elif cell_block.dim == dim - 1:
            # derive name from cell_block.tags if present?
            boundary = str(len(boundaries)) if boundary_names is None else boundary_names[len(boundaries)]
            boundaries[boundary] = cell_block.data
        else:
            raise AssertionError(f&#34;Illegal cell block of type {cell_block.type} for {dim}D mesh&#34;)
    return mesh_from_numpy(points, elements, boundaries, periodic=periodic, cell_dim=cell_dim, face_format=face_format)</code></pre>
</details>
<div class="desc"><p>Load an unstructured mesh from a <code>.msh</code> file.</p>
<p>This requires the package <code>meshio</code> to be installed.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file</code></strong></dt>
<dd>Path to <code>.su2</code> file.</dd>
<dt><strong><code>boundary_names</code></strong></dt>
<dd>Boundary identifiers corresponding to the blocks in the file. If not specified, boundaries will be numbered.</dd>
<dt>periodic:</dt>
<dt><strong><code>cell_dim</code></strong></dt>
<dd>Dimension along which to list the cells. This should be an instance dimension.</dd>
<dt><strong><code>face_format</code></strong></dt>
<dd>Sparse storage format for cell connectivity.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.geom.Mesh" href="#phi.geom.Mesh">Mesh</a></code></p></div>
</dd>
<dt id="phi.geom.load_stl"><code class="name flex">
<span>def <span class="ident">load_stl</span></span>(<span>file: str, face_dim=(facesⁱ=None)) ‑> phi.geom._mesh.Mesh</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@broadcast
def load_stl(file: str, face_dim=instance(&#39;faces&#39;)) -&gt; Mesh:
    &#34;&#34;&#34;
    Load a triangle `Mesh` from an STL file.

    Args:
        file: File path to `.stl` file.
        face_dim: Instance dim along which to list the triangles.

    Returns:
        `Mesh` with `spatial_rank=3` and `element_rank=2`.
    &#34;&#34;&#34;
    import trimesh
    mesh = trimesh.load(file)
    if isinstance(mesh, trimesh.Scene):  # STL contains multiple parts -&gt; merge
        vertices = []
        v_count = 0
        faces = []
        for geometry in mesh.geometry.values():
            assert isinstance(geometry, trimesh.Trimesh)
            vertices.append(geometry.vertices)
            faces.append(geometry.faces + v_count)
            v_count += geometry.vertices.shape[0]
        vertices = np.concatenate(vertices)
        faces = np.concatenate(faces)
    else:
        assert isinstance(mesh, trimesh.Trimesh), f&#34;Unexpected content of STL: {mesh}&#34;
        vertices, faces = mesh.vertices, mesh.faces
    return mesh_from_numpy(vertices, faces, None, 2, None, face_dim)
    # import stl  # this only loads the first part of multi-part STL files
    # model = stl.mesh.Mesh.from_file(file, calculate_normals=False, )
    # points = np.reshape(model.points, (-1, 3))
    # vertices, indices = np.unique(points, axis=0, return_inverse=True)
    # indices = np.reshape(indices, (-1, 3))
    # mesh = mesh_from_numpy(vertices, indices, element_rank=2, cell_dim=face_dim)
    # return mesh</code></pre>
</details>
<div class="desc"><p>Load a triangle <code><a title="phi.geom.Mesh" href="#phi.geom.Mesh">Mesh</a></code> from an STL file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file</code></strong></dt>
<dd>File path to <code>.stl</code> file.</dd>
<dt><strong><code>face_dim</code></strong></dt>
<dd>Instance dim along which to list the triangles.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.geom.Mesh" href="#phi.geom.Mesh">Mesh</a></code> with <code>spatial_rank=3</code> and <code>element_rank=2</code>.</p></div>
</dd>
<dt id="phi.geom.load_su2"><code class="name flex">
<span>def <span class="ident">load_su2</span></span>(<span>file_or_mesh: str, cell_dim=(cellsⁱ=None), face_format: str = 'csc') ‑> phi.geom._mesh.Mesh</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@broadcast
def load_su2(file_or_mesh: str, cell_dim=instance(&#39;cells&#39;), face_format: str = &#39;csc&#39;) -&gt; Mesh:
    &#34;&#34;&#34;
    Load an unstructured mesh from a `.su2` file.

    This requires the package `ezmesh` to be installed.

    Args:
        file_or_mesh: Path to `.su2` file or *ezmesh* `Mesh` instance.
        cell_dim: Dimension along which to list the cells. This should be an instance dimension.
        face_format: Sparse storage format for cell connectivity.

    Returns:
        `Mesh`
    &#34;&#34;&#34;
    if isinstance(file_or_mesh, str):
        from ezmesh import import_from_file
        mesh = import_from_file(file_or_mesh)
    else:
        mesh = file_or_mesh
    if mesh.dim == 2 and mesh.points.shape[-1] == 3:
        points = mesh.points[..., :2]
    else:
        assert mesh.dim == 3, f&#34;Only 2D and 3D meshes are supported but got {mesh.dim} in {file_or_mesh}&#34;
        points = mesh.points
    boundaries = {name.strip(): markers for name, markers in mesh.markers.items()}
    return mesh_from_numpy(points, mesh.elements, boundaries, cell_dim=cell_dim, face_format=face_format)</code></pre>
</details>
<div class="desc"><p>Load an unstructured mesh from a <code>.su2</code> file.</p>
<p>This requires the package <code>ezmesh</code> to be installed.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_or_mesh</code></strong></dt>
<dd>Path to <code>.su2</code> file or <em>ezmesh</em> <code><a title="phi.geom.Mesh" href="#phi.geom.Mesh">Mesh</a></code> instance.</dd>
<dt><strong><code>cell_dim</code></strong></dt>
<dd>Dimension along which to list the cells. This should be an instance dimension.</dd>
<dt><strong><code>face_format</code></strong></dt>
<dd>Sparse storage format for cell connectivity.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.geom.Mesh" href="#phi.geom.Mesh">Mesh</a></code></p></div>
</dd>
<dt id="phi.geom.mesh"><code class="name flex">
<span>def <span class="ident">mesh</span></span>(<span>vertices: phi.geom._geom.Geometry | phiml.math._tensors.Tensor,<br>elements: phiml.math._tensors.Tensor,<br>boundaries: str | Dict[str, List[Sequence]] | None = None,<br>element_rank: int = None,<br>periodic: str = None,<br>face_format: str = 'csc',<br>max_cell_walk: int = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@broadcast(dims=batch)
def mesh(vertices: Union[Geometry, Tensor],
         elements: Tensor,
         boundaries: Union[str, Dict[str, List[Sequence]], None] = None,
         element_rank: int = None,
         periodic: str = None,
         face_format: str = &#39;csc&#39;,
         max_cell_walk: int = None):
    &#34;&#34;&#34;
    Create a mesh from vertex positions and vertex lists.

    Args:
        vertices: `Tensor` with one instance and one channel dimension `vector`.
        elements: Lists of vertex indices as 2D tensor.
            The elements must be listed along an instance dimension, and the vertex indices belonging to the same polygon must be listed along a spatial dimension.
        boundaries: Pass a `str` to assign one name to all boundary faces.
            For multiple boundaries, pass a `dict` mapping group names `str` to lists of faces, defined by their vertices.
            The last entry can be `None` to group all boundary faces not explicitly listed before.
            The `boundaries` `dict` maps boundary names to a list of edges (point pairs) in 2D and faces (3 or more points) in 3D (not yet supported).
        face_format: Storage format for cell connectivity, must be one of `csc`, `coo`, `csr`, `dense`.

    Returns:
        `Mesh`
    &#34;&#34;&#34;
    assert &#39;vector&#39; in channel(vertices), f&#34;vertices must have a channel dimension called &#39;vector&#39; but got {shape(vertices)}&#34;
    assert instance(vertices), f&#34;vertices must have an instance dimension listing all vertices of the mesh but got {shape(vertices)}&#34;
    if not isinstance(vertices, Geometry):
        vertices = Point(vertices)
    if spatial(elements):  # all elements have same number of vertices
        indices: Tensor = rename_dims(elements, spatial, instance(vertices).as_dual())
        values = expand(True, non_batch(indices))
        elements = CompactSparseTensor(indices, values, instance(vertices).as_dual(), True)
    assert instance(vertices).as_dual() in elements.shape, f&#34;elements must have the instance dim of vertices {instance(vertices)} but got {shape(elements)}&#34;
    if element_rank is None:
        if vertices.vector.size == 2:
            element_rank = 2
        elif vertices.vector.size == 3:
            min_vertices = sum_(elements, instance(vertices).as_dual()).min
            element_rank = 2 if min_vertices &lt;= 4 else 3  # assume tri or quad mesh
        else:
            raise ValueError(vertices.vector.size)
    if max_cell_walk is None:
        max_cell_walk = 2 if instance(elements).volume &gt; 1 else 1
    # --- build faces ---
    periodic_dims = []
    if periodic is not None:
        periodic_dims = [s.strip() for s in periodic.split(&#39;,&#39;) if s.strip()]
        periodic_base = [p[:-len(&#39;[::-1]&#39;)] if p.endswith(&#39;[::-1]&#39;) else p for p in periodic_dims]
        assert all(p in vertices.vector.item_names for p in periodic_base), f&#34;Periodic boundaries must be named after axes, e.g. {vertices.vector.item_names} but got {periodic}&#34;
        for base in periodic_base:
            assert base+&#39;+&#39; in boundaries and base+&#39;-&#39; in boundaries, f&#34;Missing boundaries for periodicity &#39;{base}&#39;. Make sure &#39;{base}+&#39; and &#39;{base}-&#39; are keys in boundaries dict, got {tuple(boundaries)}&#34;
    return Mesh(vertices, elements, element_rank, boundaries, periodic_dims, face_format=face_format, max_cell_walk=max_cell_walk)</code></pre>
</details>
<div class="desc"><p>Create a mesh from vertex positions and vertex lists.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>vertices</code></strong></dt>
<dd><code>Tensor</code> with one instance and one channel dimension <code>vector</code>.</dd>
<dt><strong><code>elements</code></strong></dt>
<dd>Lists of vertex indices as 2D tensor.
The elements must be listed along an instance dimension, and the vertex indices belonging to the same polygon must be listed along a spatial dimension.</dd>
<dt><strong><code>boundaries</code></strong></dt>
<dd>Pass a <code>str</code> to assign one name to all boundary faces.
For multiple boundaries, pass a <code>dict</code> mapping group names <code>str</code> to lists of faces, defined by their vertices.
The last entry can be <code>None</code> to group all boundary faces not explicitly listed before.
The <code>boundaries</code> <code>dict</code> maps boundary names to a list of edges (point pairs) in 2D and faces (3 or more points) in 3D (not yet supported).</dd>
<dt><strong><code>face_format</code></strong></dt>
<dd>Storage format for cell connectivity, must be one of <code>csc</code>, <code>coo</code>, <code>csr</code>, <code>dense</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.geom.Mesh" href="#phi.geom.Mesh">Mesh</a></code></p></div>
</dd>
<dt id="phi.geom.mesh_from_numpy"><code class="name flex">
<span>def <span class="ident">mesh_from_numpy</span></span>(<span>points: Sequence[Sequence],<br>polygons: Sequence[Sequence],<br>boundaries: str | Dict[str, List[Sequence]] | None = None,<br>element_rank: int = None,<br>periodic: str = None,<br>cell_dim: phiml.math._shape.Shape = (cellsⁱ=None),<br>face_format: str = 'csc',<br>axes=('x', 'y', 'z')) ‑> phi.geom._mesh.Mesh</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mesh_from_numpy(points: Sequence[Sequence],
                    polygons: Sequence[Sequence],
                    boundaries: Union[str, Dict[str, List[Sequence]], None] = None,
                    element_rank: int = None,
                    periodic: str = None,
                    cell_dim: Shape = instance(&#39;cells&#39;),
                    face_format: str = &#39;csc&#39;,
                    axes=(&#39;x&#39;, &#39;y&#39;, &#39;z&#39;)) -&gt; Mesh:
    &#34;&#34;&#34;
    Construct an unstructured mesh from vertices.

    Args:
        points: 2D numpy array of shape (num_points, point_coord).
            The last dimension must have length 2 for 2D meshes and 3 for 3D meshes.
        polygons: List of elements. Each polygon is defined as a sequence of point indices mapping into `points&#39;.
            E.g. `[(0, 1, 2)]` denotes a single triangle connecting points 0, 1, and 2.
        boundaries: An unstructured mesh can have multiple boundaries, each defined by a name `str` and a list of faces, defined by their vertices.
            The `boundaries` `dict` maps boundary names to a list of edges (point pairs) in 2D and faces (3 or more points) in 3D (not yet supported).
        cell_dim: Dimension along which to list the cells. This should be an instance dimension.
        face_format: Storage format for cell connectivity, must be one of `csc`, `coo`, `csr`, `dense`.

    Returns:
        `Mesh`
    &#34;&#34;&#34;
    cell_dim = cell_dim.with_size(len(polygons))
    points = np.asarray(points)
    xyz = tuple(axes[:points.shape[-1]])
    vertices = wrap(points, instance(&#39;vertices&#39;), channel(vector=xyz))
    if len(polygons) == 0:
        elements = math.ones(cell_dim, instance(vertices).as_dual(), dtype=bool)
        return mesh(vertices, elements, boundaries, element_rank, periodic, face_format)
    try:  # if all elements have the same vertex count, we stack them
        elements_np = np.stack(polygons).astype(np.int32)
        elements = wrap(elements_np, cell_dim, spatial(&#39;vertex_index&#39;))
    except ValueError:
        indices = np.concatenate(polygons)
        vertex_count = np.asarray([len(e) for e in polygons])
        ptr = np.pad(np.cumsum(vertex_count), (1, 0))
        mat = csr_matrix((np.ones(indices.shape, dtype=bool), indices, ptr), shape=(len(polygons), len(points)))
        elements = wrap(mat, cell_dim, instance(vertices).as_dual())
    return mesh(vertices, elements, boundaries, element_rank, periodic, face_format=face_format)</code></pre>
</details>
<div class="desc"><p>Construct an unstructured mesh from vertices.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>points</code></strong></dt>
<dd>2D numpy array of shape (num_points, point_coord).
The last dimension must have length 2 for 2D meshes and 3 for 3D meshes.</dd>
<dt><strong><code>polygons</code></strong></dt>
<dd>List of elements. Each polygon is defined as a sequence of point indices mapping into `points'.
E.g. <code>[(0, 1, 2)]</code> denotes a single triangle connecting points 0, 1, and 2.</dd>
<dt><strong><code>boundaries</code></strong></dt>
<dd>An unstructured mesh can have multiple boundaries, each defined by a name <code>str</code> and a list of faces, defined by their vertices.
The <code>boundaries</code> <code>dict</code> maps boundary names to a list of edges (point pairs) in 2D and faces (3 or more points) in 3D (not yet supported).</dd>
<dt><strong><code>cell_dim</code></strong></dt>
<dd>Dimension along which to list the cells. This should be an instance dimension.</dd>
<dt><strong><code>face_format</code></strong></dt>
<dd>Storage format for cell connectivity, must be one of <code>csc</code>, <code>coo</code>, <code>csr</code>, <code>dense</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.geom.Mesh" href="#phi.geom.Mesh">Mesh</a></code></p></div>
</dd>
<dt id="phi.geom.normal_from_slope"><code class="name flex">
<span>def <span class="ident">normal_from_slope</span></span>(<span>slope: phiml.math._tensors.Tensor,<br>space: str | phiml.math._shape.Shape | Sequence[str])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normal_from_slope(slope: Tensor, space: Union[str, Shape, Sequence[str]]):
    &#34;&#34;&#34;
    Computes the normal vector of a line, plane, or hyperplane.

    Args:
        slope: Line Slope (2D), plane slope (3D) or hyperplane slope (4+D).
            Must have one channel dimension listing the vector components.
            The vector must list all but one dimensions of `space`.
        space: Ordered spatial dimensions as comma-separated string, sequence of names or `Shape`

    Returns:
        Normal vector with the channel dimension of `slope` listing all dimensions of `space` in that order.
    &#34;&#34;&#34;
    assert channel(slope).rank == 1 and all(d in space for d in channel(slope).item_names[0]), f&#34;slope must have a single channel dim listing all but one component of the space {space} but got {slope.shape}&#34;
    space = parse_dim_order(space)
    assert len(space) &gt; 1, f&#34;space must contain at least 2 dimensions&#34;
    up = set(space) - set(channel(slope).item_names[0])
    assert len(up) == 1, f&#34;space must have exactly one more dimension than slope but got slope {channel(slope)} for space {space}&#34;
    up = next(iter(up))
    normal = vec(channel(slope).name, **{d: 1 if d == up else -slope[d] for d in space})
    return vec_normalize(normal, allow_infinite=True)</code></pre>
</details>
<div class="desc"><p>Computes the normal vector of a line, plane, or hyperplane.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>slope</code></strong></dt>
<dd>Line Slope (2D), plane slope (3D) or hyperplane slope (4+D).
Must have one channel dimension listing the vector components.
The vector must list all but one dimensions of <code>space</code>.</dd>
<dt><strong><code>space</code></strong></dt>
<dd>Ordered spatial dimensions as comma-separated string, sequence of names or <code>Shape</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Normal vector with the channel dimension of <code>slope</code> listing all dimensions of <code>space</code> in that order.</p></div>
</dd>
<dt id="phi.geom.normalize"><code class="name flex">
<span>def <span class="ident">normalize</span></span>(<span>obj: phiml.math._tensors.Tensor,<br>epsilon=1e-05,<br>allow_infinite=False,<br>allow_zero=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalize(obj: Tensor, epsilon=1e-5, allow_infinite=False, allow_zero=True):
    &#34;&#34;&#34;
    Normalize a vector `Tensor` along the &#39;vector&#39; dim.

    Args:
        obj: `Tensor` with &#39;vector&#39; dim.
        epsilon: (Optional) Zero-length threshold. Vectors shorter than this length yield the unit vector (1, 0, 0, ...).
            If not specified, the zero-vector yields `NaN` as it cannot be normalized.
        allow_infinite: Allow infinite components in vectors. These vectors will then only points towards the infinite components.
        allow_zero: Whether to return zero vectors for inputs smaller `epsilon` instead of a unit vector.

    Returns:
        `Tensor` of the same shape as `obj`.
    &#34;&#34;&#34;
    assert &#39;vector&#39; in obj.shape, f&#34;normalize() requires &#39;vector&#39; dim but got {type(obj)} with shape {shape(obj)}.&#34;
    return math.normalize(obj, &#39;vector&#39;, epsilon, allow_infinite=allow_infinite, allow_zero=allow_zero)</code></pre>
</details>
<div class="desc"><p>Normalize a vector <code>Tensor</code> along the 'vector' dim.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>obj</code></strong></dt>
<dd><code>Tensor</code> with 'vector' dim.</dd>
<dt><strong><code>epsilon</code></strong></dt>
<dd>(Optional) Zero-length threshold. Vectors shorter than this length yield the unit vector (1, 0, 0, &hellip;).
If not specified, the zero-vector yields <code>NaN</code> as it cannot be normalized.</dd>
<dt><strong><code>allow_infinite</code></strong></dt>
<dd>Allow infinite components in vectors. These vectors will then only points towards the infinite components.</dd>
<dt><strong><code>allow_zero</code></strong></dt>
<dd>Whether to return zero vectors for inputs smaller <code>epsilon</code> instead of a unit vector.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>Tensor</code> of the same shape as <code>obj</code>.</p></div>
</dd>
<dt id="phi.geom.numpy_sdf"><code class="name flex">
<span>def <span class="ident">numpy_sdf</span></span>(<span>sdf: Callable,<br>bounds: phi.geom._box.Box,<br>center: phiml.math._tensors.Tensor = None) ‑> phi.geom._sdf.SDF</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numpy_sdf(sdf: Callable, bounds: Box, center: Tensor = None) -&gt; SDF:
    &#34;&#34;&#34;
    Define a `SDF` (signed distance function) from a NumPy function.

    Args:
        sdf: Function mapping a location `numpy.ndarray` of shape `(points, vector)` to the corresponding SDF value `(points,)`.
        bounds: Bounds inside which the function is defined.
        center: Optional center position of the object encoded via `sdf`.

    Returns:
        `SDF`
    &#34;&#34;&#34;
    def native_sdf_function(pos: Tensor) -&gt; Tensor:
        nat_pos = math.reshaped_native(pos, [..., &#39;vector&#39;])
        nat_sdf = pos.default_backend.numpy_call(sdf, nat_pos.shape[:1], math.DType(float, 32), nat_pos)
        with pos.default_backend:
            return math.reshaped_tensor(nat_sdf, [pos.shape - &#39;vector&#39;])
    return SDF(native_sdf_function, math.EMPTY_SHAPE, bounds, center)</code></pre>
</details>
<div class="desc"><p>Define a <code><a title="phi.geom.SDF" href="#phi.geom.SDF">SDF</a></code> (signed distance function) from a NumPy function.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sdf</code></strong></dt>
<dd>Function mapping a location <code>numpy.ndarray</code> of shape <code>(points, vector)</code> to the corresponding SDF value <code>(points,)</code>.</dd>
<dt><strong><code>bounds</code></strong></dt>
<dd>Bounds inside which the function is defined.</dd>
<dt><strong><code>center</code></strong></dt>
<dd>Optional center position of the object encoded via <code>sdf</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.geom.SDF" href="#phi.geom.SDF">SDF</a></code></p></div>
</dd>
<dt id="phi.geom.pack_dims"><code class="name flex">
<span>def <span class="ident">pack_dims</span></span>(<span>value,<br>dims: str | Sequence | set | phiml.math._shape.Shape | Callable | None,<br>packed_dim: phiml.math._shape.Shape | str,<br>pos: int | None = None,<br>**kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pack_dims(value, dims: DimFilter, packed_dim: Union[Shape, str], pos: Optional[int] = None, **kwargs):
    &#34;&#34;&#34;
    Compresses multiple dims into a single dimension by concatenating the elements.
    Elements along the new dims are laid out according to the order of `dims`.
    If the order of `dims` differs from the current dimension order, the tensor is transposed accordingly.
    This function replaces the traditional `reshape` for these cases.

    The type of the new dimension will be equal to the types of `dims`.
    If `dims` have varying types, the new dimension will be a batch dimension.

    If none of `dims` exist on `value`, `packed_dim` will be added only if it is given with a definite size and `value` is not a primitive type.

    See Also:
        `unpack_dim()`

    Args:
        value: `phiml.math.magic.Shapable`, such as `phiml.math.Tensor`.
        dims: Dimensions to be compressed in the specified order.
        packed_dim: Single-dimension `Shape`.
        pos: Index of new dimension. `None` for automatic, `-1` for last, `0` for first.
        **kwargs: Additional keyword arguments required by specific implementations.
            Adding spatial dims to fields requires the `bounds: Box` argument specifying the physical extent of the new dimensions.
            Adding batch dims must always work without keyword arguments.

    Returns:
        Same type as `value`.

    Examples:
        &gt;&gt;&gt; pack_dims(math.zeros(spatial(x=4, y=3)), spatial, instance(&#39;points&#39;))
        (pointsⁱ=12) const 0.0
    &#34;&#34;&#34;
    if isinstance(value, (Number, bool)):
        return value
    if DEBUG_CHECKS:
        assert isinstance(value, Shapable) and isinstance(value, Sliceable) and isinstance(value, Shaped), f&#34;value must be Shapable but got {type(value)}&#34;
    packed_dim = auto(packed_dim, dims if callable(dims) else None) if isinstance(packed_dim, str) else packed_dim
    dims = shape(value).only(dims, reorder=True)
    if packed_dim in shape(value):
        assert packed_dim in dims, f&#34;Cannot pack dims into new dimension {packed_dim} because it already exists on value {value} and is not packed.&#34;
    if len(dims) == 0 or all(dim not in shape(value) for dim in dims):
        return value if packed_dim.size is None else expand(value, packed_dim, **kwargs)  # Inserting size=1 can cause shape errors
    elif len(dims) == 1 and packed_dim.rank == 1:
        return rename_dims(value, dims, packed_dim, **kwargs)
    elif len(dims) == 1 and packed_dim.rank &gt; 1:
        return unpack_dim(value, dims, packed_dim, **kwargs)
    # --- First try __pack_dims__ ---
    if hasattr(value, &#39;__pack_dims__&#39;):
        result = value.__pack_dims__(dims, packed_dim, pos, **kwargs)
        if result is not NotImplemented:
            return result
    # --- Next try Tree Node ---
    if isinstance(value, PhiTreeNode):
        return tree_map(pack_dims, value, attr_type=all_attributes, dims=dims, packed_dim=packed_dim, pos=pos, **kwargs)
    # --- Fallback: unstack and stack ---
    if shape(value).only(dims).volume &gt; 8:
        warnings.warn(f&#34;pack_dims() default implementation is slow on large dims ({shape(value).only(dims)}). Please implement __pack_dims__() for {type(value).__name__} as defined in phiml.math.magic&#34;, RuntimeWarning, stacklevel=2)
    return stack(unstack(value, dims), packed_dim, **kwargs)</code></pre>
</details>
<div class="desc"><p>Compresses multiple dims into a single dimension by concatenating the elements.
Elements along the new dims are laid out according to the order of <code>dims</code>.
If the order of <code>dims</code> differs from the current dimension order, the tensor is transposed accordingly.
This function replaces the traditional <code>reshape</code> for these cases.</p>
<p>The type of the new dimension will be equal to the types of <code>dims</code>.
If <code>dims</code> have varying types, the new dimension will be a batch dimension.</p>
<p>If none of <code>dims</code> exist on <code>value</code>, <code>packed_dim</code> will be added only if it is given with a definite size and <code>value</code> is not a primitive type.</p>
<p>See Also:
<code>unpack_dim()</code></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong></dt>
<dd><code>phiml.math.magic.Shapable</code>, such as <code>phiml.math.Tensor</code>.</dd>
<dt><strong><code>dims</code></strong></dt>
<dd>Dimensions to be compressed in the specified order.</dd>
<dt><strong><code>packed_dim</code></strong></dt>
<dd>Single-dimension <code>Shape</code>.</dd>
<dt><strong><code>pos</code></strong></dt>
<dd>Index of new dimension. <code>None</code> for automatic, <code>-1</code> for last, <code>0</code> for first.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Additional keyword arguments required by specific implementations.
Adding spatial dims to fields requires the <code>bounds: Box</code> argument specifying the physical extent of the new dimensions.
Adding batch dims must always work without keyword arguments.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Same type as <code>value</code>.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; pack_dims(math.zeros(spatial(x=4, y=3)), spatial, instance('points'))
(pointsⁱ=12) const 0.0
</code></pre></div>
</dd>
<dt id="phi.geom.rotate"><code class="name flex">
<span>def <span class="ident">rotate</span></span>(<span>obj: ~GeometricType,<br>rot: float | phiml.math._tensors.Tensor | None,<br>invert=False,<br>pivot: str | phiml.math._tensors.Tensor = 'bounds') ‑> ~GeometricType</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotate(obj: GeometricType, rot: Union[float, Tensor, None], invert=False, pivot: Union[Tensor, str] = &#39;bounds&#39;) -&gt; GeometricType:
    &#34;&#34;&#34;
    Rotate a vector or `Geometry` about the `pivot`.

    Args:
        obj: n-dimensional vector `Tensor` or `Geometry`.
        rot: Euler angle(s) or rotation matrix.
            `None` is interpreted as no rotation.
        invert: Whether to apply the inverse rotation.
        pivot: Either a point (`Tensor`) lying on the rotation axis or one of the following strings: &#39;bounds&#39;, &#39;individual&#39;.
            Vector tensors are rotated about the origin if `pivot` is not given as a `Tensor`.

    Returns:
        Rotated vector as `Tensor`
    &#34;&#34;&#34;
    if rot is None:
        return obj
    if isinstance(rot, Tensor) and rot.dtype.kind == object:
        return math.map(rotate, obj, rot, invert=invert, pivot=pivot, dims=rot.shape)
    if isinstance(obj, Geometry):
        if pivot is None:
            pivot = obj.bounding_box().center
        from ._mesh import Mesh
        if isinstance(obj, Mesh):
            vertices = rotate(obj.vertex_positions, rot, invert=invert, pivot=pivot)
            return obj.at(vertices)
        center = pivot + rotate(obj.center - pivot, rot, invert=invert)
        if invert:
            raise NotImplementedError
        return obj.rotated(rot).at(center)
    elif isinstance(obj, Tensor):
        if isinstance(pivot, Tensor):
            return pivot + rotate_vector(obj - pivot, rot, invert=invert)
        else:
            return rotate_vector(obj, rot, invert=invert)</code></pre>
</details>
<div class="desc"><p>Rotate a vector or <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> about the <code>pivot</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>obj</code></strong></dt>
<dd>n-dimensional vector <code>Tensor</code> or <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.</dd>
<dt><strong><code>rot</code></strong></dt>
<dd>Euler angle(s) or rotation matrix.
<code>None</code> is interpreted as no rotation.</dd>
<dt><strong><code>invert</code></strong></dt>
<dd>Whether to apply the inverse rotation.</dd>
<dt><strong><code>pivot</code></strong></dt>
<dd>Either a point (<code>Tensor</code>) lying on the rotation axis or one of the following strings: 'bounds', 'individual'.
Vector tensors are rotated about the origin if <code>pivot</code> is not given as a <code>Tensor</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Rotated vector as <code>Tensor</code></p></div>
</dd>
<dt id="phi.geom.rotation_angles"><code class="name flex">
<span>def <span class="ident">rotation_angles</span></span>(<span>rot: phiml.math._tensors.Tensor)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotation_angles(rot: Tensor):
    &#34;&#34;&#34;
    Compute the scalar x in 2D or the Euler angles in 3D from a given rotation matrix.
    This function returns one valid solution but often, there are multiple solutions.

    Args:
        rot: Rotation matrix as created by `phi.math.rotation_matrix()`.
            Must have exactly one channel and one dual dimension with equally-ordered elements.

    Returns:
        Scalar x in 2D, Euler angles
    &#34;&#34;&#34;
    assert channel(rot).rank == 1 and dual(rot).rank == 1, f&#34;Rotation matrix must have one channel and one dual dimension but got {rot.shape}&#34;
    if channel(rot).size == 2:
        cos = rot[{channel: 0, dual: 0}]
        sin = rot[{channel: 1, dual: 0}]
        return math.arctan(sin, divide_by=cos)
    elif channel(rot).size == 3:
        a2 = -math.arcsin(rot[{channel: 2, dual: 0}])  # ToDo handle [2, 0] == 1 (i.e. cos_theta == 0)
        cos2 = math.cos(a2)
        a1 = math.arctan(rot[{channel: 2, dual: 1}] / cos2, divide_by=rot[{channel: 2, dual: 2}] / cos2)
        a3 = math.arctan(rot[{channel: 1, dual: 0}] / cos2, divide_by=rot[{channel: 0, dual: 0}] / cos2)
        regular_sol = stack([a1, a2, a3], channel(angle=channel(rot).item_names[0]))
        # --- pole case cos(theta) == 1 ---
        a3_pole = 0  # unconstrained
        bottom_pole = rot[{channel: 2, dual: 0}] &lt; 0
        a2_pole = math.where(bottom_pole, 1.57079632679, -1.57079632679)
        a1_pole = math.where(bottom_pole, math.arctan(rot[{channel: 0, dual: 1}], divide_by=rot[{channel: 0, dual: 2}]), math.arctan(-rot[{channel: 0, dual: 1}], divide_by=-rot[{channel: 0, dual: 2}]))
        pole_sol = stack([a1_pole, a2_pole, a3_pole], channel(regular_sol))
        return math.where(abs(rot[{channel: 2, dual: 0}]) &gt;= 1, pole_sol, regular_sol)
    else:
        raise ValueError(f&#34;&#34;)</code></pre>
</details>
<div class="desc"><p>Compute the scalar x in 2D or the Euler angles in 3D from a given rotation matrix.
This function returns one valid solution but often, there are multiple solutions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>rot</code></strong></dt>
<dd>Rotation matrix as created by <code>phi.math.rotation_matrix()</code>.
Must have exactly one channel and one dual dimension with equally-ordered elements.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Scalar x in 2D, Euler angles</p></div>
</dd>
<dt id="phi.geom.rotation_matrix"><code class="name flex">
<span>def <span class="ident">rotation_matrix</span></span>(<span>x: float | phiml.math._tensors.Tensor | None,<br>matrix_dim=(vectorᶜ=None),<br>none_to_unit=False) ‑> phiml.math._tensors.Tensor | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotation_matrix(x: Union[float, math.Tensor, None], matrix_dim=channel(&#39;vector&#39;), none_to_unit=False) -&gt; Optional[Tensor]:
    &#34;&#34;&#34;
    Create a 2D or 3D rotation matrix from the corresponding angle(s).

    Args:
        x:
            2D: scalar angle
            3D: Either vector pointing along the rotation axis with rotation angle as length or Euler angles.
            Euler angles need to be laid out along a `angle` channel dimension with dimension names listing the spatial dimensions.
            E.g. a 90° rotation about the z-axis is represented by `vec(&#39;angles&#39;, x=0, y=0, z=PI/2)`.
            If a rotation matrix is passed for `angle`, it is returned without modification.
        matrix_dim: Matrix dimension for 2D rotations. In 3D, the channel dimension of angle is used.

    Returns:
        Matrix containing `matrix_dim` in primal and dual form as well as all non-channel dimensions of `x`.
    &#34;&#34;&#34;
    if x is None and not none_to_unit:
        return None
    elif x is None:
        return to_float(arange(matrix_dim) == arange(matrix_dim.as_dual()))
    if isinstance(x, Tensor) and x.dtype == object:  # possibly None in matrices
        return math.map(rotation_matrix, x, dims=object, matrix_dim=matrix_dim, none_to_unit=none_to_unit)
    if isinstance(x, Tensor) and &#39;~vector&#39; in x.shape and &#39;vector&#39; in x.shape.channel and x.shape.get_size(&#39;~vector&#39;) == x.shape.get_size(&#39;vector&#39;):
        return x  # already a rotation matrix
    elif &#39;angle&#39; in shape(x) and shape(x).get_size(&#39;angle&#39;) == 3:  # 3D Euler angles
        assert channel(x).rank == 1 and channel(x).size == 3, f&#34;x for 3D rotations needs to be a 3-vector but got {x}&#34;
        s1, s2, s3 = math.sin(x).angle  # x, y, z
        c1, c2, c3 = math.cos(x).angle
        matrix_dim = matrix_dim.with_size(shape(x).get_item_names(&#39;angle&#39;))
        return wrap([[c3 * c2, c3 * s2 * s1 - s3 * c1, c3 * s2 * c1 + s3 * s1],
                     [s3 * c2, s3 * s2 * s1 + c3 * c1, s3 * s2 * c1 - c3 * s1],
                     [-s2, c2 * s1, c2 * c1]], matrix_dim, matrix_dim.as_dual())  # Rz * Ry * Rx  (1. rotate about X by first angle)
    elif &#39;vector&#39; in shape(x) and shape(x).get_size(&#39;vector&#39;) == 3:  # 3D axis + x
        angle = vec_length(x)
        s, c = math.sin(angle), math.cos(angle)
        t = 1 - c
        k1, k2, k3 = normalize(x, epsilon=1e-12).vector
        matrix_dim = matrix_dim.with_size(shape(x).get_item_names(&#39;vector&#39;))
        return wrap([[c + k1**2 * t, k1 * k2 * t - k3 * s, k1 * k3 * t + k2 * s],
                     [k2 * k1 * t + k3 * s, c + k2**2 * t, k2 * k3 * t - k1 * s],
                     [k3 * k1 * t - k2 * s, k3 * k2 * t + k1 * s, c + k3**2 * t]], matrix_dim, matrix_dim.as_dual())
    else:  # 2D rotation
        sin = wrap(math.sin(x))
        cos = wrap(math.cos(x))
        return wrap([[cos, -sin], [sin, cos]], matrix_dim, matrix_dim.as_dual())</code></pre>
</details>
<div class="desc"><p>Create a 2D or 3D rotation matrix from the corresponding angle(s).</p>
<h2 id="args">Args</h2>
<dl>
<dt>x:</dt>
<dt>2D: scalar angle</dt>
<dt>3D: Either vector pointing along the rotation axis with rotation angle as length or Euler angles.</dt>
<dt>Euler angles need to be laid out along a <code>angle</code> channel dimension with dimension names listing the spatial dimensions.</dt>
<dt>E.g. a 90° rotation about the z-axis is represented by <code>vec('angles', x=0, y=0, z=PI/2)</code>.</dt>
<dt>If a rotation matrix is passed for <code>angle</code>, it is returned without modification.</dt>
<dt><strong><code>matrix_dim</code></strong></dt>
<dd>Matrix dimension for 2D rotations. In 3D, the channel dimension of angle is used.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Matrix containing <code>matrix_dim</code> in primal and dual form as well as all non-channel dimensions of <code>x</code>.</p></div>
</dd>
<dt id="phi.geom.rotation_matrix_from_axis_and_angle"><code class="name flex">
<span>def <span class="ident">rotation_matrix_from_axis_and_angle</span></span>(<span>axis: phiml.math._tensors.Tensor,<br>angle: phiml.math._tensors.Tensor | float,<br>vec_dim='vector',<br>is_axis_normalized=False,<br>epsilon=1e-05) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotation_matrix_from_axis_and_angle(axis: Tensor, angle: Union[float, Tensor], vec_dim=&#39;vector&#39;, is_axis_normalized=False, epsilon=1e-5) -&gt; Tensor:
    &#34;&#34;&#34;
    Computes a rotation matrix that rotates by `angle` around `axis`.

    Args:
        axis: 3D vector. `Tensor` with channel dim called &#39;vector&#39;.
        angle: Rotation angle.
        is_axis_normalized: Whether `axis` has length 1.
        epsilon: Minimum axis length. For shorter axes, the unit matrix is returned.

    Returns:
        Rotation matrix as `Tensor` with &#39;vector&#39; dim and its dual counterpart.
    &#34;&#34;&#34;
    if axis.vector.size == 3:  # Rodrigues&#39; rotation formula
        axis = normalize(axis, vec_dim, epsilon=epsilon, allow_zero=False) if not is_axis_normalized else axis
        kx, ky, kz = axis.vector
        s = math.sin(angle)
        c = 1 - math.cos(angle)
        return wrap([
            (1 - c*(ky*ky+kz*kz),    -kz*s + c*(kx*ky),     ky*s + c*(kx*kz)),
            (   kz*s + c*(kx*ky),  1 - c*(kx*kx+kz*kz),     -kx*s + c*(ky * kz)),
            (  -ky*s + c*(kx*kz),    kx*s + c*(ky * kz),  1 - c*(kx*kx+ky*ky)),
        ], axis.shape[&#39;vector&#39;], axis.shape[&#39;vector&#39;].as_dual())
    raise NotImplementedError</code></pre>
</details>
<div class="desc"><p>Computes a rotation matrix that rotates by <code>angle</code> around <code>axis</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>axis</code></strong></dt>
<dd>3D vector. <code>Tensor</code> with channel dim called 'vector'.</dd>
<dt><strong><code>angle</code></strong></dt>
<dd>Rotation angle.</dd>
<dt><strong><code>is_axis_normalized</code></strong></dt>
<dd>Whether <code>axis</code> has length 1.</dd>
<dt><strong><code>epsilon</code></strong></dt>
<dd>Minimum axis length. For shorter axes, the unit matrix is returned.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Rotation matrix as <code>Tensor</code> with 'vector' dim and its dual counterpart.</p></div>
</dd>
<dt id="phi.geom.rotation_matrix_from_directions"><code class="name flex">
<span>def <span class="ident">rotation_matrix_from_directions</span></span>(<span>source_dir: phiml.math._tensors.Tensor,<br>target_dir: phiml.math._tensors.Tensor,<br>vec_dim: str = 'vector',<br>epsilon=None) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotation_matrix_from_directions(source_dir: Tensor, target_dir: Tensor, vec_dim: str = &#39;vector&#39;, epsilon=None) -&gt; Tensor:
    &#34;&#34;&#34;
    Computes a rotation matrix A, such that `target_dir = A @ source_dir`

    Args:
        source_dir: Two or three-dimensional vector. `Tensor` with channel dim called &#39;vector&#39;.
        target_dir: Two or three-dimensional vector. `Tensor` with channel dim called &#39;vector&#39;.

    Returns:
        Rotation matrix as `Tensor` with &#39;vector&#39; dim and its dual counterpart.
    &#34;&#34;&#34;
    if source_dir.vector.size == 3:
        axis, angle = axis_angle_from_directions(source_dir, target_dir, vec_dim, epsilon=epsilon)
        return rotation_matrix_from_axis_and_angle(axis, angle, is_axis_normalized=False, epsilon=epsilon)
    raise NotImplementedError</code></pre>
</details>
<div class="desc"><p>Computes a rotation matrix A, such that <code>target_dir = A @ source_dir</code></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>source_dir</code></strong></dt>
<dd>Two or three-dimensional vector. <code>Tensor</code> with channel dim called 'vector'.</dd>
<dt><strong><code>target_dir</code></strong></dt>
<dd>Two or three-dimensional vector. <code>Tensor</code> with channel dim called 'vector'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Rotation matrix as <code>Tensor</code> with 'vector' dim and its dual counterpart.</p></div>
</dd>
<dt id="phi.geom.sample_function"><code class="name flex">
<span>def <span class="ident">sample_function</span></span>(<span>f: Callable,<br>elements: phi.geom._geom.Geometry,<br>at: str,<br>extrapolation: phiml.math.extrapolation.Extrapolation) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_function(f: Callable, elements: Geometry, at: str, extrapolation: Extrapolation) -&gt; Tensor:
    &#34;&#34;&#34;
    Calls `f`, passing either the `elements` directly or the relevant sample points as a `Tensor`, depending on the signature of `f`.

    Args:
        f: Function taking a `Geometry` or location `Tensor´ and returning a `Tensor`.
            A `Geometry` will be passed if the first argument of `f` is called `geometry` or `geo` or ends with `_geo`.
        elements: `Geometry` on which to sample `f`.
        at: Set of sample points, see `Geometry.sets`.
        extrapolation: Determines which boundary points are relevant.

    Returns:
        Sampled values as `Tensor`.
    &#34;&#34;&#34;
    from phiml.math._functional import get_function_parameters
    pass_geometry = False
    try:
        params = get_function_parameters(f)
        dims = elements.shape.get_size(&#39;vector&#39;)
        names_match = tuple(params.keys())[:dims] == elements.shape.get_item_names(&#39;vector&#39;)
        num_positional = 0
        varargs_only = False
        for i, (n, p) in enumerate(params.items()):
            if p.default is p.empty and p.kind == 1:
                num_positional += 1
            if p.kind == 2 and i == 0:  # _ParameterKind.VAR_POSITIONAL
                varargs_only = True
        assert num_positional &lt;= dims, f&#34;Cannot sample {f.__name__}({&#39;, &#39;.join(tuple(params))}) on physical space {elements.shape.get_item_names(&#39;vector&#39;)}&#34;
        pass_varargs = varargs_only or names_match or num_positional &gt; 1 or num_positional == dims
        if num_positional &gt; 1 and not varargs_only:
            assert names_match, f&#34;Positional arguments of {f.__name__}({&#39;, &#39;.join(tuple(params))}) should match physical space {elements.shape.get_item_names(&#39;vector&#39;)}&#34;
        if not pass_varargs:
            first = next(iter(params))
            if first in [&#39;geo&#39;, &#39;geometry&#39;] or &#39;_geo&#39; in first:
                pass_geometry = True
    except ValueError as err:  # signature not available for all functions
        pass_varargs = False
    if at == &#39;center&#39;:
        pos = slice_off_constant_faces(elements if pass_geometry else elements.center, elements.boundary_elements, extrapolation)
    else:
        pos = elements if pass_geometry else slice_off_constant_faces(elements.face_centers, elements.boundary_faces, extrapolation)
    if pass_varargs:
        values = math.map_s2b(f)(*pos.vector)
    else:
        values = math.map_s2b(f)(pos)
    assert isinstance(values, math.Tensor), f&#34;values function must return a Tensor but returned {type(values)}&#34;
    return values</code></pre>
</details>
<div class="desc"><p>Calls <code>f</code>, passing either the <code>elements</code> directly or the relevant sample points as a <code>Tensor</code>, depending on the signature of <code>f</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>f</code></strong></dt>
<dd>Function taking a <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> or location <code>Tensor´ and returning a</code>Tensor`.
A <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> will be passed if the first argument of <code>f</code> is called <code>geometry</code> or <code>geo</code> or ends with <code>_geo</code>.</dd>
<dt><strong><code>elements</code></strong></dt>
<dd><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> on which to sample <code>f</code>.</dd>
<dt><strong><code>at</code></strong></dt>
<dd>Set of sample points, see <code><a title="phi.geom.Geometry.sets" href="#phi.geom.Geometry.sets">Geometry.sets</a></code>.</dd>
<dt><strong><code>extrapolation</code></strong></dt>
<dd>Determines which boundary points are relevant.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Sampled values as <code>Tensor</code>.</p></div>
</dd>
<dt id="phi.geom.sample_sdf"><code class="name flex">
<span>def <span class="ident">sample_sdf</span></span>(<span>geometry: phi.geom._geom.Geometry,<br>bounds: phi.geom._box.Box | phi.geom._grid.UniformGrid = None,<br>resolution: phiml.math._shape.Shape = (),<br>approximate_outside=False,<br>rebuild: str | None = None,<br>valid_dist=None,<br>rel_margin=0.1,<br>abs_margin=0.0,<br>cache_surface=False,<br>**resolution_: int) ‑> phi.geom._sdf_grid.SDFGrid</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_sdf(geometry: Geometry,
               bounds: Union[Box, UniformGrid] = None,
               resolution: Shape = math.EMPTY_SHAPE,
               approximate_outside=False,
               rebuild: Optional[str] = None,
               valid_dist=None,
               rel_margin=.1,
               abs_margin=0.,
               cache_surface=False,
               **resolution_: int) -&gt; SDFGrid:
    &#34;&#34;&#34;
    Build a grid of signed distance values for a given `Geometry` object.

    Args:
        geometry: `Geometry` to capture.
        bounds: Grid limits in world space.
        resolution: Grid resolution.
        **resolution_: Grid resolution as `kwargs`, e.g. `x=64, y=32`.
        approximate_outside: Whether queries outside the SDF grid should return approximate values. This requires additional computations.
        rebuild: If `&#39;from-surface&#39;`, SDF values are calculated from a narrow strip above the enclosed surface. This is more accurate but requires additional steps.
            If `None` (default), SDF values are queried from `geometry`.
            `&#39;auto&#39;` rebuilds when geometry querying is expected to be in accurate.

    Returns:
        SDF grid as `Geometry`.
    &#34;&#34;&#34;
    resolution = resolution &amp; spatial(**resolution_)
    if bounds is None:
        bounds: Box = geometry.bounding_box()
        bounds = Cuboid(bounds.center, half_size=bounds.half_size * (1 + 2 * rel_margin) + 2 * abs_margin)
    elif isinstance(bounds, UniformGrid):
        assert not resolution, f&#34;When specifying a UniformGrid, separate resolution values are not allowed.&#34;
        resolution = bounds.resolution
        bounds = bounds.bounds
    points = UniformGrid(resolution, bounds).center
    reduce = instance(geometry) &amp; spatial(geometry)
    if reduce:
        center = math.mean(geometry.center, reduce)
        volume = None
        bounding_radius = None
        rebuild = &#39;from-surface&#39; if rebuild == &#39;auto&#39; else rebuild
    else:
        center = geometry.center
        volume = geometry.volume
        bounding_radius = geometry.bounding_radius()
        rebuild = None if rebuild == &#39;auto&#39; else rebuild
    if cache_surface or rebuild is not None:
        sdf, delta, normal, _, idx = geometry.approximate_closest_surface(points)
        approximate = SDFGrid(sdf, bounds, approximate_outside, None, delta, normal, idx, center=center, volume=volume, bounding_radius=bounding_radius)
    else:
        sdf = geometry.approximate_signed_distance(points)
        approximate = SDFGrid(sdf, bounds, approximate_outside, center=center, volume=volume, bounding_radius=bounding_radius)
    if rebuild is None:
        return approximate
    assert rebuild in [&#39;from-surface&#39;]
    dx = bounds.size / resolution
    min_dist = math.sum(dx ** 2) ** (1 / geometry.spatial_rank)
    valid_dist = math.maximum(min_dist, valid_dist) if valid_dist is not None else min_dist
    sdf = rebuild_sdf(approximate, 0, valid_dist, refine=[geometry])
    return SDFGrid(sdf, bounds, approximate_outside, center=center, volume=volume, bounding_radius=bounding_radius)</code></pre>
</details>
<div class="desc"><p>Build a grid of signed distance values for a given <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>geometry</code></strong></dt>
<dd><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> to capture.</dd>
<dt><strong><code>bounds</code></strong></dt>
<dd>Grid limits in world space.</dd>
<dt><strong><code>resolution</code></strong></dt>
<dd>Grid resolution.</dd>
<dt><strong><code>**resolution_</code></strong></dt>
<dd>Grid resolution as <code>kwargs</code>, e.g. <code>x=64, y=32</code>.</dd>
<dt><strong><code>approximate_outside</code></strong></dt>
<dd>Whether queries outside the SDF grid should return approximate values. This requires additional computations.</dd>
<dt><strong><code>rebuild</code></strong></dt>
<dd>If <code>'from-surface'</code>, SDF values are calculated from a narrow strip above the enclosed surface. This is more accurate but requires additional steps.
If <code>None</code> (default), SDF values are queried from <code>geometry</code>.
<code>'auto'</code> rebuilds when geometry querying is expected to be in accurate.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>SDF grid as <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.</p></div>
</dd>
<dt id="phi.geom.scale"><code class="name flex">
<span>def <span class="ident">scale</span></span>(<span>obj: ~GeometricType,<br>scale: phiml.math._tensors.Tensor | float,<br>pivot: phiml.math._tensors.Tensor = None,<br>dim='vector') ‑> ~GeometricType</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scale(obj: GeometricType, scale: Union[float, Tensor], pivot: Tensor = None, dim=&#39;vector&#39;) -&gt; GeometricType:
    &#34;&#34;&#34;
    Scale a `Geometry` or vector `Tensor` about a pivot point.

    Args:
        obj: `Geometry` to scale.
        scale: Scaling factor.
        pivot: Point that stays fixed under the scaling operation. Defaults to the bounding box center.

    Returns:
        Rotated `Geometry`
    &#34;&#34;&#34;
    if scale is None:
        return obj
    if isinstance(obj, Geometry):
        if pivot is None:
            pivot = obj.bounding_box().center
        center = pivot + scale * (obj.center - pivot)
        return obj.scaled(scale).at(center)
    elif isinstance(obj, Tensor):
        assert &#39;vector&#39; in obj.shape, f&#34;vector must have exactly a channel dimension named &#39;vector&#39;&#34;
        if pivot is None:
            return obj * scale
        raise NotImplementedError
    raise ValueError(obj)</code></pre>
</details>
<div class="desc"><p>Scale a <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> or vector <code>Tensor</code> about a pivot point.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>obj</code></strong></dt>
<dd><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> to scale.</dd>
<dt><strong><code>scale</code></strong></dt>
<dd>Scaling factor.</dd>
<dt><strong><code>pivot</code></strong></dt>
<dd>Point that stays fixed under the scaling operation. Defaults to the bounding box center.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Rotated <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></p></div>
</dd>
<dt id="phi.geom.squared_length"><code class="name flex">
<span>def <span class="ident">squared_length</span></span>(<span>obj: phi.geom._geom.Geometry | phiml.math._tensors.Tensor) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def squared_length(obj: Union[Geometry, Tensor]) -&gt; Tensor:
    &#34;&#34;&#34;
    Returns the squared length of a vector `Tensor` or geometric object with a length-like property.

    Args:
        obj: `Tensor` with &#39;vector&#39; dim or `Geometry` with a length-like property.

    Returns:
        Squared length as `Tensor`
    &#34;&#34;&#34;
    if isinstance(obj, Tensor):
        assert &#39;vector&#39; in obj.shape, f&#34;squared_length() requires &#39;vector&#39; dim but got {type(obj)} with shape {shape(obj)}.&#34;
        return math.squared_norm(obj, &#39;vector&#39;)
    elif isinstance(obj, Cylinder):
        return obj.depth ** 2
    raise ValueError(obj)</code></pre>
</details>
<div class="desc"><p>Returns the squared length of a vector <code>Tensor</code> or geometric object with a length-like property.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>obj</code></strong></dt>
<dd><code>Tensor</code> with 'vector' dim or <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> with a length-like property.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Squared length as <code>Tensor</code></p></div>
</dd>
<dt id="phi.geom.stack"><code class="name flex">
<span>def <span class="ident">stack</span></span>(<span>values: Sequence[~PhiTreeNodeType] | Dict[str, ~PhiTreeNodeType],<br>dim: phiml.math._shape.Shape | str,<br>expand_values=False,<br>simplify=False,<br>layout_non_matching=False,<br>**kwargs) ‑> ~PhiTreeNodeType</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stack(values: Union[Sequence[PhiTreeNodeType], Dict[str, PhiTreeNodeType]], dim: Union[Shape, str], expand_values=False, simplify=False, layout_non_matching=False, **kwargs) -&gt; PhiTreeNodeType:
    &#34;&#34;&#34;
    Stacks `values` along the new dimension `dim`.
    All values must have the same spatial, instance and channel dimensions. If the dimension sizes vary, the resulting tensor will be non-uniform.
    Batch dims will be added as needed.

    Stacking tensors is performed lazily, i.e. the memory is allocated only when needed.
    This makes repeated stacking and slicing along the same dimension very efficient, i.e. jit-compiled functions will not perform these operations.

    Args:
        values: Collection of `phiml.math.magic.Shapable`, such as `phiml.math.Tensor`
            If a `dict`, keys must be of type `str` and are used as item names along `dim`.
        dim: `Shape` with a least one dimension. None of these dims can be present with any of the `values`.
            If `dim` is a single-dimension shape, its size is determined from `len(values)` and can be left undefined (`None`).
            If `dim` is a multi-dimension shape, its volume must be equal to `len(values)`.
        expand_values: If `True`, will first add missing dims to all values, not just batch dimensions.
            This allows tensors with different dims to be stacked.
            The resulting tensor will have all dims that are present in `values`.
            If `False`, this may return a non-numeric object instead.
        simplify: If `True` and all values are equal, returns one value without adding the dimension.
        layout_non_matching: If non-matching values should be stacked using a Layout object, i.e. should be put into a named list instead.
        **kwargs: Additional keyword arguments required by specific implementations.
            Adding spatial dims to fields requires the `bounds: Box` argument specifying the physical extent of the new dimensions.
            Adding batch dims must always work without keyword arguments.

    Returns:
        `Tensor` containing `values` stacked along `dim`.

    Examples:
        &gt;&gt;&gt; stack({&#39;x&#39;: 0, &#39;y&#39;: 1}, channel(&#39;vector&#39;))
        (x=0, y=1)

        &gt;&gt;&gt; stack([math.zeros(batch(b=2)), math.ones(batch(b=2))], channel(c=&#39;x,y&#39;))
        (x=0.000, y=1.000); (x=0.000, y=1.000) (bᵇ=2, cᶜ=x,y)

        &gt;&gt;&gt; stack([vec(x=1, y=0), vec(x=2, y=3.)], batch(&#39;b&#39;))
        (x=1.000, y=0.000); (x=2.000, y=3.000) (bᵇ=2, vectorᶜ=x,y)
    &#34;&#34;&#34;
    assert len(values) &gt; 0, f&#34;stack() got empty sequence {values}&#34;
    if simplify and len(values) == 1:
        return next(iter(values.values())) if isinstance(values, dict) else values[0]
    if not dim:
        assert len(values) == 1, f&#34;Only one element can be passed as `values` if no dim is passed but got {values}&#34;
        return next(iter(values.values())) if isinstance(values, dict) else values[0]
    if not isinstance(dim, SHAPE_TYPES):
        dim = auto(dim)
    values_ = tuple(values.values()) if isinstance(values, dict) else values
    if simplify:
        if all(v is None for v in values_):
            return None
        if all(type(v) == type(values_[0]) for v in values_[1:]):
            from ._tensors import equality_by_shape_and_value
            with equality_by_shape_and_value(equal_nan=True):
                if all(v == values_[0] for v in values_[1:]):
                    return values_[0]
    shapes = [shape(v) for v in values_]
    if not expand_values:
        v0_dims = set(shapes[0].non_batch.names)
        for s in shapes[1:]:
            if set(s.non_batch.names) != v0_dims:  # shapes don&#39;t match
                if layout_non_matching:
                    from ._tensors import layout
                    return layout(values, dim)
                raise ValueError(f&#34;Non-batch dims must match but got: {v0_dims} and {s.non_batch.names}. Manually expand tensors or set expand_values=True&#34;)
    # --- Add missing dims ---
    if expand_values:
        all_dims = merge_shapes(*shapes, allow_varying_sizes=True)
        if isinstance(values, dict):
            values = {k: expand(v, all_dims - s) for (k, v), s in zip(values.items(), shapes)}
        else:
            values = [expand(v, all_dims - s) for v, s in zip(values, shapes)]
    else:
        all_batch_dims = merge_shapes(*[s.batch for s in shapes], allow_varying_sizes=True)
        if isinstance(values, dict):
            values = {k: expand(v, all_batch_dims - s) for (k, v), s in zip(values.items(), shapes)}
        else:
            values = [expand(v, all_batch_dims - s) for v, s in zip(values, shapes)]
    if dim.rank == 1:
        assert dim.size == len(values) or dim.size is None, f&#34;stack dim size must match len(values) or be undefined but got {dim} for {len(values)} values&#34;
        if dim.size is None:
            dim = dim.with_size(len(values))
        if isinstance(values, dict):
            dim_item_names = tuple([k.name if isinstance(k, SHAPE_TYPES) else k for k in values.keys()])
            assert all(isinstance(k, str) for k in dim_item_names), f&#34;dict keys must be of type str but got {dim_item_names}&#34;
            values = tuple(values.values())
            dim = dim.with_size(dim_item_names)
        # --- First try __stack__ ---
        for v in values:
            if hasattr(v, &#39;__stack__&#39;):
                result = v.__stack__(values, dim, **kwargs)
                if result is not NotImplemented:
                    if DEBUG_CHECKS:
                        assert isinstance(result, SHAPE_TYPES) if isinstance(v, SHAPE_TYPES) else isinstance(result, Shapable), &#34;__stack__ must return a Shapable object&#34;
                    return result
        # --- Next: try stacking attributes for tree nodes ---
        if any(dataclasses.is_dataclass(v) for v in values):
            from ..dataclasses._merge import dc_stack
            try:
                return dc_stack(values, dim, expand_values=expand_values, simplify=simplify, layout_non_matching=layout_non_matching, **kwargs)
            except NotCompatible as err:
                if layout_non_matching:
                    from ._tensors import layout
                    return layout(values, dim)
                raise err
        if all(isinstance(v, dict) for v in values):
            keys = set(values[0])
            if all(set(v) == keys for v in values[1:]):
                new_dict = {}
                for k in keys:
                    k_values = [v[k] for v in values]
                    new_dict[k] = stack(k_values, dim, expand_values=expand_values, simplify=simplify, **kwargs)
                return new_dict
            raise NotImplementedError
        if any(isinstance(v, (tuple, list, dict)) for v in values_):
            from ._tensors import wrap, layout
            if all(np.asarray(v).dtype != object for v in values_):
                tensors = [wrap(v) for v in values_]
                return stack(tensors, dim)
            else:
                assert len(dim) == 1, f&#34;Cannot stack values with nested tuples, lists or dicts along multiple dimensions {dim}&#34;
                return layout(values_, dim)
        if all(isinstance(v, PhiTreeNode) for v in values):
            attributes = all_attributes(values[0])
            if attributes and all(all_attributes(v) == attributes for v in values):
                new_attrs = {}
                for a in attributes:
                    a_values = [getattr(v, a) for v in values]
                    if all(v is a_values[0] for v in a_values[1:]):
                        new_attrs[a] = expand(a_values[0], dim, **kwargs) if a_values[0] is not None else a_values[0]
                    else:
                        new_attrs[a] = stack(a_values, dim, expand_values=expand_values, simplify=simplify, **kwargs)
                return copy_with(values[0], **new_attrs)
            else:
                warnings.warn(f&#34;Failed to concat values using value attributes because attributes differ among values {values}&#34;)
        # --- Fallback: use expand and concat ---
        for v in values:
            if not hasattr(v, &#39;__stack__&#39;) and hasattr(v, &#39;__concat__&#39;) and hasattr(v, &#39;__expand__&#39;):
                expanded_values = tuple([expand(v, dim.with_size(1 if dim.item_names[0] is None else dim.item_names[0][i]), **kwargs) for i, v in enumerate(values)])
                if len(expanded_values) &gt; 8:
                    warnings.warn(f&#34;stack() default implementation is slow on large dims ({dim.name}={len(expanded_values)}). Please implement __stack__()&#34;, RuntimeWarning, stacklevel=2)
                result = v.__concat__(expanded_values, dim.name, **kwargs)
                if result is not NotImplemented:
                    assert isinstance(result, Shapable), &#34;__concat__ must return a Shapable object&#34;
                    return result
        # --- else maybe all values are native scalars ---
        from ._tensors import wrap
        try:
            values = tuple([wrap(v) for v in values])
        except ValueError:
            raise MagicNotImplemented(f&#34;At least one item in values must be Shapable but got types {[type(v) for v in values]}&#34;)
        return values[0].__stack__(values, dim, **kwargs)
    else:  # multi-dim stack
        assert dim.volume == len(values), f&#34;When passing multiple stack dims, their volume must equal len(values) but got {dim} for {len(values)} values&#34;
        if isinstance(values, dict):
            warnings.warn(f&#34;When stacking a dict along multiple dimensions, the key names are discarded. Got keys {tuple(values.keys())}&#34;, RuntimeWarning, stacklevel=2)
            values = tuple(values.values())
        # --- if any value implements Shapable, use stack and unpack_dim ---
        for v in values:
            if hasattr(v, &#39;__stack__&#39;) and hasattr(v, &#39;__unpack_dim__&#39;):
                stack_dim = batch(&#39;_stack&#39;)
                stacked = v.__stack__(values, stack_dim, **kwargs)
                if stacked is not NotImplemented:
                    assert isinstance(stacked, Shapable), &#34;__stack__ must return a Shapable object&#34;
                    assert hasattr(stacked, &#39;__unpack_dim__&#39;), &#34;If a value supports __unpack_dim__, the result of __stack__ must also support it.&#34;
                    reshaped = stacked.__unpack_dim__(stack_dim.name, dim, **kwargs)
                    if reshaped is NotImplemented:
                        warnings.warn(&#34;__unpack_dim__ is overridden but returned NotImplemented during multi-dimensional stack. This results in unnecessary stack operations.&#34;, RuntimeWarning, stacklevel=2)
                    else:
                        return reshaped
        # --- Fallback: multi-level stack ---
        for dim_ in reversed(dim):
            values = [stack(values[i:i + dim_.size], dim_, **kwargs) for i in range(0, len(values), dim_.size)]
        return values[0]</code></pre>
</details>
<div class="desc"><p>Stacks <code>values</code> along the new dimension <code>dim</code>.
All values must have the same spatial, instance and channel dimensions. If the dimension sizes vary, the resulting tensor will be non-uniform.
Batch dims will be added as needed.</p>
<p>Stacking tensors is performed lazily, i.e. the memory is allocated only when needed.
This makes repeated stacking and slicing along the same dimension very efficient, i.e. jit-compiled functions will not perform these operations.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>values</code></strong></dt>
<dd>Collection of <code>phiml.math.magic.Shapable</code>, such as <code>phiml.math.Tensor</code>
If a <code>dict</code>, keys must be of type <code>str</code> and are used as item names along <code>dim</code>.</dd>
<dt><strong><code>dim</code></strong></dt>
<dd><code>Shape</code> with a least one dimension. None of these dims can be present with any of the <code>values</code>.
If <code>dim</code> is a single-dimension shape, its size is determined from <code>len(values)</code> and can be left undefined (<code>None</code>).
If <code>dim</code> is a multi-dimension shape, its volume must be equal to <code>len(values)</code>.</dd>
<dt><strong><code>expand_values</code></strong></dt>
<dd>If <code>True</code>, will first add missing dims to all values, not just batch dimensions.
This allows tensors with different dims to be stacked.
The resulting tensor will have all dims that are present in <code>values</code>.
If <code>False</code>, this may return a non-numeric object instead.</dd>
<dt><strong><code>simplify</code></strong></dt>
<dd>If <code>True</code> and all values are equal, returns one value without adding the dimension.</dd>
<dt><strong><code>layout_non_matching</code></strong></dt>
<dd>If non-matching values should be stacked using a Layout object, i.e. should be put into a named list instead.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Additional keyword arguments required by specific implementations.
Adding spatial dims to fields requires the <code>bounds: Box</code> argument specifying the physical extent of the new dimensions.
Adding batch dims must always work without keyword arguments.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>Tensor</code> containing <code>values</code> stacked along <code>dim</code>.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; stack({'x': 0, 'y': 1}, channel('vector'))
(x=0, y=1)
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; stack([math.zeros(batch(b=2)), math.ones(batch(b=2))], channel(c='x,y'))
(x=0.000, y=1.000); (x=0.000, y=1.000) (bᵇ=2, cᶜ=x,y)
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; stack([vec(x=1, y=0), vec(x=2, y=3.)], batch('b'))
(x=1.000, y=0.000); (x=2.000, y=3.000) (bᵇ=2, vectorᶜ=x,y)
</code></pre></div>
</dd>
<dt id="phi.geom.surface_mesh"><code class="name flex">
<span>def <span class="ident">surface_mesh</span></span>(<span>geo: phi.geom._geom.Geometry,<br>rel_dx: float = None,<br>abs_dx: float = None,<br>method='auto') ‑> phi.geom._mesh.Mesh</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def surface_mesh(geo: Geometry,
                 rel_dx: float = None,
                 abs_dx: float = None,
                 method=&#39;auto&#39;) -&gt; Mesh:
    &#34;&#34;&#34;
    Create a surface `Mesh` from a Geometry.

    Args:
        geo: `Geometry` to convert. Must implement `approximate_signed_distance`.
        rel_dx: Relative mesh resolution as fraction of bounding box size.
        abs_dx: Absolute mesh resolution. If both `rel_dx` and `abs_dx` are provided, the lower value is used.
        method: &#39;auto&#39; to select based on the type of `geo`. &#39;lewiner&#39; or &#39;lorensen&#39; for marching cubes.

    Returns:
        `Mesh` if there is any geometry
    &#34;&#34;&#34;
    if geo.spatial_rank != 3:
        raise NotImplementedError(&#34;Only 3D SDF currently supported&#34;)
    if isinstance(geo, NoGeometry):
        return mesh_from_numpy([], [], element_rank=2)
    # --- Determine resolution ---
    if isinstance(geo, SDFGrid):
        assert rel_dx is None and abs_dx is None, f&#34;When creating a surface mesh from an SDF grid, rel_dx and abs_dx are determined from the grid and must be specified as None&#34;
    # --- Check special cases ---
    if method == &#39;auto&#39; and isinstance(geo, Box):
        assert rel_dx is None and abs_dx is None, f&#34;When method=&#39;auto&#39;, boxes will always use their corners as vertices. Leave rel_dx,abs_dx unspecified or pass &#39;lewiner&#39; or &#39;lorensen&#39; as method&#34;
        vertices = pack_dims(geo.corners, dual, instance(&#39;vertices&#39;))
        corner_count = vertices.vertices.size
        vertices = pack_dims(vertices, instance(geo) + instance(&#39;vertices&#39;), instance(&#39;vertices&#39;))
        v1 = [0, 1, 4, 5, 4, 6, 5, 7, 0, 1, 2, 6]
        v2 = [1, 3, 6, 6, 0, 0, 7, 3, 4, 4, 3, 3]
        v3 = [2, 2, 5, 7, 6, 2, 1, 1, 1, 5, 6, 7]
        instance_offset = math.range_tensor(instance(geo)) * corner_count
        faces = wrap([v1, v2, v3], spatial(&#39;vertices&#39;), instance(&#39;faces&#39;)) + instance_offset
        faces = pack_dims(faces, instance, instance(&#39;faces&#39;))
        return mesh(vertices, faces, element_rank=2)
    if rel_dx is None and abs_dx is None:
        rel_dx = 1 / 128
    rel_dx = None if rel_dx is None else rel_dx * geo.bounding_box().size.max
    dx = math.minimum(rel_dx, abs_dx, allow_none=True)
    if method == &#39;auto&#39; and isinstance(geo, Sphere):
        pass  # ToDo analytic solution
    elif method == &#39;auto&#39; and isinstance(geo, BSplineSheet):
        vol_per_cp = geo.bounding_box().volume / math.prod(geo.res, &#39;vector&#39;).sum
        avg_cp_dist = vol_per_cp ** (1/geo.spatial_rank)
        res = max(round(avg_cp_dist / dx), 3)
        return geo.build_mesh(res, res)
    # --- Build mesh from SDF ---
    if isinstance(geo, SDFGrid):
        sdf_grid = geo
    else:
        if isinstance(geo, SDF):
            sdf = geo
        else:
            sdf = as_sdf(geo, rel_margin=0, abs_margin=dx)
        resolution = maximum(1, to_int32(math.round(sdf.bounds.size / dx)))
        resolution = spatial(**resolution.vector)
        sdf_grid = sample_sdf(sdf, sdf.bounds, resolution)
    from skimage.measure import marching_cubes
    method = &#39;lewiner&#39; if method == &#39;auto&#39; else method
    def generate_mesh(sdf_grid: SDFGrid) -&gt; Mesh:
        dx = sdf_grid.dx.numpy()
        sdf_numpy = sdf_grid.values.numpy(sdf_grid.dx.vector.item_names)
        vertices, faces, v_normals, _ = marching_cubes(sdf_numpy, level=0.0, spacing=dx, allow_degenerate=False, method=method)
        vertices += sdf_grid.bounds.lower.numpy() + .5 * dx
        with math.NUMPY:
            return mesh_from_numpy(vertices, faces, element_rank=2, cell_dim=instance(&#39;faces&#39;))
    return math.map(generate_mesh, sdf_grid, dims=batch)</code></pre>
</details>
<div class="desc"><p>Create a surface <code><a title="phi.geom.Mesh" href="#phi.geom.Mesh">Mesh</a></code> from a Geometry.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>geo</code></strong></dt>
<dd><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> to convert. Must implement <code>approximate_signed_distance</code>.</dd>
<dt><strong><code>rel_dx</code></strong></dt>
<dd>Relative mesh resolution as fraction of bounding box size.</dd>
<dt><strong><code>abs_dx</code></strong></dt>
<dd>Absolute mesh resolution. If both <code>rel_dx</code> and <code>abs_dx</code> are provided, the lower value is used.</dd>
<dt><strong><code>method</code></strong></dt>
<dd>'auto' to select based on the type of <code>geo</code>. 'lewiner' or 'lorensen' for marching cubes.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.geom.Mesh" href="#phi.geom.Mesh">Mesh</a></code> if there is any geometry</p></div>
</dd>
<dt id="phi.geom.union"><code class="name flex">
<span>def <span class="ident">union</span></span>(<span>*geometries, dim=(unionⁱ=None))</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def union(*geometries, dim=instance(&#39;union&#39;)):
    &#34;&#34;&#34;
    Union of the given geometries.
    A point lies inside the union if it lies within at least one of the geometries.

    Args:
        *geometries: arbitrary geometries with same spatial dims. Arbitrary batch dims are allowed.
        dim: Union dimension. This must be an instance dimension.

    Returns:
        union `Geometry`
    &#34;&#34;&#34;
    return _stack_geometries(geometries, &#39;union&#39;, dim)</code></pre>
</details>
<div class="desc"><p>Union of the given geometries.
A point lies inside the union if it lies within at least one of the geometries.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*geometries</code></strong></dt>
<dd>arbitrary geometries with same spatial dims. Arbitrary batch dims are allowed.</dd>
<dt><strong><code>dim</code></strong></dt>
<dd>Union dimension. This must be an instance dimension.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>union <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="phi.geom.Box"><code class="flex name class">
<span>class <span class="ident">Box</span></span>
<span>(</span><span>pos: phiml.math._tensors.Tensor,<br>size: phiml.math._tensors.Tensor,<br>rot: phiml.math._tensors.Tensor,<br>is_open: phiml.math._tensors.Tensor,<br>variable_attrs: Tuple[str, ...] = ('pos', 'size', 'rot'))</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@sliceable(keepdims=&#39;vector&#39;)
@dataclass(frozen=True, eq=False)
class Box(Geometry, metaclass=BoxType):
    &#34;&#34;&#34;
    Simple cuboid defined by location of lower and upper corner in physical space.

    Boxes can be constructed either from two positional vector arguments `(lower, upper)` or by specifying the limits by dimension name as `kwargs`.

    Examples:
        &gt;&gt;&gt; Box(x=1, y=1)  # creates a two-dimensional unit box with `lower=(0, 0)` and `upper=(1, 1)`.
        &gt;&gt;&gt; Box(x=(None, 1), y=(0, None)  # creates a Box with `lower=(-inf, 0)` and `upper=(1, inf)`.

        The slicing constructor was updated in version 2.2 and now requires the dimension order as the first argument.

        &gt;&gt;&gt; Box[&#39;x,y&#39;, 0:1, 0:1]  # creates a two-dimensional unit box with `lower=(0, 0)` and `upper=(1, 1)`.
        &gt;&gt;&gt; Box[&#39;x,y&#39;, :1, 0:]  # creates a Box with `lower=(-inf, 0)` and `upper=(1, inf)`.
    &#34;&#34;&#34;

    pos: Tensor
    size: Tensor
    rot: Tensor  # can be Layout(None) for no rotation
    is_open: Tensor  # Infinite extent per face, (~side, vector) or fewer
    
    variable_attrs: Tuple[str, ...] = (&#39;pos&#39;, &#39;size&#39;, &#39;rot&#39;)

    def __post_init__(self):
        assert isinstance(self.pos, Tensor) and &#39;vector&#39; in channel(self.pos)
        assert isinstance(self.size, Tensor)
        assert isinstance(self.rot, Tensor)

    @property
    def half_size(self):
        return self.size * 0.5

    @cached_property
    def lower(self):
        return math.where(self.is_open.side[&#39;lower&#39;], -math.INF, self.pos - self.half_size)

    @cached_property
    def upper(self):
        return math.where(self.is_open.side[&#39;upper&#39;], math.INF, self.pos + self.half_size)

    @cached_property
    def is_finite(self):
        return not self.is_open.any

    def __repr__(self):
        if self.rot is not None:
            return f&#34;Cuboid(center={self.pos}, size={self.size})&#34;
        if self.pos is None or self.size is None:  # traced
            return f&#34;Box[traced, shape={self.shape}]&#34;
        if self.shape.non_channel.volume == 1:
            item_names = self.size.vector.item_names
            if item_names:
                return f&#34;Box({&#39;, &#39;.join([f&#39;{dim}=({lo}, {up})&#39; for dim, lo, up in zip(item_names, self.lower, self.upper)])})&#34;
            else:  # deprecated
                return &#39;Box[%s at %s]&#39; % (&#39;x&#39;.join([str(x) for x in self.size.numpy().flatten()]), &#39;,&#39;.join([str(x) for x in self.lower.numpy().flatten()]))
        else:
            return f&#39;Box[shape={self.shape}]&#39;

    @cached_property
    def shape(self):
        return self.pos.shape &amp; self.size.shape &amp; (shape(self.rot) - &#39;~vector&#39;)

    @property
    def center(self):
        return self.pos

    @property
    def volume(self) -&gt; Tensor:
        return math.prod(self.size, &#39;vector&#39;)

    @property
    def is_axis_aligned(self):
        return self.rot == None

    @property
    def rotation_matrix(self) -&gt; Tensor:
        return rotation_matrix(self.rot, self.shape[&#39;vector&#39;], none_to_unit=True)

    def at(self, center: Tensor) -&gt; &#39;Box&#39;:
        return replace(self, pos=center)

    def rotated(self, angle) -&gt; &#39;Box&#39;:
        rot = wrap(angle) if self.is_axis_aligned.all else self.rotation_matrix @ rotation_matrix(angle)
        return replace(self, rot=rot)

    def scaled(self, factor: Union[float, Tensor]) -&gt; &#39;Box&#39;:
        return replace(self, size=self.size * factor)

    def global_to_local(self, global_position: Tensor, scale=True, origin=&#39;lower&#39;) -&gt; Tensor:
        &#34;&#34;&#34;
        Transform world-space coordinates into box-space coordinates.

        Args:
            global_position: World-space coordinates.
            scale: Whether to re-scale the output so that [0, 1] or [-1, 1] represent the box for `origin=&#39;lower&#39;` or `origin=&#39;center&#39;`, respectively.
            origin: &#39;lower&#39; or &#39;center&#39;

        Returns:
            Box-space coordinate `Tensor`
        &#34;&#34;&#34;
        assert origin in [&#39;lower&#39;, &#39;center&#39;, &#39;upper&#39;]
        origin_loc = getattr(self, origin)
        pos = global_position if math.always_close(origin_loc, 0) else global_position - origin_loc
        pos = rotate(pos, self.rot, invert=True)
        if scale:
            pos /= (self.half_size if origin == &#39;center&#39; else self.size)
        return pos

    def local_to_global(self, local_position, scale=True, origin=&#39;lower&#39;):
        assert origin in [&#39;lower&#39;, &#39;center&#39;, &#39;upper&#39;]
        origin_loc = getattr(self, origin)
        pos = local_position * (self.half_size if origin == &#39;center&#39; else self.size) if scale else local_position
        return rotate(pos, self.rot) + origin_loc

    def __mul__(self, other):
        if not isinstance(other, Box):
            return NotImplemented
        assert self.is_axis_aligned.all and other.is_axis_aligned.all, f&#34;Box * Box only supported for axis-aligned boxes (rot=None).&#34;
        pos = concat([self.pos, other.pos], &#39;vector&#39;)
        size = concat([self.size, other.size], &#39;vector&#39;)
        return replace(self, pos=pos, size=size)

    def bounding_half_extent(self) -&gt; Tensor:
        if self.rot is not None:
            to_face = self.face_normals[{&#39;~side&#39;: 0}] * math.rename_dims(self.half_size, &#39;vector&#39;, dual)
            return math.sum(abs(to_face), &#39;~vector&#39;)
        return self.half_size

    def lies_inside(self, location: Tensor) -&gt; Tensor:
        location = self.global_to_local(location, scale=False, origin=&#39;center&#39;)  # scale can only be performed for finite sizes
        if not self.is_open.any:
            bool_inside = abs(location) &lt;= self.half_size
        else:
            above_lower = (location &gt; self.lower) | self.is_open.side.dual[&#39;lower&#39;]
            below_upper = (location &lt; self.upper) | self.is_open.side.dual[&#39;upper&#39;]
            bool_inside = above_lower &amp; below_upper
        bool_inside = math.all(bool_inside, &#39;vector&#39;)
        bool_inside = math.any(bool_inside, self.shape.instance - instance(location))  # union for instance dimensions
        return bool_inside

    def largest(self, dim: DimFilter) -&gt; &#39;Box&#39;:
        assert self.is_axis_aligned.all, f&#34;Box.largest() is only supported for axis-aligned boxes (rot=None)&#34;
        dim = self.shape.without(&#39;vector&#39;).only(dim)
        if not dim:
            return self
        return box_from_limits(math.min(self.lower, dim), math.max(self.upper, dim))

    def smallest(self, dim: DimFilter) -&gt; &#39;Box&#39;:
        assert self.is_axis_aligned.all, f&#34;Box.smallest() is only supported for axis-aligned boxes (rot=None)&#34;
        dim = self.shape.without(&#39;vector&#39;).only(dim)
        if not dim:
            return self
        return box_from_limits(math.max(self.lower, dim), math.min(self.upper, dim))

    def without(self, dims: Tuple[str, ...]):
        assert self.is_axis_aligned.all, f&#34;Box.without() is only supported for axis-aligned boxes (rot=None)&#34;
        remaining = list(self.shape.get_item_names(&#39;vector&#39;))
        for dim in dims:
            if dim in remaining:
                remaining.remove(dim)
        return self.vector[remaining]

    def bounding_radius(self):
        return vec_length(self.half_size)

    def project(self, *dimensions: str):
        &#34;&#34;&#34; Project this box into a lower-dimensional space. &#34;&#34;&#34;
        warnings.warn(&#34;Box.project(dims) is deprecated. Use Box.vector[dims] instead&#34;, DeprecationWarning, stacklevel=2)
        return self.vector[dimensions]

    def approximate_signed_distance(self, location: Union[Tensor, tuple]):
        &#34;&#34;&#34;
        Computes the signed L-infinity norm (manhattan distance) from the location to the nearest side of the box.
        For an outside location `l` with the closest surface point `s`, the distance is `max(abs(l - s))`.
        For inside locations it is `-max(abs(l - s))`.

        Args:
          location: float tensor of shape (batch_size, ..., rank)

        Returns:
          float tensor of shape (*location.shape[:-1], 1).

        &#34;&#34;&#34;
        assert not self.is_open.any, f&#34;approximate_signed_distance not supported for open boxes&#34;
        # ToDo this underestimates diagonally outside points
        location = self.global_to_local(location, scale=False, origin=&#39;center&#39;)
        distance = math.abs(location) - self.half_size
        distance = math.max(distance, &#39;vector&#39;)
        distance = math.min(distance, self.shape.instance)  # union for instance dimensions
        return distance

    def approximate_closest_surface(self, location: Tensor) -&gt; Tuple[Tensor, Tensor, Tensor, Tensor, Tensor]:
        assert not self.is_open.any, f&#34;approximate_closest_surface not supported for open boxes&#34;
        loc_to_center = self.global_to_local(location, scale=False, origin=&#39;center&#39;)
        sgn_surf_delta = math.abs(loc_to_center) - self.half_size
        if instance(self):
            raise NotImplementedError
            # self_center, self_radius, sgn_dist, center_delta, center_dist = math.at_min((self.center, self.radius, sgn_dist, center_delta, center_dist), key=abs(sgn_dist), dim=instance)
        # is_inside = math.all(sgn_surf_delta &lt; 0, &#39;vector&#39;)
        # abs_surf_delta = abs(sgn_surf_delta)
        max_sgn_dist = math.max(sgn_surf_delta, &#39;vector&#39;)
        normal_axis = max_sgn_dist == sgn_surf_delta  # ToDo only one if inside
        normal = math.vec_normalize(normal_axis * math.sign(loc_to_center))
        normal = rotate(normal, self.rot)
        surf_to_center = math.where(normal_axis, math.sign(loc_to_center) * self.half_size, loc_to_center)
        closest_to_center = math.clip(surf_to_center, -self.half_size, self.half_size)
        surface_pos = self.local_to_global(closest_to_center, scale=False, origin=&#39;center&#39;)
        delta = surface_pos - location
        face_index = expand(0, non_channel(location))
        offset = normal.vector @ surface_pos.vector
        sgn_surf_dist = vec_length(delta) * math.sign(max_sgn_dist)
        return sgn_surf_dist, delta, normal, offset, face_index

    def sample_uniform(self, *shape: Shape) -&gt; Tensor:
        assert not self.is_open.any, f&#34;sample_uniform not supported for open boxes&#34;
        uniform = math.random_uniform(self.shape.non_singleton.without(&#39;vector&#39;), *shape, self.shape[&#39;vector&#39;])
        return self.lower + uniform * self.size

    def contains(self, other: &#39;Box&#39;):
        &#34;&#34;&#34; Tests if the other box lies fully inside this box. &#34;&#34;&#34;
        assert not self.is_open.any and not other.is_open.any, f&#34;contains not supported for open boxes&#34;
        assert self.is_axis_aligned.all and other.rot is None, f&#34;contains() is only supported for axis-aligned boxes (rot=None).&#34;
        return np.all(other.lower &gt;= self.lower) and np.all(other.upper &lt;= self.upper)

    def push(self, positions: Tensor, outward: bool = True, shift_amount: float = 0) -&gt; Tensor:
        loc_to_center = self.global_to_local(positions, scale=False, origin=&#39;center&#39;)
        sgn_dist_from_surface = math.abs(loc_to_center) - self.half_size
        rotation_matrix = self.rotation_matrix
        if outward:
            # --- get negative distances (particles are inside) towards the nearest boundary and add shift_amount ---
            distances_of_interest = (sgn_dist_from_surface == math.max(sgn_dist_from_surface, &#39;vector&#39;)) &amp; (sgn_dist_from_surface &lt; 0)
            shift = distances_of_interest * (sgn_dist_from_surface - shift_amount)
            # ToDo reduce instance dim
        else:  # inward
            shift = (sgn_dist_from_surface + shift_amount) * (sgn_dist_from_surface &gt; 0)  # get positive distances (particles are outside) and add shift_amount
            if instance(self):
                shift, loc_to_center, rotation_matrix = math.at_min((shift, loc_to_center, rotation_matrix), key=vec_length(shift), dim=instance)
            shift = math.where(abs(shift) &gt; abs(loc_to_center), abs(loc_to_center), shift)  # ensure inward shift ends at center
        shift = rotate(shift, rotation_matrix)
        return positions + math.where(loc_to_center &lt; 0, 1, -1) * shift

    def sample_uniform_surface(self, *shape: Shape) -&gt; Tensor:
        assert not instance(self), &#34;sample_uniform_surface not yet supported for unions of boxes&#34;
        samples = math.random_uniform(self.shape.non_singleton.non_instance, *shape, low=self.lower, high=self.upper)
        which = math.random_uniform(samples.shape.without(&#39;vector&#39;))
        lo_or_up = math.where(which &gt; .5, self.upper, self.lower)
        which = which * 2 % 1
        # --- which axis ---
        areas = self.face_areas
        total_area = math.sum(areas)
        frac_area = math.sum(areas / total_area, &#39;~side&#39;)
        cum_area = math.cumulative_sum(frac_area, &#39;~vector&#39;)
        axis = math.min(math.where(which &lt;= cum_area, math.range(self.shape[&#39;vector&#39;].as_dual()), self.spatial_rank), &#39;~vector&#39;)
        axis_one_hot = math.scatter(math.zeros(samples.shape, dtype=bool), expand(axis, channel(index=&#39;vector&#39;)), True, treat_as_batch=samples.shape.without(&#39;vector&#39;))
        math.assert_close(1, math.sum(axis_one_hot, &#39;vector&#39;))
        samples = math.where(axis_one_hot, lo_or_up, samples)
        return samples

    @property
    def boundary_elements(self) -&gt; Dict[Any, Dict[str, slice]]:
        return {}

    @property
    def boundary_faces(self) -&gt; Dict[Any, Dict[str, slice]]:
        return {}

    @property
    def faces(self) -&gt; &#39;Geometry&#39;:
        return Cuboid(self.face_centers, self.half_size, self.rot, size_variable=False)

    @property
    def face_centers(self) -&gt; Tensor:
        return self.center + self.face_normals * self.half_size

    @property
    def face_normals(self) -&gt; Tensor:
        unit_vectors = to_float(math.range(self.shape[&#39;vector&#39;]) == math.range(dual(**self.shape[&#39;vector&#39;].untyped_dict)))
        vectors = rotate(unit_vectors, self.rot)
        return vectors * math.vec(dual(&#39;side&#39;), lower=-1, upper=1)

    @property
    def face_areas(self) -&gt; Tensor:
        others_mask = math.range(self.shape[&#39;vector&#39;]) != math.range(dual(**self.shape[&#39;vector&#39;].untyped_dict))
        result = math.exp(math.sum(math.log(self.size) * others_mask, &#39;vector&#39;))
        return expand(result, dual(side=&#39;lower,upper&#39;))  # ~vector

    @property
    def face_shape(self) -&gt; Shape:
        return self.shape.without(&#39;vector&#39;) &amp; dual(side=&#39;lower,upper&#39;) &amp; dual(**self.shape[&#39;vector&#39;].untyped_dict)

    @property
    def corners(self) -&gt; Tensor:
        to_face = self.face_normals[{&#39;~side&#39;: &#39;upper&#39;}] * math.rename_dims(self.half_size, &#39;vector&#39;, dual)
        lower_upper = math.meshgrid(math.dual, **{dim: [-1, 1] for dim in self.vector.item_names}, stack_dim=dual(&#39;vector&#39;))  # (x=2, y=2, ... vector=x,y,...)
        to_corner = math.sum(lower_upper * to_face, &#39;~vector&#39;)
        return self.center + to_corner

    @property
    def is_size_variable(self):
        warnings.warn(&#34;Box.is_size_variable is deprecated. Check Box.variable_attrs instead.&#34;, DeprecationWarning, stacklevel=2)
        return &#39;size&#39; in self.variable_attrs

    def corner_representation(self) -&gt; &#39;Box&#39;:
        assert self.is_axis_aligned.all, f&#34;corner_representation does not support rotations&#34;
        return self

    box = corner_representation

    def center_representation(self) -&gt; &#39;Cuboid&#39;:
        return self

    cuboid = center_representation</code></pre>
</details>
<div class="desc"><p>Simple cuboid defined by location of lower and upper corner in physical space.</p>
<p>Boxes can be constructed either from two positional vector arguments <code>(lower, upper)</code> or by specifying the limits by dimension name as <code>kwargs</code>.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; Box(x=1, y=1)  # creates a two-dimensional unit box with `lower=(0, 0)` and `upper=(1, 1)`.
&gt;&gt;&gt; Box(x=(None, 1), y=(0, None)  # creates a Box with `lower=(-inf, 0)` and `upper=(1, inf)`.
</code></pre>
<p>The slicing constructor was updated in version 2.2 and now requires the dimension order as the first argument.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; Box['x,y', 0:1, 0:1]  # creates a two-dimensional unit box with `lower=(0, 0)` and `upper=(1, 1)`.
&gt;&gt;&gt; Box['x,y', :1, 0:]  # creates a Box with `lower=(-inf, 0)` and `upper=(1, inf)`.
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.geom._geom.Geometry</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="phi.geom.Box.Tc"><code class="name">prop <span class="ident">Tc</span></code></dt>
<dd>
<div class="desc"><p>partial(func, <em>args, </em>*keywords) - new function with partial application
of the given arguments and keywords.</p></div>
</dd>
<dt id="phi.geom.Box.Ti"><code class="name">prop <span class="ident">Ti</span></code></dt>
<dd>
<div class="desc"><p>partial(func, <em>args, </em>*keywords) - new function with partial application
of the given arguments and keywords.</p></div>
</dd>
<dt id="phi.geom.Box.Ts"><code class="name">prop <span class="ident">Ts</span></code></dt>
<dd>
<div class="desc"><p>partial(func, <em>args, </em>*keywords) - new function with partial application
of the given arguments and keywords.</p></div>
</dd>
<dt id="phi.geom.Box.boundary_elements"><code class="name">prop <span class="ident">boundary_elements</span> : Dict[Any, Dict[str, slice]]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def boundary_elements(self) -&gt; Dict[Any, Dict[str, slice]]:
    return {}</code></pre>
</details>
<div class="desc"><p>Slices on the primal dimensions to mark boundary elements.
Grids and meshes have no boundary elements and return <code>{}</code>.
Dynamic graphs can define boundary elements for obstacles and walls.</p>
<h2 id="returns">Returns</h2>
<p>Map from <code>name</code> to slicing <code>dict</code>.</p></div>
</dd>
<dt id="phi.geom.Box.boundary_faces"><code class="name">prop <span class="ident">boundary_faces</span> : Dict[Any, Dict[str, slice]]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def boundary_faces(self) -&gt; Dict[Any, Dict[str, slice]]:
    return {}</code></pre>
</details>
<div class="desc"><p>Slices on the dual dimensions to mark boundary faces.</p>
<p>Regular grids use the keys (dim, is_upper) to identify boundaries.
Unstructured meshes use string identifiers for the boundaries.
Dynamic graphs return slices along the dual dimensions.</p>
<h2 id="returns">Returns</h2>
<p>Map from <code>name</code> to slicing <code>dict</code>.</p></div>
</dd>
<dt id="phi.geom.Box.center"><code class="name">prop <span class="ident">center</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def center(self):
    return self.pos</code></pre>
</details>
<div class="desc"><p>Center location in single channel dimension.</p></div>
</dd>
<dt id="phi.geom.Box.corners"><code class="name">prop <span class="ident">corners</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def corners(self) -&gt; Tensor:
    to_face = self.face_normals[{&#39;~side&#39;: &#39;upper&#39;}] * math.rename_dims(self.half_size, &#39;vector&#39;, dual)
    lower_upper = math.meshgrid(math.dual, **{dim: [-1, 1] for dim in self.vector.item_names}, stack_dim=dual(&#39;vector&#39;))  # (x=2, y=2, ... vector=x,y,...)
    to_corner = math.sum(lower_upper * to_face, &#39;~vector&#39;)
    return self.center + to_corner</code></pre>
</details>
<div class="desc"><h2 id="returns">Returns</h2>
<p>Corner locations as <code>phiml.math.Tensor</code>.
Corners belonging to one object or cell are listed along dual dimensions.
If the object has no corners, a size-0 tensor with the correct vector and instance dims is returned.</p></div>
</dd>
<dt id="phi.geom.Box.face_areas"><code class="name">prop <span class="ident">face_areas</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_areas(self) -&gt; Tensor:
    others_mask = math.range(self.shape[&#39;vector&#39;]) != math.range(dual(**self.shape[&#39;vector&#39;].untyped_dict))
    result = math.exp(math.sum(math.log(self.size) * others_mask, &#39;vector&#39;))
    return expand(result, dual(side=&#39;lower,upper&#39;))  # ~vector</code></pre>
</details>
<div class="desc"><p>Area of face connecting a pair of cells. Shape <code>(elements, ~)</code>.
Returns 0 for unconnected cells.</p></div>
</dd>
<dt id="phi.geom.Box.face_centers"><code class="name">prop <span class="ident">face_centers</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_centers(self) -&gt; Tensor:
    return self.center + self.face_normals * self.half_size</code></pre>
</details>
<div class="desc"><p>Center of face connecting a pair of cells. Shape <code>(elements, ~, vector)</code>.
Here, <code>~</code> represents arbitrary internal dual dimensions, such as <code>~staggered_direction</code> or <code>~elements</code>.
Returns 0-vectors for unconnected cells.</p></div>
</dd>
<dt id="phi.geom.Box.face_normals"><code class="name">prop <span class="ident">face_normals</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_normals(self) -&gt; Tensor:
    unit_vectors = to_float(math.range(self.shape[&#39;vector&#39;]) == math.range(dual(**self.shape[&#39;vector&#39;].untyped_dict)))
    vectors = rotate(unit_vectors, self.rot)
    return vectors * math.vec(dual(&#39;side&#39;), lower=-1, upper=1)</code></pre>
</details>
<div class="desc"><p>Normal vectors of cell faces, including boundary faces. Shape <code>(elements, ~, vector)</code>.
For meshes, The vectors point out of the primal cells and into the dual cells.</p>
<p>Instance/spatial dimensions along which the normal does not vary may not be included in the result tensor's shape.</p></div>
</dd>
<dt id="phi.geom.Box.face_shape"><code class="name">prop <span class="ident">face_shape</span> : phiml.math._shape.Shape</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_shape(self) -&gt; Shape:
    return self.shape.without(&#39;vector&#39;) &amp; dual(side=&#39;lower,upper&#39;) &amp; dual(**self.shape[&#39;vector&#39;].untyped_dict)</code></pre>
</details>
<div class="desc"><h2 id="returns">Returns</h2>
<p>Full Shape to identify each face of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>, including instance/spatial dimensions for the elements and dual dimensions listing the faces per element.
If this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> has no faces, returns an empty <code>Shape</code>.</p></div>
</dd>
<dt id="phi.geom.Box.faces"><code class="name">prop <span class="ident">faces</span> : <a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def faces(self) -&gt; &#39;Geometry&#39;:
    return Cuboid(self.face_centers, self.half_size, self.rot, size_variable=False)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Box.half_size"><code class="name">prop <span class="ident">half_size</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def half_size(self):
    return self.size * 0.5</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Box.is_axis_aligned"><code class="name">prop <span class="ident">is_axis_aligned</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_axis_aligned(self):
    return self.rot == None</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Box.is_finite"><code class="name">var <span class="ident">is_finite</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def is_finite(self):
    return not self.is_open.any</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Box.is_open"><code class="name">var <span class="ident">is_open</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Box.is_size_variable"><code class="name">prop <span class="ident">is_size_variable</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_size_variable(self):
    warnings.warn(&#34;Box.is_size_variable is deprecated. Check Box.variable_attrs instead.&#34;, DeprecationWarning, stacklevel=2)
    return &#39;size&#39; in self.variable_attrs</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Box.lower"><code class="name">var <span class="ident">lower</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def lower(self):
    return math.where(self.is_open.side[&#39;lower&#39;], -math.INF, self.pos - self.half_size)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Box.pos"><code class="name">var <span class="ident">pos</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Box.rot"><code class="name">var <span class="ident">rot</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Box.rotation_matrix"><code class="name">prop <span class="ident">rotation_matrix</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def rotation_matrix(self) -&gt; Tensor:
    return rotation_matrix(self.rot, self.shape[&#39;vector&#39;], none_to_unit=True)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Box.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def shape(self):
    return self.pos.shape &amp; self.size.shape &amp; (shape(self.rot) - &#39;~vector&#39;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Box.size"><code class="name">var <span class="ident">size</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Box.upper"><code class="name">var <span class="ident">upper</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def upper(self):
    return math.where(self.is_open.side[&#39;upper&#39;], math.INF, self.pos + self.half_size)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Box.variable_attrs"><code class="name">var <span class="ident">variable_attrs</span> : Tuple[str, ...]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Box.volume"><code class="name">prop <span class="ident">volume</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def volume(self) -&gt; Tensor:
    return math.prod(self.size, &#39;vector&#39;)</code></pre>
</details>
<div class="desc"><p><code>phi.math.Tensor</code> representing the volume of each element.
The result retains batch, spatial and instance dimensions.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phi.geom.Box.approximate_closest_surface"><code class="name flex">
<span>def <span class="ident">approximate_closest_surface</span></span>(<span>self, location: phiml.math._tensors.Tensor) ‑> Tuple[phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def approximate_closest_surface(self, location: Tensor) -&gt; Tuple[Tensor, Tensor, Tensor, Tensor, Tensor]:
    assert not self.is_open.any, f&#34;approximate_closest_surface not supported for open boxes&#34;
    loc_to_center = self.global_to_local(location, scale=False, origin=&#39;center&#39;)
    sgn_surf_delta = math.abs(loc_to_center) - self.half_size
    if instance(self):
        raise NotImplementedError
        # self_center, self_radius, sgn_dist, center_delta, center_dist = math.at_min((self.center, self.radius, sgn_dist, center_delta, center_dist), key=abs(sgn_dist), dim=instance)
    # is_inside = math.all(sgn_surf_delta &lt; 0, &#39;vector&#39;)
    # abs_surf_delta = abs(sgn_surf_delta)
    max_sgn_dist = math.max(sgn_surf_delta, &#39;vector&#39;)
    normal_axis = max_sgn_dist == sgn_surf_delta  # ToDo only one if inside
    normal = math.vec_normalize(normal_axis * math.sign(loc_to_center))
    normal = rotate(normal, self.rot)
    surf_to_center = math.where(normal_axis, math.sign(loc_to_center) * self.half_size, loc_to_center)
    closest_to_center = math.clip(surf_to_center, -self.half_size, self.half_size)
    surface_pos = self.local_to_global(closest_to_center, scale=False, origin=&#39;center&#39;)
    delta = surface_pos - location
    face_index = expand(0, non_channel(location))
    offset = normal.vector @ surface_pos.vector
    sgn_surf_dist = vec_length(delta) * math.sign(max_sgn_dist)
    return sgn_surf_dist, delta, normal, offset, face_index</code></pre>
</details>
<div class="desc"><p>Find the closest surface face of this geometry given a point that can be outside or inside the geometry.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd><code>Tensor</code> with a single channel dimension called vector. Can have arbitrary other dimensions.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>signed_distance</code></dt>
<dd>Scalar signed distance from <code>location</code>
to the closest point on the surface.
Positive values indicate the point lies outside the geometry, negative values indicate the point lies inside the geometry.</dd>
<dt><code>delta</code></dt>
<dd>Vector-valued distance vector from <code>location</code> to the closest point on the surface.</dd>
<dt><code>normal</code></dt>
<dd>Closest surface normal vector.</dd>
<dt><code>offset</code></dt>
<dd>Min distance of a surface-tangential plane from 0 as a scalar.</dd>
<dt><code>face_index</code></dt>
<dd>(Optional) An index vector pointing at the closest face.</dd>
</dl></div>
</dd>
<dt id="phi.geom.Box.approximate_signed_distance"><code class="name flex">
<span>def <span class="ident">approximate_signed_distance</span></span>(<span>self, location: phiml.math._tensors.Tensor | tuple)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def approximate_signed_distance(self, location: Union[Tensor, tuple]):
    &#34;&#34;&#34;
    Computes the signed L-infinity norm (manhattan distance) from the location to the nearest side of the box.
    For an outside location `l` with the closest surface point `s`, the distance is `max(abs(l - s))`.
    For inside locations it is `-max(abs(l - s))`.

    Args:
      location: float tensor of shape (batch_size, ..., rank)

    Returns:
      float tensor of shape (*location.shape[:-1], 1).

    &#34;&#34;&#34;
    assert not self.is_open.any, f&#34;approximate_signed_distance not supported for open boxes&#34;
    # ToDo this underestimates diagonally outside points
    location = self.global_to_local(location, scale=False, origin=&#39;center&#39;)
    distance = math.abs(location) - self.half_size
    distance = math.max(distance, &#39;vector&#39;)
    distance = math.min(distance, self.shape.instance)  # union for instance dimensions
    return distance</code></pre>
</details>
<div class="desc"><p>Computes the signed L-infinity norm (manhattan distance) from the location to the nearest side of the box.
For an outside location <code>l</code> with the closest surface point <code>s</code>, the distance is <code>max(abs(l - s))</code>.
For inside locations it is <code>-max(abs(l - s))</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd>float tensor of shape (batch_size, &hellip;, rank)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>float tensor of shape (*location.shape[:-1], 1).</p></div>
</dd>
<dt id="phi.geom.Box.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>self, center: phiml.math._tensors.Tensor) ‑> phi.geom._box.Box</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def at(self, center: Tensor) -&gt; &#39;Box&#39;:
    return replace(self, pos=center)</code></pre>
</details>
<div class="desc"><p>Returns a copy of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> with the center at <code>center</code>.
This is equal to calling <code>self @ center</code>.</p>
<p>See Also:
<code><a title="phi.geom.Geometry.shifted" href="#phi.geom.Geometry.shifted">Geometry.shifted()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>center</code></strong></dt>
<dd>New center as <code>Tensor</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.</p></div>
</dd>
<dt id="phi.geom.Box.bounding_half_extent"><code class="name flex">
<span>def <span class="ident">bounding_half_extent</span></span>(<span>self) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bounding_half_extent(self) -&gt; Tensor:
    if self.rot is not None:
        to_face = self.face_normals[{&#39;~side&#39;: 0}] * math.rename_dims(self.half_size, &#39;vector&#39;, dual)
        return math.sum(abs(to_face), &#39;~vector&#39;)
    return self.half_size</code></pre>
</details>
<div class="desc"><p>The bounding half-extent sets a limit on the outer-most point for each coordinate axis.
Each component is non-negative.</p>
<p>Let the bounding half-extent have value <code>e</code> in dimension <code>d</code> (<code>extent[...,d] = e</code>).
Then, no point of the geometry lies further away from its center point than <code>e</code> along <code>d</code> (in both axis directions).</p>
<p>If this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.
If these dims are not present on the result, all parts are assumed to have the same bounds.</p></div>
</dd>
<dt id="phi.geom.Box.bounding_radius"><code class="name flex">
<span>def <span class="ident">bounding_radius</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bounding_radius(self):
    return vec_length(self.half_size)</code></pre>
</details>
<div class="desc"><p>Returns the radius of a Sphere object that fully encloses this geometry.
The sphere is centered at the center of this geometry.</p>
<p>If this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.
If these dims are not present on the result, all parts are assumed to have the same bounds.</p></div>
</dd>
<dt id="phi.geom.Box.box"><code class="name flex">
<span>def <span class="ident">box</span></span>(<span>self) ‑> phi.geom._box.Box</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def corner_representation(self) -&gt; &#39;Box&#39;:
    assert self.is_axis_aligned.all, f&#34;corner_representation does not support rotations&#34;
    return self</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Box.center_representation"><code class="name flex">
<span>def <span class="ident">center_representation</span></span>(<span>self) ‑> <function <a title="phi.geom.Cuboid" href="#phi.geom.Cuboid">Cuboid()</a> at 0x7f8596084ea0></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def center_representation(self) -&gt; &#39;Cuboid&#39;:
    return self</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Box.contains"><code class="name flex">
<span>def <span class="ident">contains</span></span>(<span>self, other: <a title="phi.geom.Box" href="#phi.geom.Box">Box</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def contains(self, other: &#39;Box&#39;):
    &#34;&#34;&#34; Tests if the other box lies fully inside this box. &#34;&#34;&#34;
    assert not self.is_open.any and not other.is_open.any, f&#34;contains not supported for open boxes&#34;
    assert self.is_axis_aligned.all and other.rot is None, f&#34;contains() is only supported for axis-aligned boxes (rot=None).&#34;
    return np.all(other.lower &gt;= self.lower) and np.all(other.upper &lt;= self.upper)</code></pre>
</details>
<div class="desc"><p>Tests if the other box lies fully inside this box.</p></div>
</dd>
<dt id="phi.geom.Box.corner_representation"><code class="name flex">
<span>def <span class="ident">corner_representation</span></span>(<span>self) ‑> phi.geom._box.Box</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def corner_representation(self) -&gt; &#39;Box&#39;:
    assert self.is_axis_aligned.all, f&#34;corner_representation does not support rotations&#34;
    return self</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Box.cuboid"><code class="name flex">
<span>def <span class="ident">cuboid</span></span>(<span>self) ‑> <function <a title="phi.geom.Cuboid" href="#phi.geom.Cuboid">Cuboid()</a> at 0x7f8596084ea0></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def center_representation(self) -&gt; &#39;Cuboid&#39;:
    return self</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Box.global_to_local"><code class="name flex">
<span>def <span class="ident">global_to_local</span></span>(<span>self, global_position: phiml.math._tensors.Tensor, scale=True, origin='lower') ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def global_to_local(self, global_position: Tensor, scale=True, origin=&#39;lower&#39;) -&gt; Tensor:
    &#34;&#34;&#34;
    Transform world-space coordinates into box-space coordinates.

    Args:
        global_position: World-space coordinates.
        scale: Whether to re-scale the output so that [0, 1] or [-1, 1] represent the box for `origin=&#39;lower&#39;` or `origin=&#39;center&#39;`, respectively.
        origin: &#39;lower&#39; or &#39;center&#39;

    Returns:
        Box-space coordinate `Tensor`
    &#34;&#34;&#34;
    assert origin in [&#39;lower&#39;, &#39;center&#39;, &#39;upper&#39;]
    origin_loc = getattr(self, origin)
    pos = global_position if math.always_close(origin_loc, 0) else global_position - origin_loc
    pos = rotate(pos, self.rot, invert=True)
    if scale:
        pos /= (self.half_size if origin == &#39;center&#39; else self.size)
    return pos</code></pre>
</details>
<div class="desc"><p>Transform world-space coordinates into box-space coordinates.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>global_position</code></strong></dt>
<dd>World-space coordinates.</dd>
<dt><strong><code>scale</code></strong></dt>
<dd>Whether to re-scale the output so that [0, 1] or [-1, 1] represent the box for <code>origin='lower'</code> or <code>origin='center'</code>, respectively.</dd>
<dt><strong><code>origin</code></strong></dt>
<dd>'lower' or 'center'</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Box-space coordinate <code>Tensor</code></p></div>
</dd>
<dt id="phi.geom.Box.largest"><code class="name flex">
<span>def <span class="ident">largest</span></span>(<span>self, dim: str | Sequence | set | phiml.math._shape.Shape | Callable | None) ‑> phi.geom._box.Box</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def largest(self, dim: DimFilter) -&gt; &#39;Box&#39;:
    assert self.is_axis_aligned.all, f&#34;Box.largest() is only supported for axis-aligned boxes (rot=None)&#34;
    dim = self.shape.without(&#39;vector&#39;).only(dim)
    if not dim:
        return self
    return box_from_limits(math.min(self.lower, dim), math.max(self.upper, dim))</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Box.lies_inside"><code class="name flex">
<span>def <span class="ident">lies_inside</span></span>(<span>self, location: phiml.math._tensors.Tensor) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lies_inside(self, location: Tensor) -&gt; Tensor:
    location = self.global_to_local(location, scale=False, origin=&#39;center&#39;)  # scale can only be performed for finite sizes
    if not self.is_open.any:
        bool_inside = abs(location) &lt;= self.half_size
    else:
        above_lower = (location &gt; self.lower) | self.is_open.side.dual[&#39;lower&#39;]
        below_upper = (location &lt; self.upper) | self.is_open.side.dual[&#39;upper&#39;]
        bool_inside = above_lower &amp; below_upper
    bool_inside = math.all(bool_inside, &#39;vector&#39;)
    bool_inside = math.any(bool_inside, self.shape.instance - instance(location))  # union for instance dimensions
    return bool_inside</code></pre>
</details>
<div class="desc"><p>Tests whether the given location lies inside or outside of the geometry. Locations on the surface count as inside.</p>
<p>When dealing with unions or collections of geometries (instance dimensions), a point lies inside the geometry if it lies inside any instance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd>float tensor of shape (batch_size, &hellip;, rank)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>bool tensor of shape (*location.shape[:-1], 1).</p></div>
</dd>
<dt id="phi.geom.Box.local_to_global"><code class="name flex">
<span>def <span class="ident">local_to_global</span></span>(<span>self, local_position, scale=True, origin='lower')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def local_to_global(self, local_position, scale=True, origin=&#39;lower&#39;):
    assert origin in [&#39;lower&#39;, &#39;center&#39;, &#39;upper&#39;]
    origin_loc = getattr(self, origin)
    pos = local_position * (self.half_size if origin == &#39;center&#39; else self.size) if scale else local_position
    return rotate(pos, self.rot) + origin_loc</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Box.project"><code class="name flex">
<span>def <span class="ident">project</span></span>(<span>self, *dimensions: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def project(self, *dimensions: str):
    &#34;&#34;&#34; Project this box into a lower-dimensional space. &#34;&#34;&#34;
    warnings.warn(&#34;Box.project(dims) is deprecated. Use Box.vector[dims] instead&#34;, DeprecationWarning, stacklevel=2)
    return self.vector[dimensions]</code></pre>
</details>
<div class="desc"><p>Project this box into a lower-dimensional space.</p></div>
</dd>
<dt id="phi.geom.Box.push"><code class="name flex">
<span>def <span class="ident">push</span></span>(<span>self,<br>positions: phiml.math._tensors.Tensor,<br>outward: bool = True,<br>shift_amount: float = 0) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def push(self, positions: Tensor, outward: bool = True, shift_amount: float = 0) -&gt; Tensor:
    loc_to_center = self.global_to_local(positions, scale=False, origin=&#39;center&#39;)
    sgn_dist_from_surface = math.abs(loc_to_center) - self.half_size
    rotation_matrix = self.rotation_matrix
    if outward:
        # --- get negative distances (particles are inside) towards the nearest boundary and add shift_amount ---
        distances_of_interest = (sgn_dist_from_surface == math.max(sgn_dist_from_surface, &#39;vector&#39;)) &amp; (sgn_dist_from_surface &lt; 0)
        shift = distances_of_interest * (sgn_dist_from_surface - shift_amount)
        # ToDo reduce instance dim
    else:  # inward
        shift = (sgn_dist_from_surface + shift_amount) * (sgn_dist_from_surface &gt; 0)  # get positive distances (particles are outside) and add shift_amount
        if instance(self):
            shift, loc_to_center, rotation_matrix = math.at_min((shift, loc_to_center, rotation_matrix), key=vec_length(shift), dim=instance)
        shift = math.where(abs(shift) &gt; abs(loc_to_center), abs(loc_to_center), shift)  # ensure inward shift ends at center
    shift = rotate(shift, rotation_matrix)
    return positions + math.where(loc_to_center &lt; 0, 1, -1) * shift</code></pre>
</details>
<div class="desc"><p>Shifts positions either into or out of geometry.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>positions</code></strong></dt>
<dd>Tensor holding positions to shift</dd>
<dt><strong><code>outward</code></strong></dt>
<dd>Flag for indicating inward (False) or outward (True) shift</dd>
<dt><strong><code>shift_amount</code></strong></dt>
<dd>Minimum distance between positions and surface after shifting.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Tensor holding shifted positions.</p></div>
</dd>
<dt id="phi.geom.Box.rotated"><code class="name flex">
<span>def <span class="ident">rotated</span></span>(<span>self, angle) ‑> phi.geom._box.Box</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotated(self, angle) -&gt; &#39;Box&#39;:
    rot = wrap(angle) if self.is_axis_aligned.all else self.rotation_matrix @ rotation_matrix(angle)
    return replace(self, rot=rot)</code></pre>
</details>
<div class="desc"><p>Returns a rotated version of this geometry.
The geometry is rotated about its center point.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>angle</code></strong></dt>
<dd>
<p>Delta rotation.
Either</p>
<ul>
<li>Angle(s): scalar angle in 2d or euler angles along <code>vector</code> in 3D or higher.</li>
<li>Matrix: d⨯d rotation matrix</li>
</ul>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Rotated <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></p></div>
</dd>
<dt id="phi.geom.Box.sample_uniform"><code class="name flex">
<span>def <span class="ident">sample_uniform</span></span>(<span>self, *shape: phiml.math._shape.Shape) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_uniform(self, *shape: Shape) -&gt; Tensor:
    assert not self.is_open.any, f&#34;sample_uniform not supported for open boxes&#34;
    uniform = math.random_uniform(self.shape.non_singleton.without(&#39;vector&#39;), *shape, self.shape[&#39;vector&#39;])
    return self.lower + uniform * self.size</code></pre>
</details>
<div class="desc"><p>Samples uniformly distributed random points inside this volume.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*shape</code></strong></dt>
<dd>How many points to sample per individual geometry.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>Tensor</code> containing all dimensions from <code><a title="phi.geom.Geometry.shape" href="#phi.geom.Geometry.shape">Geometry.shape</a></code>, <code>shape</code> as well as a <code>channel</code> dimension <code>vector</code> matching the dimensionality of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.</p></div>
</dd>
<dt id="phi.geom.Box.sample_uniform_surface"><code class="name flex">
<span>def <span class="ident">sample_uniform_surface</span></span>(<span>self, *shape: phiml.math._shape.Shape) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_uniform_surface(self, *shape: Shape) -&gt; Tensor:
    assert not instance(self), &#34;sample_uniform_surface not yet supported for unions of boxes&#34;
    samples = math.random_uniform(self.shape.non_singleton.non_instance, *shape, low=self.lower, high=self.upper)
    which = math.random_uniform(samples.shape.without(&#39;vector&#39;))
    lo_or_up = math.where(which &gt; .5, self.upper, self.lower)
    which = which * 2 % 1
    # --- which axis ---
    areas = self.face_areas
    total_area = math.sum(areas)
    frac_area = math.sum(areas / total_area, &#39;~side&#39;)
    cum_area = math.cumulative_sum(frac_area, &#39;~vector&#39;)
    axis = math.min(math.where(which &lt;= cum_area, math.range(self.shape[&#39;vector&#39;].as_dual()), self.spatial_rank), &#39;~vector&#39;)
    axis_one_hot = math.scatter(math.zeros(samples.shape, dtype=bool), expand(axis, channel(index=&#39;vector&#39;)), True, treat_as_batch=samples.shape.without(&#39;vector&#39;))
    math.assert_close(1, math.sum(axis_one_hot, &#39;vector&#39;))
    samples = math.where(axis_one_hot, lo_or_up, samples)
    return samples</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Box.scaled"><code class="name flex">
<span>def <span class="ident">scaled</span></span>(<span>self, factor: phiml.math._tensors.Tensor | float) ‑> phi.geom._box.Box</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scaled(self, factor: Union[float, Tensor]) -&gt; &#39;Box&#39;:
    return replace(self, size=self.size * factor)</code></pre>
</details>
<div class="desc"><p>Scales each individual geometry by <code>factor</code>.
The individual <code>center</code> points act as pivots for the operation.</p>
<h2 id="args">Args</h2>
<p>factor:
Returns:</p></div>
</dd>
<dt id="phi.geom.Box.smallest"><code class="name flex">
<span>def <span class="ident">smallest</span></span>(<span>self, dim: str | Sequence | set | phiml.math._shape.Shape | Callable | None) ‑> phi.geom._box.Box</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def smallest(self, dim: DimFilter) -&gt; &#39;Box&#39;:
    assert self.is_axis_aligned.all, f&#34;Box.smallest() is only supported for axis-aligned boxes (rot=None)&#34;
    dim = self.shape.without(&#39;vector&#39;).only(dim)
    if not dim:
        return self
    return box_from_limits(math.max(self.lower, dim), math.min(self.upper, dim))</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Box.without"><code class="name flex">
<span>def <span class="ident">without</span></span>(<span>self, dims: Tuple[str, ...])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def without(self, dims: Tuple[str, ...]):
    assert self.is_axis_aligned.all, f&#34;Box.without() is only supported for axis-aligned boxes (rot=None)&#34;
    remaining = list(self.shape.get_item_names(&#39;vector&#39;))
    for dim in dims:
        if dim in remaining:
            remaining.remove(dim)
    return self.vector[remaining]</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="phi.geom.Box"><code class="flex name class">
<span>class <span class="ident">BaseBox</span></span>
<span>(</span><span>pos: phiml.math._tensors.Tensor,<br>size: phiml.math._tensors.Tensor,<br>rot: phiml.math._tensors.Tensor,<br>is_open: phiml.math._tensors.Tensor,<br>variable_attrs: Tuple[str, ...] = ('pos', 'size', 'rot'))</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@sliceable(keepdims=&#39;vector&#39;)
@dataclass(frozen=True, eq=False)
class Box(Geometry, metaclass=BoxType):
    &#34;&#34;&#34;
    Simple cuboid defined by location of lower and upper corner in physical space.

    Boxes can be constructed either from two positional vector arguments `(lower, upper)` or by specifying the limits by dimension name as `kwargs`.

    Examples:
        &gt;&gt;&gt; Box(x=1, y=1)  # creates a two-dimensional unit box with `lower=(0, 0)` and `upper=(1, 1)`.
        &gt;&gt;&gt; Box(x=(None, 1), y=(0, None)  # creates a Box with `lower=(-inf, 0)` and `upper=(1, inf)`.

        The slicing constructor was updated in version 2.2 and now requires the dimension order as the first argument.

        &gt;&gt;&gt; Box[&#39;x,y&#39;, 0:1, 0:1]  # creates a two-dimensional unit box with `lower=(0, 0)` and `upper=(1, 1)`.
        &gt;&gt;&gt; Box[&#39;x,y&#39;, :1, 0:]  # creates a Box with `lower=(-inf, 0)` and `upper=(1, inf)`.
    &#34;&#34;&#34;

    pos: Tensor
    size: Tensor
    rot: Tensor  # can be Layout(None) for no rotation
    is_open: Tensor  # Infinite extent per face, (~side, vector) or fewer
    
    variable_attrs: Tuple[str, ...] = (&#39;pos&#39;, &#39;size&#39;, &#39;rot&#39;)

    def __post_init__(self):
        assert isinstance(self.pos, Tensor) and &#39;vector&#39; in channel(self.pos)
        assert isinstance(self.size, Tensor)
        assert isinstance(self.rot, Tensor)

    @property
    def half_size(self):
        return self.size * 0.5

    @cached_property
    def lower(self):
        return math.where(self.is_open.side[&#39;lower&#39;], -math.INF, self.pos - self.half_size)

    @cached_property
    def upper(self):
        return math.where(self.is_open.side[&#39;upper&#39;], math.INF, self.pos + self.half_size)

    @cached_property
    def is_finite(self):
        return not self.is_open.any

    def __repr__(self):
        if self.rot is not None:
            return f&#34;Cuboid(center={self.pos}, size={self.size})&#34;
        if self.pos is None or self.size is None:  # traced
            return f&#34;Box[traced, shape={self.shape}]&#34;
        if self.shape.non_channel.volume == 1:
            item_names = self.size.vector.item_names
            if item_names:
                return f&#34;Box({&#39;, &#39;.join([f&#39;{dim}=({lo}, {up})&#39; for dim, lo, up in zip(item_names, self.lower, self.upper)])})&#34;
            else:  # deprecated
                return &#39;Box[%s at %s]&#39; % (&#39;x&#39;.join([str(x) for x in self.size.numpy().flatten()]), &#39;,&#39;.join([str(x) for x in self.lower.numpy().flatten()]))
        else:
            return f&#39;Box[shape={self.shape}]&#39;

    @cached_property
    def shape(self):
        return self.pos.shape &amp; self.size.shape &amp; (shape(self.rot) - &#39;~vector&#39;)

    @property
    def center(self):
        return self.pos

    @property
    def volume(self) -&gt; Tensor:
        return math.prod(self.size, &#39;vector&#39;)

    @property
    def is_axis_aligned(self):
        return self.rot == None

    @property
    def rotation_matrix(self) -&gt; Tensor:
        return rotation_matrix(self.rot, self.shape[&#39;vector&#39;], none_to_unit=True)

    def at(self, center: Tensor) -&gt; &#39;Box&#39;:
        return replace(self, pos=center)

    def rotated(self, angle) -&gt; &#39;Box&#39;:
        rot = wrap(angle) if self.is_axis_aligned.all else self.rotation_matrix @ rotation_matrix(angle)
        return replace(self, rot=rot)

    def scaled(self, factor: Union[float, Tensor]) -&gt; &#39;Box&#39;:
        return replace(self, size=self.size * factor)

    def global_to_local(self, global_position: Tensor, scale=True, origin=&#39;lower&#39;) -&gt; Tensor:
        &#34;&#34;&#34;
        Transform world-space coordinates into box-space coordinates.

        Args:
            global_position: World-space coordinates.
            scale: Whether to re-scale the output so that [0, 1] or [-1, 1] represent the box for `origin=&#39;lower&#39;` or `origin=&#39;center&#39;`, respectively.
            origin: &#39;lower&#39; or &#39;center&#39;

        Returns:
            Box-space coordinate `Tensor`
        &#34;&#34;&#34;
        assert origin in [&#39;lower&#39;, &#39;center&#39;, &#39;upper&#39;]
        origin_loc = getattr(self, origin)
        pos = global_position if math.always_close(origin_loc, 0) else global_position - origin_loc
        pos = rotate(pos, self.rot, invert=True)
        if scale:
            pos /= (self.half_size if origin == &#39;center&#39; else self.size)
        return pos

    def local_to_global(self, local_position, scale=True, origin=&#39;lower&#39;):
        assert origin in [&#39;lower&#39;, &#39;center&#39;, &#39;upper&#39;]
        origin_loc = getattr(self, origin)
        pos = local_position * (self.half_size if origin == &#39;center&#39; else self.size) if scale else local_position
        return rotate(pos, self.rot) + origin_loc

    def __mul__(self, other):
        if not isinstance(other, Box):
            return NotImplemented
        assert self.is_axis_aligned.all and other.is_axis_aligned.all, f&#34;Box * Box only supported for axis-aligned boxes (rot=None).&#34;
        pos = concat([self.pos, other.pos], &#39;vector&#39;)
        size = concat([self.size, other.size], &#39;vector&#39;)
        return replace(self, pos=pos, size=size)

    def bounding_half_extent(self) -&gt; Tensor:
        if self.rot is not None:
            to_face = self.face_normals[{&#39;~side&#39;: 0}] * math.rename_dims(self.half_size, &#39;vector&#39;, dual)
            return math.sum(abs(to_face), &#39;~vector&#39;)
        return self.half_size

    def lies_inside(self, location: Tensor) -&gt; Tensor:
        location = self.global_to_local(location, scale=False, origin=&#39;center&#39;)  # scale can only be performed for finite sizes
        if not self.is_open.any:
            bool_inside = abs(location) &lt;= self.half_size
        else:
            above_lower = (location &gt; self.lower) | self.is_open.side.dual[&#39;lower&#39;]
            below_upper = (location &lt; self.upper) | self.is_open.side.dual[&#39;upper&#39;]
            bool_inside = above_lower &amp; below_upper
        bool_inside = math.all(bool_inside, &#39;vector&#39;)
        bool_inside = math.any(bool_inside, self.shape.instance - instance(location))  # union for instance dimensions
        return bool_inside

    def largest(self, dim: DimFilter) -&gt; &#39;Box&#39;:
        assert self.is_axis_aligned.all, f&#34;Box.largest() is only supported for axis-aligned boxes (rot=None)&#34;
        dim = self.shape.without(&#39;vector&#39;).only(dim)
        if not dim:
            return self
        return box_from_limits(math.min(self.lower, dim), math.max(self.upper, dim))

    def smallest(self, dim: DimFilter) -&gt; &#39;Box&#39;:
        assert self.is_axis_aligned.all, f&#34;Box.smallest() is only supported for axis-aligned boxes (rot=None)&#34;
        dim = self.shape.without(&#39;vector&#39;).only(dim)
        if not dim:
            return self
        return box_from_limits(math.max(self.lower, dim), math.min(self.upper, dim))

    def without(self, dims: Tuple[str, ...]):
        assert self.is_axis_aligned.all, f&#34;Box.without() is only supported for axis-aligned boxes (rot=None)&#34;
        remaining = list(self.shape.get_item_names(&#39;vector&#39;))
        for dim in dims:
            if dim in remaining:
                remaining.remove(dim)
        return self.vector[remaining]

    def bounding_radius(self):
        return vec_length(self.half_size)

    def project(self, *dimensions: str):
        &#34;&#34;&#34; Project this box into a lower-dimensional space. &#34;&#34;&#34;
        warnings.warn(&#34;Box.project(dims) is deprecated. Use Box.vector[dims] instead&#34;, DeprecationWarning, stacklevel=2)
        return self.vector[dimensions]

    def approximate_signed_distance(self, location: Union[Tensor, tuple]):
        &#34;&#34;&#34;
        Computes the signed L-infinity norm (manhattan distance) from the location to the nearest side of the box.
        For an outside location `l` with the closest surface point `s`, the distance is `max(abs(l - s))`.
        For inside locations it is `-max(abs(l - s))`.

        Args:
          location: float tensor of shape (batch_size, ..., rank)

        Returns:
          float tensor of shape (*location.shape[:-1], 1).

        &#34;&#34;&#34;
        assert not self.is_open.any, f&#34;approximate_signed_distance not supported for open boxes&#34;
        # ToDo this underestimates diagonally outside points
        location = self.global_to_local(location, scale=False, origin=&#39;center&#39;)
        distance = math.abs(location) - self.half_size
        distance = math.max(distance, &#39;vector&#39;)
        distance = math.min(distance, self.shape.instance)  # union for instance dimensions
        return distance

    def approximate_closest_surface(self, location: Tensor) -&gt; Tuple[Tensor, Tensor, Tensor, Tensor, Tensor]:
        assert not self.is_open.any, f&#34;approximate_closest_surface not supported for open boxes&#34;
        loc_to_center = self.global_to_local(location, scale=False, origin=&#39;center&#39;)
        sgn_surf_delta = math.abs(loc_to_center) - self.half_size
        if instance(self):
            raise NotImplementedError
            # self_center, self_radius, sgn_dist, center_delta, center_dist = math.at_min((self.center, self.radius, sgn_dist, center_delta, center_dist), key=abs(sgn_dist), dim=instance)
        # is_inside = math.all(sgn_surf_delta &lt; 0, &#39;vector&#39;)
        # abs_surf_delta = abs(sgn_surf_delta)
        max_sgn_dist = math.max(sgn_surf_delta, &#39;vector&#39;)
        normal_axis = max_sgn_dist == sgn_surf_delta  # ToDo only one if inside
        normal = math.vec_normalize(normal_axis * math.sign(loc_to_center))
        normal = rotate(normal, self.rot)
        surf_to_center = math.where(normal_axis, math.sign(loc_to_center) * self.half_size, loc_to_center)
        closest_to_center = math.clip(surf_to_center, -self.half_size, self.half_size)
        surface_pos = self.local_to_global(closest_to_center, scale=False, origin=&#39;center&#39;)
        delta = surface_pos - location
        face_index = expand(0, non_channel(location))
        offset = normal.vector @ surface_pos.vector
        sgn_surf_dist = vec_length(delta) * math.sign(max_sgn_dist)
        return sgn_surf_dist, delta, normal, offset, face_index

    def sample_uniform(self, *shape: Shape) -&gt; Tensor:
        assert not self.is_open.any, f&#34;sample_uniform not supported for open boxes&#34;
        uniform = math.random_uniform(self.shape.non_singleton.without(&#39;vector&#39;), *shape, self.shape[&#39;vector&#39;])
        return self.lower + uniform * self.size

    def contains(self, other: &#39;Box&#39;):
        &#34;&#34;&#34; Tests if the other box lies fully inside this box. &#34;&#34;&#34;
        assert not self.is_open.any and not other.is_open.any, f&#34;contains not supported for open boxes&#34;
        assert self.is_axis_aligned.all and other.rot is None, f&#34;contains() is only supported for axis-aligned boxes (rot=None).&#34;
        return np.all(other.lower &gt;= self.lower) and np.all(other.upper &lt;= self.upper)

    def push(self, positions: Tensor, outward: bool = True, shift_amount: float = 0) -&gt; Tensor:
        loc_to_center = self.global_to_local(positions, scale=False, origin=&#39;center&#39;)
        sgn_dist_from_surface = math.abs(loc_to_center) - self.half_size
        rotation_matrix = self.rotation_matrix
        if outward:
            # --- get negative distances (particles are inside) towards the nearest boundary and add shift_amount ---
            distances_of_interest = (sgn_dist_from_surface == math.max(sgn_dist_from_surface, &#39;vector&#39;)) &amp; (sgn_dist_from_surface &lt; 0)
            shift = distances_of_interest * (sgn_dist_from_surface - shift_amount)
            # ToDo reduce instance dim
        else:  # inward
            shift = (sgn_dist_from_surface + shift_amount) * (sgn_dist_from_surface &gt; 0)  # get positive distances (particles are outside) and add shift_amount
            if instance(self):
                shift, loc_to_center, rotation_matrix = math.at_min((shift, loc_to_center, rotation_matrix), key=vec_length(shift), dim=instance)
            shift = math.where(abs(shift) &gt; abs(loc_to_center), abs(loc_to_center), shift)  # ensure inward shift ends at center
        shift = rotate(shift, rotation_matrix)
        return positions + math.where(loc_to_center &lt; 0, 1, -1) * shift

    def sample_uniform_surface(self, *shape: Shape) -&gt; Tensor:
        assert not instance(self), &#34;sample_uniform_surface not yet supported for unions of boxes&#34;
        samples = math.random_uniform(self.shape.non_singleton.non_instance, *shape, low=self.lower, high=self.upper)
        which = math.random_uniform(samples.shape.without(&#39;vector&#39;))
        lo_or_up = math.where(which &gt; .5, self.upper, self.lower)
        which = which * 2 % 1
        # --- which axis ---
        areas = self.face_areas
        total_area = math.sum(areas)
        frac_area = math.sum(areas / total_area, &#39;~side&#39;)
        cum_area = math.cumulative_sum(frac_area, &#39;~vector&#39;)
        axis = math.min(math.where(which &lt;= cum_area, math.range(self.shape[&#39;vector&#39;].as_dual()), self.spatial_rank), &#39;~vector&#39;)
        axis_one_hot = math.scatter(math.zeros(samples.shape, dtype=bool), expand(axis, channel(index=&#39;vector&#39;)), True, treat_as_batch=samples.shape.without(&#39;vector&#39;))
        math.assert_close(1, math.sum(axis_one_hot, &#39;vector&#39;))
        samples = math.where(axis_one_hot, lo_or_up, samples)
        return samples

    @property
    def boundary_elements(self) -&gt; Dict[Any, Dict[str, slice]]:
        return {}

    @property
    def boundary_faces(self) -&gt; Dict[Any, Dict[str, slice]]:
        return {}

    @property
    def faces(self) -&gt; &#39;Geometry&#39;:
        return Cuboid(self.face_centers, self.half_size, self.rot, size_variable=False)

    @property
    def face_centers(self) -&gt; Tensor:
        return self.center + self.face_normals * self.half_size

    @property
    def face_normals(self) -&gt; Tensor:
        unit_vectors = to_float(math.range(self.shape[&#39;vector&#39;]) == math.range(dual(**self.shape[&#39;vector&#39;].untyped_dict)))
        vectors = rotate(unit_vectors, self.rot)
        return vectors * math.vec(dual(&#39;side&#39;), lower=-1, upper=1)

    @property
    def face_areas(self) -&gt; Tensor:
        others_mask = math.range(self.shape[&#39;vector&#39;]) != math.range(dual(**self.shape[&#39;vector&#39;].untyped_dict))
        result = math.exp(math.sum(math.log(self.size) * others_mask, &#39;vector&#39;))
        return expand(result, dual(side=&#39;lower,upper&#39;))  # ~vector

    @property
    def face_shape(self) -&gt; Shape:
        return self.shape.without(&#39;vector&#39;) &amp; dual(side=&#39;lower,upper&#39;) &amp; dual(**self.shape[&#39;vector&#39;].untyped_dict)

    @property
    def corners(self) -&gt; Tensor:
        to_face = self.face_normals[{&#39;~side&#39;: &#39;upper&#39;}] * math.rename_dims(self.half_size, &#39;vector&#39;, dual)
        lower_upper = math.meshgrid(math.dual, **{dim: [-1, 1] for dim in self.vector.item_names}, stack_dim=dual(&#39;vector&#39;))  # (x=2, y=2, ... vector=x,y,...)
        to_corner = math.sum(lower_upper * to_face, &#39;~vector&#39;)
        return self.center + to_corner

    @property
    def is_size_variable(self):
        warnings.warn(&#34;Box.is_size_variable is deprecated. Check Box.variable_attrs instead.&#34;, DeprecationWarning, stacklevel=2)
        return &#39;size&#39; in self.variable_attrs

    def corner_representation(self) -&gt; &#39;Box&#39;:
        assert self.is_axis_aligned.all, f&#34;corner_representation does not support rotations&#34;
        return self

    box = corner_representation

    def center_representation(self) -&gt; &#39;Cuboid&#39;:
        return self

    cuboid = center_representation</code></pre>
</details>
<div class="desc"><p>Simple cuboid defined by location of lower and upper corner in physical space.</p>
<p>Boxes can be constructed either from two positional vector arguments <code>(lower, upper)</code> or by specifying the limits by dimension name as <code>kwargs</code>.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; Box(x=1, y=1)  # creates a two-dimensional unit box with `lower=(0, 0)` and `upper=(1, 1)`.
&gt;&gt;&gt; Box(x=(None, 1), y=(0, None)  # creates a Box with `lower=(-inf, 0)` and `upper=(1, inf)`.
</code></pre>
<p>The slicing constructor was updated in version 2.2 and now requires the dimension order as the first argument.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; Box['x,y', 0:1, 0:1]  # creates a two-dimensional unit box with `lower=(0, 0)` and `upper=(1, 1)`.
&gt;&gt;&gt; Box['x,y', :1, 0:]  # creates a Box with `lower=(-inf, 0)` and `upper=(1, inf)`.
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.geom._geom.Geometry</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="phi.geom.Box.Tc"><code class="name">prop <span class="ident">Tc</span></code></dt>
<dd>
<div class="desc"><p>partial(func, <em>args, </em>*keywords) - new function with partial application
of the given arguments and keywords.</p></div>
</dd>
<dt id="phi.geom.Box.Ti"><code class="name">prop <span class="ident">Ti</span></code></dt>
<dd>
<div class="desc"><p>partial(func, <em>args, </em>*keywords) - new function with partial application
of the given arguments and keywords.</p></div>
</dd>
<dt id="phi.geom.Box.Ts"><code class="name">prop <span class="ident">Ts</span></code></dt>
<dd>
<div class="desc"><p>partial(func, <em>args, </em>*keywords) - new function with partial application
of the given arguments and keywords.</p></div>
</dd>
<dt id="phi.geom.Box.boundary_elements"><code class="name">prop <span class="ident">boundary_elements</span> : Dict[Any, Dict[str, slice]]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def boundary_elements(self) -&gt; Dict[Any, Dict[str, slice]]:
    return {}</code></pre>
</details>
<div class="desc"><p>Slices on the primal dimensions to mark boundary elements.
Grids and meshes have no boundary elements and return <code>{}</code>.
Dynamic graphs can define boundary elements for obstacles and walls.</p>
<h2 id="returns">Returns</h2>
<p>Map from <code>name</code> to slicing <code>dict</code>.</p></div>
</dd>
<dt id="phi.geom.Box.boundary_faces"><code class="name">prop <span class="ident">boundary_faces</span> : Dict[Any, Dict[str, slice]]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def boundary_faces(self) -&gt; Dict[Any, Dict[str, slice]]:
    return {}</code></pre>
</details>
<div class="desc"><p>Slices on the dual dimensions to mark boundary faces.</p>
<p>Regular grids use the keys (dim, is_upper) to identify boundaries.
Unstructured meshes use string identifiers for the boundaries.
Dynamic graphs return slices along the dual dimensions.</p>
<h2 id="returns">Returns</h2>
<p>Map from <code>name</code> to slicing <code>dict</code>.</p></div>
</dd>
<dt id="phi.geom.Box.center"><code class="name">prop <span class="ident">center</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def center(self):
    return self.pos</code></pre>
</details>
<div class="desc"><p>Center location in single channel dimension.</p></div>
</dd>
<dt id="phi.geom.Box.corners"><code class="name">prop <span class="ident">corners</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def corners(self) -&gt; Tensor:
    to_face = self.face_normals[{&#39;~side&#39;: &#39;upper&#39;}] * math.rename_dims(self.half_size, &#39;vector&#39;, dual)
    lower_upper = math.meshgrid(math.dual, **{dim: [-1, 1] for dim in self.vector.item_names}, stack_dim=dual(&#39;vector&#39;))  # (x=2, y=2, ... vector=x,y,...)
    to_corner = math.sum(lower_upper * to_face, &#39;~vector&#39;)
    return self.center + to_corner</code></pre>
</details>
<div class="desc"><h2 id="returns">Returns</h2>
<p>Corner locations as <code>phiml.math.Tensor</code>.
Corners belonging to one object or cell are listed along dual dimensions.
If the object has no corners, a size-0 tensor with the correct vector and instance dims is returned.</p></div>
</dd>
<dt id="phi.geom.Box.face_areas"><code class="name">prop <span class="ident">face_areas</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_areas(self) -&gt; Tensor:
    others_mask = math.range(self.shape[&#39;vector&#39;]) != math.range(dual(**self.shape[&#39;vector&#39;].untyped_dict))
    result = math.exp(math.sum(math.log(self.size) * others_mask, &#39;vector&#39;))
    return expand(result, dual(side=&#39;lower,upper&#39;))  # ~vector</code></pre>
</details>
<div class="desc"><p>Area of face connecting a pair of cells. Shape <code>(elements, ~)</code>.
Returns 0 for unconnected cells.</p></div>
</dd>
<dt id="phi.geom.Box.face_centers"><code class="name">prop <span class="ident">face_centers</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_centers(self) -&gt; Tensor:
    return self.center + self.face_normals * self.half_size</code></pre>
</details>
<div class="desc"><p>Center of face connecting a pair of cells. Shape <code>(elements, ~, vector)</code>.
Here, <code>~</code> represents arbitrary internal dual dimensions, such as <code>~staggered_direction</code> or <code>~elements</code>.
Returns 0-vectors for unconnected cells.</p></div>
</dd>
<dt id="phi.geom.Box.face_normals"><code class="name">prop <span class="ident">face_normals</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_normals(self) -&gt; Tensor:
    unit_vectors = to_float(math.range(self.shape[&#39;vector&#39;]) == math.range(dual(**self.shape[&#39;vector&#39;].untyped_dict)))
    vectors = rotate(unit_vectors, self.rot)
    return vectors * math.vec(dual(&#39;side&#39;), lower=-1, upper=1)</code></pre>
</details>
<div class="desc"><p>Normal vectors of cell faces, including boundary faces. Shape <code>(elements, ~, vector)</code>.
For meshes, The vectors point out of the primal cells and into the dual cells.</p>
<p>Instance/spatial dimensions along which the normal does not vary may not be included in the result tensor's shape.</p></div>
</dd>
<dt id="phi.geom.Box.face_shape"><code class="name">prop <span class="ident">face_shape</span> : phiml.math._shape.Shape</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_shape(self) -&gt; Shape:
    return self.shape.without(&#39;vector&#39;) &amp; dual(side=&#39;lower,upper&#39;) &amp; dual(**self.shape[&#39;vector&#39;].untyped_dict)</code></pre>
</details>
<div class="desc"><h2 id="returns">Returns</h2>
<p>Full Shape to identify each face of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>, including instance/spatial dimensions for the elements and dual dimensions listing the faces per element.
If this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> has no faces, returns an empty <code>Shape</code>.</p></div>
</dd>
<dt id="phi.geom.Box.faces"><code class="name">prop <span class="ident">faces</span> : <a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def faces(self) -&gt; &#39;Geometry&#39;:
    return Cuboid(self.face_centers, self.half_size, self.rot, size_variable=False)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Box.half_size"><code class="name">prop <span class="ident">half_size</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def half_size(self):
    return self.size * 0.5</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Box.is_axis_aligned"><code class="name">prop <span class="ident">is_axis_aligned</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_axis_aligned(self):
    return self.rot == None</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Box.is_finite"><code class="name">var <span class="ident">is_finite</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def is_finite(self):
    return not self.is_open.any</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Box.is_open"><code class="name">var <span class="ident">is_open</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Box.is_size_variable"><code class="name">prop <span class="ident">is_size_variable</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_size_variable(self):
    warnings.warn(&#34;Box.is_size_variable is deprecated. Check Box.variable_attrs instead.&#34;, DeprecationWarning, stacklevel=2)
    return &#39;size&#39; in self.variable_attrs</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Box.lower"><code class="name">var <span class="ident">lower</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def lower(self):
    return math.where(self.is_open.side[&#39;lower&#39;], -math.INF, self.pos - self.half_size)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Box.pos"><code class="name">var <span class="ident">pos</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Box.rot"><code class="name">var <span class="ident">rot</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Box.rotation_matrix"><code class="name">prop <span class="ident">rotation_matrix</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def rotation_matrix(self) -&gt; Tensor:
    return rotation_matrix(self.rot, self.shape[&#39;vector&#39;], none_to_unit=True)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Box.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def shape(self):
    return self.pos.shape &amp; self.size.shape &amp; (shape(self.rot) - &#39;~vector&#39;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Box.size"><code class="name">var <span class="ident">size</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Box.upper"><code class="name">var <span class="ident">upper</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def upper(self):
    return math.where(self.is_open.side[&#39;upper&#39;], math.INF, self.pos + self.half_size)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Box.variable_attrs"><code class="name">var <span class="ident">variable_attrs</span> : Tuple[str, ...]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Box.volume"><code class="name">prop <span class="ident">volume</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def volume(self) -&gt; Tensor:
    return math.prod(self.size, &#39;vector&#39;)</code></pre>
</details>
<div class="desc"><p><code>phi.math.Tensor</code> representing the volume of each element.
The result retains batch, spatial and instance dimensions.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phi.geom.Box.approximate_closest_surface"><code class="name flex">
<span>def <span class="ident">approximate_closest_surface</span></span>(<span>self, location: phiml.math._tensors.Tensor) ‑> Tuple[phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def approximate_closest_surface(self, location: Tensor) -&gt; Tuple[Tensor, Tensor, Tensor, Tensor, Tensor]:
    assert not self.is_open.any, f&#34;approximate_closest_surface not supported for open boxes&#34;
    loc_to_center = self.global_to_local(location, scale=False, origin=&#39;center&#39;)
    sgn_surf_delta = math.abs(loc_to_center) - self.half_size
    if instance(self):
        raise NotImplementedError
        # self_center, self_radius, sgn_dist, center_delta, center_dist = math.at_min((self.center, self.radius, sgn_dist, center_delta, center_dist), key=abs(sgn_dist), dim=instance)
    # is_inside = math.all(sgn_surf_delta &lt; 0, &#39;vector&#39;)
    # abs_surf_delta = abs(sgn_surf_delta)
    max_sgn_dist = math.max(sgn_surf_delta, &#39;vector&#39;)
    normal_axis = max_sgn_dist == sgn_surf_delta  # ToDo only one if inside
    normal = math.vec_normalize(normal_axis * math.sign(loc_to_center))
    normal = rotate(normal, self.rot)
    surf_to_center = math.where(normal_axis, math.sign(loc_to_center) * self.half_size, loc_to_center)
    closest_to_center = math.clip(surf_to_center, -self.half_size, self.half_size)
    surface_pos = self.local_to_global(closest_to_center, scale=False, origin=&#39;center&#39;)
    delta = surface_pos - location
    face_index = expand(0, non_channel(location))
    offset = normal.vector @ surface_pos.vector
    sgn_surf_dist = vec_length(delta) * math.sign(max_sgn_dist)
    return sgn_surf_dist, delta, normal, offset, face_index</code></pre>
</details>
<div class="desc"><p>Find the closest surface face of this geometry given a point that can be outside or inside the geometry.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd><code>Tensor</code> with a single channel dimension called vector. Can have arbitrary other dimensions.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>signed_distance</code></dt>
<dd>Scalar signed distance from <code>location</code>
to the closest point on the surface.
Positive values indicate the point lies outside the geometry, negative values indicate the point lies inside the geometry.</dd>
<dt><code>delta</code></dt>
<dd>Vector-valued distance vector from <code>location</code> to the closest point on the surface.</dd>
<dt><code>normal</code></dt>
<dd>Closest surface normal vector.</dd>
<dt><code>offset</code></dt>
<dd>Min distance of a surface-tangential plane from 0 as a scalar.</dd>
<dt><code>face_index</code></dt>
<dd>(Optional) An index vector pointing at the closest face.</dd>
</dl></div>
</dd>
<dt id="phi.geom.Box.approximate_signed_distance"><code class="name flex">
<span>def <span class="ident">approximate_signed_distance</span></span>(<span>self, location: phiml.math._tensors.Tensor | tuple)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def approximate_signed_distance(self, location: Union[Tensor, tuple]):
    &#34;&#34;&#34;
    Computes the signed L-infinity norm (manhattan distance) from the location to the nearest side of the box.
    For an outside location `l` with the closest surface point `s`, the distance is `max(abs(l - s))`.
    For inside locations it is `-max(abs(l - s))`.

    Args:
      location: float tensor of shape (batch_size, ..., rank)

    Returns:
      float tensor of shape (*location.shape[:-1], 1).

    &#34;&#34;&#34;
    assert not self.is_open.any, f&#34;approximate_signed_distance not supported for open boxes&#34;
    # ToDo this underestimates diagonally outside points
    location = self.global_to_local(location, scale=False, origin=&#39;center&#39;)
    distance = math.abs(location) - self.half_size
    distance = math.max(distance, &#39;vector&#39;)
    distance = math.min(distance, self.shape.instance)  # union for instance dimensions
    return distance</code></pre>
</details>
<div class="desc"><p>Computes the signed L-infinity norm (manhattan distance) from the location to the nearest side of the box.
For an outside location <code>l</code> with the closest surface point <code>s</code>, the distance is <code>max(abs(l - s))</code>.
For inside locations it is <code>-max(abs(l - s))</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd>float tensor of shape (batch_size, &hellip;, rank)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>float tensor of shape (*location.shape[:-1], 1).</p></div>
</dd>
<dt id="phi.geom.Box.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>self, center: phiml.math._tensors.Tensor) ‑> phi.geom._box.Box</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def at(self, center: Tensor) -&gt; &#39;Box&#39;:
    return replace(self, pos=center)</code></pre>
</details>
<div class="desc"><p>Returns a copy of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> with the center at <code>center</code>.
This is equal to calling <code>self @ center</code>.</p>
<p>See Also:
<code><a title="phi.geom.Geometry.shifted" href="#phi.geom.Geometry.shifted">Geometry.shifted()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>center</code></strong></dt>
<dd>New center as <code>Tensor</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.</p></div>
</dd>
<dt id="phi.geom.Box.bounding_half_extent"><code class="name flex">
<span>def <span class="ident">bounding_half_extent</span></span>(<span>self) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bounding_half_extent(self) -&gt; Tensor:
    if self.rot is not None:
        to_face = self.face_normals[{&#39;~side&#39;: 0}] * math.rename_dims(self.half_size, &#39;vector&#39;, dual)
        return math.sum(abs(to_face), &#39;~vector&#39;)
    return self.half_size</code></pre>
</details>
<div class="desc"><p>The bounding half-extent sets a limit on the outer-most point for each coordinate axis.
Each component is non-negative.</p>
<p>Let the bounding half-extent have value <code>e</code> in dimension <code>d</code> (<code>extent[...,d] = e</code>).
Then, no point of the geometry lies further away from its center point than <code>e</code> along <code>d</code> (in both axis directions).</p>
<p>If this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.
If these dims are not present on the result, all parts are assumed to have the same bounds.</p></div>
</dd>
<dt id="phi.geom.Box.bounding_radius"><code class="name flex">
<span>def <span class="ident">bounding_radius</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bounding_radius(self):
    return vec_length(self.half_size)</code></pre>
</details>
<div class="desc"><p>Returns the radius of a Sphere object that fully encloses this geometry.
The sphere is centered at the center of this geometry.</p>
<p>If this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.
If these dims are not present on the result, all parts are assumed to have the same bounds.</p></div>
</dd>
<dt id="phi.geom.Box.box"><code class="name flex">
<span>def <span class="ident">box</span></span>(<span>self) ‑> phi.geom._box.Box</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def corner_representation(self) -&gt; &#39;Box&#39;:
    assert self.is_axis_aligned.all, f&#34;corner_representation does not support rotations&#34;
    return self</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Box.center_representation"><code class="name flex">
<span>def <span class="ident">center_representation</span></span>(<span>self) ‑> <function <a title="phi.geom.Cuboid" href="#phi.geom.Cuboid">Cuboid()</a> at 0x7f8596084ea0></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def center_representation(self) -&gt; &#39;Cuboid&#39;:
    return self</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Box.contains"><code class="name flex">
<span>def <span class="ident">contains</span></span>(<span>self, other: <a title="phi.geom.Box" href="#phi.geom.Box">Box</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def contains(self, other: &#39;Box&#39;):
    &#34;&#34;&#34; Tests if the other box lies fully inside this box. &#34;&#34;&#34;
    assert not self.is_open.any and not other.is_open.any, f&#34;contains not supported for open boxes&#34;
    assert self.is_axis_aligned.all and other.rot is None, f&#34;contains() is only supported for axis-aligned boxes (rot=None).&#34;
    return np.all(other.lower &gt;= self.lower) and np.all(other.upper &lt;= self.upper)</code></pre>
</details>
<div class="desc"><p>Tests if the other box lies fully inside this box.</p></div>
</dd>
<dt id="phi.geom.Box.corner_representation"><code class="name flex">
<span>def <span class="ident">corner_representation</span></span>(<span>self) ‑> phi.geom._box.Box</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def corner_representation(self) -&gt; &#39;Box&#39;:
    assert self.is_axis_aligned.all, f&#34;corner_representation does not support rotations&#34;
    return self</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Box.cuboid"><code class="name flex">
<span>def <span class="ident">cuboid</span></span>(<span>self) ‑> <function <a title="phi.geom.Cuboid" href="#phi.geom.Cuboid">Cuboid()</a> at 0x7f8596084ea0></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def center_representation(self) -&gt; &#39;Cuboid&#39;:
    return self</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Box.global_to_local"><code class="name flex">
<span>def <span class="ident">global_to_local</span></span>(<span>self, global_position: phiml.math._tensors.Tensor, scale=True, origin='lower') ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def global_to_local(self, global_position: Tensor, scale=True, origin=&#39;lower&#39;) -&gt; Tensor:
    &#34;&#34;&#34;
    Transform world-space coordinates into box-space coordinates.

    Args:
        global_position: World-space coordinates.
        scale: Whether to re-scale the output so that [0, 1] or [-1, 1] represent the box for `origin=&#39;lower&#39;` or `origin=&#39;center&#39;`, respectively.
        origin: &#39;lower&#39; or &#39;center&#39;

    Returns:
        Box-space coordinate `Tensor`
    &#34;&#34;&#34;
    assert origin in [&#39;lower&#39;, &#39;center&#39;, &#39;upper&#39;]
    origin_loc = getattr(self, origin)
    pos = global_position if math.always_close(origin_loc, 0) else global_position - origin_loc
    pos = rotate(pos, self.rot, invert=True)
    if scale:
        pos /= (self.half_size if origin == &#39;center&#39; else self.size)
    return pos</code></pre>
</details>
<div class="desc"><p>Transform world-space coordinates into box-space coordinates.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>global_position</code></strong></dt>
<dd>World-space coordinates.</dd>
<dt><strong><code>scale</code></strong></dt>
<dd>Whether to re-scale the output so that [0, 1] or [-1, 1] represent the box for <code>origin='lower'</code> or <code>origin='center'</code>, respectively.</dd>
<dt><strong><code>origin</code></strong></dt>
<dd>'lower' or 'center'</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Box-space coordinate <code>Tensor</code></p></div>
</dd>
<dt id="phi.geom.Box.largest"><code class="name flex">
<span>def <span class="ident">largest</span></span>(<span>self, dim: str | Sequence | set | phiml.math._shape.Shape | Callable | None) ‑> phi.geom._box.Box</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def largest(self, dim: DimFilter) -&gt; &#39;Box&#39;:
    assert self.is_axis_aligned.all, f&#34;Box.largest() is only supported for axis-aligned boxes (rot=None)&#34;
    dim = self.shape.without(&#39;vector&#39;).only(dim)
    if not dim:
        return self
    return box_from_limits(math.min(self.lower, dim), math.max(self.upper, dim))</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Box.lies_inside"><code class="name flex">
<span>def <span class="ident">lies_inside</span></span>(<span>self, location: phiml.math._tensors.Tensor) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lies_inside(self, location: Tensor) -&gt; Tensor:
    location = self.global_to_local(location, scale=False, origin=&#39;center&#39;)  # scale can only be performed for finite sizes
    if not self.is_open.any:
        bool_inside = abs(location) &lt;= self.half_size
    else:
        above_lower = (location &gt; self.lower) | self.is_open.side.dual[&#39;lower&#39;]
        below_upper = (location &lt; self.upper) | self.is_open.side.dual[&#39;upper&#39;]
        bool_inside = above_lower &amp; below_upper
    bool_inside = math.all(bool_inside, &#39;vector&#39;)
    bool_inside = math.any(bool_inside, self.shape.instance - instance(location))  # union for instance dimensions
    return bool_inside</code></pre>
</details>
<div class="desc"><p>Tests whether the given location lies inside or outside of the geometry. Locations on the surface count as inside.</p>
<p>When dealing with unions or collections of geometries (instance dimensions), a point lies inside the geometry if it lies inside any instance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd>float tensor of shape (batch_size, &hellip;, rank)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>bool tensor of shape (*location.shape[:-1], 1).</p></div>
</dd>
<dt id="phi.geom.Box.local_to_global"><code class="name flex">
<span>def <span class="ident">local_to_global</span></span>(<span>self, local_position, scale=True, origin='lower')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def local_to_global(self, local_position, scale=True, origin=&#39;lower&#39;):
    assert origin in [&#39;lower&#39;, &#39;center&#39;, &#39;upper&#39;]
    origin_loc = getattr(self, origin)
    pos = local_position * (self.half_size if origin == &#39;center&#39; else self.size) if scale else local_position
    return rotate(pos, self.rot) + origin_loc</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Box.project"><code class="name flex">
<span>def <span class="ident">project</span></span>(<span>self, *dimensions: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def project(self, *dimensions: str):
    &#34;&#34;&#34; Project this box into a lower-dimensional space. &#34;&#34;&#34;
    warnings.warn(&#34;Box.project(dims) is deprecated. Use Box.vector[dims] instead&#34;, DeprecationWarning, stacklevel=2)
    return self.vector[dimensions]</code></pre>
</details>
<div class="desc"><p>Project this box into a lower-dimensional space.</p></div>
</dd>
<dt id="phi.geom.Box.push"><code class="name flex">
<span>def <span class="ident">push</span></span>(<span>self,<br>positions: phiml.math._tensors.Tensor,<br>outward: bool = True,<br>shift_amount: float = 0) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def push(self, positions: Tensor, outward: bool = True, shift_amount: float = 0) -&gt; Tensor:
    loc_to_center = self.global_to_local(positions, scale=False, origin=&#39;center&#39;)
    sgn_dist_from_surface = math.abs(loc_to_center) - self.half_size
    rotation_matrix = self.rotation_matrix
    if outward:
        # --- get negative distances (particles are inside) towards the nearest boundary and add shift_amount ---
        distances_of_interest = (sgn_dist_from_surface == math.max(sgn_dist_from_surface, &#39;vector&#39;)) &amp; (sgn_dist_from_surface &lt; 0)
        shift = distances_of_interest * (sgn_dist_from_surface - shift_amount)
        # ToDo reduce instance dim
    else:  # inward
        shift = (sgn_dist_from_surface + shift_amount) * (sgn_dist_from_surface &gt; 0)  # get positive distances (particles are outside) and add shift_amount
        if instance(self):
            shift, loc_to_center, rotation_matrix = math.at_min((shift, loc_to_center, rotation_matrix), key=vec_length(shift), dim=instance)
        shift = math.where(abs(shift) &gt; abs(loc_to_center), abs(loc_to_center), shift)  # ensure inward shift ends at center
    shift = rotate(shift, rotation_matrix)
    return positions + math.where(loc_to_center &lt; 0, 1, -1) * shift</code></pre>
</details>
<div class="desc"><p>Shifts positions either into or out of geometry.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>positions</code></strong></dt>
<dd>Tensor holding positions to shift</dd>
<dt><strong><code>outward</code></strong></dt>
<dd>Flag for indicating inward (False) or outward (True) shift</dd>
<dt><strong><code>shift_amount</code></strong></dt>
<dd>Minimum distance between positions and surface after shifting.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Tensor holding shifted positions.</p></div>
</dd>
<dt id="phi.geom.Box.rotated"><code class="name flex">
<span>def <span class="ident">rotated</span></span>(<span>self, angle) ‑> phi.geom._box.Box</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotated(self, angle) -&gt; &#39;Box&#39;:
    rot = wrap(angle) if self.is_axis_aligned.all else self.rotation_matrix @ rotation_matrix(angle)
    return replace(self, rot=rot)</code></pre>
</details>
<div class="desc"><p>Returns a rotated version of this geometry.
The geometry is rotated about its center point.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>angle</code></strong></dt>
<dd>
<p>Delta rotation.
Either</p>
<ul>
<li>Angle(s): scalar angle in 2d or euler angles along <code>vector</code> in 3D or higher.</li>
<li>Matrix: d⨯d rotation matrix</li>
</ul>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Rotated <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></p></div>
</dd>
<dt id="phi.geom.Box.sample_uniform"><code class="name flex">
<span>def <span class="ident">sample_uniform</span></span>(<span>self, *shape: phiml.math._shape.Shape) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_uniform(self, *shape: Shape) -&gt; Tensor:
    assert not self.is_open.any, f&#34;sample_uniform not supported for open boxes&#34;
    uniform = math.random_uniform(self.shape.non_singleton.without(&#39;vector&#39;), *shape, self.shape[&#39;vector&#39;])
    return self.lower + uniform * self.size</code></pre>
</details>
<div class="desc"><p>Samples uniformly distributed random points inside this volume.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*shape</code></strong></dt>
<dd>How many points to sample per individual geometry.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>Tensor</code> containing all dimensions from <code><a title="phi.geom.Geometry.shape" href="#phi.geom.Geometry.shape">Geometry.shape</a></code>, <code>shape</code> as well as a <code>channel</code> dimension <code>vector</code> matching the dimensionality of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.</p></div>
</dd>
<dt id="phi.geom.Box.sample_uniform_surface"><code class="name flex">
<span>def <span class="ident">sample_uniform_surface</span></span>(<span>self, *shape: phiml.math._shape.Shape) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_uniform_surface(self, *shape: Shape) -&gt; Tensor:
    assert not instance(self), &#34;sample_uniform_surface not yet supported for unions of boxes&#34;
    samples = math.random_uniform(self.shape.non_singleton.non_instance, *shape, low=self.lower, high=self.upper)
    which = math.random_uniform(samples.shape.without(&#39;vector&#39;))
    lo_or_up = math.where(which &gt; .5, self.upper, self.lower)
    which = which * 2 % 1
    # --- which axis ---
    areas = self.face_areas
    total_area = math.sum(areas)
    frac_area = math.sum(areas / total_area, &#39;~side&#39;)
    cum_area = math.cumulative_sum(frac_area, &#39;~vector&#39;)
    axis = math.min(math.where(which &lt;= cum_area, math.range(self.shape[&#39;vector&#39;].as_dual()), self.spatial_rank), &#39;~vector&#39;)
    axis_one_hot = math.scatter(math.zeros(samples.shape, dtype=bool), expand(axis, channel(index=&#39;vector&#39;)), True, treat_as_batch=samples.shape.without(&#39;vector&#39;))
    math.assert_close(1, math.sum(axis_one_hot, &#39;vector&#39;))
    samples = math.where(axis_one_hot, lo_or_up, samples)
    return samples</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Box.scaled"><code class="name flex">
<span>def <span class="ident">scaled</span></span>(<span>self, factor: phiml.math._tensors.Tensor | float) ‑> phi.geom._box.Box</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scaled(self, factor: Union[float, Tensor]) -&gt; &#39;Box&#39;:
    return replace(self, size=self.size * factor)</code></pre>
</details>
<div class="desc"><p>Scales each individual geometry by <code>factor</code>.
The individual <code>center</code> points act as pivots for the operation.</p>
<h2 id="args">Args</h2>
<p>factor:
Returns:</p></div>
</dd>
<dt id="phi.geom.Box.smallest"><code class="name flex">
<span>def <span class="ident">smallest</span></span>(<span>self, dim: str | Sequence | set | phiml.math._shape.Shape | Callable | None) ‑> phi.geom._box.Box</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def smallest(self, dim: DimFilter) -&gt; &#39;Box&#39;:
    assert self.is_axis_aligned.all, f&#34;Box.smallest() is only supported for axis-aligned boxes (rot=None)&#34;
    dim = self.shape.without(&#39;vector&#39;).only(dim)
    if not dim:
        return self
    return box_from_limits(math.max(self.lower, dim), math.min(self.upper, dim))</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Box.without"><code class="name flex">
<span>def <span class="ident">without</span></span>(<span>self, dims: Tuple[str, ...])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def without(self, dims: Tuple[str, ...]):
    assert self.is_axis_aligned.all, f&#34;Box.without() is only supported for axis-aligned boxes (rot=None)&#34;
    remaining = list(self.shape.get_item_names(&#39;vector&#39;))
    for dim in dims:
        if dim in remaining:
            remaining.remove(dim)
    return self.vector[remaining]</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="phi.geom.Cylinder"><code class="flex name class">
<span>class <span class="ident">Cylinder</span></span>
<span>(</span><span>_center: phiml.math._tensors.Tensor,<br>radius: phiml.math._tensors.Tensor,<br>depth: phiml.math._tensors.Tensor,<br>rotation: phiml.math._tensors.Tensor,<br>axis: str,<br>variable_attrs: Tuple[str, ...] = ('_center', 'radius', 'depth', 'rotation'),<br>value_attrs: Tuple[str, ...] = ())</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@sliceable(keepdims=&#39;vector&#39;)
@dataclass(frozen=True)
class Cylinder(Geometry):
    &#34;&#34;&#34;
    N-dimensional cylinder.
    Defined by center position, radius, depth, alignment axis, rotation.

    For cylinders whose bottom and top lie outside the domain or are otherwise not needed, you may use `infinite_cylinder` instead, which simplifies computations.
    &#34;&#34;&#34;

    _center: Tensor
    radius: Tensor
    depth: Tensor
    rotation: Tensor  # rotation matrix
    axis: str

    variable_attrs: Tuple[str, ...] = (&#39;_center&#39;, &#39;radius&#39;, &#39;depth&#39;, &#39;rotation&#39;)
    value_attrs: Tuple[str, ...] = ()

    @property
    def center(self) -&gt; Tensor:
        return self._center

    @cached_property
    def shape(self) -&gt; Shape:
        return self._center.shape &amp; self.radius.shape &amp; self.depth.shape &amp; batch(self.rotation)

    @cached_property
    def radial_axes(self) -&gt; Sequence[str]:
        return [d for d in self.shape.get_item_names(&#39;vector&#39;) if d != self.axis]

    @cached_property
    def volume(self) -&gt; math.Tensor:
        return Sphere.volume_from_radius(self.radius, self.spatial_rank - 1) * self.depth

    @cached_property
    def up(self):
        return rotate(vec(**{d: 1 if d == self.axis else 0 for d in self.shape.get_item_names(&#39;vector&#39;)}), self._rot_or_none)

    @cached_property
    def rotation_matrix(self):
        return rotation_matrix(self.rotation, self.shape[&#39;vector&#39;], none_to_unit=True)

    @property
    def _rot_or_none(self):
        return None if self.rotation is None else self.rotation_matrix

    def with_radius(self, radius: Tensor) -&gt; &#39;Cylinder&#39;:
        return replace(self, radius=wrap(radius))

    def with_depth(self, depth: Tensor) -&gt; &#39;Cylinder&#39;:
        return replace(self, depth=wrap(depth))

    def lies_inside(self, location):
        pos = rotate(location - self._center, self._rot_or_none, invert=True)
        r = pos.vector[self.radial_axes]
        h = pos.vector[self.axis]
        inside = (vec_squared(r) &lt;= self.radius**2) &amp; (h &gt;= -.5*self.depth) &amp; (h &lt;= .5*self.depth)
        return math.any(inside, instance(self))  # union for instance dimensions

    def approximate_signed_distance(self, location: Union[Tensor, tuple]):
        location = rotate(location - self._center, self._rot_or_none, invert=True)
        r = location.vector[self.radial_axes]
        h = location.vector[self.axis]
        top_h = .5*self.depth
        # bot_h = -.5*self.depth
        # --- Compute distances ---
        radial_outward = normalize(r, &#39;vector&#39;, epsilon=1e-5)
        surf_r = radial_outward * self.radius
        radial_dist2 = vec_squared(r)
        inside_cyl = radial_dist2 &lt;= self.radius**2
        clamped_r = where(inside_cyl, r, surf_r)
        # --- Closest point on bottom / top ---
        sgn_dist_side = abs(h) - top_h
        # --- Closest point on cylinder ---
        sgn_dist_cyl = length(r, &#39;vector&#39;) - self.radius
        # inside (all &lt;= 0) -&gt; largest SDF, outside (any &gt; 0) -&gt; largest positive SDF
        sgn_dist = maximum(sgn_dist_cyl, sgn_dist_side)
        return math.min(sgn_dist, instance(self))

    def approximate_closest_surface(self, location: Tensor):
        location = rotate(location - self._center, self._rot_or_none, invert=True)
        r = location.vector[self.radial_axes]
        h = location.vector[self.axis]
        top_h = .5*self.depth
        bot_h = -.5*self.depth
        # --- Compute distances ---
        radial_outward = normalize(r, &#39;vector&#39;, epsilon=1e-5)
        surf_r = radial_outward * self.radius
        radial_dist2 = vec_squared(r)
        inside_cyl = radial_dist2 &lt;= self.radius**2
        clamped_r = where(inside_cyl, r, surf_r)
        # --- Closest point on bottom / top ---
        above = h &gt;= 0
        flat_h = where(above, top_h, bot_h)
        on_flat = ncat([flat_h, clamped_r], self._center.shape[&#39;vector&#39;])
        normal_flat = where(above, self.up, -self.up)
        # --- Closest point on cylinder ---
        clamped_h = clip(h, bot_h, top_h)
        on_cyl = ncat([surf_r, clamped_h], self._center.shape[&#39;vector&#39;])
        normal_cyl = ncat([radial_outward, 0], self._center.shape[&#39;vector&#39;], expand_values=True)
        # --- Choose closest ---
        d_flat = length(on_flat - location, &#39;vector&#39;)
        d_cyl = length(on_cyl - location, &#39;vector&#39;)
        flat_closer = d_flat &lt;= d_cyl
        surf_point = where(flat_closer, on_flat, on_cyl)
        inside = inside_cyl &amp; (h &gt;= bot_h) &amp; (h &lt;= top_h)
        sgn_dist = minimum(d_flat, d_cyl) * where(inside, -1, 1)
        delta = surf_point - location
        normal = where(flat_closer, normal_flat, normal_cyl)
        delta = rotate(delta, self._rot_or_none)
        normal = rotate(normal, self._rot_or_none)
        idx = None
        if instance(self):
            sgn_dist, delta, normal, idx = math.min((sgn_dist, delta, normal, range), instance(self), key=sgn_dist)
        return sgn_dist, delta, normal, None, idx

    def sample_uniform(self, *shape: math.Shape):
        r = Sphere(self._center[self.radial_axes], self.radius).sample_uniform(*shape)
        h = math.random_uniform(*shape, -.5*self.depth, .5*self.depth)
        rh = ncat([r, h], self._center.shape[&#39;vector&#39;])
        return rotate(rh, self._rot_or_none)

    def bounding_radius(self):
        return length(vec(rad=self.radius, dep=.5*self.depth), &#39;vector&#39;)

    def bounding_half_extent(self, epsilon=1e-5):
        if self.rotation is not None:
            tip = abs(self.up) * .5 * self.depth
            return tip + self.radius * sqrt(maximum(epsilon, 1 - self.up**2))
        return ncat([.5*self.depth, expand(self.radius, channel(vector=self.radial_axes))], self._center.shape[&#39;vector&#39;], expand_values=True)

    def at(self, center: Tensor) -&gt; &#39;Geometry&#39;:
        return replace(self, _center=center)

    def rotated(self, angle):
        rot = self.rotation_matrix @ rotation_matrix(angle) if self.rotation is not None else rotation_matrix(angle)
        return replace(self, rotation=rot)

    def scaled(self, factor: Union[float, Tensor]) -&gt; &#39;Geometry&#39;:
        return replace(self, radius=self.radius * factor, depth=self.depth * factor)

    @property
    def faces(self) -&gt; &#39;Geometry&#39;:
        raise NotImplementedError(f&#34;Cylinder.faces not implemented.&#34;)

    @property
    def face_centers(self) -&gt; Tensor:
        fac = wrap([-.5, .5, 0], dual(shell=&#39;bottom,top,lateral&#39;))
        return self.center + fac * self.depth * self.up

    @property
    def face_areas(self) -&gt; Tensor:
        flat = Sphere.volume_from_radius(self.radius, self.spatial_rank - 1)
        lateral = 2*PI*self.radius * self.depth
        return stack({&#39;bottom&#39;: flat, &#39;top&#39;: flat, &#39;lateral&#39;: lateral}, dual(&#39;shell&#39;), expand_values=True)

    @property
    def face_normals(self) -&gt; Tensor:
        raise NotImplementedError

    @property
    def boundary_elements(self) -&gt; Dict[str, Tuple[Dict[str, slice], Dict[str, slice]]]:
        return {}

    @property
    def boundary_faces(self) -&gt; Dict[str, Tuple[Dict[str, slice], Dict[str, slice]]]:
        return {}

    @property
    def face_shape(self) -&gt; Shape:
        return self.shape.without(&#39;vector&#39;) &amp; dual(shell=&#39;bottom,top,lateral&#39;)

    @property
    def corners(self) -&gt; Tensor:
        return math.zeros(self.shape &amp; dual(corners=0))

    def __eq__(self, other):
        return Geometry.__eq__(self, other)

    def vertex_rings(self, count: Shape) -&gt; Tensor:
        if self.spatial_rank == 3:
            angle = linspace(0, 2*PI, count)
            h = stack({&#39;bot&#39;: -.5 * self.depth, &#39;top&#39;: .5 * self.depth}, &#39;~face&#39;)
            s = sin(angle) * self.radius
            c = cos(angle) * self.radius
            r = stack([s, c], channel(vector=self.radial_axes))
            x = ncat([h, r], self._center.shape[&#39;vector&#39;], expand_values=True)
            return rotate(x, self._rot_or_none) + self._center
        raise NotImplementedError</code></pre>
</details>
<div class="desc"><p>N-dimensional cylinder.
Defined by center position, radius, depth, alignment axis, rotation.</p>
<p>For cylinders whose bottom and top lie outside the domain or are otherwise not needed, you may use <code><a title="phi.geom.infinite_cylinder" href="#phi.geom.infinite_cylinder">infinite_cylinder()</a></code> instead, which simplifies computations.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.geom._geom.Geometry</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="phi.geom.Cylinder.Tc"><code class="name">prop <span class="ident">Tc</span></code></dt>
<dd>
<div class="desc"><p>partial(func, <em>args, </em>*keywords) - new function with partial application
of the given arguments and keywords.</p></div>
</dd>
<dt id="phi.geom.Cylinder.Ti"><code class="name">prop <span class="ident">Ti</span></code></dt>
<dd>
<div class="desc"><p>partial(func, <em>args, </em>*keywords) - new function with partial application
of the given arguments and keywords.</p></div>
</dd>
<dt id="phi.geom.Cylinder.Ts"><code class="name">prop <span class="ident">Ts</span></code></dt>
<dd>
<div class="desc"><p>partial(func, <em>args, </em>*keywords) - new function with partial application
of the given arguments and keywords.</p></div>
</dd>
<dt id="phi.geom.Cylinder.axis"><code class="name">var <span class="ident">axis</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Cylinder.boundary_elements"><code class="name">prop <span class="ident">boundary_elements</span> : Dict[str, Tuple[Dict[str, slice], Dict[str, slice]]]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def boundary_elements(self) -&gt; Dict[str, Tuple[Dict[str, slice], Dict[str, slice]]]:
    return {}</code></pre>
</details>
<div class="desc"><p>Slices on the primal dimensions to mark boundary elements.
Grids and meshes have no boundary elements and return <code>{}</code>.
Dynamic graphs can define boundary elements for obstacles and walls.</p>
<h2 id="returns">Returns</h2>
<p>Map from <code>name</code> to slicing <code>dict</code>.</p></div>
</dd>
<dt id="phi.geom.Cylinder.boundary_faces"><code class="name">prop <span class="ident">boundary_faces</span> : Dict[str, Tuple[Dict[str, slice], Dict[str, slice]]]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def boundary_faces(self) -&gt; Dict[str, Tuple[Dict[str, slice], Dict[str, slice]]]:
    return {}</code></pre>
</details>
<div class="desc"><p>Slices on the dual dimensions to mark boundary faces.</p>
<p>Regular grids use the keys (dim, is_upper) to identify boundaries.
Unstructured meshes use string identifiers for the boundaries.
Dynamic graphs return slices along the dual dimensions.</p>
<h2 id="returns">Returns</h2>
<p>Map from <code>name</code> to slicing <code>dict</code>.</p></div>
</dd>
<dt id="phi.geom.Cylinder.center"><code class="name">prop <span class="ident">center</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def center(self) -&gt; Tensor:
    return self._center</code></pre>
</details>
<div class="desc"><p>Center location in single channel dimension.</p></div>
</dd>
<dt id="phi.geom.Cylinder.corners"><code class="name">prop <span class="ident">corners</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def corners(self) -&gt; Tensor:
    return math.zeros(self.shape &amp; dual(corners=0))</code></pre>
</details>
<div class="desc"><h2 id="returns">Returns</h2>
<p>Corner locations as <code>phiml.math.Tensor</code>.
Corners belonging to one object or cell are listed along dual dimensions.
If the object has no corners, a size-0 tensor with the correct vector and instance dims is returned.</p></div>
</dd>
<dt id="phi.geom.Cylinder.depth"><code class="name">var <span class="ident">depth</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Cylinder.face_areas"><code class="name">prop <span class="ident">face_areas</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_areas(self) -&gt; Tensor:
    flat = Sphere.volume_from_radius(self.radius, self.spatial_rank - 1)
    lateral = 2*PI*self.radius * self.depth
    return stack({&#39;bottom&#39;: flat, &#39;top&#39;: flat, &#39;lateral&#39;: lateral}, dual(&#39;shell&#39;), expand_values=True)</code></pre>
</details>
<div class="desc"><p>Area of face connecting a pair of cells. Shape <code>(elements, ~)</code>.
Returns 0 for unconnected cells.</p></div>
</dd>
<dt id="phi.geom.Cylinder.face_centers"><code class="name">prop <span class="ident">face_centers</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_centers(self) -&gt; Tensor:
    fac = wrap([-.5, .5, 0], dual(shell=&#39;bottom,top,lateral&#39;))
    return self.center + fac * self.depth * self.up</code></pre>
</details>
<div class="desc"><p>Center of face connecting a pair of cells. Shape <code>(elements, ~, vector)</code>.
Here, <code>~</code> represents arbitrary internal dual dimensions, such as <code>~staggered_direction</code> or <code>~elements</code>.
Returns 0-vectors for unconnected cells.</p></div>
</dd>
<dt id="phi.geom.Cylinder.face_normals"><code class="name">prop <span class="ident">face_normals</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_normals(self) -&gt; Tensor:
    raise NotImplementedError</code></pre>
</details>
<div class="desc"><p>Normal vectors of cell faces, including boundary faces. Shape <code>(elements, ~, vector)</code>.
For meshes, The vectors point out of the primal cells and into the dual cells.</p>
<p>Instance/spatial dimensions along which the normal does not vary may not be included in the result tensor's shape.</p></div>
</dd>
<dt id="phi.geom.Cylinder.face_shape"><code class="name">prop <span class="ident">face_shape</span> : phiml.math._shape.Shape</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_shape(self) -&gt; Shape:
    return self.shape.without(&#39;vector&#39;) &amp; dual(shell=&#39;bottom,top,lateral&#39;)</code></pre>
</details>
<div class="desc"><h2 id="returns">Returns</h2>
<p>Full Shape to identify each face of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>, including instance/spatial dimensions for the elements and dual dimensions listing the faces per element.
If this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> has no faces, returns an empty <code>Shape</code>.</p></div>
</dd>
<dt id="phi.geom.Cylinder.faces"><code class="name">prop <span class="ident">faces</span> : <a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def faces(self) -&gt; &#39;Geometry&#39;:
    raise NotImplementedError(f&#34;Cylinder.faces not implemented.&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Cylinder.radial_axes"><code class="name">var <span class="ident">radial_axes</span> : Sequence[str]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def radial_axes(self) -&gt; Sequence[str]:
    return [d for d in self.shape.get_item_names(&#39;vector&#39;) if d != self.axis]</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Cylinder.radius"><code class="name">var <span class="ident">radius</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Cylinder.rotation"><code class="name">var <span class="ident">rotation</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Cylinder.rotation_matrix"><code class="name">var <span class="ident">rotation_matrix</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def rotation_matrix(self):
    return rotation_matrix(self.rotation, self.shape[&#39;vector&#39;], none_to_unit=True)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Cylinder.shape"><code class="name">var <span class="ident">shape</span> : phiml.math._shape.Shape</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def shape(self) -&gt; Shape:
    return self._center.shape &amp; self.radius.shape &amp; self.depth.shape &amp; batch(self.rotation)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Cylinder.up"><code class="name">var <span class="ident">up</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def up(self):
    return rotate(vec(**{d: 1 if d == self.axis else 0 for d in self.shape.get_item_names(&#39;vector&#39;)}), self._rot_or_none)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Cylinder.value_attrs"><code class="name">var <span class="ident">value_attrs</span> : Tuple[str, ...]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Cylinder.variable_attrs"><code class="name">var <span class="ident">variable_attrs</span> : Tuple[str, ...]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Cylinder.volume"><code class="name">var <span class="ident">volume</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def volume(self) -&gt; math.Tensor:
    return Sphere.volume_from_radius(self.radius, self.spatial_rank - 1) * self.depth</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phi.geom.Cylinder.approximate_closest_surface"><code class="name flex">
<span>def <span class="ident">approximate_closest_surface</span></span>(<span>self, location: phiml.math._tensors.Tensor)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def approximate_closest_surface(self, location: Tensor):
    location = rotate(location - self._center, self._rot_or_none, invert=True)
    r = location.vector[self.radial_axes]
    h = location.vector[self.axis]
    top_h = .5*self.depth
    bot_h = -.5*self.depth
    # --- Compute distances ---
    radial_outward = normalize(r, &#39;vector&#39;, epsilon=1e-5)
    surf_r = radial_outward * self.radius
    radial_dist2 = vec_squared(r)
    inside_cyl = radial_dist2 &lt;= self.radius**2
    clamped_r = where(inside_cyl, r, surf_r)
    # --- Closest point on bottom / top ---
    above = h &gt;= 0
    flat_h = where(above, top_h, bot_h)
    on_flat = ncat([flat_h, clamped_r], self._center.shape[&#39;vector&#39;])
    normal_flat = where(above, self.up, -self.up)
    # --- Closest point on cylinder ---
    clamped_h = clip(h, bot_h, top_h)
    on_cyl = ncat([surf_r, clamped_h], self._center.shape[&#39;vector&#39;])
    normal_cyl = ncat([radial_outward, 0], self._center.shape[&#39;vector&#39;], expand_values=True)
    # --- Choose closest ---
    d_flat = length(on_flat - location, &#39;vector&#39;)
    d_cyl = length(on_cyl - location, &#39;vector&#39;)
    flat_closer = d_flat &lt;= d_cyl
    surf_point = where(flat_closer, on_flat, on_cyl)
    inside = inside_cyl &amp; (h &gt;= bot_h) &amp; (h &lt;= top_h)
    sgn_dist = minimum(d_flat, d_cyl) * where(inside, -1, 1)
    delta = surf_point - location
    normal = where(flat_closer, normal_flat, normal_cyl)
    delta = rotate(delta, self._rot_or_none)
    normal = rotate(normal, self._rot_or_none)
    idx = None
    if instance(self):
        sgn_dist, delta, normal, idx = math.min((sgn_dist, delta, normal, range), instance(self), key=sgn_dist)
    return sgn_dist, delta, normal, None, idx</code></pre>
</details>
<div class="desc"><p>Find the closest surface face of this geometry given a point that can be outside or inside the geometry.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd><code>Tensor</code> with a single channel dimension called vector. Can have arbitrary other dimensions.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>signed_distance</code></dt>
<dd>Scalar signed distance from <code>location</code>
to the closest point on the surface.
Positive values indicate the point lies outside the geometry, negative values indicate the point lies inside the geometry.</dd>
<dt><code>delta</code></dt>
<dd>Vector-valued distance vector from <code>location</code> to the closest point on the surface.</dd>
<dt><code>normal</code></dt>
<dd>Closest surface normal vector.</dd>
<dt><code>offset</code></dt>
<dd>Min distance of a surface-tangential plane from 0 as a scalar.</dd>
<dt><code>face_index</code></dt>
<dd>(Optional) An index vector pointing at the closest face.</dd>
</dl></div>
</dd>
<dt id="phi.geom.Cylinder.approximate_signed_distance"><code class="name flex">
<span>def <span class="ident">approximate_signed_distance</span></span>(<span>self, location: phiml.math._tensors.Tensor | tuple)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def approximate_signed_distance(self, location: Union[Tensor, tuple]):
    location = rotate(location - self._center, self._rot_or_none, invert=True)
    r = location.vector[self.radial_axes]
    h = location.vector[self.axis]
    top_h = .5*self.depth
    # bot_h = -.5*self.depth
    # --- Compute distances ---
    radial_outward = normalize(r, &#39;vector&#39;, epsilon=1e-5)
    surf_r = radial_outward * self.radius
    radial_dist2 = vec_squared(r)
    inside_cyl = radial_dist2 &lt;= self.radius**2
    clamped_r = where(inside_cyl, r, surf_r)
    # --- Closest point on bottom / top ---
    sgn_dist_side = abs(h) - top_h
    # --- Closest point on cylinder ---
    sgn_dist_cyl = length(r, &#39;vector&#39;) - self.radius
    # inside (all &lt;= 0) -&gt; largest SDF, outside (any &gt; 0) -&gt; largest positive SDF
    sgn_dist = maximum(sgn_dist_cyl, sgn_dist_side)
    return math.min(sgn_dist, instance(self))</code></pre>
</details>
<div class="desc"><p>Computes the approximate distance from location to the surface of the geometry.
Locations outside return positive values, inside negative values and zero exactly at the boundary.</p>
<p>The exact distance metric used depends on the geometry.
The approximation holds close to the surface and the distance grows to infinity as the location is moved infinitely far from the geometry.
The distance metric is differentiable and its gradients are bounded at every point in space.</p>
<p>When dealing with unions or collections of geometries (instance dimensions), the shortest distance to any instance is returned.
This also holds for negative distances.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd><code>Tensor</code> with one channel dim <code>vector</code> matching the geometry's <code>vector</code> dim.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Float <code>Tensor</code></p></div>
</dd>
<dt id="phi.geom.Cylinder.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>self, center: phiml.math._tensors.Tensor) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def at(self, center: Tensor) -&gt; &#39;Geometry&#39;:
    return replace(self, _center=center)</code></pre>
</details>
<div class="desc"><p>Returns a copy of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> with the center at <code>center</code>.
This is equal to calling <code>self @ center</code>.</p>
<p>See Also:
<code><a title="phi.geom.Geometry.shifted" href="#phi.geom.Geometry.shifted">Geometry.shifted()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>center</code></strong></dt>
<dd>New center as <code>Tensor</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.</p></div>
</dd>
<dt id="phi.geom.Cylinder.bounding_half_extent"><code class="name flex">
<span>def <span class="ident">bounding_half_extent</span></span>(<span>self, epsilon=1e-05)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bounding_half_extent(self, epsilon=1e-5):
    if self.rotation is not None:
        tip = abs(self.up) * .5 * self.depth
        return tip + self.radius * sqrt(maximum(epsilon, 1 - self.up**2))
    return ncat([.5*self.depth, expand(self.radius, channel(vector=self.radial_axes))], self._center.shape[&#39;vector&#39;], expand_values=True)</code></pre>
</details>
<div class="desc"><p>The bounding half-extent sets a limit on the outer-most point for each coordinate axis.
Each component is non-negative.</p>
<p>Let the bounding half-extent have value <code>e</code> in dimension <code>d</code> (<code>extent[...,d] = e</code>).
Then, no point of the geometry lies further away from its center point than <code>e</code> along <code>d</code> (in both axis directions).</p>
<p>If this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.
If these dims are not present on the result, all parts are assumed to have the same bounds.</p></div>
</dd>
<dt id="phi.geom.Cylinder.bounding_radius"><code class="name flex">
<span>def <span class="ident">bounding_radius</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bounding_radius(self):
    return length(vec(rad=self.radius, dep=.5*self.depth), &#39;vector&#39;)</code></pre>
</details>
<div class="desc"><p>Returns the radius of a Sphere object that fully encloses this geometry.
The sphere is centered at the center of this geometry.</p>
<p>If this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.
If these dims are not present on the result, all parts are assumed to have the same bounds.</p></div>
</dd>
<dt id="phi.geom.Cylinder.lies_inside"><code class="name flex">
<span>def <span class="ident">lies_inside</span></span>(<span>self, location)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lies_inside(self, location):
    pos = rotate(location - self._center, self._rot_or_none, invert=True)
    r = pos.vector[self.radial_axes]
    h = pos.vector[self.axis]
    inside = (vec_squared(r) &lt;= self.radius**2) &amp; (h &gt;= -.5*self.depth) &amp; (h &lt;= .5*self.depth)
    return math.any(inside, instance(self))  # union for instance dimensions</code></pre>
</details>
<div class="desc"><p>Tests whether the given location lies inside or outside of the geometry. Locations on the surface count as inside.</p>
<p>When dealing with unions or collections of geometries (instance dimensions), a point lies inside the geometry if it lies inside any instance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd>float tensor of shape (batch_size, &hellip;, rank)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>bool tensor of shape (*location.shape[:-1], 1).</p></div>
</dd>
<dt id="phi.geom.Cylinder.rotated"><code class="name flex">
<span>def <span class="ident">rotated</span></span>(<span>self, angle)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotated(self, angle):
    rot = self.rotation_matrix @ rotation_matrix(angle) if self.rotation is not None else rotation_matrix(angle)
    return replace(self, rotation=rot)</code></pre>
</details>
<div class="desc"><p>Returns a rotated version of this geometry.
The geometry is rotated about its center point.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>angle</code></strong></dt>
<dd>
<p>Delta rotation.
Either</p>
<ul>
<li>Angle(s): scalar angle in 2d or euler angles along <code>vector</code> in 3D or higher.</li>
<li>Matrix: d⨯d rotation matrix</li>
</ul>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Rotated <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></p></div>
</dd>
<dt id="phi.geom.Cylinder.sample_uniform"><code class="name flex">
<span>def <span class="ident">sample_uniform</span></span>(<span>self, *shape: phiml.math._shape.Shape)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_uniform(self, *shape: math.Shape):
    r = Sphere(self._center[self.radial_axes], self.radius).sample_uniform(*shape)
    h = math.random_uniform(*shape, -.5*self.depth, .5*self.depth)
    rh = ncat([r, h], self._center.shape[&#39;vector&#39;])
    return rotate(rh, self._rot_or_none)</code></pre>
</details>
<div class="desc"><p>Samples uniformly distributed random points inside this volume.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*shape</code></strong></dt>
<dd>How many points to sample per individual geometry.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>Tensor</code> containing all dimensions from <code><a title="phi.geom.Geometry.shape" href="#phi.geom.Geometry.shape">Geometry.shape</a></code>, <code>shape</code> as well as a <code>channel</code> dimension <code>vector</code> matching the dimensionality of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.</p></div>
</dd>
<dt id="phi.geom.Cylinder.scaled"><code class="name flex">
<span>def <span class="ident">scaled</span></span>(<span>self, factor: phiml.math._tensors.Tensor | float) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scaled(self, factor: Union[float, Tensor]) -&gt; &#39;Geometry&#39;:
    return replace(self, radius=self.radius * factor, depth=self.depth * factor)</code></pre>
</details>
<div class="desc"><p>Scales each individual geometry by <code>factor</code>.
The individual <code>center</code> points act as pivots for the operation.</p>
<h2 id="args">Args</h2>
<p>factor:
Returns:</p></div>
</dd>
<dt id="phi.geom.Cylinder.vertex_rings"><code class="name flex">
<span>def <span class="ident">vertex_rings</span></span>(<span>self, count: phiml.math._shape.Shape) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vertex_rings(self, count: Shape) -&gt; Tensor:
    if self.spatial_rank == 3:
        angle = linspace(0, 2*PI, count)
        h = stack({&#39;bot&#39;: -.5 * self.depth, &#39;top&#39;: .5 * self.depth}, &#39;~face&#39;)
        s = sin(angle) * self.radius
        c = cos(angle) * self.radius
        r = stack([s, c], channel(vector=self.radial_axes))
        x = ncat([h, r], self._center.shape[&#39;vector&#39;], expand_values=True)
        return rotate(x, self._rot_or_none) + self._center
    raise NotImplementedError</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Cylinder.with_depth"><code class="name flex">
<span>def <span class="ident">with_depth</span></span>(<span>self, depth: phiml.math._tensors.Tensor) ‑> phi.geom._cylinder.Cylinder</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_depth(self, depth: Tensor) -&gt; &#39;Cylinder&#39;:
    return replace(self, depth=wrap(depth))</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Cylinder.with_radius"><code class="name flex">
<span>def <span class="ident">with_radius</span></span>(<span>self, radius: phiml.math._tensors.Tensor) ‑> phi.geom._cylinder.Cylinder</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_radius(self, radius: Tensor) -&gt; &#39;Cylinder&#39;:
    return replace(self, radius=wrap(radius))</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="phi.geom.Geometry"><code class="flex name class">
<span>class <span class="ident">Geometry</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Geometry:
    &#34;&#34;&#34;
    Abstract base class for N-dimensional shapes.

    Main implementing classes:

    * `Sphere`
    * `Box`
    * `Cylinder`
    * `Graph`
    * `Mesh`
    * `Heightmap`
    * `SDFGrid`
    * `SDF`
    * `SplineSheet`

    All geometry objects support batching.
    Thereby any parameter defining the geometry can be varied along arbitrary batch dims.
    All batch dimensions are listed in Geometry.shape.

    Property getters (`@property`, such as `shape`), save for getters, must not depend on any variables marked as *variable* via `__variable_attrs__()` as these may be `None` during tracing.
    Equality checks must also take this into account.
    &#34;&#34;&#34;

    @property
    def center(self) -&gt; Tensor:
        &#34;&#34;&#34;
        Center location in single channel dimension.
        &#34;&#34;&#34;
        raise NotImplementedError(self.__class__)

    @property
    def shape(self) -&gt; Shape:
        &#34;&#34;&#34;
        The `shape` of a `Geometry` consists of the following dimensions:

        * A single *channel* dimension called `&#39;vector&#39;` specifying the physical space
        * Instance dimensions denote that this geometry consists of multiple copies in the same space
        * Spatial dimensions denote a crystal (repeating structure) of this geometric primitive in space
        * Batch dimensions indicate non-interacting versions of this geometry for parallelization only.
        &#34;&#34;&#34;
        raise NotImplementedError(self.__class__)

    @property
    def volume(self) -&gt; Tensor:
        &#34;&#34;&#34;
        `phi.math.Tensor` representing the volume of each element.
        The result retains batch, spatial and instance dimensions.
        &#34;&#34;&#34;
        raise NotImplementedError(self.__class__)

    @property
    def faces(self) -&gt; &#39;Geometry&#39;:
        raise NotImplementedError(self.__class__)

    @property
    def face_centers(self) -&gt; Tensor:
        &#34;&#34;&#34;
        Center of face connecting a pair of cells. Shape `(elements, ~, vector)`.
        Here, `~` represents arbitrary internal dual dimensions, such as `~staggered_direction` or `~elements`.
        Returns 0-vectors for unconnected cells.
        &#34;&#34;&#34;
        raise NotImplementedError(self.__class__)

    @property
    def face_areas(self) -&gt; Tensor:
        &#34;&#34;&#34;
        Area of face connecting a pair of cells. Shape `(elements, ~)`.
        Returns 0 for unconnected cells.
        &#34;&#34;&#34;
        raise NotImplementedError(self.__class__)

    @property
    def face_normals(self) -&gt; Tensor:
        &#34;&#34;&#34;
        Normal vectors of cell faces, including boundary faces. Shape `(elements, ~, vector)`.
        For meshes, The vectors point out of the primal cells and into the dual cells.

        Instance/spatial dimensions along which the normal does not vary may not be included in the result tensor&#39;s shape.
        &#34;&#34;&#34;
        raise NotImplementedError(self.__class__)

    @property
    def boundary_elements(self) -&gt; Dict[str, Dict[str, slice]]:
        &#34;&#34;&#34;
        Slices on the primal dimensions to mark boundary elements.
        Grids and meshes have no boundary elements and return `{}`.
        Dynamic graphs can define boundary elements for obstacles and walls.

        Returns:
            Map from `name` to slicing `dict`.
        &#34;&#34;&#34;
        raise NotImplementedError(self.__class__)

    @property
    def boundary_faces(self) -&gt; Dict[str, Dict[str, slice]]:
        &#34;&#34;&#34;
        Slices on the dual dimensions to mark boundary faces.

        Regular grids use the keys (dim, is_upper) to identify boundaries.
        Unstructured meshes use string identifiers for the boundaries.
        Dynamic graphs return slices along the dual dimensions.

        Returns:
            Map from `name` to slicing `dict`.
        &#34;&#34;&#34;
        raise NotImplementedError(self.__class__)

    @property
    def face_shape(self) -&gt; Shape:
        &#34;&#34;&#34;
        Returns:
            Full Shape to identify each face of this `Geometry`, including instance/spatial dimensions for the elements and dual dimensions listing the faces per element.
            If this `Geometry` has no faces, returns an empty `Shape`.
        &#34;&#34;&#34;
        return math.EMPTY_SHAPE

    @property
    def sets(self) -&gt; Dict[str, Shape]:
        if self.face_shape and self.face_shape != self.shape and self.face_shape.volume &gt; 0:
            return {&#39;center&#39;: non_batch(self)-&#39;vector&#39;, &#39;face&#39;: self.face_shape.non_batch}
        else:
            return {&#39;center&#39;: non_batch(self)-&#39;vector&#39;}

    def get_points(self, set_key: str) -&gt; Tensor:
        if set_key == &#39;center&#39;:
            return self.center
        elif set_key == &#39;face&#39;:
            return self.face_centers
        else:
            raise ValueError(f&#34;Unknown set: &#39;{set_key}&#39;&#34;)

    def get_boundary(self, set_key: str) -&gt; Dict[str, Dict[str, slice]]:
        if set_key == &#39;center&#39;:
            return self.boundary_elements
        elif set_key == &#39;face&#39;:
            return self.boundary_faces
        else:
            raise ValueError(f&#34;Unknown set: &#39;{set_key}&#39;&#34;)

    @property
    def corners(self) -&gt; Tensor:
        &#34;&#34;&#34;
        Returns:
            Corner locations as `phiml.math.Tensor`.
            Corners belonging to one object or cell are listed along dual dimensions.
            If the object has no corners, a size-0 tensor with the correct vector and instance dims is returned.
        &#34;&#34;&#34;
        raise NotImplementedError(self.__class__)

    def integrate_surface(self, face_values: Tensor, divide_volume=False) -&gt; Tensor:
        &#34;&#34;&#34;
        Multiplies `values´ by the corresponding face area, computes the sum over all faces and divides by the cell volume.
        ∑ values * A.

        Args:
            face_values: Values sampled at the face centers.
            divide_volume: Whether to divide by the cell `volume´

        Returns:
            `Tensor` of values sampled at the centroids.
        &#34;&#34;&#34;
        result = math.sum(face_values * self.face_areas, self.face_shape.dual)
        return result / self.volume if divide_volume else result

    def integrate_flux(self, flux: Tensor, divide_volume=False) -&gt; Tensor:
        assert &#39;vector&#39; in flux.shape, f&#34;flux must have a &#39;vector&#39; dimension but got {flux.shape}&#34;
        result = math.sum(flux.vector @ (self.face_normals * self.face_areas).vector, self.face_shape.dual)
        return result / self.volume if divide_volume else result

    # def resample_to_faces(self, values: Tensor, boundary: Extrapolation, **kwargs):
    #     raise NotImplementedError(self.__class__)
    #
    # def resample_to_centers(self, values: Tensor, boundary: Extrapolation, **kwargs):
    #     raise NotImplementedError(self.__class__)
    #
    # def centered_gradient_of(self, values: Tensor, boundary: Extrapolation, dims=None, **kwargs):
    #     raise NotImplementedError(self.__class__)
    #
    # def staggered_gradient_of(self, values: Tensor, boundary: Extrapolation, dims=None, **kwargs):
    #     raise NotImplementedError(self.__class__)
    #
    # def divergence_of(self, values: Tensor, boundary: Extrapolation, dims=None, **kwargs):
    #     raise NotImplementedError(self.__class__)
    #
    # def laplace_of(self, values: Tensor, boundary: Extrapolation, dims=None, **kwargs):
    #     raise NotImplementedError(self.__class__)
    #
    # def centered_curl_of(self, values: Tensor, boundary: Extrapolation, dims=None, **kwargs):
    #     raise NotImplementedError(self.__class__)
    #
    # def staggered_curl_of(self, values: Tensor, boundary: Extrapolation, dims=None, **kwargs):
    #     raise NotImplementedError(self.__class__)

    def unstack(self, dimension: str) -&gt; tuple:
        &#34;&#34;&#34;
        Unstacks this Geometry along the given dimension.
        The shapes of the returned geometries are reduced by `dimension`.

        Args:
            dimension: dimension along which to unstack

        Returns:
            geometries: tuple of length equal to `geometry.shape.get_size(dimension)`
        &#34;&#34;&#34;
        warnings.warn(f&#34;Geometry.unstack() is deprecated. Use math.unstack(geometry) instead.&#34;, DeprecationWarning)
        return math.unstack(self, dimension)

    @property
    def spatial_rank(self) -&gt; int:
        &#34;&#34;&#34; Number of spatial dimensions of the geometry, 1 = 1D, 2 = 2D, 3 = 3D, etc. &#34;&#34;&#34;
        return self.shape.get_size(&#39;vector&#39;)

    def lies_inside(self, location: Tensor) -&gt; Tensor:
        &#34;&#34;&#34;
        Tests whether the given location lies inside or outside of the geometry. Locations on the surface count as inside.

        When dealing with unions or collections of geometries (instance dimensions), a point lies inside the geometry if it lies inside any instance.

        Args:
          location: float tensor of shape (batch_size, ..., rank)

        Returns:
          bool tensor of shape (*location.shape[:-1], 1).

        &#34;&#34;&#34;
        raise NotImplementedError(self.__class__)

    def approximate_closest_surface(self, location: Tensor) -&gt; Tuple[Tensor, Tensor, Tensor, Tensor, Tensor]:
        &#34;&#34;&#34;
        Find the closest surface face of this geometry given a point that can be outside or inside the geometry.

        Args:
            location: `Tensor` with a single channel dimension called vector. Can have arbitrary other dimensions.

        Returns:
            signed_distance: Scalar signed distance from `location`  to the closest point on the surface.
                Positive values indicate the point lies outside the geometry, negative values indicate the point lies inside the geometry.
            delta: Vector-valued distance vector from `location` to the closest point on the surface.
            normal: Closest surface normal vector.
            offset: Min distance of a surface-tangential plane from 0 as a scalar.
            face_index: (Optional) An index vector pointing at the closest face.
        &#34;&#34;&#34;
        raise NotImplementedError(self.__class__)

    def approximate_signed_distance(self, location: Tensor) -&gt; Tensor:
        &#34;&#34;&#34;
        Computes the approximate distance from location to the surface of the geometry.
        Locations outside return positive values, inside negative values and zero exactly at the boundary.

        The exact distance metric used depends on the geometry.
        The approximation holds close to the surface and the distance grows to infinity as the location is moved infinitely far from the geometry.
        The distance metric is differentiable and its gradients are bounded at every point in space.

        When dealing with unions or collections of geometries (instance dimensions), the shortest distance to any instance is returned.
        This also holds for negative distances.

        Args:
            location: `Tensor` with one channel dim `vector` matching the geometry&#39;s `vector` dim.

        Returns:
            Float `Tensor`
        &#34;&#34;&#34;
        raise NotImplementedError(self.__class__)

    def approximate_fraction_inside(self, other_geometry: &#39;Geometry&#39;, balance: Union[Tensor, Number] = 0.5) -&gt; Tensor:
        &#34;&#34;&#34;
        Computes the approximate overlap between the geometry and a small other geometry.
        Returns 1.0 if `other_geometry` is fully enclosed in this geometry and 0.0 if there is no overlap.
        Close to the surface of this geometry, the fraction filled is differentiable w.r.t. the location and size of `other_geometry`.

        To call this method on batches of geometries of same shape, pass a batched Geometry instance.
        The result tensor will match the batch shape of `other_geometry`.

        The result may only be accurate in special cases.
        The given geometries may be approximated as spheres or boxes using `bounding_radius()` and `bounding_half_extent()`.

        The default implementation of this method approximates other_geometry as a Sphere and computes the fraction using `approximate_signed_distance()`.

        Args:
            other_geometry: `Geometry` or geometry batch for which to compute the overlap with `self`.
            balance: Mid-level between 0 and 1, default 0.5.
                This value is returned when exactly half of `other_geometry` lies inside `self`.
                `0.5 &lt; balance &lt;= 1` makes `self` seem larger while `0 &lt;= balance &lt; 0.5`makes `self` seem smaller.

        Returns:
          fraction of cell volume lying inside the geometry. float tensor of shape (other_geometry.batch_shape, 1).

        &#34;&#34;&#34;
        assert isinstance(other_geometry, Geometry)
        radius = other_geometry.bounding_radius()
        location = other_geometry.center
        distance = self.approximate_signed_distance(location)
        inside_fraction = balance - distance / radius
        inside_fraction = math.clip(inside_fraction, 0, 1)
        return inside_fraction

    def push(self, positions: Tensor, outward: bool = True, shift_amount: float = 0) -&gt; Tensor:
        &#34;&#34;&#34;
        Shifts positions either into or out of geometry.

        Args:
            positions: Tensor holding positions to shift
            outward: Flag for indicating inward (False) or outward (True) shift
            shift_amount: Minimum distance between positions and surface after shifting.

        Returns:
            Tensor holding shifted positions.
        &#34;&#34;&#34;
        from ._geom_ops import expel
        return expel(self, positions, min_separation=shift_amount, invert=not outward)

    def sample_uniform(self, *shape: math.Shape) -&gt; Tensor:
        &#34;&#34;&#34;
        Samples uniformly distributed random points inside this volume.

        Args:
            *shape: How many points to sample per individual geometry.

        Returns:
            `Tensor` containing all dimensions from `Geometry.shape`, `shape` as well as a `channel` dimension `vector` matching the dimensionality of this `Geometry`.
        &#34;&#34;&#34;
        raise NotImplementedError(self.__class__)

    def bounding_radius(self) -&gt; Tensor:
        &#34;&#34;&#34;
        Returns the radius of a Sphere object that fully encloses this geometry.
        The sphere is centered at the center of this geometry.

        If this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.
        If these dims are not present on the result, all parts are assumed to have the same bounds.
        &#34;&#34;&#34;
        raise NotImplementedError(self.__class__)

    def bounding_half_extent(self) -&gt; Tensor:
        &#34;&#34;&#34;
        The bounding half-extent sets a limit on the outer-most point for each coordinate axis.
        Each component is non-negative.

        Let the bounding half-extent have value `e` in dimension `d` (`extent[...,d] = e`).
        Then, no point of the geometry lies further away from its center point than `e` along `d` (in both axis directions).

        If this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.
        If these dims are not present on the result, all parts are assumed to have the same bounds.
        &#34;&#34;&#34;
        raise NotImplementedError(self.__class__)

    def bounding_box(self):
        &#34;&#34;&#34;
        Returns the approximately smallest axis-aligned box that contains this `Geometry`.
        The center of the box may not be equal to `self.center`.

        Returns:
            `Box` or `Cuboid` that fully contains this `Geometry`.
        &#34;&#34;&#34;
        center = self.center
        half = self.bounding_half_extent()
        min_vec = math.min(center - half, dim=center.shape.non_batch.non_channel)
        max_vec = math.max(center + half, dim=center.shape.non_batch.non_channel)
        from ._box import box_from_limits
        return box_from_limits(min_vec, max_vec)

    def bounding_sphere(self):
        from phi.geom._functions import vec_length
        from ._sphere import Sphere
        center = self.bounding_box().center
        dist = vec_length(self.center - center) + self.bounding_radius()
        max_dist = math.max(dist, dim=self.shape.non_batch - &#39;vector&#39;)
        return Sphere(center, max_dist)

    def shifted(self, delta: Tensor) -&gt; &#39;Geometry&#39;:
        &#34;&#34;&#34;
        Returns a translated version of this geometry.

        See Also:
            `Geometry.at()`.

        Args:
          delta: direction vector
          delta: Tensor:

        Returns:
          Geometry: shifted geometry

        &#34;&#34;&#34;
        return self.at(self.center + delta)

    def at(self, center: Tensor) -&gt; &#39;Geometry&#39;:
        &#34;&#34;&#34;
        Returns a copy of this `Geometry` with the center at `center`.
        This is equal to calling `self @ center`.

        See Also:
            `Geometry.shifted()`.

        Args:
            center: New center as `Tensor`.

        Returns:
            `Geometry`.
        &#34;&#34;&#34;
        raise NotImplementedError(self.__class__)

    def __matmul__(self, other):
        if isinstance(other, (Tensor, float, int)):
            return self.at(other)
        return NotImplemented

    def rotated(self, angle: Union[float, Tensor]) -&gt; &#39;Geometry&#39;:
        &#34;&#34;&#34;
        Returns a rotated version of this geometry.
        The geometry is rotated about its center point.

        Args:
            angle: Delta rotation.
                Either

                * Angle(s): scalar angle in 2d or euler angles along `vector` in 3D or higher.
                * Matrix: d⨯d rotation matrix

        Returns:
            Rotated `Geometry`
        &#34;&#34;&#34;
        raise NotImplementedError(self.__class__)

    def scaled(self, factor: Union[float, Tensor]) -&gt; &#39;Geometry&#39;:
        &#34;&#34;&#34;
        Scales each individual geometry by `factor`.
        The individual `center` points act as pivots for the operation.

        Args:
            factor:

        Returns:

        &#34;&#34;&#34;
        raise NotImplementedError(self.__class__)

    def __invert__(self):
        return InvertedGeometry(self)

    def __eq__(self, other):
        &#34;&#34;&#34;
        Slow equality check.
        Unlike `==`, this method compares all tensor elements to check whether they are equal.
        Use `==` for a faster check which only checks whether the referenced tensors are the same.

        See Also:
            `shallow_equals()`
        &#34;&#34;&#34;
        def tensor_equality(a, b):
            if a is None or b is None:
                return True  # stored mode, tensors unavailable
            return math.close(a, b, rel_tolerance=1e-5, equal_nan=True)
        differences = find_differences(self, other, attr_type=all_attributes, tensor_equality=tensor_equality)
        return not differences

    def shallow_equals(self, other):
        &#34;&#34;&#34;
        Quick equality check.
        May return `False` even if `other == self`.
        However, if `True` is returned, the geometries are guaranteed to be equal.

        The `shallow_equals()` check does not compare all tensor elements but merely checks whether the same tensors are referenced.
        &#34;&#34;&#34;
        differences = find_differences(self, other, compare_tensors_by_id=True, attr_type=all_attributes)
        return not differences

    @staticmethod
    def __stack__(values: tuple, dim: Shape, **kwargs) -&gt; &#39;Geometry&#39;:
        if all(type(v) == type(values[0]) for v in values):
            return NotImplemented  # let attributes be stacked
        else:
            from ._geom_ops import GeometryStack
            set_op = kwargs.get(&#39;set_op&#39;)
            return GeometryStack(math.layout(values, dim), set_op)

    def __flatten__(self, flat_dim: Shape, flatten_batch: bool, **kwargs) -&gt; &#39;Geometry&#39;:
        dims = self.shape.without(&#39;vector&#39;)
        if not flatten_batch:
            dims = dims.non_batch
        return math.pack_dims(self, dims, flat_dim, **kwargs)

    def __ne__(self, other):
        return not self == other

    def __hash__(self):
        return id(self.__class__) + hash(self.shape)

    def __repr__(self):
        return f&#34;{self.__class__.__name__}{self.shape}&#34;</code></pre>
</details>
<div class="desc"><p>Abstract base class for N-dimensional shapes.</p>
<p>Main implementing classes:</p>
<ul>
<li><code><a title="phi.geom.Sphere" href="#phi.geom.Sphere">Sphere</a></code></li>
<li><code><a title="phi.geom.Box" href="#phi.geom.Box">Box</a></code></li>
<li><code><a title="phi.geom.Cylinder" href="#phi.geom.Cylinder">Cylinder</a></code></li>
<li><code><a title="phi.geom.Graph" href="#phi.geom.Graph">Graph</a></code></li>
<li><code><a title="phi.geom.Mesh" href="#phi.geom.Mesh">Mesh</a></code></li>
<li><code><a title="phi.geom.Heightmap" href="#phi.geom.Heightmap">Heightmap</a></code></li>
<li><code><a title="phi.geom.SDFGrid" href="#phi.geom.SDFGrid">SDFGrid</a></code></li>
<li><code><a title="phi.geom.SDF" href="#phi.geom.SDF">SDF</a></code></li>
<li><code>SplineSheet</code></li>
</ul>
<p>All geometry objects support batching.
Thereby any parameter defining the geometry can be varied along arbitrary batch dims.
All batch dimensions are listed in Geometry.shape.</p>
<p>Property getters (<code>@property</code>, such as <code>shape</code>), save for getters, must not depend on any variables marked as <em>variable</em> via <code>__variable_attrs__()</code> as these may be <code>None</code> during tracing.
Equality checks must also take this into account.</p></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li>phi.geom._box.Box</li>
<li>phi.geom._cylinder.Cylinder</li>
<li>phi.geom._embed._EmbeddedGeometry</li>
<li>phi.geom._geom.InvertedGeometry</li>
<li>phi.geom._geom.NoGeometry</li>
<li>phi.geom._geom.Point</li>
<li>phi.geom._geom_ops.GeometryStack</li>
<li>phi.geom._graph.Graph</li>
<li>phi.geom._grid.UniformGrid</li>
<li>phi.geom._heightmap.Heightmap</li>
<li>phi.geom._mesh.Mesh</li>
<li>phi.geom._sdf.SDF</li>
<li>phi.geom._sdf_grid.SDFGrid</li>
<li>phi.geom._sphere.Sphere</li>
<li>phi.geom._spline_sheet.BSplineSheet</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="phi.geom.Geometry.boundary_elements"><code class="name">prop <span class="ident">boundary_elements</span> : Dict[str, Dict[str, slice]]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def boundary_elements(self) -&gt; Dict[str, Dict[str, slice]]:
    &#34;&#34;&#34;
    Slices on the primal dimensions to mark boundary elements.
    Grids and meshes have no boundary elements and return `{}`.
    Dynamic graphs can define boundary elements for obstacles and walls.

    Returns:
        Map from `name` to slicing `dict`.
    &#34;&#34;&#34;
    raise NotImplementedError(self.__class__)</code></pre>
</details>
<div class="desc"><p>Slices on the primal dimensions to mark boundary elements.
Grids and meshes have no boundary elements and return <code>{}</code>.
Dynamic graphs can define boundary elements for obstacles and walls.</p>
<h2 id="returns">Returns</h2>
<p>Map from <code>name</code> to slicing <code>dict</code>.</p></div>
</dd>
<dt id="phi.geom.Geometry.boundary_faces"><code class="name">prop <span class="ident">boundary_faces</span> : Dict[str, Dict[str, slice]]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def boundary_faces(self) -&gt; Dict[str, Dict[str, slice]]:
    &#34;&#34;&#34;
    Slices on the dual dimensions to mark boundary faces.

    Regular grids use the keys (dim, is_upper) to identify boundaries.
    Unstructured meshes use string identifiers for the boundaries.
    Dynamic graphs return slices along the dual dimensions.

    Returns:
        Map from `name` to slicing `dict`.
    &#34;&#34;&#34;
    raise NotImplementedError(self.__class__)</code></pre>
</details>
<div class="desc"><p>Slices on the dual dimensions to mark boundary faces.</p>
<p>Regular grids use the keys (dim, is_upper) to identify boundaries.
Unstructured meshes use string identifiers for the boundaries.
Dynamic graphs return slices along the dual dimensions.</p>
<h2 id="returns">Returns</h2>
<p>Map from <code>name</code> to slicing <code>dict</code>.</p></div>
</dd>
<dt id="phi.geom.Geometry.center"><code class="name">prop <span class="ident">center</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def center(self) -&gt; Tensor:
    &#34;&#34;&#34;
    Center location in single channel dimension.
    &#34;&#34;&#34;
    raise NotImplementedError(self.__class__)</code></pre>
</details>
<div class="desc"><p>Center location in single channel dimension.</p></div>
</dd>
<dt id="phi.geom.Geometry.corners"><code class="name">prop <span class="ident">corners</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def corners(self) -&gt; Tensor:
    &#34;&#34;&#34;
    Returns:
        Corner locations as `phiml.math.Tensor`.
        Corners belonging to one object or cell are listed along dual dimensions.
        If the object has no corners, a size-0 tensor with the correct vector and instance dims is returned.
    &#34;&#34;&#34;
    raise NotImplementedError(self.__class__)</code></pre>
</details>
<div class="desc"><h2 id="returns">Returns</h2>
<p>Corner locations as <code>phiml.math.Tensor</code>.
Corners belonging to one object or cell are listed along dual dimensions.
If the object has no corners, a size-0 tensor with the correct vector and instance dims is returned.</p></div>
</dd>
<dt id="phi.geom.Geometry.face_areas"><code class="name">prop <span class="ident">face_areas</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_areas(self) -&gt; Tensor:
    &#34;&#34;&#34;
    Area of face connecting a pair of cells. Shape `(elements, ~)`.
    Returns 0 for unconnected cells.
    &#34;&#34;&#34;
    raise NotImplementedError(self.__class__)</code></pre>
</details>
<div class="desc"><p>Area of face connecting a pair of cells. Shape <code>(elements, ~)</code>.
Returns 0 for unconnected cells.</p></div>
</dd>
<dt id="phi.geom.Geometry.face_centers"><code class="name">prop <span class="ident">face_centers</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_centers(self) -&gt; Tensor:
    &#34;&#34;&#34;
    Center of face connecting a pair of cells. Shape `(elements, ~, vector)`.
    Here, `~` represents arbitrary internal dual dimensions, such as `~staggered_direction` or `~elements`.
    Returns 0-vectors for unconnected cells.
    &#34;&#34;&#34;
    raise NotImplementedError(self.__class__)</code></pre>
</details>
<div class="desc"><p>Center of face connecting a pair of cells. Shape <code>(elements, ~, vector)</code>.
Here, <code>~</code> represents arbitrary internal dual dimensions, such as <code>~staggered_direction</code> or <code>~elements</code>.
Returns 0-vectors for unconnected cells.</p></div>
</dd>
<dt id="phi.geom.Geometry.face_normals"><code class="name">prop <span class="ident">face_normals</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_normals(self) -&gt; Tensor:
    &#34;&#34;&#34;
    Normal vectors of cell faces, including boundary faces. Shape `(elements, ~, vector)`.
    For meshes, The vectors point out of the primal cells and into the dual cells.

    Instance/spatial dimensions along which the normal does not vary may not be included in the result tensor&#39;s shape.
    &#34;&#34;&#34;
    raise NotImplementedError(self.__class__)</code></pre>
</details>
<div class="desc"><p>Normal vectors of cell faces, including boundary faces. Shape <code>(elements, ~, vector)</code>.
For meshes, The vectors point out of the primal cells and into the dual cells.</p>
<p>Instance/spatial dimensions along which the normal does not vary may not be included in the result tensor's shape.</p></div>
</dd>
<dt id="phi.geom.Geometry.face_shape"><code class="name">prop <span class="ident">face_shape</span> : phiml.math._shape.Shape</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_shape(self) -&gt; Shape:
    &#34;&#34;&#34;
    Returns:
        Full Shape to identify each face of this `Geometry`, including instance/spatial dimensions for the elements and dual dimensions listing the faces per element.
        If this `Geometry` has no faces, returns an empty `Shape`.
    &#34;&#34;&#34;
    return math.EMPTY_SHAPE</code></pre>
</details>
<div class="desc"><h2 id="returns">Returns</h2>
<p>Full Shape to identify each face of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>, including instance/spatial dimensions for the elements and dual dimensions listing the faces per element.
If this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> has no faces, returns an empty <code>Shape</code>.</p></div>
</dd>
<dt id="phi.geom.Geometry.faces"><code class="name">prop <span class="ident">faces</span> : <a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def faces(self) -&gt; &#39;Geometry&#39;:
    raise NotImplementedError(self.__class__)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Geometry.sets"><code class="name">prop <span class="ident">sets</span> : Dict[str, phiml.math._shape.Shape]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sets(self) -&gt; Dict[str, Shape]:
    if self.face_shape and self.face_shape != self.shape and self.face_shape.volume &gt; 0:
        return {&#39;center&#39;: non_batch(self)-&#39;vector&#39;, &#39;face&#39;: self.face_shape.non_batch}
    else:
        return {&#39;center&#39;: non_batch(self)-&#39;vector&#39;}</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Geometry.shape"><code class="name">prop <span class="ident">shape</span> : phiml.math._shape.Shape</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape(self) -&gt; Shape:
    &#34;&#34;&#34;
    The `shape` of a `Geometry` consists of the following dimensions:

    * A single *channel* dimension called `&#39;vector&#39;` specifying the physical space
    * Instance dimensions denote that this geometry consists of multiple copies in the same space
    * Spatial dimensions denote a crystal (repeating structure) of this geometric primitive in space
    * Batch dimensions indicate non-interacting versions of this geometry for parallelization only.
    &#34;&#34;&#34;
    raise NotImplementedError(self.__class__)</code></pre>
</details>
<div class="desc"><p>The <code>shape</code> of a <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> consists of the following dimensions:</p>
<ul>
<li>A single <em>channel</em> dimension called <code>'vector'</code> specifying the physical space</li>
<li>Instance dimensions denote that this geometry consists of multiple copies in the same space</li>
<li>Spatial dimensions denote a crystal (repeating structure) of this geometric primitive in space</li>
<li>Batch dimensions indicate non-interacting versions of this geometry for parallelization only.</li>
</ul></div>
</dd>
<dt id="phi.geom.Geometry.spatial_rank"><code class="name">prop <span class="ident">spatial_rank</span> : int</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def spatial_rank(self) -&gt; int:
    &#34;&#34;&#34; Number of spatial dimensions of the geometry, 1 = 1D, 2 = 2D, 3 = 3D, etc. &#34;&#34;&#34;
    return self.shape.get_size(&#39;vector&#39;)</code></pre>
</details>
<div class="desc"><p>Number of spatial dimensions of the geometry, 1 = 1D, 2 = 2D, 3 = 3D, etc.</p></div>
</dd>
<dt id="phi.geom.Geometry.volume"><code class="name">prop <span class="ident">volume</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def volume(self) -&gt; Tensor:
    &#34;&#34;&#34;
    `phi.math.Tensor` representing the volume of each element.
    The result retains batch, spatial and instance dimensions.
    &#34;&#34;&#34;
    raise NotImplementedError(self.__class__)</code></pre>
</details>
<div class="desc"><p><code>phi.math.Tensor</code> representing the volume of each element.
The result retains batch, spatial and instance dimensions.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phi.geom.Geometry.approximate_closest_surface"><code class="name flex">
<span>def <span class="ident">approximate_closest_surface</span></span>(<span>self, location: phiml.math._tensors.Tensor) ‑> Tuple[phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def approximate_closest_surface(self, location: Tensor) -&gt; Tuple[Tensor, Tensor, Tensor, Tensor, Tensor]:
    &#34;&#34;&#34;
    Find the closest surface face of this geometry given a point that can be outside or inside the geometry.

    Args:
        location: `Tensor` with a single channel dimension called vector. Can have arbitrary other dimensions.

    Returns:
        signed_distance: Scalar signed distance from `location`  to the closest point on the surface.
            Positive values indicate the point lies outside the geometry, negative values indicate the point lies inside the geometry.
        delta: Vector-valued distance vector from `location` to the closest point on the surface.
        normal: Closest surface normal vector.
        offset: Min distance of a surface-tangential plane from 0 as a scalar.
        face_index: (Optional) An index vector pointing at the closest face.
    &#34;&#34;&#34;
    raise NotImplementedError(self.__class__)</code></pre>
</details>
<div class="desc"><p>Find the closest surface face of this geometry given a point that can be outside or inside the geometry.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd><code>Tensor</code> with a single channel dimension called vector. Can have arbitrary other dimensions.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>signed_distance</code></dt>
<dd>Scalar signed distance from <code>location</code>
to the closest point on the surface.
Positive values indicate the point lies outside the geometry, negative values indicate the point lies inside the geometry.</dd>
<dt><code>delta</code></dt>
<dd>Vector-valued distance vector from <code>location</code> to the closest point on the surface.</dd>
<dt><code>normal</code></dt>
<dd>Closest surface normal vector.</dd>
<dt><code>offset</code></dt>
<dd>Min distance of a surface-tangential plane from 0 as a scalar.</dd>
<dt><code>face_index</code></dt>
<dd>(Optional) An index vector pointing at the closest face.</dd>
</dl></div>
</dd>
<dt id="phi.geom.Geometry.approximate_fraction_inside"><code class="name flex">
<span>def <span class="ident">approximate_fraction_inside</span></span>(<span>self,<br>other_geometry: <a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a>,<br>balance: phiml.math._tensors.Tensor | numbers.Number = 0.5) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def approximate_fraction_inside(self, other_geometry: &#39;Geometry&#39;, balance: Union[Tensor, Number] = 0.5) -&gt; Tensor:
    &#34;&#34;&#34;
    Computes the approximate overlap between the geometry and a small other geometry.
    Returns 1.0 if `other_geometry` is fully enclosed in this geometry and 0.0 if there is no overlap.
    Close to the surface of this geometry, the fraction filled is differentiable w.r.t. the location and size of `other_geometry`.

    To call this method on batches of geometries of same shape, pass a batched Geometry instance.
    The result tensor will match the batch shape of `other_geometry`.

    The result may only be accurate in special cases.
    The given geometries may be approximated as spheres or boxes using `bounding_radius()` and `bounding_half_extent()`.

    The default implementation of this method approximates other_geometry as a Sphere and computes the fraction using `approximate_signed_distance()`.

    Args:
        other_geometry: `Geometry` or geometry batch for which to compute the overlap with `self`.
        balance: Mid-level between 0 and 1, default 0.5.
            This value is returned when exactly half of `other_geometry` lies inside `self`.
            `0.5 &lt; balance &lt;= 1` makes `self` seem larger while `0 &lt;= balance &lt; 0.5`makes `self` seem smaller.

    Returns:
      fraction of cell volume lying inside the geometry. float tensor of shape (other_geometry.batch_shape, 1).

    &#34;&#34;&#34;
    assert isinstance(other_geometry, Geometry)
    radius = other_geometry.bounding_radius()
    location = other_geometry.center
    distance = self.approximate_signed_distance(location)
    inside_fraction = balance - distance / radius
    inside_fraction = math.clip(inside_fraction, 0, 1)
    return inside_fraction</code></pre>
</details>
<div class="desc"><p>Computes the approximate overlap between the geometry and a small other geometry.
Returns 1.0 if <code>other_geometry</code> is fully enclosed in this geometry and 0.0 if there is no overlap.
Close to the surface of this geometry, the fraction filled is differentiable w.r.t. the location and size of <code>other_geometry</code>.</p>
<p>To call this method on batches of geometries of same shape, pass a batched Geometry instance.
The result tensor will match the batch shape of <code>other_geometry</code>.</p>
<p>The result may only be accurate in special cases.
The given geometries may be approximated as spheres or boxes using <code>bounding_radius()</code> and <code>bounding_half_extent()</code>.</p>
<p>The default implementation of this method approximates other_geometry as a Sphere and computes the fraction using <code>approximate_signed_distance()</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>other_geometry</code></strong></dt>
<dd><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> or geometry batch for which to compute the overlap with <code>self</code>.</dd>
<dt><strong><code>balance</code></strong></dt>
<dd>Mid-level between 0 and 1, default 0.5.
This value is returned when exactly half of <code>other_geometry</code> lies inside <code>self</code>.
<code>0.5 &lt; balance &lt;= 1</code> makes <code>self</code> seem larger while <code>0 &lt;= balance &lt; 0.5</code>makes <code>self</code> seem smaller.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>fraction of cell volume lying inside the geometry. float tensor of shape (other_geometry.batch_shape, 1).</p></div>
</dd>
<dt id="phi.geom.Geometry.approximate_signed_distance"><code class="name flex">
<span>def <span class="ident">approximate_signed_distance</span></span>(<span>self, location: phiml.math._tensors.Tensor) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def approximate_signed_distance(self, location: Tensor) -&gt; Tensor:
    &#34;&#34;&#34;
    Computes the approximate distance from location to the surface of the geometry.
    Locations outside return positive values, inside negative values and zero exactly at the boundary.

    The exact distance metric used depends on the geometry.
    The approximation holds close to the surface and the distance grows to infinity as the location is moved infinitely far from the geometry.
    The distance metric is differentiable and its gradients are bounded at every point in space.

    When dealing with unions or collections of geometries (instance dimensions), the shortest distance to any instance is returned.
    This also holds for negative distances.

    Args:
        location: `Tensor` with one channel dim `vector` matching the geometry&#39;s `vector` dim.

    Returns:
        Float `Tensor`
    &#34;&#34;&#34;
    raise NotImplementedError(self.__class__)</code></pre>
</details>
<div class="desc"><p>Computes the approximate distance from location to the surface of the geometry.
Locations outside return positive values, inside negative values and zero exactly at the boundary.</p>
<p>The exact distance metric used depends on the geometry.
The approximation holds close to the surface and the distance grows to infinity as the location is moved infinitely far from the geometry.
The distance metric is differentiable and its gradients are bounded at every point in space.</p>
<p>When dealing with unions or collections of geometries (instance dimensions), the shortest distance to any instance is returned.
This also holds for negative distances.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd><code>Tensor</code> with one channel dim <code>vector</code> matching the geometry's <code>vector</code> dim.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Float <code>Tensor</code></p></div>
</dd>
<dt id="phi.geom.Geometry.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>self, center: phiml.math._tensors.Tensor) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def at(self, center: Tensor) -&gt; &#39;Geometry&#39;:
    &#34;&#34;&#34;
    Returns a copy of this `Geometry` with the center at `center`.
    This is equal to calling `self @ center`.

    See Also:
        `Geometry.shifted()`.

    Args:
        center: New center as `Tensor`.

    Returns:
        `Geometry`.
    &#34;&#34;&#34;
    raise NotImplementedError(self.__class__)</code></pre>
</details>
<div class="desc"><p>Returns a copy of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> with the center at <code>center</code>.
This is equal to calling <code>self @ center</code>.</p>
<p>See Also:
<code><a title="phi.geom.Geometry.shifted" href="#phi.geom.Geometry.shifted">Geometry.shifted()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>center</code></strong></dt>
<dd>New center as <code>Tensor</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.</p></div>
</dd>
<dt id="phi.geom.Geometry.bounding_box"><code class="name flex">
<span>def <span class="ident">bounding_box</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bounding_box(self):
    &#34;&#34;&#34;
    Returns the approximately smallest axis-aligned box that contains this `Geometry`.
    The center of the box may not be equal to `self.center`.

    Returns:
        `Box` or `Cuboid` that fully contains this `Geometry`.
    &#34;&#34;&#34;
    center = self.center
    half = self.bounding_half_extent()
    min_vec = math.min(center - half, dim=center.shape.non_batch.non_channel)
    max_vec = math.max(center + half, dim=center.shape.non_batch.non_channel)
    from ._box import box_from_limits
    return box_from_limits(min_vec, max_vec)</code></pre>
</details>
<div class="desc"><p>Returns the approximately smallest axis-aligned box that contains this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.
The center of the box may not be equal to <code>self.center</code>.</p>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.geom.Box" href="#phi.geom.Box">Box</a></code> or <code><a title="phi.geom.Cuboid" href="#phi.geom.Cuboid">Cuboid()</a></code> that fully contains this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.</p></div>
</dd>
<dt id="phi.geom.Geometry.bounding_half_extent"><code class="name flex">
<span>def <span class="ident">bounding_half_extent</span></span>(<span>self) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bounding_half_extent(self) -&gt; Tensor:
    &#34;&#34;&#34;
    The bounding half-extent sets a limit on the outer-most point for each coordinate axis.
    Each component is non-negative.

    Let the bounding half-extent have value `e` in dimension `d` (`extent[...,d] = e`).
    Then, no point of the geometry lies further away from its center point than `e` along `d` (in both axis directions).

    If this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.
    If these dims are not present on the result, all parts are assumed to have the same bounds.
    &#34;&#34;&#34;
    raise NotImplementedError(self.__class__)</code></pre>
</details>
<div class="desc"><p>The bounding half-extent sets a limit on the outer-most point for each coordinate axis.
Each component is non-negative.</p>
<p>Let the bounding half-extent have value <code>e</code> in dimension <code>d</code> (<code>extent[...,d] = e</code>).
Then, no point of the geometry lies further away from its center point than <code>e</code> along <code>d</code> (in both axis directions).</p>
<p>If this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.
If these dims are not present on the result, all parts are assumed to have the same bounds.</p></div>
</dd>
<dt id="phi.geom.Geometry.bounding_radius"><code class="name flex">
<span>def <span class="ident">bounding_radius</span></span>(<span>self) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bounding_radius(self) -&gt; Tensor:
    &#34;&#34;&#34;
    Returns the radius of a Sphere object that fully encloses this geometry.
    The sphere is centered at the center of this geometry.

    If this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.
    If these dims are not present on the result, all parts are assumed to have the same bounds.
    &#34;&#34;&#34;
    raise NotImplementedError(self.__class__)</code></pre>
</details>
<div class="desc"><p>Returns the radius of a Sphere object that fully encloses this geometry.
The sphere is centered at the center of this geometry.</p>
<p>If this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.
If these dims are not present on the result, all parts are assumed to have the same bounds.</p></div>
</dd>
<dt id="phi.geom.Geometry.bounding_sphere"><code class="name flex">
<span>def <span class="ident">bounding_sphere</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bounding_sphere(self):
    from phi.geom._functions import vec_length
    from ._sphere import Sphere
    center = self.bounding_box().center
    dist = vec_length(self.center - center) + self.bounding_radius()
    max_dist = math.max(dist, dim=self.shape.non_batch - &#39;vector&#39;)
    return Sphere(center, max_dist)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Geometry.get_boundary"><code class="name flex">
<span>def <span class="ident">get_boundary</span></span>(<span>self, set_key: str) ‑> Dict[str, Dict[str, slice]]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_boundary(self, set_key: str) -&gt; Dict[str, Dict[str, slice]]:
    if set_key == &#39;center&#39;:
        return self.boundary_elements
    elif set_key == &#39;face&#39;:
        return self.boundary_faces
    else:
        raise ValueError(f&#34;Unknown set: &#39;{set_key}&#39;&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Geometry.get_points"><code class="name flex">
<span>def <span class="ident">get_points</span></span>(<span>self, set_key: str) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_points(self, set_key: str) -&gt; Tensor:
    if set_key == &#39;center&#39;:
        return self.center
    elif set_key == &#39;face&#39;:
        return self.face_centers
    else:
        raise ValueError(f&#34;Unknown set: &#39;{set_key}&#39;&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Geometry.integrate_flux"><code class="name flex">
<span>def <span class="ident">integrate_flux</span></span>(<span>self, flux: phiml.math._tensors.Tensor, divide_volume=False) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def integrate_flux(self, flux: Tensor, divide_volume=False) -&gt; Tensor:
    assert &#39;vector&#39; in flux.shape, f&#34;flux must have a &#39;vector&#39; dimension but got {flux.shape}&#34;
    result = math.sum(flux.vector @ (self.face_normals * self.face_areas).vector, self.face_shape.dual)
    return result / self.volume if divide_volume else result</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Geometry.integrate_surface"><code class="name flex">
<span>def <span class="ident">integrate_surface</span></span>(<span>self, face_values: phiml.math._tensors.Tensor, divide_volume=False) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def integrate_surface(self, face_values: Tensor, divide_volume=False) -&gt; Tensor:
    &#34;&#34;&#34;
    Multiplies `values´ by the corresponding face area, computes the sum over all faces and divides by the cell volume.
    ∑ values * A.

    Args:
        face_values: Values sampled at the face centers.
        divide_volume: Whether to divide by the cell `volume´

    Returns:
        `Tensor` of values sampled at the centroids.
    &#34;&#34;&#34;
    result = math.sum(face_values * self.face_areas, self.face_shape.dual)
    return result / self.volume if divide_volume else result</code></pre>
</details>
<div class="desc"><p>Multiplies `values´ by the corresponding face area, computes the sum over all faces and divides by the cell volume.
∑ values * A.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>face_values</code></strong></dt>
<dd>Values sampled at the face centers.</dd>
<dt><strong><code>divide_volume</code></strong></dt>
<dd>Whether to divide by the cell `volume´</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>Tensor</code> of values sampled at the centroids.</p></div>
</dd>
<dt id="phi.geom.Geometry.lies_inside"><code class="name flex">
<span>def <span class="ident">lies_inside</span></span>(<span>self, location: phiml.math._tensors.Tensor) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lies_inside(self, location: Tensor) -&gt; Tensor:
    &#34;&#34;&#34;
    Tests whether the given location lies inside or outside of the geometry. Locations on the surface count as inside.

    When dealing with unions or collections of geometries (instance dimensions), a point lies inside the geometry if it lies inside any instance.

    Args:
      location: float tensor of shape (batch_size, ..., rank)

    Returns:
      bool tensor of shape (*location.shape[:-1], 1).

    &#34;&#34;&#34;
    raise NotImplementedError(self.__class__)</code></pre>
</details>
<div class="desc"><p>Tests whether the given location lies inside or outside of the geometry. Locations on the surface count as inside.</p>
<p>When dealing with unions or collections of geometries (instance dimensions), a point lies inside the geometry if it lies inside any instance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd>float tensor of shape (batch_size, &hellip;, rank)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>bool tensor of shape (*location.shape[:-1], 1).</p></div>
</dd>
<dt id="phi.geom.Geometry.push"><code class="name flex">
<span>def <span class="ident">push</span></span>(<span>self,<br>positions: phiml.math._tensors.Tensor,<br>outward: bool = True,<br>shift_amount: float = 0) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def push(self, positions: Tensor, outward: bool = True, shift_amount: float = 0) -&gt; Tensor:
    &#34;&#34;&#34;
    Shifts positions either into or out of geometry.

    Args:
        positions: Tensor holding positions to shift
        outward: Flag for indicating inward (False) or outward (True) shift
        shift_amount: Minimum distance between positions and surface after shifting.

    Returns:
        Tensor holding shifted positions.
    &#34;&#34;&#34;
    from ._geom_ops import expel
    return expel(self, positions, min_separation=shift_amount, invert=not outward)</code></pre>
</details>
<div class="desc"><p>Shifts positions either into or out of geometry.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>positions</code></strong></dt>
<dd>Tensor holding positions to shift</dd>
<dt><strong><code>outward</code></strong></dt>
<dd>Flag for indicating inward (False) or outward (True) shift</dd>
<dt><strong><code>shift_amount</code></strong></dt>
<dd>Minimum distance between positions and surface after shifting.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Tensor holding shifted positions.</p></div>
</dd>
<dt id="phi.geom.Geometry.rotated"><code class="name flex">
<span>def <span class="ident">rotated</span></span>(<span>self, angle: phiml.math._tensors.Tensor | float) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotated(self, angle: Union[float, Tensor]) -&gt; &#39;Geometry&#39;:
    &#34;&#34;&#34;
    Returns a rotated version of this geometry.
    The geometry is rotated about its center point.

    Args:
        angle: Delta rotation.
            Either

            * Angle(s): scalar angle in 2d or euler angles along `vector` in 3D or higher.
            * Matrix: d⨯d rotation matrix

    Returns:
        Rotated `Geometry`
    &#34;&#34;&#34;
    raise NotImplementedError(self.__class__)</code></pre>
</details>
<div class="desc"><p>Returns a rotated version of this geometry.
The geometry is rotated about its center point.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>angle</code></strong></dt>
<dd>
<p>Delta rotation.
Either</p>
<ul>
<li>Angle(s): scalar angle in 2d or euler angles along <code>vector</code> in 3D or higher.</li>
<li>Matrix: d⨯d rotation matrix</li>
</ul>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Rotated <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></p></div>
</dd>
<dt id="phi.geom.Geometry.sample_uniform"><code class="name flex">
<span>def <span class="ident">sample_uniform</span></span>(<span>self, *shape: phiml.math._shape.Shape) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_uniform(self, *shape: math.Shape) -&gt; Tensor:
    &#34;&#34;&#34;
    Samples uniformly distributed random points inside this volume.

    Args:
        *shape: How many points to sample per individual geometry.

    Returns:
        `Tensor` containing all dimensions from `Geometry.shape`, `shape` as well as a `channel` dimension `vector` matching the dimensionality of this `Geometry`.
    &#34;&#34;&#34;
    raise NotImplementedError(self.__class__)</code></pre>
</details>
<div class="desc"><p>Samples uniformly distributed random points inside this volume.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*shape</code></strong></dt>
<dd>How many points to sample per individual geometry.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>Tensor</code> containing all dimensions from <code><a title="phi.geom.Geometry.shape" href="#phi.geom.Geometry.shape">Geometry.shape</a></code>, <code>shape</code> as well as a <code>channel</code> dimension <code>vector</code> matching the dimensionality of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.</p></div>
</dd>
<dt id="phi.geom.Geometry.scaled"><code class="name flex">
<span>def <span class="ident">scaled</span></span>(<span>self, factor: phiml.math._tensors.Tensor | float) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scaled(self, factor: Union[float, Tensor]) -&gt; &#39;Geometry&#39;:
    &#34;&#34;&#34;
    Scales each individual geometry by `factor`.
    The individual `center` points act as pivots for the operation.

    Args:
        factor:

    Returns:

    &#34;&#34;&#34;
    raise NotImplementedError(self.__class__)</code></pre>
</details>
<div class="desc"><p>Scales each individual geometry by <code>factor</code>.
The individual <code>center</code> points act as pivots for the operation.</p>
<h2 id="args">Args</h2>
<p>factor:
Returns:</p></div>
</dd>
<dt id="phi.geom.Geometry.shallow_equals"><code class="name flex">
<span>def <span class="ident">shallow_equals</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shallow_equals(self, other):
    &#34;&#34;&#34;
    Quick equality check.
    May return `False` even if `other == self`.
    However, if `True` is returned, the geometries are guaranteed to be equal.

    The `shallow_equals()` check does not compare all tensor elements but merely checks whether the same tensors are referenced.
    &#34;&#34;&#34;
    differences = find_differences(self, other, compare_tensors_by_id=True, attr_type=all_attributes)
    return not differences</code></pre>
</details>
<div class="desc"><p>Quick equality check.
May return <code>False</code> even if <code>other == self</code>.
However, if <code>True</code> is returned, the geometries are guaranteed to be equal.</p>
<p>The <code>shallow_equals()</code> check does not compare all tensor elements but merely checks whether the same tensors are referenced.</p></div>
</dd>
<dt id="phi.geom.Geometry.shifted"><code class="name flex">
<span>def <span class="ident">shifted</span></span>(<span>self, delta: phiml.math._tensors.Tensor) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shifted(self, delta: Tensor) -&gt; &#39;Geometry&#39;:
    &#34;&#34;&#34;
    Returns a translated version of this geometry.

    See Also:
        `Geometry.at()`.

    Args:
      delta: direction vector
      delta: Tensor:

    Returns:
      Geometry: shifted geometry

    &#34;&#34;&#34;
    return self.at(self.center + delta)</code></pre>
</details>
<div class="desc"><p>Returns a translated version of this geometry.</p>
<p>See Also:
<code><a title="phi.geom.Geometry.at" href="#phi.geom.Geometry.at">Geometry.at()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>delta</code></strong></dt>
<dd>direction vector</dd>
<dt><strong><code>delta</code></strong></dt>
<dd>Tensor:</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></dt>
<dd>shifted geometry</dd>
</dl></div>
</dd>
<dt id="phi.geom.Geometry.unstack"><code class="name flex">
<span>def <span class="ident">unstack</span></span>(<span>self, dimension: str) ‑> tuple</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unstack(self, dimension: str) -&gt; tuple:
    &#34;&#34;&#34;
    Unstacks this Geometry along the given dimension.
    The shapes of the returned geometries are reduced by `dimension`.

    Args:
        dimension: dimension along which to unstack

    Returns:
        geometries: tuple of length equal to `geometry.shape.get_size(dimension)`
    &#34;&#34;&#34;
    warnings.warn(f&#34;Geometry.unstack() is deprecated. Use math.unstack(geometry) instead.&#34;, DeprecationWarning)
    return math.unstack(self, dimension)</code></pre>
</details>
<div class="desc"><p>Unstacks this Geometry along the given dimension.
The shapes of the returned geometries are reduced by <code>dimension</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dimension</code></strong></dt>
<dd>dimension along which to unstack</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>geometries</code></dt>
<dd>tuple of length equal to <code>geometry.shape.get_size(dimension)</code></dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="phi.geom.GeometryException"><code class="flex name class">
<span>class <span class="ident">GeometryException</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GeometryException(BaseException):
    &#34;&#34;&#34;
    Raised when an operation is fundamentally not possible for a `Geometry`.
    Possible causes:

    * Trying to get the interior of a non-surface `Geometry`
    * Trying to get the surface of a point-like `Geometry`
    &#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Raised when an operation is fundamentally not possible for a <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.
Possible causes:</p>
<ul>
<li>Trying to get the interior of a non-surface <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></li>
<li>Trying to get the surface of a point-like <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></li>
</ul></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="phi.geom.Graph"><code class="flex name class">
<span>class <span class="ident">Graph</span></span>
<span>(</span><span>nodes: phi.geom._geom.Geometry,<br>edges: phiml.math._tensors.Tensor,<br>boundary: Dict[str, Dict[str, slice]])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@sliceable(keepdims=&#39;vector&#39;)
@dataclass(frozen=True, eq=False)
class Graph(Geometry):
    &#34;&#34;&#34;
    A graph consists of multiple geometry nodes and corresponding edge information.

    Edges are stored as a Tensor with the same axes ad `geometry` plus their dual counterparts.
    Additional dimensions can be added to `edges` to store vector-valued connectivity weights.
    &#34;&#34;&#34;
    nodes: Geometry
    edges: Tensor
    boundary: Dict[str, Dict[str, slice]]

    variable_attrs = (&#39;nodes&#39;, &#39;edges&#39;)

    def __post_init__(self):
        assert isinstance(self.nodes, Geometry), f&#34;nodes must be a Geometry  but got {self.nodes}&#34;
        node_dims = non_batch(self.nodes).non_channel
        assert node_dims in self.edges.shape and self.edges.shape.dual.rank == node_dims.rank, f&#34;edges must contain all node dims {node_dims} as primal and dual but got {self.edges.shape}&#34;

    @cached_property
    def connectivity(self) -&gt; Tensor:
        return math.tensor_like(self.edges, 1) if math.is_sparse(self.edges) else (self.edges != 0) &amp; ~math.is_nan(self.edges)

    def as_points(self):
        return replace(self, nodes=Point(self.nodes.center))

    @cached_property
    def deltas(self):
        return math.pairwise_distances(self.nodes.center, format=self.edges)

    @cached_property
    def unit_deltas(self):
        return math.safe_div(self.deltas, self.distances)

    @cached_property
    def distances(self):
        return vec_length(self.deltas)

    @cached_property
    def bounding_distance(self) -&gt; Optional[Tensor]:
        return math.max(self.distances)

    @property
    def center(self) -&gt; Tensor:
        return self.nodes.center

    @property
    def shape(self) -&gt; Shape:
        return self.nodes.shape

    @property
    def volume(self) -&gt; Tensor:
        return self.nodes.volume

    @property
    def faces(self) -&gt; &#39;Geometry&#39;:
        raise NotImplementedError

    @property
    def face_centers(self) -&gt; Tensor:
        raise NotImplementedError

    @property
    def face_areas(self) -&gt; Tensor:
        raise NotImplementedError

    @property
    def face_normals(self) -&gt; Tensor:
        raise NotImplementedError

    @property
    def boundary_elements(self) -&gt; Dict[str, Dict[str, slice]]:
        return self.boundary

    @property
    def boundary_faces(self) -&gt; Dict[Any, Dict[str, slice]]:
        raise NotImplementedError  # connections between boundary elements

    @property
    def face_shape(self) -&gt; Shape:
        return non_batch(self.edges).non_channel

    def lies_inside(self, location: Tensor) -&gt; Tensor:
        raise NotImplementedError

    def approximate_closest_surface(self, location: Tensor) -&gt; Tuple[Tensor, Tensor, Tensor, Tensor, Tensor]:
        raise NotImplementedError

    def approximate_signed_distance(self, location: Tensor) -&gt; Tensor:
        raise NotImplementedError

    def sample_uniform(self, *shape: math.Shape) -&gt; Tensor:
        raise NotImplementedError

    def bounding_radius(self) -&gt; Tensor:
        return self.nodes.bounding_radius()

    def bounding_half_extent(self) -&gt; Tensor:
        return self.nodes.bounding_half_extent()

    def at(self, center: Tensor) -&gt; &#39;Geometry&#39;:
        raise NotImplementedError(&#34;Changing the node positions of a Graph is not supported as it would invalidate distances.&#34;)
        # warnings.warn(&#34;Changing the node positions of a graph triggers re-evaluation of distances.&#34;, RuntimeWarning, stacklevel=2)
        # return Graph(self.nodes.at(center), self._edges, self._boundary, bounding_distance=self._bounding_distance is not None)

    def shifted(self, delta: Tensor) -&gt; &#39;Geometry&#39;:
        if non_batch(delta).non_channel.only(self.nodes.shape):  # shift varies between elements
            raise NotImplementedError(&#34;Shifting the node positions of a Graph is not supported as it would invalidate distances.&#34;)
        return replace(self, nodes=self.nodes.shifted(delta))

    def rotated(self, angle: Union[float, Tensor]) -&gt; &#39;Geometry&#39;:
        return replace(self, nodes=self.nodes.rotated(angle))

    def scaled(self, factor: Union[float, Tensor]) -&gt; &#39;Geometry&#39;:
        return replace(self, nodes=self.nodes.scaled(factor))

    def __getitem__(self, item):
        item = slicing_dict(self, item)
        node_dims = non_batch(self.nodes).non_channel
        edge_sel = {}
        for i, (dim, sel) in enumerate(item.items()):
            if dim in node_dims:
                dual_dim = &#39;~&#39; + dim
                if dual_dim not in self.edges.shape:
                    dual_dim = dual(self.edges).shape.names[i]
                edge_sel[dim] = edge_sel[dual_dim] = sel
            elif dim in batch(self):
                edge_sel[dim] = sel
        return Graph(self.nodes[item], self.edges[edge_sel], self.boundary)</code></pre>
</details>
<div class="desc"><p>A graph consists of multiple geometry nodes and corresponding edge information.</p>
<p>Edges are stored as a Tensor with the same axes ad <code>geometry</code> plus their dual counterparts.
Additional dimensions can be added to <code>edges</code> to store vector-valued connectivity weights.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.geom._geom.Geometry</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="phi.geom.Graph.variable_attrs"><code class="name">var <span class="ident">variable_attrs</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="phi.geom.Graph.Tc"><code class="name">prop <span class="ident">Tc</span></code></dt>
<dd>
<div class="desc"><p>partial(func, <em>args, </em>*keywords) - new function with partial application
of the given arguments and keywords.</p></div>
</dd>
<dt id="phi.geom.Graph.Ti"><code class="name">prop <span class="ident">Ti</span></code></dt>
<dd>
<div class="desc"><p>partial(func, <em>args, </em>*keywords) - new function with partial application
of the given arguments and keywords.</p></div>
</dd>
<dt id="phi.geom.Graph.Ts"><code class="name">prop <span class="ident">Ts</span></code></dt>
<dd>
<div class="desc"><p>partial(func, <em>args, </em>*keywords) - new function with partial application
of the given arguments and keywords.</p></div>
</dd>
<dt id="phi.geom.Graph.boundary"><code class="name">var <span class="ident">boundary</span> : Dict[str, Dict[str, slice]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Graph.boundary_elements"><code class="name">prop <span class="ident">boundary_elements</span> : Dict[str, Dict[str, slice]]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def boundary_elements(self) -&gt; Dict[str, Dict[str, slice]]:
    return self.boundary</code></pre>
</details>
<div class="desc"><p>Slices on the primal dimensions to mark boundary elements.
Grids and meshes have no boundary elements and return <code>{}</code>.
Dynamic graphs can define boundary elements for obstacles and walls.</p>
<h2 id="returns">Returns</h2>
<p>Map from <code>name</code> to slicing <code>dict</code>.</p></div>
</dd>
<dt id="phi.geom.Graph.boundary_faces"><code class="name">prop <span class="ident">boundary_faces</span> : Dict[Any, Dict[str, slice]]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def boundary_faces(self) -&gt; Dict[Any, Dict[str, slice]]:
    raise NotImplementedError  # connections between boundary elements</code></pre>
</details>
<div class="desc"><p>Slices on the dual dimensions to mark boundary faces.</p>
<p>Regular grids use the keys (dim, is_upper) to identify boundaries.
Unstructured meshes use string identifiers for the boundaries.
Dynamic graphs return slices along the dual dimensions.</p>
<h2 id="returns">Returns</h2>
<p>Map from <code>name</code> to slicing <code>dict</code>.</p></div>
</dd>
<dt id="phi.geom.Graph.bounding_distance"><code class="name">var <span class="ident">bounding_distance</span> : phiml.math._tensors.Tensor | None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def bounding_distance(self) -&gt; Optional[Tensor]:
    return math.max(self.distances)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Graph.center"><code class="name">prop <span class="ident">center</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def center(self) -&gt; Tensor:
    return self.nodes.center</code></pre>
</details>
<div class="desc"><p>Center location in single channel dimension.</p></div>
</dd>
<dt id="phi.geom.Graph.connectivity"><code class="name">var <span class="ident">connectivity</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def connectivity(self) -&gt; Tensor:
    return math.tensor_like(self.edges, 1) if math.is_sparse(self.edges) else (self.edges != 0) &amp; ~math.is_nan(self.edges)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Graph.deltas"><code class="name">var <span class="ident">deltas</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def deltas(self):
    return math.pairwise_distances(self.nodes.center, format=self.edges)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Graph.distances"><code class="name">var <span class="ident">distances</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def distances(self):
    return vec_length(self.deltas)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Graph.edges"><code class="name">var <span class="ident">edges</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Graph.face_areas"><code class="name">prop <span class="ident">face_areas</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_areas(self) -&gt; Tensor:
    raise NotImplementedError</code></pre>
</details>
<div class="desc"><p>Area of face connecting a pair of cells. Shape <code>(elements, ~)</code>.
Returns 0 for unconnected cells.</p></div>
</dd>
<dt id="phi.geom.Graph.face_centers"><code class="name">prop <span class="ident">face_centers</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_centers(self) -&gt; Tensor:
    raise NotImplementedError</code></pre>
</details>
<div class="desc"><p>Center of face connecting a pair of cells. Shape <code>(elements, ~, vector)</code>.
Here, <code>~</code> represents arbitrary internal dual dimensions, such as <code>~staggered_direction</code> or <code>~elements</code>.
Returns 0-vectors for unconnected cells.</p></div>
</dd>
<dt id="phi.geom.Graph.face_normals"><code class="name">prop <span class="ident">face_normals</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_normals(self) -&gt; Tensor:
    raise NotImplementedError</code></pre>
</details>
<div class="desc"><p>Normal vectors of cell faces, including boundary faces. Shape <code>(elements, ~, vector)</code>.
For meshes, The vectors point out of the primal cells and into the dual cells.</p>
<p>Instance/spatial dimensions along which the normal does not vary may not be included in the result tensor's shape.</p></div>
</dd>
<dt id="phi.geom.Graph.face_shape"><code class="name">prop <span class="ident">face_shape</span> : phiml.math._shape.Shape</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_shape(self) -&gt; Shape:
    return non_batch(self.edges).non_channel</code></pre>
</details>
<div class="desc"><h2 id="returns">Returns</h2>
<p>Full Shape to identify each face of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>, including instance/spatial dimensions for the elements and dual dimensions listing the faces per element.
If this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> has no faces, returns an empty <code>Shape</code>.</p></div>
</dd>
<dt id="phi.geom.Graph.faces"><code class="name">prop <span class="ident">faces</span> : <a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def faces(self) -&gt; &#39;Geometry&#39;:
    raise NotImplementedError</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Graph.nodes"><code class="name">var <span class="ident">nodes</span> : phi.geom._geom.Geometry</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Graph.shape"><code class="name">prop <span class="ident">shape</span> : phiml.math._shape.Shape</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape(self) -&gt; Shape:
    return self.nodes.shape</code></pre>
</details>
<div class="desc"><p>The <code>shape</code> of a <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> consists of the following dimensions:</p>
<ul>
<li>A single <em>channel</em> dimension called <code>'vector'</code> specifying the physical space</li>
<li>Instance dimensions denote that this geometry consists of multiple copies in the same space</li>
<li>Spatial dimensions denote a crystal (repeating structure) of this geometric primitive in space</li>
<li>Batch dimensions indicate non-interacting versions of this geometry for parallelization only.</li>
</ul></div>
</dd>
<dt id="phi.geom.Graph.unit_deltas"><code class="name">var <span class="ident">unit_deltas</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def unit_deltas(self):
    return math.safe_div(self.deltas, self.distances)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Graph.volume"><code class="name">prop <span class="ident">volume</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def volume(self) -&gt; Tensor:
    return self.nodes.volume</code></pre>
</details>
<div class="desc"><p><code>phi.math.Tensor</code> representing the volume of each element.
The result retains batch, spatial and instance dimensions.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phi.geom.Graph.approximate_closest_surface"><code class="name flex">
<span>def <span class="ident">approximate_closest_surface</span></span>(<span>self, location: phiml.math._tensors.Tensor) ‑> Tuple[phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def approximate_closest_surface(self, location: Tensor) -&gt; Tuple[Tensor, Tensor, Tensor, Tensor, Tensor]:
    raise NotImplementedError</code></pre>
</details>
<div class="desc"><p>Find the closest surface face of this geometry given a point that can be outside or inside the geometry.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd><code>Tensor</code> with a single channel dimension called vector. Can have arbitrary other dimensions.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>signed_distance</code></dt>
<dd>Scalar signed distance from <code>location</code>
to the closest point on the surface.
Positive values indicate the point lies outside the geometry, negative values indicate the point lies inside the geometry.</dd>
<dt><code>delta</code></dt>
<dd>Vector-valued distance vector from <code>location</code> to the closest point on the surface.</dd>
<dt><code>normal</code></dt>
<dd>Closest surface normal vector.</dd>
<dt><code>offset</code></dt>
<dd>Min distance of a surface-tangential plane from 0 as a scalar.</dd>
<dt><code>face_index</code></dt>
<dd>(Optional) An index vector pointing at the closest face.</dd>
</dl></div>
</dd>
<dt id="phi.geom.Graph.approximate_signed_distance"><code class="name flex">
<span>def <span class="ident">approximate_signed_distance</span></span>(<span>self, location: phiml.math._tensors.Tensor) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def approximate_signed_distance(self, location: Tensor) -&gt; Tensor:
    raise NotImplementedError</code></pre>
</details>
<div class="desc"><p>Computes the approximate distance from location to the surface of the geometry.
Locations outside return positive values, inside negative values and zero exactly at the boundary.</p>
<p>The exact distance metric used depends on the geometry.
The approximation holds close to the surface and the distance grows to infinity as the location is moved infinitely far from the geometry.
The distance metric is differentiable and its gradients are bounded at every point in space.</p>
<p>When dealing with unions or collections of geometries (instance dimensions), the shortest distance to any instance is returned.
This also holds for negative distances.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd><code>Tensor</code> with one channel dim <code>vector</code> matching the geometry's <code>vector</code> dim.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Float <code>Tensor</code></p></div>
</dd>
<dt id="phi.geom.Graph.as_points"><code class="name flex">
<span>def <span class="ident">as_points</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_points(self):
    return replace(self, nodes=Point(self.nodes.center))</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Graph.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>self, center: phiml.math._tensors.Tensor) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def at(self, center: Tensor) -&gt; &#39;Geometry&#39;:
    raise NotImplementedError(&#34;Changing the node positions of a Graph is not supported as it would invalidate distances.&#34;)
    # warnings.warn(&#34;Changing the node positions of a graph triggers re-evaluation of distances.&#34;, RuntimeWarning, stacklevel=2)
    # return Graph(self.nodes.at(center), self._edges, self._boundary, bounding_distance=self._bounding_distance is not None)</code></pre>
</details>
<div class="desc"><p>Returns a copy of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> with the center at <code>center</code>.
This is equal to calling <code>self @ center</code>.</p>
<p>See Also:
<code><a title="phi.geom.Geometry.shifted" href="#phi.geom.Geometry.shifted">Geometry.shifted()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>center</code></strong></dt>
<dd>New center as <code>Tensor</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.</p></div>
</dd>
<dt id="phi.geom.Graph.bounding_half_extent"><code class="name flex">
<span>def <span class="ident">bounding_half_extent</span></span>(<span>self) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bounding_half_extent(self) -&gt; Tensor:
    return self.nodes.bounding_half_extent()</code></pre>
</details>
<div class="desc"><p>The bounding half-extent sets a limit on the outer-most point for each coordinate axis.
Each component is non-negative.</p>
<p>Let the bounding half-extent have value <code>e</code> in dimension <code>d</code> (<code>extent[...,d] = e</code>).
Then, no point of the geometry lies further away from its center point than <code>e</code> along <code>d</code> (in both axis directions).</p>
<p>If this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.
If these dims are not present on the result, all parts are assumed to have the same bounds.</p></div>
</dd>
<dt id="phi.geom.Graph.bounding_radius"><code class="name flex">
<span>def <span class="ident">bounding_radius</span></span>(<span>self) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bounding_radius(self) -&gt; Tensor:
    return self.nodes.bounding_radius()</code></pre>
</details>
<div class="desc"><p>Returns the radius of a Sphere object that fully encloses this geometry.
The sphere is centered at the center of this geometry.</p>
<p>If this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.
If these dims are not present on the result, all parts are assumed to have the same bounds.</p></div>
</dd>
<dt id="phi.geom.Graph.lies_inside"><code class="name flex">
<span>def <span class="ident">lies_inside</span></span>(<span>self, location: phiml.math._tensors.Tensor) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lies_inside(self, location: Tensor) -&gt; Tensor:
    raise NotImplementedError</code></pre>
</details>
<div class="desc"><p>Tests whether the given location lies inside or outside of the geometry. Locations on the surface count as inside.</p>
<p>When dealing with unions or collections of geometries (instance dimensions), a point lies inside the geometry if it lies inside any instance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd>float tensor of shape (batch_size, &hellip;, rank)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>bool tensor of shape (*location.shape[:-1], 1).</p></div>
</dd>
<dt id="phi.geom.Graph.rotated"><code class="name flex">
<span>def <span class="ident">rotated</span></span>(<span>self, angle: phiml.math._tensors.Tensor | float) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotated(self, angle: Union[float, Tensor]) -&gt; &#39;Geometry&#39;:
    return replace(self, nodes=self.nodes.rotated(angle))</code></pre>
</details>
<div class="desc"><p>Returns a rotated version of this geometry.
The geometry is rotated about its center point.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>angle</code></strong></dt>
<dd>
<p>Delta rotation.
Either</p>
<ul>
<li>Angle(s): scalar angle in 2d or euler angles along <code>vector</code> in 3D or higher.</li>
<li>Matrix: d⨯d rotation matrix</li>
</ul>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Rotated <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></p></div>
</dd>
<dt id="phi.geom.Graph.sample_uniform"><code class="name flex">
<span>def <span class="ident">sample_uniform</span></span>(<span>self, *shape: phiml.math._shape.Shape) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_uniform(self, *shape: math.Shape) -&gt; Tensor:
    raise NotImplementedError</code></pre>
</details>
<div class="desc"><p>Samples uniformly distributed random points inside this volume.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*shape</code></strong></dt>
<dd>How many points to sample per individual geometry.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>Tensor</code> containing all dimensions from <code><a title="phi.geom.Geometry.shape" href="#phi.geom.Geometry.shape">Geometry.shape</a></code>, <code>shape</code> as well as a <code>channel</code> dimension <code>vector</code> matching the dimensionality of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.</p></div>
</dd>
<dt id="phi.geom.Graph.scaled"><code class="name flex">
<span>def <span class="ident">scaled</span></span>(<span>self, factor: phiml.math._tensors.Tensor | float) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scaled(self, factor: Union[float, Tensor]) -&gt; &#39;Geometry&#39;:
    return replace(self, nodes=self.nodes.scaled(factor))</code></pre>
</details>
<div class="desc"><p>Scales each individual geometry by <code>factor</code>.
The individual <code>center</code> points act as pivots for the operation.</p>
<h2 id="args">Args</h2>
<p>factor:
Returns:</p></div>
</dd>
<dt id="phi.geom.Graph.shifted"><code class="name flex">
<span>def <span class="ident">shifted</span></span>(<span>self, delta: phiml.math._tensors.Tensor) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shifted(self, delta: Tensor) -&gt; &#39;Geometry&#39;:
    if non_batch(delta).non_channel.only(self.nodes.shape):  # shift varies between elements
        raise NotImplementedError(&#34;Shifting the node positions of a Graph is not supported as it would invalidate distances.&#34;)
    return replace(self, nodes=self.nodes.shifted(delta))</code></pre>
</details>
<div class="desc"><p>Returns a translated version of this geometry.</p>
<p>See Also:
<code><a title="phi.geom.Geometry.at" href="#phi.geom.Geometry.at">Geometry.at()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>delta</code></strong></dt>
<dd>direction vector</dd>
<dt><strong><code>delta</code></strong></dt>
<dd>Tensor:</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></dt>
<dd>shifted geometry</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="phi.geom.Heightmap"><code class="flex name class">
<span>class <span class="ident">Heightmap</span></span>
<span>(</span><span>height: phiml.math._tensors.Tensor,<br>bounds: phi.geom._box.Box,<br>max_dist: phiml.math._tensors.Tensor | float,<br>fill_below: bool | phiml.math._tensors.Tensor = True,<br>extrapolation: float | str | phiml.math.extrapolation.Extrapolation = None,<br>faces=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Heightmap(Geometry):

    def __init__(self,
                 height: Tensor,
                 bounds: Box,
                 max_dist: Union[float, Tensor],
                 fill_below: Union[bool, Tensor] = True,
                 extrapolation: Union[float, str, math.Extrapolation] = None,
                 faces=None):
        &#34;&#34;&#34;

        Args:
            height: Heightmap `Tensor` of absolute (world-space) height values.
                Scalar height values on a d-1 dimensional grid.
            bounds: d-dimensional bounds.
                Locations outside `bounds&#39; can never lie inside this geometry if `extrapolation is None`.
                Otherwise, only the height dimension is checked.
                The grid dimensions of `bounds` must be finite but the height dimension may be infinite to count all values above/below `height` as inside.
            max_dist: Maximum distance up to which the distance approximations should be valid.
                This does not affect the number of computations performed to compute the distance.
                Low values increase accuracy close to the surface but trade off possibly very wrong distances further away.
            fill_below: Whether the inside is below or above the height values.
            extrapolation: Surface height outside `bounds´. Can be any valid `phiml.math.Extrapolation`, such as a constant.
                If not `None`, values outside `bounds` will be checked against the extrapolated `height` values.
                Otherwise, values outside `bounds` always lie on the outside.
        &#34;&#34;&#34;
        assert channel(height).is_empty, f&#34;height must be a scalar quantity but got {height.shape}&#34;
        assert spatial(height), f&#34;height field must have at least one spatial dim but got {height}&#34;
        assert bounds.vector.size == spatial(height).rank + 1, f&#34;bounds must include the spatial grid dimensions {spatial(height)} and the height dimension but got {bounds}&#34;
        dims = bounds.vector.item_names
        self._hdim = spatial(*dims).without(height.shape).name
        if math.all_available(height, bounds.lower, bounds.upper):
            assert bounds[self._hdim].lies_inside(height).all, f&#34;All height values should be within the {self._hdim}-range given by bounds but got height={height}&#34;
        self._height = height
        self._fill_below = wrap(fill_below)
        self._bounds = bounds
        self._max_dist = wrap(max_dist)
        self._extrapolation = math.as_extrapolation(extrapolation)
        if faces is None:
            proj_faces = build_faces(self)
            with numpy.errstate(divide=&#39;ignore&#39;, invalid=&#39;ignore&#39;):
                secondary_idx = math.map(find_most_important_neighbor, proj_faces, self.dx, self.resolution, self._hdim, self._fill_below, self._max_dist, dims=instance, unwrap_scalars=False)
                secondary_faces = math.map(math.gather, proj_faces, secondary_idx, dims=instance)
            self._faces: Face = stack([proj_faces, *unstack(secondary_faces, &#39;side&#39;)], batch(consider=&#39;self,outside,inside&#39;), expand_values=True)
            self._faces = cached(self._faces)  # otherwise, this may get expanded during tracing
        else:
            self._faces = faces

    @property
    def height(self):
        return self._height

    @property
    def bounds(self):
        return self._bounds

    @property
    def max_dist(self):
        return self._max_dist

    @property
    def fill_below(self):
        return self._fill_below

    @property
    def extrapolation(self):
        return self._extrapolation

    @property
    def shape(self) -&gt; Shape:
        return (self._height.shape - 1) &amp; channel(self._bounds)

    @property
    def resolution(self):
        return spatial(self._height) - 1

    @property
    def grid_bounds(self):
        return self._bounds[self.resolution.name_list]

    @property
    def up(self):
        dims = self._bounds.vector.item_names
        height_unit = vec(**{d: 1 if d == self._hdim else 0 for d in dims})
        return math.where(self._fill_below, height_unit, -height_unit)

    @property
    def dx(self):
        return self._bounds.size[self.resolution.name_list] / spatial(self.resolution)

    @property
    def vertices(self):
        hdim = self._hdim
        space = self.vector.item_names
        pos = self.grid_bounds.local_to_global(math.meshgrid(spatial(self._height)) / self.resolution)
        vert = stack({dim: self.height if dim == hdim else pos[dim] for dim in space}, channel(&#39;vector&#39;))
        return vert

    def lies_inside(self, location: Tensor) -&gt; Tensor:
        location = rename_dims(location, self.resolution.names, [&#39;loc_&#39; + n for n in self.resolution.names])
        projected_loc = location[self.resolution.name_list]
        @math.map_i2b
        def lies_inside_(height, grid_bounds, bounds, fill_below, extrapolation):
            float_idx = (projected_loc - grid_bounds.lower) / grid_bounds.size * self.resolution
            if extrapolation is None:
                within_bounds = bounds.lies_inside(location)
            else:
                within_bounds = bounds[self._hdim].lies_inside(location[self._hdim])
            surface_height = math.grid_sample(height, float_idx - 1, math.NAN if extrapolation is None else extrapolation)
            is_below = location[self._hdim] &lt;= surface_height
            inside = is_below == fill_below
            result = math.where(within_bounds, inside, False)
            return rename_dims(result, [&#39;loc_&#39; + n for n in self.resolution.names], self.resolution.names)
        return math.any(lies_inside_(self._height, self.grid_bounds, self._bounds, self._fill_below, self._extrapolation), instance(self))

    def approximate_closest_surface(self, location: Tensor) -&gt; Tuple[Tensor, Tensor, Tensor, Tensor, Tensor]:
        grid_bounds = math.i2b(self.grid_bounds)
        faces = math.i2b(self._faces)
        cell_idx = cell_index(location, grid_bounds, self.resolution, clip=True)
        # --- gather face infos at projected cell ---
        normals = faces.normal[cell_idx]
        offsets = faces.origin_distance[cell_idx]
        face_idx = faces.index[cell_idx]
        # --- test location against all considered faces and boundaries ---
        # distances = plane_sgn_dist(-offsets, normals, location)  # offset has the - convention here
        distances = normals.vector @ location.vector + offsets
        projected_onto_face = location - normals * distances
        projected_idx = cell_index(projected_onto_face, grid_bounds, self.resolution, clip=False)
        projects_onto_face = math.all(projected_idx == face_idx, channel)
        proj_delta = normals * -distances
        # --- if not projected onto face, use distance to highest point instead ---
        delta_highest = faces.extrema_points[cell_idx] - location
        flat_normal = math.vec_normalize(normals[self.resolution.name_list], epsilon=1e-5)
        delta_edge = flat_normal * (delta_highest[self.resolution].vector @ flat_normal.vector)  # project onto flat normal
        delta_edge = concat([delta_edge, delta_highest[[self._hdim]]], &#39;vector&#39;)
        distance_edge = math.vec_length(delta_edge, eps=1e-5)
        delta_highest, distance_edge = math.at_min((delta_highest, distance_edge), distance_edge, &#39;extremum&#39;)
        distance_edge = math.where(distances &lt; 0, -distance_edge, distance_edge)  # copy sign of distances onto distance_edges to always return the signed distance
        distances = math.where(projects_onto_face, distances, distance_edge)
        # --- use closest face from considered ---
        delta = math.where(projects_onto_face, proj_delta, delta_highest)
        return math.at_min((distances, delta, normals, offsets, face_idx), key=abs(distances), dim=batch(&#39;consider&#39;) &amp; instance(self).as_batch())

    def shallow_equals(self, other):
        return self == other

    def __repr__(self):
        return f&#34;Heightmap {self.resolution}, bounds={self._bounds}&#34;

    def __variable_attrs__(self):
        return &#39;_height&#39;, &#39;_bounds&#39;, &#39;_max_dist&#39;, &#39;_fill_below&#39;, &#39;_extrapolation&#39;, &#39;_faces&#39;

    def __value_attrs__(self):
        return ()

    def __getitem__(self, item):
        item = slicing_dict(self, item)
        return Heightmap(self._height[item], self._bounds[item], self._max_dist[item], self._fill_below[item], self._extrapolation[item] if self._extrapolation is not None else None, math.slice(self._faces, item))

    def bounding_half_extent(self) -&gt; Tensor:
        h_min, h_max = self._faces.extrema_points[{&#39;consider&#39;: 0, &#39;vector&#39;: self._hdim}].extremum
        dh = h_max - h_min
        return stack({d: self.dx[d] if d in self.resolution else dh for d in self.vector.item_names}, channel(&#39;vector&#39;), expand_values=True) * .5

    @property
    def center(self) -&gt; Tensor:
        return self._faces.center.consider[0]

    @property
    def volume(self) -&gt; Tensor:
        return math.prod(self.bounding_half_extent() * 2, channel)

    @property
    def faces(self) -&gt; &#39;Geometry&#39;:
        raise NotImplementedError

    @property
    def face_centers(self) -&gt; Tensor:
        return self._faces.center

    @property
    def face_areas(self) -&gt; Tensor:
        raise NotImplementedError

    @property
    def face_normals(self) -&gt; Tensor:
        return self._faces.normal

    @property
    def boundary_elements(self) -&gt; Dict[Any, Dict[str, slice]]:
        return {}

    @property
    def boundary_faces(self) -&gt; Dict[Any, Dict[str, slice]]:
        return {}

    @property
    def face_shape(self) -&gt; Shape:
        return non_channel(self._faces.center)

    def approximate_signed_distance(self, location: Tensor) -&gt; Tensor:
        return self.approximate_closest_surface(location)[0]

    def sample_uniform(self, *shape: math.Shape) -&gt; Tensor:
        raise NotImplementedError

    def bounding_radius(self) -&gt; Tensor:
        return self._bounds.bounding_radius()

    def at(self, center: Tensor) -&gt; &#39;Geometry&#39;:
        raise NotImplementedError

    def rotated(self, angle: Union[float, Tensor]) -&gt; &#39;Geometry&#39;:
        raise NotImplementedError

    def scaled(self, factor: Union[float, Tensor]) -&gt; &#39;Geometry&#39;:
        raise NotImplementedError

    def __getattr__(self, item):
        if item in self.shape:
            return BoundDim(self, item)
        raise AttributeError(f&#34;{self.__class__.__name__} has no attribute &#39;{item}&#39;&#34;)</code></pre>
</details>
<div class="desc"><p>Abstract base class for N-dimensional shapes.</p>
<p>Main implementing classes:</p>
<ul>
<li><code><a title="phi.geom.Sphere" href="#phi.geom.Sphere">Sphere</a></code></li>
<li><code><a title="phi.geom.Box" href="#phi.geom.Box">Box</a></code></li>
<li><code><a title="phi.geom.Cylinder" href="#phi.geom.Cylinder">Cylinder</a></code></li>
<li><code><a title="phi.geom.Graph" href="#phi.geom.Graph">Graph</a></code></li>
<li><code><a title="phi.geom.Mesh" href="#phi.geom.Mesh">Mesh</a></code></li>
<li><code><a title="phi.geom.Heightmap" href="#phi.geom.Heightmap">Heightmap</a></code></li>
<li><code><a title="phi.geom.SDFGrid" href="#phi.geom.SDFGrid">SDFGrid</a></code></li>
<li><code><a title="phi.geom.SDF" href="#phi.geom.SDF">SDF</a></code></li>
<li><code>SplineSheet</code></li>
</ul>
<p>All geometry objects support batching.
Thereby any parameter defining the geometry can be varied along arbitrary batch dims.
All batch dimensions are listed in Geometry.shape.</p>
<p>Property getters (<code>@property</code>, such as <code>shape</code>), save for getters, must not depend on any variables marked as <em>variable</em> via <code>__variable_attrs__()</code> as these may be <code>None</code> during tracing.
Equality checks must also take this into account.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>height</code></strong></dt>
<dd>Heightmap <code>Tensor</code> of absolute (world-space) height values.
Scalar height values on a d-1 dimensional grid.</dd>
<dt><strong><code>bounds</code></strong></dt>
<dd>d-dimensional bounds.
Locations outside <code>bounds' can never lie inside this geometry if</code>extrapolation is None`.
Otherwise, only the height dimension is checked.
The grid dimensions of <code>bounds</code> must be finite but the height dimension may be infinite to count all values above/below <code>height</code> as inside.</dd>
<dt><strong><code>max_dist</code></strong></dt>
<dd>Maximum distance up to which the distance approximations should be valid.
This does not affect the number of computations performed to compute the distance.
Low values increase accuracy close to the surface but trade off possibly very wrong distances further away.</dd>
<dt><strong><code>fill_below</code></strong></dt>
<dd>Whether the inside is below or above the height values.</dd>
<dt><strong><code>extrapolation</code></strong></dt>
<dd>Surface height outside <code>bounds´. Can be any valid</code>phiml.math.Extrapolation`, such as a constant.
If not <code>None</code>, values outside <code>bounds</code> will be checked against the extrapolated <code>height</code> values.
Otherwise, values outside <code>bounds</code> always lie on the outside.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.geom._geom.Geometry</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="phi.geom.Heightmap.boundary_elements"><code class="name">prop <span class="ident">boundary_elements</span> : Dict[Any, Dict[str, slice]]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def boundary_elements(self) -&gt; Dict[Any, Dict[str, slice]]:
    return {}</code></pre>
</details>
<div class="desc"><p>Slices on the primal dimensions to mark boundary elements.
Grids and meshes have no boundary elements and return <code>{}</code>.
Dynamic graphs can define boundary elements for obstacles and walls.</p>
<h2 id="returns">Returns</h2>
<p>Map from <code>name</code> to slicing <code>dict</code>.</p></div>
</dd>
<dt id="phi.geom.Heightmap.boundary_faces"><code class="name">prop <span class="ident">boundary_faces</span> : Dict[Any, Dict[str, slice]]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def boundary_faces(self) -&gt; Dict[Any, Dict[str, slice]]:
    return {}</code></pre>
</details>
<div class="desc"><p>Slices on the dual dimensions to mark boundary faces.</p>
<p>Regular grids use the keys (dim, is_upper) to identify boundaries.
Unstructured meshes use string identifiers for the boundaries.
Dynamic graphs return slices along the dual dimensions.</p>
<h2 id="returns">Returns</h2>
<p>Map from <code>name</code> to slicing <code>dict</code>.</p></div>
</dd>
<dt id="phi.geom.Heightmap.bounds"><code class="name">prop <span class="ident">bounds</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bounds(self):
    return self._bounds</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Heightmap.center"><code class="name">prop <span class="ident">center</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def center(self) -&gt; Tensor:
    return self._faces.center.consider[0]</code></pre>
</details>
<div class="desc"><p>Center location in single channel dimension.</p></div>
</dd>
<dt id="phi.geom.Heightmap.dx"><code class="name">prop <span class="ident">dx</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def dx(self):
    return self._bounds.size[self.resolution.name_list] / spatial(self.resolution)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Heightmap.extrapolation"><code class="name">prop <span class="ident">extrapolation</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def extrapolation(self):
    return self._extrapolation</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Heightmap.face_areas"><code class="name">prop <span class="ident">face_areas</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_areas(self) -&gt; Tensor:
    raise NotImplementedError</code></pre>
</details>
<div class="desc"><p>Area of face connecting a pair of cells. Shape <code>(elements, ~)</code>.
Returns 0 for unconnected cells.</p></div>
</dd>
<dt id="phi.geom.Heightmap.face_centers"><code class="name">prop <span class="ident">face_centers</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_centers(self) -&gt; Tensor:
    return self._faces.center</code></pre>
</details>
<div class="desc"><p>Center of face connecting a pair of cells. Shape <code>(elements, ~, vector)</code>.
Here, <code>~</code> represents arbitrary internal dual dimensions, such as <code>~staggered_direction</code> or <code>~elements</code>.
Returns 0-vectors for unconnected cells.</p></div>
</dd>
<dt id="phi.geom.Heightmap.face_normals"><code class="name">prop <span class="ident">face_normals</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_normals(self) -&gt; Tensor:
    return self._faces.normal</code></pre>
</details>
<div class="desc"><p>Normal vectors of cell faces, including boundary faces. Shape <code>(elements, ~, vector)</code>.
For meshes, The vectors point out of the primal cells and into the dual cells.</p>
<p>Instance/spatial dimensions along which the normal does not vary may not be included in the result tensor's shape.</p></div>
</dd>
<dt id="phi.geom.Heightmap.face_shape"><code class="name">prop <span class="ident">face_shape</span> : phiml.math._shape.Shape</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_shape(self) -&gt; Shape:
    return non_channel(self._faces.center)</code></pre>
</details>
<div class="desc"><h2 id="returns">Returns</h2>
<p>Full Shape to identify each face of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>, including instance/spatial dimensions for the elements and dual dimensions listing the faces per element.
If this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> has no faces, returns an empty <code>Shape</code>.</p></div>
</dd>
<dt id="phi.geom.Heightmap.faces"><code class="name">prop <span class="ident">faces</span> : <a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def faces(self) -&gt; &#39;Geometry&#39;:
    raise NotImplementedError</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Heightmap.fill_below"><code class="name">prop <span class="ident">fill_below</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def fill_below(self):
    return self._fill_below</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Heightmap.grid_bounds"><code class="name">prop <span class="ident">grid_bounds</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def grid_bounds(self):
    return self._bounds[self.resolution.name_list]</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Heightmap.height"><code class="name">prop <span class="ident">height</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def height(self):
    return self._height</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Heightmap.max_dist"><code class="name">prop <span class="ident">max_dist</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def max_dist(self):
    return self._max_dist</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Heightmap.resolution"><code class="name">prop <span class="ident">resolution</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def resolution(self):
    return spatial(self._height) - 1</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Heightmap.shape"><code class="name">prop <span class="ident">shape</span> : phiml.math._shape.Shape</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape(self) -&gt; Shape:
    return (self._height.shape - 1) &amp; channel(self._bounds)</code></pre>
</details>
<div class="desc"><p>The <code>shape</code> of a <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> consists of the following dimensions:</p>
<ul>
<li>A single <em>channel</em> dimension called <code>'vector'</code> specifying the physical space</li>
<li>Instance dimensions denote that this geometry consists of multiple copies in the same space</li>
<li>Spatial dimensions denote a crystal (repeating structure) of this geometric primitive in space</li>
<li>Batch dimensions indicate non-interacting versions of this geometry for parallelization only.</li>
</ul></div>
</dd>
<dt id="phi.geom.Heightmap.up"><code class="name">prop <span class="ident">up</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def up(self):
    dims = self._bounds.vector.item_names
    height_unit = vec(**{d: 1 if d == self._hdim else 0 for d in dims})
    return math.where(self._fill_below, height_unit, -height_unit)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Heightmap.vertices"><code class="name">prop <span class="ident">vertices</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def vertices(self):
    hdim = self._hdim
    space = self.vector.item_names
    pos = self.grid_bounds.local_to_global(math.meshgrid(spatial(self._height)) / self.resolution)
    vert = stack({dim: self.height if dim == hdim else pos[dim] for dim in space}, channel(&#39;vector&#39;))
    return vert</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Heightmap.volume"><code class="name">prop <span class="ident">volume</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def volume(self) -&gt; Tensor:
    return math.prod(self.bounding_half_extent() * 2, channel)</code></pre>
</details>
<div class="desc"><p><code>phi.math.Tensor</code> representing the volume of each element.
The result retains batch, spatial and instance dimensions.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phi.geom.Heightmap.approximate_closest_surface"><code class="name flex">
<span>def <span class="ident">approximate_closest_surface</span></span>(<span>self, location: phiml.math._tensors.Tensor) ‑> Tuple[phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def approximate_closest_surface(self, location: Tensor) -&gt; Tuple[Tensor, Tensor, Tensor, Tensor, Tensor]:
    grid_bounds = math.i2b(self.grid_bounds)
    faces = math.i2b(self._faces)
    cell_idx = cell_index(location, grid_bounds, self.resolution, clip=True)
    # --- gather face infos at projected cell ---
    normals = faces.normal[cell_idx]
    offsets = faces.origin_distance[cell_idx]
    face_idx = faces.index[cell_idx]
    # --- test location against all considered faces and boundaries ---
    # distances = plane_sgn_dist(-offsets, normals, location)  # offset has the - convention here
    distances = normals.vector @ location.vector + offsets
    projected_onto_face = location - normals * distances
    projected_idx = cell_index(projected_onto_face, grid_bounds, self.resolution, clip=False)
    projects_onto_face = math.all(projected_idx == face_idx, channel)
    proj_delta = normals * -distances
    # --- if not projected onto face, use distance to highest point instead ---
    delta_highest = faces.extrema_points[cell_idx] - location
    flat_normal = math.vec_normalize(normals[self.resolution.name_list], epsilon=1e-5)
    delta_edge = flat_normal * (delta_highest[self.resolution].vector @ flat_normal.vector)  # project onto flat normal
    delta_edge = concat([delta_edge, delta_highest[[self._hdim]]], &#39;vector&#39;)
    distance_edge = math.vec_length(delta_edge, eps=1e-5)
    delta_highest, distance_edge = math.at_min((delta_highest, distance_edge), distance_edge, &#39;extremum&#39;)
    distance_edge = math.where(distances &lt; 0, -distance_edge, distance_edge)  # copy sign of distances onto distance_edges to always return the signed distance
    distances = math.where(projects_onto_face, distances, distance_edge)
    # --- use closest face from considered ---
    delta = math.where(projects_onto_face, proj_delta, delta_highest)
    return math.at_min((distances, delta, normals, offsets, face_idx), key=abs(distances), dim=batch(&#39;consider&#39;) &amp; instance(self).as_batch())</code></pre>
</details>
<div class="desc"><p>Find the closest surface face of this geometry given a point that can be outside or inside the geometry.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd><code>Tensor</code> with a single channel dimension called vector. Can have arbitrary other dimensions.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>signed_distance</code></dt>
<dd>Scalar signed distance from <code>location</code>
to the closest point on the surface.
Positive values indicate the point lies outside the geometry, negative values indicate the point lies inside the geometry.</dd>
<dt><code>delta</code></dt>
<dd>Vector-valued distance vector from <code>location</code> to the closest point on the surface.</dd>
<dt><code>normal</code></dt>
<dd>Closest surface normal vector.</dd>
<dt><code>offset</code></dt>
<dd>Min distance of a surface-tangential plane from 0 as a scalar.</dd>
<dt><code>face_index</code></dt>
<dd>(Optional) An index vector pointing at the closest face.</dd>
</dl></div>
</dd>
<dt id="phi.geom.Heightmap.approximate_signed_distance"><code class="name flex">
<span>def <span class="ident">approximate_signed_distance</span></span>(<span>self, location: phiml.math._tensors.Tensor) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def approximate_signed_distance(self, location: Tensor) -&gt; Tensor:
    return self.approximate_closest_surface(location)[0]</code></pre>
</details>
<div class="desc"><p>Computes the approximate distance from location to the surface of the geometry.
Locations outside return positive values, inside negative values and zero exactly at the boundary.</p>
<p>The exact distance metric used depends on the geometry.
The approximation holds close to the surface and the distance grows to infinity as the location is moved infinitely far from the geometry.
The distance metric is differentiable and its gradients are bounded at every point in space.</p>
<p>When dealing with unions or collections of geometries (instance dimensions), the shortest distance to any instance is returned.
This also holds for negative distances.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd><code>Tensor</code> with one channel dim <code>vector</code> matching the geometry's <code>vector</code> dim.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Float <code>Tensor</code></p></div>
</dd>
<dt id="phi.geom.Heightmap.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>self, center: phiml.math._tensors.Tensor) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def at(self, center: Tensor) -&gt; &#39;Geometry&#39;:
    raise NotImplementedError</code></pre>
</details>
<div class="desc"><p>Returns a copy of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> with the center at <code>center</code>.
This is equal to calling <code>self @ center</code>.</p>
<p>See Also:
<code><a title="phi.geom.Geometry.shifted" href="#phi.geom.Geometry.shifted">Geometry.shifted()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>center</code></strong></dt>
<dd>New center as <code>Tensor</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.</p></div>
</dd>
<dt id="phi.geom.Heightmap.bounding_half_extent"><code class="name flex">
<span>def <span class="ident">bounding_half_extent</span></span>(<span>self) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bounding_half_extent(self) -&gt; Tensor:
    h_min, h_max = self._faces.extrema_points[{&#39;consider&#39;: 0, &#39;vector&#39;: self._hdim}].extremum
    dh = h_max - h_min
    return stack({d: self.dx[d] if d in self.resolution else dh for d in self.vector.item_names}, channel(&#39;vector&#39;), expand_values=True) * .5</code></pre>
</details>
<div class="desc"><p>The bounding half-extent sets a limit on the outer-most point for each coordinate axis.
Each component is non-negative.</p>
<p>Let the bounding half-extent have value <code>e</code> in dimension <code>d</code> (<code>extent[...,d] = e</code>).
Then, no point of the geometry lies further away from its center point than <code>e</code> along <code>d</code> (in both axis directions).</p>
<p>If this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.
If these dims are not present on the result, all parts are assumed to have the same bounds.</p></div>
</dd>
<dt id="phi.geom.Heightmap.bounding_radius"><code class="name flex">
<span>def <span class="ident">bounding_radius</span></span>(<span>self) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bounding_radius(self) -&gt; Tensor:
    return self._bounds.bounding_radius()</code></pre>
</details>
<div class="desc"><p>Returns the radius of a Sphere object that fully encloses this geometry.
The sphere is centered at the center of this geometry.</p>
<p>If this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.
If these dims are not present on the result, all parts are assumed to have the same bounds.</p></div>
</dd>
<dt id="phi.geom.Heightmap.lies_inside"><code class="name flex">
<span>def <span class="ident">lies_inside</span></span>(<span>self, location: phiml.math._tensors.Tensor) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lies_inside(self, location: Tensor) -&gt; Tensor:
    location = rename_dims(location, self.resolution.names, [&#39;loc_&#39; + n for n in self.resolution.names])
    projected_loc = location[self.resolution.name_list]
    @math.map_i2b
    def lies_inside_(height, grid_bounds, bounds, fill_below, extrapolation):
        float_idx = (projected_loc - grid_bounds.lower) / grid_bounds.size * self.resolution
        if extrapolation is None:
            within_bounds = bounds.lies_inside(location)
        else:
            within_bounds = bounds[self._hdim].lies_inside(location[self._hdim])
        surface_height = math.grid_sample(height, float_idx - 1, math.NAN if extrapolation is None else extrapolation)
        is_below = location[self._hdim] &lt;= surface_height
        inside = is_below == fill_below
        result = math.where(within_bounds, inside, False)
        return rename_dims(result, [&#39;loc_&#39; + n for n in self.resolution.names], self.resolution.names)
    return math.any(lies_inside_(self._height, self.grid_bounds, self._bounds, self._fill_below, self._extrapolation), instance(self))</code></pre>
</details>
<div class="desc"><p>Tests whether the given location lies inside or outside of the geometry. Locations on the surface count as inside.</p>
<p>When dealing with unions or collections of geometries (instance dimensions), a point lies inside the geometry if it lies inside any instance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd>float tensor of shape (batch_size, &hellip;, rank)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>bool tensor of shape (*location.shape[:-1], 1).</p></div>
</dd>
<dt id="phi.geom.Heightmap.rotated"><code class="name flex">
<span>def <span class="ident">rotated</span></span>(<span>self, angle: phiml.math._tensors.Tensor | float) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotated(self, angle: Union[float, Tensor]) -&gt; &#39;Geometry&#39;:
    raise NotImplementedError</code></pre>
</details>
<div class="desc"><p>Returns a rotated version of this geometry.
The geometry is rotated about its center point.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>angle</code></strong></dt>
<dd>
<p>Delta rotation.
Either</p>
<ul>
<li>Angle(s): scalar angle in 2d or euler angles along <code>vector</code> in 3D or higher.</li>
<li>Matrix: d⨯d rotation matrix</li>
</ul>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Rotated <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></p></div>
</dd>
<dt id="phi.geom.Heightmap.sample_uniform"><code class="name flex">
<span>def <span class="ident">sample_uniform</span></span>(<span>self, *shape: phiml.math._shape.Shape) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_uniform(self, *shape: math.Shape) -&gt; Tensor:
    raise NotImplementedError</code></pre>
</details>
<div class="desc"><p>Samples uniformly distributed random points inside this volume.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*shape</code></strong></dt>
<dd>How many points to sample per individual geometry.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>Tensor</code> containing all dimensions from <code><a title="phi.geom.Geometry.shape" href="#phi.geom.Geometry.shape">Geometry.shape</a></code>, <code>shape</code> as well as a <code>channel</code> dimension <code>vector</code> matching the dimensionality of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.</p></div>
</dd>
<dt id="phi.geom.Heightmap.scaled"><code class="name flex">
<span>def <span class="ident">scaled</span></span>(<span>self, factor: phiml.math._tensors.Tensor | float) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scaled(self, factor: Union[float, Tensor]) -&gt; &#39;Geometry&#39;:
    raise NotImplementedError</code></pre>
</details>
<div class="desc"><p>Scales each individual geometry by <code>factor</code>.
The individual <code>center</code> points act as pivots for the operation.</p>
<h2 id="args">Args</h2>
<p>factor:
Returns:</p></div>
</dd>
<dt id="phi.geom.Heightmap.shallow_equals"><code class="name flex">
<span>def <span class="ident">shallow_equals</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shallow_equals(self, other):
    return self == other</code></pre>
</details>
<div class="desc"><p>Quick equality check.
May return <code>False</code> even if <code>other == self</code>.
However, if <code>True</code> is returned, the geometries are guaranteed to be equal.</p>
<p>The <code>shallow_equals()</code> check does not compare all tensor elements but merely checks whether the same tensors are referenced.</p></div>
</dd>
</dl>
</dd>
<dt id="phi.geom.Mesh"><code class="flex name class">
<span>class <span class="ident">Mesh</span></span>
<span>(</span><span>vertices: phi.geom._geom.Geometry,<br>elements: phiml.math._tensors.Tensor,<br>element_rank: int,<br>boundaries: Dict[str, Dict[str, slice]],<br>periodic: Sequence[str],<br>face_format: str = 'csc',<br>max_cell_walk: int = None,<br>variable_attrs: Tuple[str, ...] = ('vertices',),<br>value_attrs: Tuple[str, ...] = ())</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(frozen=True)
class Mesh(Geometry):
    &#34;&#34;&#34;
    Unstructured mesh, consisting of vertices and elements.
    
    Use `phi.geom.mesh()` or `phi.geom.mesh_from_numpy()` to construct a mesh manually or `phi.geom.load_su2()` to load one from a file.
    &#34;&#34;&#34;

    vertices: Geometry
    &#34;&#34;&#34; Vertices are represented by a `Geometry` instance with an instance dim. &#34;&#34;&#34;
    elements: Tensor
    &#34;&#34;&#34; elements: Sparse `Tensor` listing ordered vertex indices per element (solid or surface element, depending on `element_rank`).
    Must have one instance dim listing the elements and the corresponding dual dim to `vertices`.
    The vertex count of an element is equal to the number of elements in that row (i.e. summing the dual dim). &#34;&#34;&#34;
    element_rank: int
    &#34;&#34;&#34;The spatial rank of the elements. Solid elements have the same as the ambient space, faces one less.&#34;&#34;&#34;
    boundaries: Dict[str, Dict[str, slice]]
    &#34;&#34;&#34;Slices to retrieve boundary face values.&#34;&#34;&#34;
    periodic: Sequence[str]
    &#34;&#34;&#34;List of axis names that are periodic. Periodic boundaries must be named as axis- and axis+. For example `[&#39;x&#39;]` will connect the boundaries x- and x+.&#34;&#34;&#34;
    face_format: str = &#39;csc&#39;
    &#34;&#34;&#34;Sparse matrix format for storing quantities that depend on a pair of neighboring elements, e.g. `face_area`, `face_normal`, `face_center`.&#34;&#34;&#34;
    max_cell_walk: int = None
    &#34;&#34;&#34; Maximum number of steps to walk along the element connectivity in order to find a cell, e.g. for sampling at an arbitrary point.&#34;&#34;&#34;

    variable_attrs: Tuple[str, ...] = (&#39;vertices&#39;,)  # PhiML keyword
    value_attrs: Tuple[str, ...] = ()  # PhiML keyword

    def __post_init__(self):
        if spatial(self.elements):
            assert self.elements.dtype.kind == int, f&#34;elements listing vertices must be integer lists but got dtype {self.elements.dtype}&#34;
        else:
            assert self.elements.dtype.kind == bool, f&#34;element matrices must be of type bool but got {self.elements.dtype}&#34;

    @cached_property
    def shape(self) -&gt; Shape:
        return non_dual(self.elements) &amp; channel(self.vertices) &amp; batch(self.vertices)

    @cached_property
    def cell_count(self):
        return instance(self.elements).size

    @cached_property
    def center(self) -&gt; Tensor:
        if self.element_rank == self.spatial_rank:  # Compute volumetric center from faces
            return sum_(self.face_centers * self.face_areas, dual) / sum_(self.face_areas, dual)
        else:  # approximate center from vertices
            return self._vertex_mean

    @cached_property
    def _vertex_mean(self):
        &#34;&#34;&#34;Mean vertex location per element.&#34;&#34;&#34;
        vertex_count = sum_(self.elements, instance(self.vertices).as_dual())
        return (self.elements @ self.vertices.center) / vertex_count

    @cached_property
    def face_centers(self) -&gt; Tensor:
        return self._faces[&#39;center&#39;]

    @property
    def face_areas(self) -&gt; Tensor:
        return self._faces[&#39;area&#39;]

    @cached_property
    def face_normals(self) -&gt; Tensor:
        if self.element_rank == self.spatial_rank:  # this cannot depend on element centers because that depends on the normals.
            normals = self._faces[&#39;normal&#39;]
            face_centers = self._faces[&#39;center&#39;]
            normals_out = normals.vector * (face_centers - self._vertex_mean).vector &gt; 0
            normals = where(normals_out, normals, -normals)
            return normals
        raise NotImplementedError

    @cached_property
    def _faces(self) -&gt; Dict[str, Any]:
        centers, normals, areas, boundary_slices = build_faces(self.vertices.center, self.elements, self.boundaries, self.element_rank, self.periodic, self._vertex_mean, self.face_format)
        return {
            &#39;center&#39;: centers,
            &#39;normal&#39;: normals,
            &#39;area&#39;: areas,
            &#39;boundary_slices&#39;: boundary_slices,
        }

    def _build_faces(self):
        return build_faces(self.vertices.center, self.elements, self.boundaries, self.element_rank, self.periodic, self._vertex_mean, self.face_format)

    @property
    def face_shape(self) -&gt; Shape:
        if not self.boundary_faces:
            return instance(self) &amp; dual
        dual_len = max([next(iter(sl.values())).stop for sl in self.boundary_faces.values()])
        dim = instance(self)
        return dim.as_dual().with_size(dual_len) + dim

    @property
    def sets(self):
        return {
            &#39;center&#39;: non_batch(self)-&#39;vector&#39;,
            &#39;vertex&#39;: instance(self.vertices),
            &#39;~vertex&#39;: dual(self.elements)
        }

    def get_points(self, set_key: str) -&gt; Tensor:
        if set_key == &#39;vertex&#39;:
            return self.vertices.center
        elif set_key == &#39;~vertex&#39;:
            return si2d(self.vertices.center)
        else:
            return Geometry.get_points(self, set_key)

    def get_boundary(self, set_key: str) -&gt; Dict[str, Dict[str, slice]]:
        if set_key in [&#39;vertex&#39;, &#39;~vertex&#39;]:
            return {}
        return Geometry.get_boundary(self, set_key)

    @property
    def boundary_elements(self) -&gt; Dict[str, Dict[str, slice]]:
        return {}

    @property
    def boundary_faces(self) -&gt; Dict[str, Dict[str, slice]]:
        if self.boundaries is None:
            return {}
        return self._faces[&#39;boundary_slices&#39;]

    @property
    def all_boundary_faces(self) -&gt; Dict[str, slice]:
        if self.face_shape.dual.size == self.elements.shape.instance.size:
            return {}
        return {self.face_shape.dual.name: slice(instance(self).volume, None)}

    @property
    def interior_faces(self) -&gt; Dict[str, slice]:
        return {self.face_shape.dual.name: slice(0, instance(self).volume)}

    def pad_boundary(self, value: Tensor, widths: Dict[str, Dict[str, slice]] = None, mode: Extrapolation or Tensor or Number = 0, **kwargs) -&gt; Tensor:
        mode = as_extrapolation(mode)
        if self.face_shape.dual.name not in value.shape:
            value = rename_dims(value, instance, self.face_shape.dual.without_sizes())
        else:
            raise NotImplementedError
        if widths is None:
            widths = self.boundary_faces
        if isinstance(widths, dict) and len(widths) == 0:
            return value
        if isinstance(widths, (tuple, list)):
            if len(widths) == 0 or isinstance(widths[0], dict):  # add sliced-off slices
                pass
        dim = next(iter(next(iter(widths.values()))))
        slices = [slice(0, value.shape.get_size(dim))]
        values = [value]
        connectivity = self.connectivity
        for name, b_slice in widths.items():
            if b_slice[dim].stop - b_slice[dim].start &gt; 0:
                slices.append(b_slice[dim])
                values.append(mode.sparse_pad_values(value, connectivity[b_slice], name, mesh=self, **kwargs))
        perm = np.argsort([s.start for s in slices])
        ordered_pieces = [values[i] for i in perm]
        return concat(ordered_pieces, dim, expand_values=True)

    @cached_property
    def cell_connectivity(self) -&gt; Tensor:
        &#34;&#34;&#34;
        Returns a bool-like matrix whose non-zero entries denote connected elements.
        In meshes or grids, elements are connected if they share a face in 3D, an edge in 2D, or a vertex in 1D.

        Returns:
            `Tensor` of shape (elements, ~elements)
        &#34;&#34;&#34;
        return self.connectivity[self.interior_faces]

    @cached_property
    def boundary_connectivity(self) -&gt; Tensor:
        if not self.all_boundary_faces:
            dual_dim = instance(self).as_dual().with_size(0)
            return zeros(instance(self) &amp; dual_dim)
        return self.connectivity[self.all_boundary_faces]

    @cached_property
    def distance_matrix(self):
        return vec_length(pairwise_distances(self.center, edges=self.cell_connectivity, format=&#39;as edges&#39;, default=None))

    def faces_to_vertices(self, values: Tensor, reduce=sum):
        v = stored_values(values, invalid=&#39;keep&#39;)  # ToDo replace this once PhiML has support for dense instance dims and sparse scatter
        i = stored_values(self.face_vertices, invalid=&#39;keep&#39;)
        i = rename_dims(i, channel, instance)
        out_shape = non_channel(self.vertices) &amp; shape(values).without(self.face_shape)
        return scatter(out_shape, i, v, mode=reduce, outside_handling=&#39;undefined&#39;)

    @cached_property
    def _cell_deltas(self):
        bounds = bounding_box(self.vertices)
        periodic = {dim[:-len(&#39;[::-1]&#39;)] if dim.endswith(&#39;[::-1]&#39;) else dim: dim.endswith(&#39;[::-1]&#39;) for dim in self.periodic}
        is_periodic = dim_mask(self.vector.item_names, tuple(periodic))
        return pairwise_distances(self.center, format=self.cell_connectivity, periodic=is_periodic, domain=(bounds.lower, bounds.upper))

    @cached_property
    def relative_face_distance(self):
        &#34;&#34;&#34;|face_center - center| / |neighbor_center - center|&#34;&#34;&#34;
        cell_distances = vec_length(self._cell_deltas)
        assert (cell_distances &gt; 0).all, f&#34;All cells must have distance &gt; 0 but found 0 distance at {nonzero(cell_distances == 0)}&#34;
        face_distances = vec_length(self.face_centers[self.interior_faces] - self.center)
        return concat([face_distances / cell_distances, self.boundary_connectivity], self.face_shape.dual)

    @cached_property
    def neighbor_offsets(self):
        &#34;&#34;&#34;Returns shift vector to neighbor centroids and boundary faces.&#34;&#34;&#34;
        if not self.all_boundary_faces:
            return self._cell_deltas
        boundary_deltas = (self.face_centers - self.center)[self.all_boundary_faces]
        # assert (vec_length(boundary_deltas) &gt; 0).all, f&#34;All boundary faces must be separated from the cell centers but 0 distance at the following {channel(stored_indices(boundary_deltas)).item_names[0]}:\n{nonzero(vec_length(boundary_deltas) == 0):full}&#34;
        return concat([self._cell_deltas, boundary_deltas], self.face_shape.dual)

    @cached_property
    def neighbor_distances(self):
        return vec_length(self.neighbor_offsets)

    @property
    def faces(self) -&gt; &#39;Geometry&#39;:
        &#34;&#34;&#34;
        Assembles information about the boundaries of the elements that make up the surface.
        For 2D elements, the faces are edges, for 3D elements, the faces are planar elements.

        Returns:
            center: Center of face connecting a pair of elements. Shape (~elements, elements, vector).
                Returns 0-vectors for unconnected elements.
            area: Area of face connecting a pair of elements. Shape (~elements, elements).
                Returns 0 for unconnected elements.
            normal: Normal vector of face connecting a pair of elements. Shape (~elements, elements, vector).
                Unconnected elements are assigned the vector 0.
                The vector points out of polygon and into ~polygon.
        &#34;&#34;&#34;
        return Point(self.face_centers)

    @property
    def connectivity(self) -&gt; Tensor:
        return self.element_connectivity

    @cached_property
    def element_connectivity(self) -&gt; Tensor:
        &#34;&#34;&#34;Neighbor element connectivity, excluding diagonal.&#34;&#34;&#34;
        if self.element_rank == self.spatial_rank:
            if is_sparse(self.face_areas):
                return tensor_like(self.face_areas, True)
            else:
                return self.face_areas &gt; 0
        else:  # fallback with no boundaries
            coo = to_format(self.elements, &#39;coo&#39;).numpy()
            connected_elements = coo @ coo.T
            connected_elements.setdiag(0)
            connected_elements.eliminate_zeros()
            connected_elements.data = np.ones_like(connected_elements.data)
            element_connectivity = wrap(connected_elements, instance(self.elements), instance(self.elements).as_dual())
            return element_connectivity

    @cached_property
    def vertex_connectivity(self) -&gt; Tensor:
        if isinstance(self.vertices, Graph):
            return self.vertices.connectivity
        elif self.element_rank &lt;= 2:
            def single_vertex_connectivity(elements: Tensor):
                indices = stored_indices(elements).index[dual(elements).name]
                idx1 = indices.numpy()
                v_count = sum_(elements, dual).numpy()
                ptr_end = np.cumsum(v_count)
                roll = np.arange(idx1.size) + 1
                roll[ptr_end-1] = ptr_end - v_count
                idx2 = idx1[roll]
                v_conn = coo_matrix((np.ones(idx1.size, dtype=bool), (idx1, idx2)), shape=(dual(elements).size,)*2).tocsr()
                return wrap(v_conn, dual(elements).as_instance(), dual(elements))
            return math.map(single_vertex_connectivity, self.elements, dims=batch)
        raise NotImplementedError

    @cached_property
    def vertex_graph(self) -&gt; Graph:
        return self.vertices if isinstance(self.vertices, Graph) else graph(self.vertices, self.vertex_connectivity)

    def filter_unused_vertices(self) -&gt; &#39;Mesh&#39;:
        coo = to_format(self.elements, &#39;coo&#39;).numpy()
        has_element = np.asarray(coo.sum(0) &gt; 0)[0]
        new_index = np.cumsum(has_element) - 1
        new_index_t = wrap(new_index, dual(self.elements))
        has_element = wrap(has_element, instance(self.vertices))
        # has_element_d = si2d(has_element)
        vertices = self.vertices[has_element]
        # v_normals = self.vertex_normals[has_element_d]
        # if self._vertex_connectivity is not None:
        #     vertex_connectivity = stored_indices(self._vertex_connectivity).index.as_batch()
        #     vertex_connectivity = new_index_t[{dual: vertex_connectivity}].index.as_channel()
        #     vertex_connectivity = sparse_tensor(vertex_connectivity, stored_values(self._vertex_connectivity), non_batch(self._vertex_connectivity).with_sizes(instance(vertices).size), False)
        if isinstance(self.elements, CompactSparseTensor):
            indices = new_index_t[{dual: self.elements._indices}]
            elements = CompactSparseTensor(indices, self.elements._values, self.elements._compressed_dims.with_size(instance(vertices).volume), self.elements._indices_constant, self.elements._matrix_rank)
        else:
            filtered_coo = coo_matrix((coo.data, (coo.row, new_index[coo.col])), shape=(instance(self.elements).volume, instance(vertices).volume))  # ToDo keep sparse format
            elements = wrap(filtered_coo, self.elements.shape.without_sizes())
        return replace(self, vertices=vertices, elements=elements)

    @cached_property
    def volume(self) -&gt; Tensor:
        if self.element_rank == 2:
            if instance(self.elements).volume &gt; 0:
                three_vertices = nonzero(self.elements, 3, list_dims=dual)
                v1, v2, v3 = unstack(self.vertices.center[{instance: three_vertices}], dual)
                cross_area = vec_length(cross(v2-v1, v3-v1))
                vertex_count = math.sum(self.elements, dual)
                fac = where(vertex_count == 3, 0.5, 1)  # tri, quad, ...
                return fac * cross_area
            else:
                return zeros(instance(self.vertices))  # empty mesh
        elif self.element_rank == self.spatial_rank:
            vol_contributions = (self.face_centers.vector @ self.face_normals.vector) * self.face_areas
            return sum_(vol_contributions, dual) / self.spatial_rank
        raise NotImplementedError


    @property
    def normals(self) -&gt; Tensor:
        &#34;&#34;&#34;Extrinsic element normal space. This is a 0D vector for solid elements and 1D for surface elements.&#34;&#34;&#34;
        if self.element_rank == 2:
            three_vertices = nonzero(self.elements, 3, list_dims=dual)
            v1, v2, v3 = unstack(self.vertices.center[{instance: three_vertices}], dual)
            return vec_normalize(cross(v2 - v1, v3 - v1))
        raise NotImplementedError

    @property
    def vertex_normals(self) -&gt; Tensor:
        v_normals = mean(self.elements * self.normals, instance)  # (~vertices,vector)
        return vec_normalize(v_normals)

    @property
    def vertex_positions(self) -&gt; Tensor:
        &#34;&#34;&#34;Lists the vertex centers along the corresponding dual dim to `self.vertices.center`.&#34;&#34;&#34;
        return si2d(self.vertices.center)

    @cached_property
    def _v_kdtree_i(self):
        return math.find_closest(self.vertices.center, method=&#39;kd&#39;)

    def closest_vertex(self, location: Tensor):
        idx = self._v_kdtree_i(location)
        v_pos = self.vertices.center[idx]
        return idx, v_pos - location

    def lies_inside(self, location: Tensor) -&gt; Tensor:
        idx = find_closest(self.center, location)
        for i in range(self.max_cell_walk):
            idx, leaves_mesh, is_outside, *_ = self.cell_walk_towards(location, idx, allow_exit=i == self.max_cell_walk - 1)
        return ~(leaves_mesh &amp; is_outside)

    def approximate_signed_distance(self, location: Union[Tensor, tuple]) -&gt; Tensor:
        if self.element_rank == 2 and self.spatial_rank == 3:
            closest_elem = find_closest(self.center, location)
            center = self.center[closest_elem]
            normal = self.normals[closest_elem]
            return plane_sgn_dist(center, normal, location)
        idx = find_closest(self.center, location)
        for i in range(self.max_cell_walk):
            idx, leaves_mesh, is_outside, distances, nb_idx = self.cell_walk_towards(location, idx, allow_exit=False)
        return math.max(distances, dual)

    def approximate_closest_surface(self, location: Tensor) -&gt; Tuple[Tensor, Tensor, Tensor, Tensor, Tensor]:
        def acs_single_mesh(self: Mesh, location: Tensor):
            if self.element_rank == 2 and self.spatial_rank == 3:
                closest_elem = find_closest(self.center, location)
                normal = self.normals[closest_elem]
                if math.get_format(self.elements) == &#39;compact-cols&#39; and dual(self.elements._indices).size == 3:  # triangle mesh
                    three_vertices = self.elements[closest_elem]._indices
                    v1, v2, v3 = unstack(self.vertices.center[{instance: three_vertices}], dual(self.elements))
                    surf_pos = closest_on_triangle(v1, v2, v3, location, exact_edges=True)
                    delta = surf_pos - location
                    sgn_dist = vec_length(delta) * -sign(delta.vector @ normal)
                    return sgn_dist, delta, normal, None, closest_elem
                center = self.center[closest_elem]
                face_size = sqrt(self.volume) * 2
                size = face_size[closest_elem]
                sgn_dist = plane_sgn_dist(center, normal, location)
                delta_far = center - location  # this is not accurate...
                delta_near = normal * -sgn_dist
                far_fac = minimum(1, abs(sgn_dist) / size)
                delta = far_fac * delta_far + (1 - far_fac) * delta_near
                return sgn_dist, delta, normal, None, closest_elem
            # idx = find_closest(self.center, location)
            # for i in range(self.max_cell_walk):
            #     idx, leaves_mesh, is_outside, distances, nb_idx = self.cell_walk_towards(location, idx, allow_exit=False)
            # sgn_dist = max(distances, dual)
            # cell_normals = self.face_normals[idx]
            # normal = cell_normals[{dual: nb_idx}]
            # return sgn_dist, delta, normal, offset, face_index
            raise NotImplementedError
        return math.map(acs_single_mesh, self, location, dims=batch(self.elements), map_name=&#34;Mesh.approximate_closest_surface&#34;)

    def cell_walk_towards(self, location: Tensor, start_cell_idx: Tensor, allow_exit=False):
        &#34;&#34;&#34;
        If `location` is not within the cell at index `from_cell_idx`, moves to a closer neighbor cell.

        Args:
            location: Target location as `Tensor`.
            start_cell_idx: Index of starting cell. Must be a valid cell index.
            allow_exit: If `True`, returns an invalid index for points outside the mesh, otherwise keeps the current index.

        Returns:
            index: Index of the neighbor cell or starting cell.
            leaves_mesh: Whether the walk crossed the mesh boundary. Then `index` is invalid. This is only possible if `allow_exit` is true.
            is_outside: Whether `location` was outside the cell at index `start_cell_idx`.
        &#34;&#34;&#34;
        closest_normals = self.face_normals[start_cell_idx]
        closest_face_centers = self.face_centers[start_cell_idx]
        offsets = closest_normals.vector @ closest_face_centers.vector  # this dot product could be cashed in the mesh
        distances = closest_normals.vector @ location.vector - offsets
        is_outside = math.any(distances &gt; 0, dual)
        nb_idx = argmax(distances, dual).index[0]  # cell index or boundary face index
        leaves_mesh = nb_idx &gt;= instance(self).volume
        next_idx = where(is_outside &amp; (~leaves_mesh | allow_exit), nb_idx, start_cell_idx)
        return next_idx, leaves_mesh, is_outside, distances, nb_idx

    def sample_uniform(self, *shape: Shape) -&gt; Tensor:
        raise NotImplementedError

    def bounding_radius(self) -&gt; Tensor:
        center = self.elements * self.center
        vert_pos = rename_dims(self.vertices.center, instance, dual)
        dist_to_vert = vec_length(vert_pos - center)
        max_dist = math.max(dist_to_vert, dual)
        return max_dist

    def bounding_half_extent(self) -&gt; Tensor:
        center = self.elements * self.center
        vert_pos = rename_dims(self.vertices.center, instance, dual)
        max_delta = math.max(abs(vert_pos - center), dual)
        return max_delta

    def bounding_box(self) -&gt; &#39;Box&#39;:
        return self.vertices.bounding_box()

    @property
    def bounds(self):
        return Box(math.min(self.vertices.center, instance), math.max(self.vertices.center, instance))

    def at(self, center: Tensor) -&gt; &#39;Mesh&#39;:
        if instance(self.elements) in center.shape:
            raise NotImplementedError(&#34;Setting Mesh positions only supported for vertices, not elements&#34;)
        if dual(self.elements) in center.shape:
            center = rename_dims(center, dual, instance(self.vertices))
        if instance(self.vertices) in center.shape:
            vertices = self.vertices.at(center)
            return replace(self, vertices=vertices)
        else:
            return self.shifted(center - self.bounds.center)

    def shifted(self, delta: Tensor) -&gt; &#39;Mesh&#39;:
        if instance(self.elements) in delta.shape:
            raise NotImplementedError(&#34;Shifting Mesh positions only supported for vertices, not elements&#34;)
        if dual(self.elements) in delta.shape:
            delta = rename_dims(delta, dual, instance(self.vertices))
        if instance(self.vertices) in delta.shape:
            vertices = self.vertices.shifted(delta)
            return replace(self, vertices=vertices)
        else:  # shift everything
            # ToDo transfer cached properties
            # copy: center+delta, normals, volume, face_centers+delta, face_areas, face_normals, vertex_normals, vertex_connectivity, element_connectivity
            vertices = self.vertices.shifted(delta)
            return replace(self, vertices=vertices)

    def rotated(self, angle: Union[float, Tensor]) -&gt; &#39;Geometry&#39;:
        raise NotImplementedError

    def scaled(self, factor: Union[float, Tensor]) -&gt; &#39;Geometry&#39;:
        pivot = self.bounds.center
        vertices = scale(self.vertices, factor, pivot)
        # center = scale(Point(self.center), factor, pivot).center
        # volume = self.volume * factor**self.element_rank if self.volume is not None else None
        return replace(self, vertices=vertices)

    def __getitem__(self, item):
        item: dict = slicing_dict(self, item)
        assert not dual(self.elements).only(tuple(item)), f&#34;Cannot slice vertex lists (&#39;{spatial(self.elements)}&#39;) but got slicing dict {item}&#34;
        return getitem(self, item, keepdims=[(self.shape.instance - instance(self.vertices)).name, &#39;vector&#39;])

    def __repr__(self):
        return Geometry.__repr__(self)</code></pre>
</details>
<div class="desc"><p>Unstructured mesh, consisting of vertices and elements.</p>
<p>Use <code><a title="phi.geom.mesh" href="#phi.geom.mesh">mesh()</a></code> or <code><a title="phi.geom.mesh_from_numpy" href="#phi.geom.mesh_from_numpy">mesh_from_numpy()</a></code> to construct a mesh manually or <code><a title="phi.geom.load_su2" href="#phi.geom.load_su2">load_su2()</a></code> to load one from a file.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.geom._geom.Geometry</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="phi.geom.Mesh.all_boundary_faces"><code class="name">prop <span class="ident">all_boundary_faces</span> : Dict[str, slice]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def all_boundary_faces(self) -&gt; Dict[str, slice]:
    if self.face_shape.dual.size == self.elements.shape.instance.size:
        return {}
    return {self.face_shape.dual.name: slice(instance(self).volume, None)}</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Mesh.boundaries"><code class="name">var <span class="ident">boundaries</span> : Dict[str, Dict[str, slice]]</code></dt>
<dd>
<div class="desc"><p>Slices to retrieve boundary face values.</p></div>
</dd>
<dt id="phi.geom.Mesh.boundary_connectivity"><code class="name">var <span class="ident">boundary_connectivity</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def boundary_connectivity(self) -&gt; Tensor:
    if not self.all_boundary_faces:
        dual_dim = instance(self).as_dual().with_size(0)
        return zeros(instance(self) &amp; dual_dim)
    return self.connectivity[self.all_boundary_faces]</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Mesh.boundary_elements"><code class="name">prop <span class="ident">boundary_elements</span> : Dict[str, Dict[str, slice]]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def boundary_elements(self) -&gt; Dict[str, Dict[str, slice]]:
    return {}</code></pre>
</details>
<div class="desc"><p>Slices on the primal dimensions to mark boundary elements.
Grids and meshes have no boundary elements and return <code>{}</code>.
Dynamic graphs can define boundary elements for obstacles and walls.</p>
<h2 id="returns">Returns</h2>
<p>Map from <code>name</code> to slicing <code>dict</code>.</p></div>
</dd>
<dt id="phi.geom.Mesh.boundary_faces"><code class="name">prop <span class="ident">boundary_faces</span> : Dict[str, Dict[str, slice]]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def boundary_faces(self) -&gt; Dict[str, Dict[str, slice]]:
    if self.boundaries is None:
        return {}
    return self._faces[&#39;boundary_slices&#39;]</code></pre>
</details>
<div class="desc"><p>Slices on the dual dimensions to mark boundary faces.</p>
<p>Regular grids use the keys (dim, is_upper) to identify boundaries.
Unstructured meshes use string identifiers for the boundaries.
Dynamic graphs return slices along the dual dimensions.</p>
<h2 id="returns">Returns</h2>
<p>Map from <code>name</code> to slicing <code>dict</code>.</p></div>
</dd>
<dt id="phi.geom.Mesh.bounds"><code class="name">prop <span class="ident">bounds</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bounds(self):
    return Box(math.min(self.vertices.center, instance), math.max(self.vertices.center, instance))</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Mesh.cell_connectivity"><code class="name">var <span class="ident">cell_connectivity</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def cell_connectivity(self) -&gt; Tensor:
    &#34;&#34;&#34;
    Returns a bool-like matrix whose non-zero entries denote connected elements.
    In meshes or grids, elements are connected if they share a face in 3D, an edge in 2D, or a vertex in 1D.

    Returns:
        `Tensor` of shape (elements, ~elements)
    &#34;&#34;&#34;
    return self.connectivity[self.interior_faces]</code></pre>
</details>
<div class="desc"><p>Returns a bool-like matrix whose non-zero entries denote connected elements.
In meshes or grids, elements are connected if they share a face in 3D, an edge in 2D, or a vertex in 1D.</p>
<h2 id="returns">Returns</h2>
<p><code>Tensor</code> of shape (elements, ~elements)</p></div>
</dd>
<dt id="phi.geom.Mesh.cell_count"><code class="name">var <span class="ident">cell_count</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def cell_count(self):
    return instance(self.elements).size</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Mesh.center"><code class="name">var <span class="ident">center</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def center(self) -&gt; Tensor:
    if self.element_rank == self.spatial_rank:  # Compute volumetric center from faces
        return sum_(self.face_centers * self.face_areas, dual) / sum_(self.face_areas, dual)
    else:  # approximate center from vertices
        return self._vertex_mean</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Mesh.connectivity"><code class="name">prop <span class="ident">connectivity</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def connectivity(self) -&gt; Tensor:
    return self.element_connectivity</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Mesh.distance_matrix"><code class="name">var <span class="ident">distance_matrix</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def distance_matrix(self):
    return vec_length(pairwise_distances(self.center, edges=self.cell_connectivity, format=&#39;as edges&#39;, default=None))</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Mesh.element_connectivity"><code class="name">var <span class="ident">element_connectivity</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def element_connectivity(self) -&gt; Tensor:
    &#34;&#34;&#34;Neighbor element connectivity, excluding diagonal.&#34;&#34;&#34;
    if self.element_rank == self.spatial_rank:
        if is_sparse(self.face_areas):
            return tensor_like(self.face_areas, True)
        else:
            return self.face_areas &gt; 0
    else:  # fallback with no boundaries
        coo = to_format(self.elements, &#39;coo&#39;).numpy()
        connected_elements = coo @ coo.T
        connected_elements.setdiag(0)
        connected_elements.eliminate_zeros()
        connected_elements.data = np.ones_like(connected_elements.data)
        element_connectivity = wrap(connected_elements, instance(self.elements), instance(self.elements).as_dual())
        return element_connectivity</code></pre>
</details>
<div class="desc"><p>Neighbor element connectivity, excluding diagonal.</p></div>
</dd>
<dt id="phi.geom.Mesh.element_rank"><code class="name">var <span class="ident">element_rank</span> : int</code></dt>
<dd>
<div class="desc"><p>The spatial rank of the elements. Solid elements have the same as the ambient space, faces one less.</p></div>
</dd>
<dt id="phi.geom.Mesh.elements"><code class="name">var <span class="ident">elements</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p>elements: Sparse <code>Tensor</code> listing ordered vertex indices per element (solid or surface element, depending on <code>element_rank</code>).
Must have one instance dim listing the elements and the corresponding dual dim to <code>vertices</code>.
The vertex count of an element is equal to the number of elements in that row (i.e. summing the dual dim).</p></div>
</dd>
<dt id="phi.geom.Mesh.face_areas"><code class="name">prop <span class="ident">face_areas</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_areas(self) -&gt; Tensor:
    return self._faces[&#39;area&#39;]</code></pre>
</details>
<div class="desc"><p>Area of face connecting a pair of cells. Shape <code>(elements, ~)</code>.
Returns 0 for unconnected cells.</p></div>
</dd>
<dt id="phi.geom.Mesh.face_centers"><code class="name">var <span class="ident">face_centers</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def face_centers(self) -&gt; Tensor:
    return self._faces[&#39;center&#39;]</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Mesh.face_format"><code class="name">var <span class="ident">face_format</span> : str</code></dt>
<dd>
<div class="desc"><p>Sparse matrix format for storing quantities that depend on a pair of neighboring elements, e.g. <code>face_area</code>, <code>face_normal</code>, <code>face_center</code>.</p></div>
</dd>
<dt id="phi.geom.Mesh.face_normals"><code class="name">var <span class="ident">face_normals</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def face_normals(self) -&gt; Tensor:
    if self.element_rank == self.spatial_rank:  # this cannot depend on element centers because that depends on the normals.
        normals = self._faces[&#39;normal&#39;]
        face_centers = self._faces[&#39;center&#39;]
        normals_out = normals.vector * (face_centers - self._vertex_mean).vector &gt; 0
        normals = where(normals_out, normals, -normals)
        return normals
    raise NotImplementedError</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Mesh.face_shape"><code class="name">prop <span class="ident">face_shape</span> : phiml.math._shape.Shape</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_shape(self) -&gt; Shape:
    if not self.boundary_faces:
        return instance(self) &amp; dual
    dual_len = max([next(iter(sl.values())).stop for sl in self.boundary_faces.values()])
    dim = instance(self)
    return dim.as_dual().with_size(dual_len) + dim</code></pre>
</details>
<div class="desc"><h2 id="returns">Returns</h2>
<p>Full Shape to identify each face of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>, including instance/spatial dimensions for the elements and dual dimensions listing the faces per element.
If this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> has no faces, returns an empty <code>Shape</code>.</p></div>
</dd>
<dt id="phi.geom.Mesh.faces"><code class="name">prop <span class="ident">faces</span> : <a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def faces(self) -&gt; &#39;Geometry&#39;:
    &#34;&#34;&#34;
    Assembles information about the boundaries of the elements that make up the surface.
    For 2D elements, the faces are edges, for 3D elements, the faces are planar elements.

    Returns:
        center: Center of face connecting a pair of elements. Shape (~elements, elements, vector).
            Returns 0-vectors for unconnected elements.
        area: Area of face connecting a pair of elements. Shape (~elements, elements).
            Returns 0 for unconnected elements.
        normal: Normal vector of face connecting a pair of elements. Shape (~elements, elements, vector).
            Unconnected elements are assigned the vector 0.
            The vector points out of polygon and into ~polygon.
    &#34;&#34;&#34;
    return Point(self.face_centers)</code></pre>
</details>
<div class="desc"><p>Assembles information about the boundaries of the elements that make up the surface.
For 2D elements, the faces are edges, for 3D elements, the faces are planar elements.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>center</code></dt>
<dd>Center of face connecting a pair of elements. Shape (~elements, elements, vector).
Returns 0-vectors for unconnected elements.</dd>
<dt><code>area</code></dt>
<dd>Area of face connecting a pair of elements. Shape (~elements, elements).
Returns 0 for unconnected elements.</dd>
<dt><code>normal</code></dt>
<dd>Normal vector of face connecting a pair of elements. Shape (~elements, elements, vector).
Unconnected elements are assigned the vector 0.
The vector points out of polygon and into ~polygon.</dd>
</dl></div>
</dd>
<dt id="phi.geom.Mesh.interior_faces"><code class="name">prop <span class="ident">interior_faces</span> : Dict[str, slice]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def interior_faces(self) -&gt; Dict[str, slice]:
    return {self.face_shape.dual.name: slice(0, instance(self).volume)}</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Mesh.max_cell_walk"><code class="name">var <span class="ident">max_cell_walk</span> : int</code></dt>
<dd>
<div class="desc"><p>Maximum number of steps to walk along the element connectivity in order to find a cell, e.g. for sampling at an arbitrary point.</p></div>
</dd>
<dt id="phi.geom.Mesh.neighbor_distances"><code class="name">var <span class="ident">neighbor_distances</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def neighbor_distances(self):
    return vec_length(self.neighbor_offsets)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Mesh.neighbor_offsets"><code class="name">var <span class="ident">neighbor_offsets</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def neighbor_offsets(self):
    &#34;&#34;&#34;Returns shift vector to neighbor centroids and boundary faces.&#34;&#34;&#34;
    if not self.all_boundary_faces:
        return self._cell_deltas
    boundary_deltas = (self.face_centers - self.center)[self.all_boundary_faces]
    # assert (vec_length(boundary_deltas) &gt; 0).all, f&#34;All boundary faces must be separated from the cell centers but 0 distance at the following {channel(stored_indices(boundary_deltas)).item_names[0]}:\n{nonzero(vec_length(boundary_deltas) == 0):full}&#34;
    return concat([self._cell_deltas, boundary_deltas], self.face_shape.dual)</code></pre>
</details>
<div class="desc"><p>Returns shift vector to neighbor centroids and boundary faces.</p></div>
</dd>
<dt id="phi.geom.Mesh.normals"><code class="name">prop <span class="ident">normals</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def normals(self) -&gt; Tensor:
    &#34;&#34;&#34;Extrinsic element normal space. This is a 0D vector for solid elements and 1D for surface elements.&#34;&#34;&#34;
    if self.element_rank == 2:
        three_vertices = nonzero(self.elements, 3, list_dims=dual)
        v1, v2, v3 = unstack(self.vertices.center[{instance: three_vertices}], dual)
        return vec_normalize(cross(v2 - v1, v3 - v1))
    raise NotImplementedError</code></pre>
</details>
<div class="desc"><p>Extrinsic element normal space. This is a 0D vector for solid elements and 1D for surface elements.</p></div>
</dd>
<dt id="phi.geom.Mesh.periodic"><code class="name">var <span class="ident">periodic</span> : Sequence[str]</code></dt>
<dd>
<div class="desc"><p>List of axis names that are periodic. Periodic boundaries must be named as axis- and axis+. For example <code>['x']</code> will connect the boundaries x- and x+.</p></div>
</dd>
<dt id="phi.geom.Mesh.relative_face_distance"><code class="name">var <span class="ident">relative_face_distance</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def relative_face_distance(self):
    &#34;&#34;&#34;|face_center - center| / |neighbor_center - center|&#34;&#34;&#34;
    cell_distances = vec_length(self._cell_deltas)
    assert (cell_distances &gt; 0).all, f&#34;All cells must have distance &gt; 0 but found 0 distance at {nonzero(cell_distances == 0)}&#34;
    face_distances = vec_length(self.face_centers[self.interior_faces] - self.center)
    return concat([face_distances / cell_distances, self.boundary_connectivity], self.face_shape.dual)</code></pre>
</details>
<div class="desc"><p>|face_center - center| / |neighbor_center - center|</p></div>
</dd>
<dt id="phi.geom.Mesh.sets"><code class="name">prop <span class="ident">sets</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sets(self):
    return {
        &#39;center&#39;: non_batch(self)-&#39;vector&#39;,
        &#39;vertex&#39;: instance(self.vertices),
        &#39;~vertex&#39;: dual(self.elements)
    }</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Mesh.shape"><code class="name">var <span class="ident">shape</span> : phiml.math._shape.Shape</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def shape(self) -&gt; Shape:
    return non_dual(self.elements) &amp; channel(self.vertices) &amp; batch(self.vertices)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Mesh.value_attrs"><code class="name">var <span class="ident">value_attrs</span> : Tuple[str, ...]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Mesh.variable_attrs"><code class="name">var <span class="ident">variable_attrs</span> : Tuple[str, ...]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Mesh.vertex_connectivity"><code class="name">var <span class="ident">vertex_connectivity</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def vertex_connectivity(self) -&gt; Tensor:
    if isinstance(self.vertices, Graph):
        return self.vertices.connectivity
    elif self.element_rank &lt;= 2:
        def single_vertex_connectivity(elements: Tensor):
            indices = stored_indices(elements).index[dual(elements).name]
            idx1 = indices.numpy()
            v_count = sum_(elements, dual).numpy()
            ptr_end = np.cumsum(v_count)
            roll = np.arange(idx1.size) + 1
            roll[ptr_end-1] = ptr_end - v_count
            idx2 = idx1[roll]
            v_conn = coo_matrix((np.ones(idx1.size, dtype=bool), (idx1, idx2)), shape=(dual(elements).size,)*2).tocsr()
            return wrap(v_conn, dual(elements).as_instance(), dual(elements))
        return math.map(single_vertex_connectivity, self.elements, dims=batch)
    raise NotImplementedError</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Mesh.vertex_graph"><code class="name">var <span class="ident">vertex_graph</span> : phi.geom._graph.Graph</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def vertex_graph(self) -&gt; Graph:
    return self.vertices if isinstance(self.vertices, Graph) else graph(self.vertices, self.vertex_connectivity)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Mesh.vertex_normals"><code class="name">prop <span class="ident">vertex_normals</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def vertex_normals(self) -&gt; Tensor:
    v_normals = mean(self.elements * self.normals, instance)  # (~vertices,vector)
    return vec_normalize(v_normals)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Mesh.vertex_positions"><code class="name">prop <span class="ident">vertex_positions</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def vertex_positions(self) -&gt; Tensor:
    &#34;&#34;&#34;Lists the vertex centers along the corresponding dual dim to `self.vertices.center`.&#34;&#34;&#34;
    return si2d(self.vertices.center)</code></pre>
</details>
<div class="desc"><p>Lists the vertex centers along the corresponding dual dim to <code>self.vertices.center</code>.</p></div>
</dd>
<dt id="phi.geom.Mesh.vertices"><code class="name">var <span class="ident">vertices</span> : phi.geom._geom.Geometry</code></dt>
<dd>
<div class="desc"><p>Vertices are represented by a <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> instance with an instance dim.</p></div>
</dd>
<dt id="phi.geom.Mesh.volume"><code class="name">var <span class="ident">volume</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def volume(self) -&gt; Tensor:
    if self.element_rank == 2:
        if instance(self.elements).volume &gt; 0:
            three_vertices = nonzero(self.elements, 3, list_dims=dual)
            v1, v2, v3 = unstack(self.vertices.center[{instance: three_vertices}], dual)
            cross_area = vec_length(cross(v2-v1, v3-v1))
            vertex_count = math.sum(self.elements, dual)
            fac = where(vertex_count == 3, 0.5, 1)  # tri, quad, ...
            return fac * cross_area
        else:
            return zeros(instance(self.vertices))  # empty mesh
    elif self.element_rank == self.spatial_rank:
        vol_contributions = (self.face_centers.vector @ self.face_normals.vector) * self.face_areas
        return sum_(vol_contributions, dual) / self.spatial_rank
    raise NotImplementedError</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phi.geom.Mesh.approximate_closest_surface"><code class="name flex">
<span>def <span class="ident">approximate_closest_surface</span></span>(<span>self, location: phiml.math._tensors.Tensor) ‑> Tuple[phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def approximate_closest_surface(self, location: Tensor) -&gt; Tuple[Tensor, Tensor, Tensor, Tensor, Tensor]:
    def acs_single_mesh(self: Mesh, location: Tensor):
        if self.element_rank == 2 and self.spatial_rank == 3:
            closest_elem = find_closest(self.center, location)
            normal = self.normals[closest_elem]
            if math.get_format(self.elements) == &#39;compact-cols&#39; and dual(self.elements._indices).size == 3:  # triangle mesh
                three_vertices = self.elements[closest_elem]._indices
                v1, v2, v3 = unstack(self.vertices.center[{instance: three_vertices}], dual(self.elements))
                surf_pos = closest_on_triangle(v1, v2, v3, location, exact_edges=True)
                delta = surf_pos - location
                sgn_dist = vec_length(delta) * -sign(delta.vector @ normal)
                return sgn_dist, delta, normal, None, closest_elem
            center = self.center[closest_elem]
            face_size = sqrt(self.volume) * 2
            size = face_size[closest_elem]
            sgn_dist = plane_sgn_dist(center, normal, location)
            delta_far = center - location  # this is not accurate...
            delta_near = normal * -sgn_dist
            far_fac = minimum(1, abs(sgn_dist) / size)
            delta = far_fac * delta_far + (1 - far_fac) * delta_near
            return sgn_dist, delta, normal, None, closest_elem
        # idx = find_closest(self.center, location)
        # for i in range(self.max_cell_walk):
        #     idx, leaves_mesh, is_outside, distances, nb_idx = self.cell_walk_towards(location, idx, allow_exit=False)
        # sgn_dist = max(distances, dual)
        # cell_normals = self.face_normals[idx]
        # normal = cell_normals[{dual: nb_idx}]
        # return sgn_dist, delta, normal, offset, face_index
        raise NotImplementedError
    return math.map(acs_single_mesh, self, location, dims=batch(self.elements), map_name=&#34;Mesh.approximate_closest_surface&#34;)</code></pre>
</details>
<div class="desc"><p>Find the closest surface face of this geometry given a point that can be outside or inside the geometry.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd><code>Tensor</code> with a single channel dimension called vector. Can have arbitrary other dimensions.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>signed_distance</code></dt>
<dd>Scalar signed distance from <code>location</code>
to the closest point on the surface.
Positive values indicate the point lies outside the geometry, negative values indicate the point lies inside the geometry.</dd>
<dt><code>delta</code></dt>
<dd>Vector-valued distance vector from <code>location</code> to the closest point on the surface.</dd>
<dt><code>normal</code></dt>
<dd>Closest surface normal vector.</dd>
<dt><code>offset</code></dt>
<dd>Min distance of a surface-tangential plane from 0 as a scalar.</dd>
<dt><code>face_index</code></dt>
<dd>(Optional) An index vector pointing at the closest face.</dd>
</dl></div>
</dd>
<dt id="phi.geom.Mesh.approximate_signed_distance"><code class="name flex">
<span>def <span class="ident">approximate_signed_distance</span></span>(<span>self, location: phiml.math._tensors.Tensor | tuple) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def approximate_signed_distance(self, location: Union[Tensor, tuple]) -&gt; Tensor:
    if self.element_rank == 2 and self.spatial_rank == 3:
        closest_elem = find_closest(self.center, location)
        center = self.center[closest_elem]
        normal = self.normals[closest_elem]
        return plane_sgn_dist(center, normal, location)
    idx = find_closest(self.center, location)
    for i in range(self.max_cell_walk):
        idx, leaves_mesh, is_outside, distances, nb_idx = self.cell_walk_towards(location, idx, allow_exit=False)
    return math.max(distances, dual)</code></pre>
</details>
<div class="desc"><p>Computes the approximate distance from location to the surface of the geometry.
Locations outside return positive values, inside negative values and zero exactly at the boundary.</p>
<p>The exact distance metric used depends on the geometry.
The approximation holds close to the surface and the distance grows to infinity as the location is moved infinitely far from the geometry.
The distance metric is differentiable and its gradients are bounded at every point in space.</p>
<p>When dealing with unions or collections of geometries (instance dimensions), the shortest distance to any instance is returned.
This also holds for negative distances.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd><code>Tensor</code> with one channel dim <code>vector</code> matching the geometry's <code>vector</code> dim.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Float <code>Tensor</code></p></div>
</dd>
<dt id="phi.geom.Mesh.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>self, center: phiml.math._tensors.Tensor) ‑> phi.geom._mesh.Mesh</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def at(self, center: Tensor) -&gt; &#39;Mesh&#39;:
    if instance(self.elements) in center.shape:
        raise NotImplementedError(&#34;Setting Mesh positions only supported for vertices, not elements&#34;)
    if dual(self.elements) in center.shape:
        center = rename_dims(center, dual, instance(self.vertices))
    if instance(self.vertices) in center.shape:
        vertices = self.vertices.at(center)
        return replace(self, vertices=vertices)
    else:
        return self.shifted(center - self.bounds.center)</code></pre>
</details>
<div class="desc"><p>Returns a copy of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> with the center at <code>center</code>.
This is equal to calling <code>self @ center</code>.</p>
<p>See Also:
<code><a title="phi.geom.Geometry.shifted" href="#phi.geom.Geometry.shifted">Geometry.shifted()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>center</code></strong></dt>
<dd>New center as <code>Tensor</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.</p></div>
</dd>
<dt id="phi.geom.Mesh.bounding_box"><code class="name flex">
<span>def <span class="ident">bounding_box</span></span>(<span>self) ‑> phi.geom._box.Box</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bounding_box(self) -&gt; &#39;Box&#39;:
    return self.vertices.bounding_box()</code></pre>
</details>
<div class="desc"><p>Returns the approximately smallest axis-aligned box that contains this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.
The center of the box may not be equal to <code>self.center</code>.</p>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.geom.Box" href="#phi.geom.Box">Box</a></code> or <code><a title="phi.geom.Cuboid" href="#phi.geom.Cuboid">Cuboid()</a></code> that fully contains this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.</p></div>
</dd>
<dt id="phi.geom.Mesh.bounding_half_extent"><code class="name flex">
<span>def <span class="ident">bounding_half_extent</span></span>(<span>self) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bounding_half_extent(self) -&gt; Tensor:
    center = self.elements * self.center
    vert_pos = rename_dims(self.vertices.center, instance, dual)
    max_delta = math.max(abs(vert_pos - center), dual)
    return max_delta</code></pre>
</details>
<div class="desc"><p>The bounding half-extent sets a limit on the outer-most point for each coordinate axis.
Each component is non-negative.</p>
<p>Let the bounding half-extent have value <code>e</code> in dimension <code>d</code> (<code>extent[...,d] = e</code>).
Then, no point of the geometry lies further away from its center point than <code>e</code> along <code>d</code> (in both axis directions).</p>
<p>If this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.
If these dims are not present on the result, all parts are assumed to have the same bounds.</p></div>
</dd>
<dt id="phi.geom.Mesh.bounding_radius"><code class="name flex">
<span>def <span class="ident">bounding_radius</span></span>(<span>self) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bounding_radius(self) -&gt; Tensor:
    center = self.elements * self.center
    vert_pos = rename_dims(self.vertices.center, instance, dual)
    dist_to_vert = vec_length(vert_pos - center)
    max_dist = math.max(dist_to_vert, dual)
    return max_dist</code></pre>
</details>
<div class="desc"><p>Returns the radius of a Sphere object that fully encloses this geometry.
The sphere is centered at the center of this geometry.</p>
<p>If this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.
If these dims are not present on the result, all parts are assumed to have the same bounds.</p></div>
</dd>
<dt id="phi.geom.Mesh.cell_walk_towards"><code class="name flex">
<span>def <span class="ident">cell_walk_towards</span></span>(<span>self,<br>location: phiml.math._tensors.Tensor,<br>start_cell_idx: phiml.math._tensors.Tensor,<br>allow_exit=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cell_walk_towards(self, location: Tensor, start_cell_idx: Tensor, allow_exit=False):
    &#34;&#34;&#34;
    If `location` is not within the cell at index `from_cell_idx`, moves to a closer neighbor cell.

    Args:
        location: Target location as `Tensor`.
        start_cell_idx: Index of starting cell. Must be a valid cell index.
        allow_exit: If `True`, returns an invalid index for points outside the mesh, otherwise keeps the current index.

    Returns:
        index: Index of the neighbor cell or starting cell.
        leaves_mesh: Whether the walk crossed the mesh boundary. Then `index` is invalid. This is only possible if `allow_exit` is true.
        is_outside: Whether `location` was outside the cell at index `start_cell_idx`.
    &#34;&#34;&#34;
    closest_normals = self.face_normals[start_cell_idx]
    closest_face_centers = self.face_centers[start_cell_idx]
    offsets = closest_normals.vector @ closest_face_centers.vector  # this dot product could be cashed in the mesh
    distances = closest_normals.vector @ location.vector - offsets
    is_outside = math.any(distances &gt; 0, dual)
    nb_idx = argmax(distances, dual).index[0]  # cell index or boundary face index
    leaves_mesh = nb_idx &gt;= instance(self).volume
    next_idx = where(is_outside &amp; (~leaves_mesh | allow_exit), nb_idx, start_cell_idx)
    return next_idx, leaves_mesh, is_outside, distances, nb_idx</code></pre>
</details>
<div class="desc"><p>If <code>location</code> is not within the cell at index <code>from_cell_idx</code>, moves to a closer neighbor cell.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd>Target location as <code>Tensor</code>.</dd>
<dt><strong><code>start_cell_idx</code></strong></dt>
<dd>Index of starting cell. Must be a valid cell index.</dd>
<dt><strong><code>allow_exit</code></strong></dt>
<dd>If <code>True</code>, returns an invalid index for points outside the mesh, otherwise keeps the current index.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>index</code></dt>
<dd>Index of the neighbor cell or starting cell.</dd>
<dt><code>leaves_mesh</code></dt>
<dd>Whether the walk crossed the mesh boundary. Then <code>index</code> is invalid. This is only possible if <code>allow_exit</code> is true.</dd>
<dt><code>is_outside</code></dt>
<dd>Whether <code>location</code> was outside the cell at index <code>start_cell_idx</code>.</dd>
</dl></div>
</dd>
<dt id="phi.geom.Mesh.closest_vertex"><code class="name flex">
<span>def <span class="ident">closest_vertex</span></span>(<span>self, location: phiml.math._tensors.Tensor)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def closest_vertex(self, location: Tensor):
    idx = self._v_kdtree_i(location)
    v_pos = self.vertices.center[idx]
    return idx, v_pos - location</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Mesh.faces_to_vertices"><code class="name flex">
<span>def <span class="ident">faces_to_vertices</span></span>(<span>self, values: phiml.math._tensors.Tensor, reduce=&lt;built-in function sum&gt;)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def faces_to_vertices(self, values: Tensor, reduce=sum):
    v = stored_values(values, invalid=&#39;keep&#39;)  # ToDo replace this once PhiML has support for dense instance dims and sparse scatter
    i = stored_values(self.face_vertices, invalid=&#39;keep&#39;)
    i = rename_dims(i, channel, instance)
    out_shape = non_channel(self.vertices) &amp; shape(values).without(self.face_shape)
    return scatter(out_shape, i, v, mode=reduce, outside_handling=&#39;undefined&#39;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Mesh.filter_unused_vertices"><code class="name flex">
<span>def <span class="ident">filter_unused_vertices</span></span>(<span>self) ‑> phi.geom._mesh.Mesh</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_unused_vertices(self) -&gt; &#39;Mesh&#39;:
    coo = to_format(self.elements, &#39;coo&#39;).numpy()
    has_element = np.asarray(coo.sum(0) &gt; 0)[0]
    new_index = np.cumsum(has_element) - 1
    new_index_t = wrap(new_index, dual(self.elements))
    has_element = wrap(has_element, instance(self.vertices))
    # has_element_d = si2d(has_element)
    vertices = self.vertices[has_element]
    # v_normals = self.vertex_normals[has_element_d]
    # if self._vertex_connectivity is not None:
    #     vertex_connectivity = stored_indices(self._vertex_connectivity).index.as_batch()
    #     vertex_connectivity = new_index_t[{dual: vertex_connectivity}].index.as_channel()
    #     vertex_connectivity = sparse_tensor(vertex_connectivity, stored_values(self._vertex_connectivity), non_batch(self._vertex_connectivity).with_sizes(instance(vertices).size), False)
    if isinstance(self.elements, CompactSparseTensor):
        indices = new_index_t[{dual: self.elements._indices}]
        elements = CompactSparseTensor(indices, self.elements._values, self.elements._compressed_dims.with_size(instance(vertices).volume), self.elements._indices_constant, self.elements._matrix_rank)
    else:
        filtered_coo = coo_matrix((coo.data, (coo.row, new_index[coo.col])), shape=(instance(self.elements).volume, instance(vertices).volume))  # ToDo keep sparse format
        elements = wrap(filtered_coo, self.elements.shape.without_sizes())
    return replace(self, vertices=vertices, elements=elements)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Mesh.get_boundary"><code class="name flex">
<span>def <span class="ident">get_boundary</span></span>(<span>self, set_key: str) ‑> Dict[str, Dict[str, slice]]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_boundary(self, set_key: str) -&gt; Dict[str, Dict[str, slice]]:
    if set_key in [&#39;vertex&#39;, &#39;~vertex&#39;]:
        return {}
    return Geometry.get_boundary(self, set_key)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Mesh.get_points"><code class="name flex">
<span>def <span class="ident">get_points</span></span>(<span>self, set_key: str) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_points(self, set_key: str) -&gt; Tensor:
    if set_key == &#39;vertex&#39;:
        return self.vertices.center
    elif set_key == &#39;~vertex&#39;:
        return si2d(self.vertices.center)
    else:
        return Geometry.get_points(self, set_key)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Mesh.lies_inside"><code class="name flex">
<span>def <span class="ident">lies_inside</span></span>(<span>self, location: phiml.math._tensors.Tensor) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lies_inside(self, location: Tensor) -&gt; Tensor:
    idx = find_closest(self.center, location)
    for i in range(self.max_cell_walk):
        idx, leaves_mesh, is_outside, *_ = self.cell_walk_towards(location, idx, allow_exit=i == self.max_cell_walk - 1)
    return ~(leaves_mesh &amp; is_outside)</code></pre>
</details>
<div class="desc"><p>Tests whether the given location lies inside or outside of the geometry. Locations on the surface count as inside.</p>
<p>When dealing with unions or collections of geometries (instance dimensions), a point lies inside the geometry if it lies inside any instance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd>float tensor of shape (batch_size, &hellip;, rank)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>bool tensor of shape (*location.shape[:-1], 1).</p></div>
</dd>
<dt id="phi.geom.Mesh.pad_boundary"><code class="name flex">
<span>def <span class="ident">pad_boundary</span></span>(<span>self,<br>value: phiml.math._tensors.Tensor,<br>widths: Dict[str, Dict[str, slice]] = None,<br>mode: phiml.math.extrapolation.Extrapolation = 0,<br>**kwargs) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pad_boundary(self, value: Tensor, widths: Dict[str, Dict[str, slice]] = None, mode: Extrapolation or Tensor or Number = 0, **kwargs) -&gt; Tensor:
    mode = as_extrapolation(mode)
    if self.face_shape.dual.name not in value.shape:
        value = rename_dims(value, instance, self.face_shape.dual.without_sizes())
    else:
        raise NotImplementedError
    if widths is None:
        widths = self.boundary_faces
    if isinstance(widths, dict) and len(widths) == 0:
        return value
    if isinstance(widths, (tuple, list)):
        if len(widths) == 0 or isinstance(widths[0], dict):  # add sliced-off slices
            pass
    dim = next(iter(next(iter(widths.values()))))
    slices = [slice(0, value.shape.get_size(dim))]
    values = [value]
    connectivity = self.connectivity
    for name, b_slice in widths.items():
        if b_slice[dim].stop - b_slice[dim].start &gt; 0:
            slices.append(b_slice[dim])
            values.append(mode.sparse_pad_values(value, connectivity[b_slice], name, mesh=self, **kwargs))
    perm = np.argsort([s.start for s in slices])
    ordered_pieces = [values[i] for i in perm]
    return concat(ordered_pieces, dim, expand_values=True)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Mesh.rotated"><code class="name flex">
<span>def <span class="ident">rotated</span></span>(<span>self, angle: phiml.math._tensors.Tensor | float) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotated(self, angle: Union[float, Tensor]) -&gt; &#39;Geometry&#39;:
    raise NotImplementedError</code></pre>
</details>
<div class="desc"><p>Returns a rotated version of this geometry.
The geometry is rotated about its center point.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>angle</code></strong></dt>
<dd>
<p>Delta rotation.
Either</p>
<ul>
<li>Angle(s): scalar angle in 2d or euler angles along <code>vector</code> in 3D or higher.</li>
<li>Matrix: d⨯d rotation matrix</li>
</ul>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Rotated <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></p></div>
</dd>
<dt id="phi.geom.Mesh.sample_uniform"><code class="name flex">
<span>def <span class="ident">sample_uniform</span></span>(<span>self, *shape: phiml.math._shape.Shape) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_uniform(self, *shape: Shape) -&gt; Tensor:
    raise NotImplementedError</code></pre>
</details>
<div class="desc"><p>Samples uniformly distributed random points inside this volume.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*shape</code></strong></dt>
<dd>How many points to sample per individual geometry.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>Tensor</code> containing all dimensions from <code><a title="phi.geom.Geometry.shape" href="#phi.geom.Geometry.shape">Geometry.shape</a></code>, <code>shape</code> as well as a <code>channel</code> dimension <code>vector</code> matching the dimensionality of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.</p></div>
</dd>
<dt id="phi.geom.Mesh.scaled"><code class="name flex">
<span>def <span class="ident">scaled</span></span>(<span>self, factor: phiml.math._tensors.Tensor | float) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scaled(self, factor: Union[float, Tensor]) -&gt; &#39;Geometry&#39;:
    pivot = self.bounds.center
    vertices = scale(self.vertices, factor, pivot)
    # center = scale(Point(self.center), factor, pivot).center
    # volume = self.volume * factor**self.element_rank if self.volume is not None else None
    return replace(self, vertices=vertices)</code></pre>
</details>
<div class="desc"><p>Scales each individual geometry by <code>factor</code>.
The individual <code>center</code> points act as pivots for the operation.</p>
<h2 id="args">Args</h2>
<p>factor:
Returns:</p></div>
</dd>
<dt id="phi.geom.Mesh.shifted"><code class="name flex">
<span>def <span class="ident">shifted</span></span>(<span>self, delta: phiml.math._tensors.Tensor) ‑> phi.geom._mesh.Mesh</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shifted(self, delta: Tensor) -&gt; &#39;Mesh&#39;:
    if instance(self.elements) in delta.shape:
        raise NotImplementedError(&#34;Shifting Mesh positions only supported for vertices, not elements&#34;)
    if dual(self.elements) in delta.shape:
        delta = rename_dims(delta, dual, instance(self.vertices))
    if instance(self.vertices) in delta.shape:
        vertices = self.vertices.shifted(delta)
        return replace(self, vertices=vertices)
    else:  # shift everything
        # ToDo transfer cached properties
        # copy: center+delta, normals, volume, face_centers+delta, face_areas, face_normals, vertex_normals, vertex_connectivity, element_connectivity
        vertices = self.vertices.shifted(delta)
        return replace(self, vertices=vertices)</code></pre>
</details>
<div class="desc"><p>Returns a translated version of this geometry.</p>
<p>See Also:
<code><a title="phi.geom.Geometry.at" href="#phi.geom.Geometry.at">Geometry.at()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>delta</code></strong></dt>
<dd>direction vector</dd>
<dt><strong><code>delta</code></strong></dt>
<dd>Tensor:</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></dt>
<dd>shifted geometry</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="phi.geom.Point"><code class="flex name class">
<span>class <span class="ident">Point</span></span>
<span>(</span><span>location: phiml.math._tensors.Tensor)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@sliceable(keepdims=&#39;vector&#39;)
@dataclass(frozen=True, eq=False)
class Point(Geometry):
    &#34;&#34;&#34;
    Points have zero volume and are determined by a single location.
    An instance of `Point` represents a single n-dimensional point or a batch of points.
    &#34;&#34;&#34;

    location: Tensor

    variable_attrs = (&#39;location&#39;,)
    value_attrs = (&#39;location&#39;,)

    def __post_init__(self):
        assert &#39;vector&#39; in self.location.shape, &#34;location must have a vector dimension&#34;
        assert self.location.shape.get_item_names(&#39;vector&#39;) is not None, &#34;Vector dimension needs to list spatial dimension as item names.&#34;

    @property
    def center(self) -&gt; Tensor:
        return self.location

    @property
    def shape(self) -&gt; Shape:
        return self.location.shape

    @property
    def faces(self) -&gt; &#39;Geometry&#39;:
        return self

    def unstack(self, dimension: str) -&gt; tuple:
        return tuple(Point(loc) for loc in math.unstack(self.location, dimension))

    def lies_inside(self, location: Tensor) -&gt; Tensor:
        return expand(math.wrap(False), shape(location).without(&#39;vector&#39;))

    def approximate_signed_distance(self, location: Union[Tensor, tuple]) -&gt; Tensor:
        return math.norm(location - self.location)

    def bounding_radius(self) -&gt; Tensor:
        return math.zeros()

    def bounding_half_extent(self) -&gt; Tensor:
        return wrap(0)

    def at(self, center: Tensor) -&gt; &#39;Geometry&#39;:
        return Point(center)

    def rotated(self, angle) -&gt; &#39;Geometry&#39;:
        return self

    @property
    def volume(self) -&gt; Tensor:
        return math.wrap(0)

    def sample_uniform(self, *shape: math.Shape) -&gt; Tensor:
        raise NotImplementedError

    def scaled(self, factor: Union[float, Tensor]) -&gt; &#39;Geometry&#39;:
        return self

    @property
    def face_centers(self) -&gt; Tensor:
        return self.location

    @property
    def face_areas(self) -&gt; Tensor:
        return expand(0, self.face_shape)

    @property
    def face_normals(self) -&gt; Tensor:
        raise AssertionError(f&#34;Points have no normals&#34;)

    @property
    def boundary_elements(self) -&gt; Dict[str, Tuple[Dict[str, slice], Dict[str, slice]]]:
        return {}

    @property
    def boundary_faces(self) -&gt; Dict[str, Tuple[Dict[str, slice], Dict[str, slice]]]:
        return {}

    @property
    def face_shape(self) -&gt; Shape:
        return self.shape

    @property
    def corners(self):
        return self.location

    def __getitem__(self, item):
        return Point(self.location[_keep_vector(slicing_dict(self, item))])</code></pre>
</details>
<div class="desc"><p>Points have zero volume and are determined by a single location.
An instance of <code><a title="phi.geom.Point" href="#phi.geom.Point">Point</a></code> represents a single n-dimensional point or a batch of points.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.geom._geom.Geometry</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="phi.geom.Point.value_attrs"><code class="name">var <span class="ident">value_attrs</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Point.variable_attrs"><code class="name">var <span class="ident">variable_attrs</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="phi.geom.Point.Tc"><code class="name">prop <span class="ident">Tc</span></code></dt>
<dd>
<div class="desc"><p>partial(func, <em>args, </em>*keywords) - new function with partial application
of the given arguments and keywords.</p></div>
</dd>
<dt id="phi.geom.Point.Ti"><code class="name">prop <span class="ident">Ti</span></code></dt>
<dd>
<div class="desc"><p>partial(func, <em>args, </em>*keywords) - new function with partial application
of the given arguments and keywords.</p></div>
</dd>
<dt id="phi.geom.Point.Ts"><code class="name">prop <span class="ident">Ts</span></code></dt>
<dd>
<div class="desc"><p>partial(func, <em>args, </em>*keywords) - new function with partial application
of the given arguments and keywords.</p></div>
</dd>
<dt id="phi.geom.Point.boundary_elements"><code class="name">prop <span class="ident">boundary_elements</span> : Dict[str, Tuple[Dict[str, slice], Dict[str, slice]]]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def boundary_elements(self) -&gt; Dict[str, Tuple[Dict[str, slice], Dict[str, slice]]]:
    return {}</code></pre>
</details>
<div class="desc"><p>Slices on the primal dimensions to mark boundary elements.
Grids and meshes have no boundary elements and return <code>{}</code>.
Dynamic graphs can define boundary elements for obstacles and walls.</p>
<h2 id="returns">Returns</h2>
<p>Map from <code>name</code> to slicing <code>dict</code>.</p></div>
</dd>
<dt id="phi.geom.Point.boundary_faces"><code class="name">prop <span class="ident">boundary_faces</span> : Dict[str, Tuple[Dict[str, slice], Dict[str, slice]]]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def boundary_faces(self) -&gt; Dict[str, Tuple[Dict[str, slice], Dict[str, slice]]]:
    return {}</code></pre>
</details>
<div class="desc"><p>Slices on the dual dimensions to mark boundary faces.</p>
<p>Regular grids use the keys (dim, is_upper) to identify boundaries.
Unstructured meshes use string identifiers for the boundaries.
Dynamic graphs return slices along the dual dimensions.</p>
<h2 id="returns">Returns</h2>
<p>Map from <code>name</code> to slicing <code>dict</code>.</p></div>
</dd>
<dt id="phi.geom.Point.center"><code class="name">prop <span class="ident">center</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def center(self) -&gt; Tensor:
    return self.location</code></pre>
</details>
<div class="desc"><p>Center location in single channel dimension.</p></div>
</dd>
<dt id="phi.geom.Point.corners"><code class="name">prop <span class="ident">corners</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def corners(self):
    return self.location</code></pre>
</details>
<div class="desc"><h2 id="returns">Returns</h2>
<p>Corner locations as <code>phiml.math.Tensor</code>.
Corners belonging to one object or cell are listed along dual dimensions.
If the object has no corners, a size-0 tensor with the correct vector and instance dims is returned.</p></div>
</dd>
<dt id="phi.geom.Point.face_areas"><code class="name">prop <span class="ident">face_areas</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_areas(self) -&gt; Tensor:
    return expand(0, self.face_shape)</code></pre>
</details>
<div class="desc"><p>Area of face connecting a pair of cells. Shape <code>(elements, ~)</code>.
Returns 0 for unconnected cells.</p></div>
</dd>
<dt id="phi.geom.Point.face_centers"><code class="name">prop <span class="ident">face_centers</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_centers(self) -&gt; Tensor:
    return self.location</code></pre>
</details>
<div class="desc"><p>Center of face connecting a pair of cells. Shape <code>(elements, ~, vector)</code>.
Here, <code>~</code> represents arbitrary internal dual dimensions, such as <code>~staggered_direction</code> or <code>~elements</code>.
Returns 0-vectors for unconnected cells.</p></div>
</dd>
<dt id="phi.geom.Point.face_normals"><code class="name">prop <span class="ident">face_normals</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_normals(self) -&gt; Tensor:
    raise AssertionError(f&#34;Points have no normals&#34;)</code></pre>
</details>
<div class="desc"><p>Normal vectors of cell faces, including boundary faces. Shape <code>(elements, ~, vector)</code>.
For meshes, The vectors point out of the primal cells and into the dual cells.</p>
<p>Instance/spatial dimensions along which the normal does not vary may not be included in the result tensor's shape.</p></div>
</dd>
<dt id="phi.geom.Point.face_shape"><code class="name">prop <span class="ident">face_shape</span> : phiml.math._shape.Shape</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_shape(self) -&gt; Shape:
    return self.shape</code></pre>
</details>
<div class="desc"><h2 id="returns">Returns</h2>
<p>Full Shape to identify each face of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>, including instance/spatial dimensions for the elements and dual dimensions listing the faces per element.
If this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> has no faces, returns an empty <code>Shape</code>.</p></div>
</dd>
<dt id="phi.geom.Point.faces"><code class="name">prop <span class="ident">faces</span> : <a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def faces(self) -&gt; &#39;Geometry&#39;:
    return self</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Point.location"><code class="name">var <span class="ident">location</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Point.shape"><code class="name">prop <span class="ident">shape</span> : phiml.math._shape.Shape</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape(self) -&gt; Shape:
    return self.location.shape</code></pre>
</details>
<div class="desc"><p>The <code>shape</code> of a <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> consists of the following dimensions:</p>
<ul>
<li>A single <em>channel</em> dimension called <code>'vector'</code> specifying the physical space</li>
<li>Instance dimensions denote that this geometry consists of multiple copies in the same space</li>
<li>Spatial dimensions denote a crystal (repeating structure) of this geometric primitive in space</li>
<li>Batch dimensions indicate non-interacting versions of this geometry for parallelization only.</li>
</ul></div>
</dd>
<dt id="phi.geom.Point.volume"><code class="name">prop <span class="ident">volume</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def volume(self) -&gt; Tensor:
    return math.wrap(0)</code></pre>
</details>
<div class="desc"><p><code>phi.math.Tensor</code> representing the volume of each element.
The result retains batch, spatial and instance dimensions.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phi.geom.Point.approximate_signed_distance"><code class="name flex">
<span>def <span class="ident">approximate_signed_distance</span></span>(<span>self, location: phiml.math._tensors.Tensor | tuple) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def approximate_signed_distance(self, location: Union[Tensor, tuple]) -&gt; Tensor:
    return math.norm(location - self.location)</code></pre>
</details>
<div class="desc"><p>Computes the approximate distance from location to the surface of the geometry.
Locations outside return positive values, inside negative values and zero exactly at the boundary.</p>
<p>The exact distance metric used depends on the geometry.
The approximation holds close to the surface and the distance grows to infinity as the location is moved infinitely far from the geometry.
The distance metric is differentiable and its gradients are bounded at every point in space.</p>
<p>When dealing with unions or collections of geometries (instance dimensions), the shortest distance to any instance is returned.
This also holds for negative distances.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd><code>Tensor</code> with one channel dim <code>vector</code> matching the geometry's <code>vector</code> dim.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Float <code>Tensor</code></p></div>
</dd>
<dt id="phi.geom.Point.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>self, center: phiml.math._tensors.Tensor) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def at(self, center: Tensor) -&gt; &#39;Geometry&#39;:
    return Point(center)</code></pre>
</details>
<div class="desc"><p>Returns a copy of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> with the center at <code>center</code>.
This is equal to calling <code>self @ center</code>.</p>
<p>See Also:
<code><a title="phi.geom.Geometry.shifted" href="#phi.geom.Geometry.shifted">Geometry.shifted()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>center</code></strong></dt>
<dd>New center as <code>Tensor</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.</p></div>
</dd>
<dt id="phi.geom.Point.bounding_half_extent"><code class="name flex">
<span>def <span class="ident">bounding_half_extent</span></span>(<span>self) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bounding_half_extent(self) -&gt; Tensor:
    return wrap(0)</code></pre>
</details>
<div class="desc"><p>The bounding half-extent sets a limit on the outer-most point for each coordinate axis.
Each component is non-negative.</p>
<p>Let the bounding half-extent have value <code>e</code> in dimension <code>d</code> (<code>extent[...,d] = e</code>).
Then, no point of the geometry lies further away from its center point than <code>e</code> along <code>d</code> (in both axis directions).</p>
<p>If this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.
If these dims are not present on the result, all parts are assumed to have the same bounds.</p></div>
</dd>
<dt id="phi.geom.Point.bounding_radius"><code class="name flex">
<span>def <span class="ident">bounding_radius</span></span>(<span>self) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bounding_radius(self) -&gt; Tensor:
    return math.zeros()</code></pre>
</details>
<div class="desc"><p>Returns the radius of a Sphere object that fully encloses this geometry.
The sphere is centered at the center of this geometry.</p>
<p>If this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.
If these dims are not present on the result, all parts are assumed to have the same bounds.</p></div>
</dd>
<dt id="phi.geom.Point.lies_inside"><code class="name flex">
<span>def <span class="ident">lies_inside</span></span>(<span>self, location: phiml.math._tensors.Tensor) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lies_inside(self, location: Tensor) -&gt; Tensor:
    return expand(math.wrap(False), shape(location).without(&#39;vector&#39;))</code></pre>
</details>
<div class="desc"><p>Tests whether the given location lies inside or outside of the geometry. Locations on the surface count as inside.</p>
<p>When dealing with unions or collections of geometries (instance dimensions), a point lies inside the geometry if it lies inside any instance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd>float tensor of shape (batch_size, &hellip;, rank)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>bool tensor of shape (*location.shape[:-1], 1).</p></div>
</dd>
<dt id="phi.geom.Point.rotated"><code class="name flex">
<span>def <span class="ident">rotated</span></span>(<span>self, angle) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotated(self, angle) -&gt; &#39;Geometry&#39;:
    return self</code></pre>
</details>
<div class="desc"><p>Returns a rotated version of this geometry.
The geometry is rotated about its center point.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>angle</code></strong></dt>
<dd>
<p>Delta rotation.
Either</p>
<ul>
<li>Angle(s): scalar angle in 2d or euler angles along <code>vector</code> in 3D or higher.</li>
<li>Matrix: d⨯d rotation matrix</li>
</ul>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Rotated <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></p></div>
</dd>
<dt id="phi.geom.Point.sample_uniform"><code class="name flex">
<span>def <span class="ident">sample_uniform</span></span>(<span>self, *shape: phiml.math._shape.Shape) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_uniform(self, *shape: math.Shape) -&gt; Tensor:
    raise NotImplementedError</code></pre>
</details>
<div class="desc"><p>Samples uniformly distributed random points inside this volume.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*shape</code></strong></dt>
<dd>How many points to sample per individual geometry.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>Tensor</code> containing all dimensions from <code><a title="phi.geom.Geometry.shape" href="#phi.geom.Geometry.shape">Geometry.shape</a></code>, <code>shape</code> as well as a <code>channel</code> dimension <code>vector</code> matching the dimensionality of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.</p></div>
</dd>
<dt id="phi.geom.Point.scaled"><code class="name flex">
<span>def <span class="ident">scaled</span></span>(<span>self, factor: phiml.math._tensors.Tensor | float) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scaled(self, factor: Union[float, Tensor]) -&gt; &#39;Geometry&#39;:
    return self</code></pre>
</details>
<div class="desc"><p>Scales each individual geometry by <code>factor</code>.
The individual <code>center</code> points act as pivots for the operation.</p>
<h2 id="args">Args</h2>
<p>factor:
Returns:</p></div>
</dd>
<dt id="phi.geom.Point.unstack"><code class="name flex">
<span>def <span class="ident">unstack</span></span>(<span>self, dimension: str) ‑> tuple</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unstack(self, dimension: str) -&gt; tuple:
    return tuple(Point(loc) for loc in math.unstack(self.location, dimension))</code></pre>
</details>
<div class="desc"><p>Unstacks this Geometry along the given dimension.
The shapes of the returned geometries are reduced by <code>dimension</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dimension</code></strong></dt>
<dd>dimension along which to unstack</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>geometries</code></dt>
<dd>tuple of length equal to <code>geometry.shape.get_size(dimension)</code></dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="phi.geom.SDF"><code class="flex name class">
<span>class <span class="ident">SDF</span></span>
<span>(</span><span>sdf: Callable,<br>out_shape=None,<br>bounds: phi.geom._box.Box = None,<br>center: phiml.math._tensors.Tensor = None,<br>volume: phiml.math._tensors.Tensor = None,<br>bounding_radius: phiml.math._tensors.Tensor = None,<br>sdf_and_grad: Callable = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SDF(Geometry):
    &#34;&#34;&#34;
    Function-based signed distance field.
    Negative values lie inside the geometry, the 0-level represents the surface.
    &#34;&#34;&#34;
    def __init__(self, sdf: Callable, out_shape=None, bounds: Box = None, center: Tensor = None, volume: Tensor = None, bounding_radius: Tensor = None, sdf_and_grad: Callable = None):
        &#34;&#34;&#34;
        Args:
            sdf: SDF function. First argument is a `phiml.math.Tensor` with a `vector` channel dim.
            bounds: Grid limits. The bounds fully enclose all virtual cells.
            center: (Optional) Geometry center point. Will be computed otherwise.
            volume: (Optional) Geometry volume. Will be computed otherwise.
            bounding_radius: (Optional) Geometry bounding radius around center. Will be computed otherwise.
        &#34;&#34;&#34;
        self._sdf = sdf
        if out_shape is not None:
            self._out_shape = out_shape or math.EMPTY_SHAPE
        else:
            dims = channel([bounds, center, bounding_radius])
            assert &#39;vector&#39; in dims, f&#34;If out_shape is not specified, either bounds, center or bounding_radius must be given.&#34;
            self._out_shape = sdf(math.zeros(dims[&#39;vector&#39;])).shape
        self._bounds = bounds
        if sdf_and_grad is not None:
            self._grad = sdf_and_grad
        else:
            self._grad = math.gradient(sdf, wrt=0, get_output=True)
        if center is not None:
            self._center = center
        else:
            self._center = bounds.center
        if volume is not None:
            self._volume = volume
        else:
            self._volume = None
        if bounding_radius is not None:
            self._bounding_radius = bounding_radius
        else:
            self._bounding_radius = self._bounds.bounding_radius()

    def __call__(self, location, *aux_args, **aux_kwargs):
        native_loc = not isinstance(location, Tensor)
        if native_loc:
            location = math.wrap(location, instance(&#39;points&#39;), self.shape[&#39;vector&#39;])
        sdf_val: Tensor = self._sdf(location, *aux_args, **aux_kwargs)
        return sdf_val.native() if native_loc else sdf_val

    def __variable_attrs__(self):
        return &#39;_bounds&#39;, &#39;_center&#39;, &#39;_volume&#39;, &#39;_bounding_radius&#39;

    def __value_attrs__(self):
        return ()

    @property
    def bounds(self) -&gt; Box:
        return self._bounds

    @property
    def size(self):
        return self._bounds.size

    @property
    def center(self) -&gt; Tensor:
        return self._center

    @property
    def shape(self) -&gt; Shape:
        return self._out_shape &amp; self._bounds.shape

    @property
    def volume(self) -&gt; Tensor:
        return self._volume

    @property
    def faces(self) -&gt; &#39;Geometry&#39;:
        raise NotImplementedError(f&#34;SDF does not support faces&#34;)

    @property
    def face_centers(self) -&gt; Tensor:
        raise NotImplementedError(f&#34;SDF does not support faces&#34;)

    @property
    def face_areas(self) -&gt; Tensor:
        raise NotImplementedError(f&#34;SDF does not support faces&#34;)

    @property
    def face_normals(self) -&gt; Tensor:
        raise NotImplementedError(f&#34;SDF does not support faces&#34;)

    @property
    def boundary_elements(self) -&gt; Dict[Any, Dict[str, slice]]:
        return {}

    @property
    def boundary_faces(self) -&gt; Dict[Any, Dict[str, slice]]:
        return {}

    @property
    def face_shape(self) -&gt; Shape:
        return math.EMPTY_SHAPE

    @property
    def corners(self) -&gt; Tensor:
        raise NotImplementedError(f&#34;SDF does not support corners&#34;)

    def lies_inside(self, location: Tensor) -&gt; Tensor:
        sdf = self._sdf(location)
        return sdf &lt;= 0

    def approximate_closest_surface(self, location: Tensor, refine_iter=0) -&gt; Tuple[Tensor, Tensor, Tensor, Tensor, Tensor]:
        sgn_dist, outward = self._grad(location)
        closest = location - sgn_dist * outward
        if not refine_iter:
            _, normal = self._grad(closest)
        else:
            for i in range(refine_iter):
                sgn_dist, outward = self._grad(closest)
                closest -= sgn_dist * outward
            normal = outward
        offset = None
        face_index = None
        return sgn_dist, closest - location, normal, offset, face_index

    def sdf_and_gradient(self, location: Tensor, refine_iter=0) -&gt; Tuple[Tensor, Tensor]:
        if not refine_iter:
            sgn_dist, outward = self._grad(location)
        else:
            sgn_dist, delta, *_ = self.approximate_closest_surface(location)
            outward = math.vec_normalize(math.sign(-sgn_dist) * delta)
        return sgn_dist, outward

    def approximate_signed_distance(self, location: Tensor) -&gt; Tensor:
        return self._sdf(location)

    def sample_uniform(self, *shape: math.Shape) -&gt; Tensor:
        raise NotImplementedError

    def bounding_radius(self) -&gt; Tensor:
        return self._bounding_radius

    def bounding_half_extent(self) -&gt; Tensor:
        return self._bounds.half_size  # this could be too small if the center is not in the middle of the bounds

    def bounding_box(self) -&gt; &#39;Box&#39;:
        return self._bounds

    def shifted(self, delta: Tensor) -&gt; &#39;Geometry&#39;:
        raise NotImplementedError(&#34;SDF does not yet support shifting&#34;)

    def at(self, center: Tensor) -&gt; &#39;Geometry&#39;:
        raise NotImplementedError(&#34;SDF does not yet support shifting&#34;)

    def rotated(self, angle: Union[float, Tensor]) -&gt; &#39;Geometry&#39;:
        raise NotImplementedError(&#34;SDF does not yet support rotation&#34;)

    def scaled(self, factor: Union[float, Tensor]) -&gt; &#39;Geometry&#39;:
        off_center = self._center - self._bounds.center
        volume = self._volume * factor ** self.spatial_rank
        bounds = self._bounds.scaled(factor).shifted(off_center * (factor - 1)).corner_representation()
        return SDF(self._sdf, bounds, self._center, volume, self._bounding_radius * factor)

    def __getitem__(self, item):
        item = slicing_dict(self, item)
        if not item:
            return self
        raise NotImplementedError

    @staticmethod
    def __stack__(values: tuple, dim: Shape, **kwargs) -&gt; &#39;Geometry&#39;:
        from ._geom_ops import GeometryStack
        return GeometryStack(math.layout(values, dim))</code></pre>
</details>
<div class="desc"><p>Function-based signed distance field.
Negative values lie inside the geometry, the 0-level represents the surface.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sdf</code></strong></dt>
<dd>SDF function. First argument is a <code>phiml.math.Tensor</code> with a <code>vector</code> channel dim.</dd>
<dt><strong><code>bounds</code></strong></dt>
<dd>Grid limits. The bounds fully enclose all virtual cells.</dd>
<dt><strong><code>center</code></strong></dt>
<dd>(Optional) Geometry center point. Will be computed otherwise.</dd>
<dt><strong><code>volume</code></strong></dt>
<dd>(Optional) Geometry volume. Will be computed otherwise.</dd>
<dt><strong><code>bounding_radius</code></strong></dt>
<dd>(Optional) Geometry bounding radius around center. Will be computed otherwise.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.geom._geom.Geometry</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="phi.geom.SDF.boundary_elements"><code class="name">prop <span class="ident">boundary_elements</span> : Dict[Any, Dict[str, slice]]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def boundary_elements(self) -&gt; Dict[Any, Dict[str, slice]]:
    return {}</code></pre>
</details>
<div class="desc"><p>Slices on the primal dimensions to mark boundary elements.
Grids and meshes have no boundary elements and return <code>{}</code>.
Dynamic graphs can define boundary elements for obstacles and walls.</p>
<h2 id="returns">Returns</h2>
<p>Map from <code>name</code> to slicing <code>dict</code>.</p></div>
</dd>
<dt id="phi.geom.SDF.boundary_faces"><code class="name">prop <span class="ident">boundary_faces</span> : Dict[Any, Dict[str, slice]]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def boundary_faces(self) -&gt; Dict[Any, Dict[str, slice]]:
    return {}</code></pre>
</details>
<div class="desc"><p>Slices on the dual dimensions to mark boundary faces.</p>
<p>Regular grids use the keys (dim, is_upper) to identify boundaries.
Unstructured meshes use string identifiers for the boundaries.
Dynamic graphs return slices along the dual dimensions.</p>
<h2 id="returns">Returns</h2>
<p>Map from <code>name</code> to slicing <code>dict</code>.</p></div>
</dd>
<dt id="phi.geom.SDF.bounds"><code class="name">prop <span class="ident">bounds</span> : phi.geom._box.Box</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bounds(self) -&gt; Box:
    return self._bounds</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.SDF.center"><code class="name">prop <span class="ident">center</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def center(self) -&gt; Tensor:
    return self._center</code></pre>
</details>
<div class="desc"><p>Center location in single channel dimension.</p></div>
</dd>
<dt id="phi.geom.SDF.corners"><code class="name">prop <span class="ident">corners</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def corners(self) -&gt; Tensor:
    raise NotImplementedError(f&#34;SDF does not support corners&#34;)</code></pre>
</details>
<div class="desc"><h2 id="returns">Returns</h2>
<p>Corner locations as <code>phiml.math.Tensor</code>.
Corners belonging to one object or cell are listed along dual dimensions.
If the object has no corners, a size-0 tensor with the correct vector and instance dims is returned.</p></div>
</dd>
<dt id="phi.geom.SDF.face_areas"><code class="name">prop <span class="ident">face_areas</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_areas(self) -&gt; Tensor:
    raise NotImplementedError(f&#34;SDF does not support faces&#34;)</code></pre>
</details>
<div class="desc"><p>Area of face connecting a pair of cells. Shape <code>(elements, ~)</code>.
Returns 0 for unconnected cells.</p></div>
</dd>
<dt id="phi.geom.SDF.face_centers"><code class="name">prop <span class="ident">face_centers</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_centers(self) -&gt; Tensor:
    raise NotImplementedError(f&#34;SDF does not support faces&#34;)</code></pre>
</details>
<div class="desc"><p>Center of face connecting a pair of cells. Shape <code>(elements, ~, vector)</code>.
Here, <code>~</code> represents arbitrary internal dual dimensions, such as <code>~staggered_direction</code> or <code>~elements</code>.
Returns 0-vectors for unconnected cells.</p></div>
</dd>
<dt id="phi.geom.SDF.face_normals"><code class="name">prop <span class="ident">face_normals</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_normals(self) -&gt; Tensor:
    raise NotImplementedError(f&#34;SDF does not support faces&#34;)</code></pre>
</details>
<div class="desc"><p>Normal vectors of cell faces, including boundary faces. Shape <code>(elements, ~, vector)</code>.
For meshes, The vectors point out of the primal cells and into the dual cells.</p>
<p>Instance/spatial dimensions along which the normal does not vary may not be included in the result tensor's shape.</p></div>
</dd>
<dt id="phi.geom.SDF.face_shape"><code class="name">prop <span class="ident">face_shape</span> : phiml.math._shape.Shape</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_shape(self) -&gt; Shape:
    return math.EMPTY_SHAPE</code></pre>
</details>
<div class="desc"><h2 id="returns">Returns</h2>
<p>Full Shape to identify each face of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>, including instance/spatial dimensions for the elements and dual dimensions listing the faces per element.
If this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> has no faces, returns an empty <code>Shape</code>.</p></div>
</dd>
<dt id="phi.geom.SDF.faces"><code class="name">prop <span class="ident">faces</span> : <a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def faces(self) -&gt; &#39;Geometry&#39;:
    raise NotImplementedError(f&#34;SDF does not support faces&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.SDF.shape"><code class="name">prop <span class="ident">shape</span> : phiml.math._shape.Shape</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape(self) -&gt; Shape:
    return self._out_shape &amp; self._bounds.shape</code></pre>
</details>
<div class="desc"><p>The <code>shape</code> of a <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> consists of the following dimensions:</p>
<ul>
<li>A single <em>channel</em> dimension called <code>'vector'</code> specifying the physical space</li>
<li>Instance dimensions denote that this geometry consists of multiple copies in the same space</li>
<li>Spatial dimensions denote a crystal (repeating structure) of this geometric primitive in space</li>
<li>Batch dimensions indicate non-interacting versions of this geometry for parallelization only.</li>
</ul></div>
</dd>
<dt id="phi.geom.SDF.size"><code class="name">prop <span class="ident">size</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self):
    return self._bounds.size</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.SDF.volume"><code class="name">prop <span class="ident">volume</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def volume(self) -&gt; Tensor:
    return self._volume</code></pre>
</details>
<div class="desc"><p><code>phi.math.Tensor</code> representing the volume of each element.
The result retains batch, spatial and instance dimensions.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phi.geom.SDF.approximate_closest_surface"><code class="name flex">
<span>def <span class="ident">approximate_closest_surface</span></span>(<span>self, location: phiml.math._tensors.Tensor, refine_iter=0) ‑> Tuple[phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def approximate_closest_surface(self, location: Tensor, refine_iter=0) -&gt; Tuple[Tensor, Tensor, Tensor, Tensor, Tensor]:
    sgn_dist, outward = self._grad(location)
    closest = location - sgn_dist * outward
    if not refine_iter:
        _, normal = self._grad(closest)
    else:
        for i in range(refine_iter):
            sgn_dist, outward = self._grad(closest)
            closest -= sgn_dist * outward
        normal = outward
    offset = None
    face_index = None
    return sgn_dist, closest - location, normal, offset, face_index</code></pre>
</details>
<div class="desc"><p>Find the closest surface face of this geometry given a point that can be outside or inside the geometry.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd><code>Tensor</code> with a single channel dimension called vector. Can have arbitrary other dimensions.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>signed_distance</code></dt>
<dd>Scalar signed distance from <code>location</code>
to the closest point on the surface.
Positive values indicate the point lies outside the geometry, negative values indicate the point lies inside the geometry.</dd>
<dt><code>delta</code></dt>
<dd>Vector-valued distance vector from <code>location</code> to the closest point on the surface.</dd>
<dt><code>normal</code></dt>
<dd>Closest surface normal vector.</dd>
<dt><code>offset</code></dt>
<dd>Min distance of a surface-tangential plane from 0 as a scalar.</dd>
<dt><code>face_index</code></dt>
<dd>(Optional) An index vector pointing at the closest face.</dd>
</dl></div>
</dd>
<dt id="phi.geom.SDF.approximate_signed_distance"><code class="name flex">
<span>def <span class="ident">approximate_signed_distance</span></span>(<span>self, location: phiml.math._tensors.Tensor) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def approximate_signed_distance(self, location: Tensor) -&gt; Tensor:
    return self._sdf(location)</code></pre>
</details>
<div class="desc"><p>Computes the approximate distance from location to the surface of the geometry.
Locations outside return positive values, inside negative values and zero exactly at the boundary.</p>
<p>The exact distance metric used depends on the geometry.
The approximation holds close to the surface and the distance grows to infinity as the location is moved infinitely far from the geometry.
The distance metric is differentiable and its gradients are bounded at every point in space.</p>
<p>When dealing with unions or collections of geometries (instance dimensions), the shortest distance to any instance is returned.
This also holds for negative distances.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd><code>Tensor</code> with one channel dim <code>vector</code> matching the geometry's <code>vector</code> dim.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Float <code>Tensor</code></p></div>
</dd>
<dt id="phi.geom.SDF.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>self, center: phiml.math._tensors.Tensor) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def at(self, center: Tensor) -&gt; &#39;Geometry&#39;:
    raise NotImplementedError(&#34;SDF does not yet support shifting&#34;)</code></pre>
</details>
<div class="desc"><p>Returns a copy of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> with the center at <code>center</code>.
This is equal to calling <code>self @ center</code>.</p>
<p>See Also:
<code><a title="phi.geom.Geometry.shifted" href="#phi.geom.Geometry.shifted">Geometry.shifted()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>center</code></strong></dt>
<dd>New center as <code>Tensor</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.</p></div>
</dd>
<dt id="phi.geom.SDF.bounding_box"><code class="name flex">
<span>def <span class="ident">bounding_box</span></span>(<span>self) ‑> phi.geom._box.Box</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bounding_box(self) -&gt; &#39;Box&#39;:
    return self._bounds</code></pre>
</details>
<div class="desc"><p>Returns the approximately smallest axis-aligned box that contains this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.
The center of the box may not be equal to <code>self.center</code>.</p>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.geom.Box" href="#phi.geom.Box">Box</a></code> or <code><a title="phi.geom.Cuboid" href="#phi.geom.Cuboid">Cuboid()</a></code> that fully contains this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.</p></div>
</dd>
<dt id="phi.geom.SDF.bounding_half_extent"><code class="name flex">
<span>def <span class="ident">bounding_half_extent</span></span>(<span>self) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bounding_half_extent(self) -&gt; Tensor:
    return self._bounds.half_size  # this could be too small if the center is not in the middle of the bounds</code></pre>
</details>
<div class="desc"><p>The bounding half-extent sets a limit on the outer-most point for each coordinate axis.
Each component is non-negative.</p>
<p>Let the bounding half-extent have value <code>e</code> in dimension <code>d</code> (<code>extent[...,d] = e</code>).
Then, no point of the geometry lies further away from its center point than <code>e</code> along <code>d</code> (in both axis directions).</p>
<p>If this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.
If these dims are not present on the result, all parts are assumed to have the same bounds.</p></div>
</dd>
<dt id="phi.geom.SDF.bounding_radius"><code class="name flex">
<span>def <span class="ident">bounding_radius</span></span>(<span>self) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bounding_radius(self) -&gt; Tensor:
    return self._bounding_radius</code></pre>
</details>
<div class="desc"><p>Returns the radius of a Sphere object that fully encloses this geometry.
The sphere is centered at the center of this geometry.</p>
<p>If this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.
If these dims are not present on the result, all parts are assumed to have the same bounds.</p></div>
</dd>
<dt id="phi.geom.SDF.lies_inside"><code class="name flex">
<span>def <span class="ident">lies_inside</span></span>(<span>self, location: phiml.math._tensors.Tensor) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lies_inside(self, location: Tensor) -&gt; Tensor:
    sdf = self._sdf(location)
    return sdf &lt;= 0</code></pre>
</details>
<div class="desc"><p>Tests whether the given location lies inside or outside of the geometry. Locations on the surface count as inside.</p>
<p>When dealing with unions or collections of geometries (instance dimensions), a point lies inside the geometry if it lies inside any instance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd>float tensor of shape (batch_size, &hellip;, rank)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>bool tensor of shape (*location.shape[:-1], 1).</p></div>
</dd>
<dt id="phi.geom.SDF.rotated"><code class="name flex">
<span>def <span class="ident">rotated</span></span>(<span>self, angle: phiml.math._tensors.Tensor | float) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotated(self, angle: Union[float, Tensor]) -&gt; &#39;Geometry&#39;:
    raise NotImplementedError(&#34;SDF does not yet support rotation&#34;)</code></pre>
</details>
<div class="desc"><p>Returns a rotated version of this geometry.
The geometry is rotated about its center point.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>angle</code></strong></dt>
<dd>
<p>Delta rotation.
Either</p>
<ul>
<li>Angle(s): scalar angle in 2d or euler angles along <code>vector</code> in 3D or higher.</li>
<li>Matrix: d⨯d rotation matrix</li>
</ul>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Rotated <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></p></div>
</dd>
<dt id="phi.geom.SDF.sample_uniform"><code class="name flex">
<span>def <span class="ident">sample_uniform</span></span>(<span>self, *shape: phiml.math._shape.Shape) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_uniform(self, *shape: math.Shape) -&gt; Tensor:
    raise NotImplementedError</code></pre>
</details>
<div class="desc"><p>Samples uniformly distributed random points inside this volume.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*shape</code></strong></dt>
<dd>How many points to sample per individual geometry.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>Tensor</code> containing all dimensions from <code><a title="phi.geom.Geometry.shape" href="#phi.geom.Geometry.shape">Geometry.shape</a></code>, <code>shape</code> as well as a <code>channel</code> dimension <code>vector</code> matching the dimensionality of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.</p></div>
</dd>
<dt id="phi.geom.SDF.scaled"><code class="name flex">
<span>def <span class="ident">scaled</span></span>(<span>self, factor: phiml.math._tensors.Tensor | float) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scaled(self, factor: Union[float, Tensor]) -&gt; &#39;Geometry&#39;:
    off_center = self._center - self._bounds.center
    volume = self._volume * factor ** self.spatial_rank
    bounds = self._bounds.scaled(factor).shifted(off_center * (factor - 1)).corner_representation()
    return SDF(self._sdf, bounds, self._center, volume, self._bounding_radius * factor)</code></pre>
</details>
<div class="desc"><p>Scales each individual geometry by <code>factor</code>.
The individual <code>center</code> points act as pivots for the operation.</p>
<h2 id="args">Args</h2>
<p>factor:
Returns:</p></div>
</dd>
<dt id="phi.geom.SDF.sdf_and_gradient"><code class="name flex">
<span>def <span class="ident">sdf_and_gradient</span></span>(<span>self, location: phiml.math._tensors.Tensor, refine_iter=0) ‑> Tuple[phiml.math._tensors.Tensor, phiml.math._tensors.Tensor]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sdf_and_gradient(self, location: Tensor, refine_iter=0) -&gt; Tuple[Tensor, Tensor]:
    if not refine_iter:
        sgn_dist, outward = self._grad(location)
    else:
        sgn_dist, delta, *_ = self.approximate_closest_surface(location)
        outward = math.vec_normalize(math.sign(-sgn_dist) * delta)
    return sgn_dist, outward</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.SDF.shifted"><code class="name flex">
<span>def <span class="ident">shifted</span></span>(<span>self, delta: phiml.math._tensors.Tensor) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shifted(self, delta: Tensor) -&gt; &#39;Geometry&#39;:
    raise NotImplementedError(&#34;SDF does not yet support shifting&#34;)</code></pre>
</details>
<div class="desc"><p>Returns a translated version of this geometry.</p>
<p>See Also:
<code><a title="phi.geom.Geometry.at" href="#phi.geom.Geometry.at">Geometry.at()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>delta</code></strong></dt>
<dd>direction vector</dd>
<dt><strong><code>delta</code></strong></dt>
<dd>Tensor:</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></dt>
<dd>shifted geometry</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="phi.geom.SDFGrid"><code class="flex name class">
<span>class <span class="ident">SDFGrid</span></span>
<span>(</span><span>sdf: phiml.math._tensors.Tensor,<br>bounds: phi.geom._box.Box,<br>approximate_outside=True,<br>gradient: phiml.math._tensors.Tensor = None,<br>to_surface: phiml.math._tensors.Tensor = None,<br>surf_normal: phiml.math._tensors.Tensor = None,<br>surf_index: phiml.math._tensors.Tensor = None,<br>center: phiml.math._tensors.Tensor = None,<br>volume: phiml.math._tensors.Tensor = None,<br>bounding_radius: phiml.math._tensors.Tensor = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SDFGrid(Geometry):
    &#34;&#34;&#34;
    Grid-based signed distance field.
    &#34;&#34;&#34;
    def __init__(self,
                 sdf: Tensor,
                 bounds: Box,
                 approximate_outside=True,
                 gradient: Tensor = None,
                 to_surface: Tensor = None, surf_normal: Tensor = None, surf_index: Tensor = None,
                 center: Tensor = None, volume: Tensor = None, bounding_radius: Tensor = None):
        &#34;&#34;&#34;
        Args:
            sdf: Signed distance values. `Tensor` with spatial dimensions corresponding to the physical space.
                Each value samples the SDF value at the center of a virtual cell.
            bounds: Grid limits. The bounds fully enclose all virtual cells.
            approximate_outside: Whether queries outside the SDF grid should return approximate values. This requires additional computations.
            gradient: (Optional) Pre-computed gradient grid. Will be computed otherwise.
            center: (Optional) Geometry center point. Will be computed otherwise.
            volume: (Optional) Geometry volume. Will be computed otherwise.
            bounding_radius: (Optional) Geometry bounding radius around center. Will be computed otherwise.
        &#34;&#34;&#34;
        super().__init__()
        self._sdf = sdf
        self._bounds = bounds
        self._approximate_outside = approximate_outside
        dx = bounds.size / spatial(sdf)
        if gradient is True:
            grad = math.spatial_gradient(sdf, dx=dx, difference=&#39;forward&#39;, padding=math.extrapolation.ZERO_GRADIENT, stack_dim=channel(&#39;vector&#39;))
            self._grad = grad[{dim: slice(0, -1) for dim in spatial(sdf).names}]
        else:
            self._grad = gradient
        self._to_surface = to_surface
        self._surf_normal = surf_normal
        self._surf_index = surf_index
        if center is not None:
            self._center = center
        else:
            min_index = math.argmin(self._sdf, spatial, index_dim=channel(&#39;vector&#39;))
            self._center = bounds.local_to_global(min_index / spatial(sdf))
        if volume is not None:
            self._volume = volume
        else:
            filled = math.sum(sdf &lt; 0)
            self._volume = filled * math.prod(dx)
        if bounding_radius is not None:
            self._bounding_radius = bounding_radius
        else:
            points = UniformGrid(spatial(sdf), self._bounds).center
            dist = math.vec_length(points - self._center)
            dist = math.where(self._sdf &lt;= 0, dist, 0)
            self._bounding_radius = math.max(dist)

    def __variable_attrs__(self):
        return &#39;_sdf&#39;, &#39;_bounds&#39;, &#39;_grad&#39;, &#39;_to_surface&#39;, &#39;_surf_normal&#39;, &#39;_surf_index&#39;, &#39;_center&#39;, &#39;_volume&#39;, &#39;_bounding_radius&#39;

    def __value_attrs__(self):
        return &#39;_sdf&#39;,

    @property
    def values(self):
        &#34;&#34;&#34;Signed distance grid.&#34;&#34;&#34;
        return self._sdf

    def with_values(self, values: Tensor):
        values = expand(values, spatial(self._sdf) - spatial(values))
        return SDFGrid(values, self._bounds, self._approximate_outside, self._grad, self._to_surface, self._surf_normal, self._surf_index, self._center, self._volume, self._bounding_radius)

    @property
    def bounds(self) -&gt; Box:
        return self._bounds

    @property
    def size(self) -&gt; Tensor:
        return self._bounds.size

    @property
    def resolution(self) -&gt; Shape:
        return spatial(self._sdf)

    @property
    def dx(self) -&gt; Tensor:
        return self._bounds.size / spatial(self._sdf)

    @property
    def points(self) -&gt; Tensor:
        return UniformGrid(spatial(self._sdf), self._bounds).center

    @property
    def grid(self) -&gt; UniformGrid:
        return UniformGrid(spatial(self._sdf), self._bounds)

    @property
    def center(self) -&gt; Tensor:
        return self._center

    @property
    def shape(self) -&gt; Shape:
        return non_spatial(self._sdf) &amp; channel(vector=spatial(self._sdf))

    @property
    def volume(self) -&gt; Tensor:
        return self._volume

    @property
    def faces(self) -&gt; &#39;Geometry&#39;:
        raise NotImplementedError(f&#34;SDF does not support faces&#34;)

    @property
    def face_centers(self) -&gt; Tensor:
        raise NotImplementedError(f&#34;SDF does not support faces&#34;)

    @property
    def face_areas(self) -&gt; Tensor:
        raise NotImplementedError(f&#34;SDF does not support faces&#34;)

    @property
    def face_normals(self) -&gt; Tensor:
        raise NotImplementedError(f&#34;SDF does not support faces&#34;)

    @property
    def boundary_elements(self) -&gt; Dict[Any, Dict[str, slice]]:
        return {}

    @property
    def boundary_faces(self) -&gt; Dict[Any, Dict[str, slice]]:
        return {}

    @property
    def face_shape(self) -&gt; Shape:
        return math.EMPTY_SHAPE

    @property
    def corners(self) -&gt; Tensor:
        raise NotImplementedError(f&#34;SDF does not support corners&#34;)

    def lies_inside(self, location: Tensor) -&gt; Tensor:
        float_idx = (location - self._bounds.lower) / self.size * self.resolution
        sdf_val = math.grid_sample(self._sdf, float_idx - .5, math.extrapolation.ZERO_GRADIENT)
        if self._approximate_outside:
            within_bounds = self._bounds.lies_inside(location)
            return within_bounds &amp; (sdf_val &lt;= 0)
        else:
            return sdf_val &lt;= 0

    def approximate_closest_surface(self, location: Tensor) -&gt; Tuple[Tensor, Tensor, Tensor, Tensor, Tensor]:
        if self._approximate_outside:
            location = self._bounds.push(location, outward=False)
        float_idx = (location - self._bounds.lower) / self.size * self.resolution
        sgn_dist = math.grid_sample(self._sdf, float_idx - .5, math.extrapolation.ZERO_GRADIENT)
        if self._to_surface is not None:
            to_surf = math.grid_sample(self._to_surface, float_idx - .5, math.extrapolation.ZERO_GRADIENT)
        else:
            sdf_grad = math.grid_sample(self._grad, float_idx - 1, math.extrapolation.ZERO_GRADIENT)
            sdf_grad = math.vec_normalize(sdf_grad)  # theoretically not necessary
            to_surf = sgn_dist * -sdf_grad
        surface_pos = location + to_surf
        if self._surf_normal is not None:
            normal = math.grid_sample(self._surf_normal, float_idx - .5, math.extrapolation.ZERO_GRADIENT)
            int_index = clip(math.to_int32(float_idx), 0, wrap(spatial(self._surf_index), &#39;(x,y,z)&#39;)-1)
            face_index = self._surf_index[int_index]
        else:
            surf_float_idx = (surface_pos - self._bounds.lower) / self.size * self.resolution
            normal = math.grid_sample(self._grad, surf_float_idx - 1, math.extrapolation.ZERO_GRADIENT)
            # normal = math.where(self._bounds.lies_inside(surface_pos), normal, sdf_grad)  # use current normal if surface point is outside SDF grid
            normal = math.vec_normalize(normal)
            face_index = None
        offset = normal.vector @ surface_pos.vector
        return sgn_dist, to_surf, normal, offset, face_index

    def approximate_signed_distance(self, location: Tensor) -&gt; Tensor:
        float_idx = (location - self._bounds.lower) / self.size * self.resolution
        sdf_val = math.grid_sample(self._sdf, float_idx - .5, math.extrapolation.ZERO_GRADIENT)
        if self._approximate_outside:
            within_bounds = self._bounds.lies_inside(location)
            dist_from_center = math.vec_length(location - self._center) - self._bounding_radius
            return math.where(within_bounds, sdf_val, dist_from_center)
        else:
            return sdf_val

    def sample_uniform(self, *shape: math.Shape) -&gt; Tensor:
        raise NotImplementedError

    def bounding_radius(self) -&gt; Tensor:
        return self._bounding_radius

    def bounding_half_extent(self) -&gt; Tensor:
        return self._bounds.half_size  # this could be too small if the center is not in the middle of the bounds

    def shifted(self, delta: Tensor) -&gt; &#39;Geometry&#39;:
        return SDFGrid(self._sdf, self._bounds.shifted(delta), self._approximate_outside, self._grad, self._to_surface, self._surf_normal, self._surf_index, self._center + delta, self._volume, self._bounding_radius)

    def at(self, center: Tensor) -&gt; &#39;Geometry&#39;:
        return self.shifted(center - self._center)

    def rotated(self, angle: Union[float, Tensor]) -&gt; &#39;Geometry&#39;:
        raise NotImplementedError(&#34;SDF does not yet support rotation&#34;)

    def scaled(self, factor: Union[float, Tensor]) -&gt; &#39;Geometry&#39;:
        off_center = self._center - self._bounds.center
        volume = self._volume * factor ** self.spatial_rank
        bounds = self._bounds.scaled(factor).shifted(off_center * (factor - 1)).corner_representation()
        return SDFGrid(self._sdf, bounds, self._approximate_outside, self._grad, self._to_surface, self._surf_normal, self._surf_index, self._center, volume, self._bounding_radius * factor)

    def __getitem__(self, item):
        item = slicing_dict(self, item)
        if &#39;vector&#39; in item:
            raise NotImplementedError(&#34;SDF projection not yet supported&#34;)
        return SDFGrid(self._sdf[item], self._bounds[item], self._approximate_outside, math.slice(self._grad, item), math.slice(self._to_surface, item), math.slice(self._surf_normal, item), math.slice(self._surf_index, item), math.slice(self._center, item), math.slice(self._volume, item), math.slice(self._bounding_radius, item))

    def approximate_occupancy(self):
        assert self._surf_normal is not None
        unit_corners = Cuboid(half_size=.5*self.dx).corners
        surf_dist = self._surf_normal.vector @ self._to_surface.vector
        corner_sdf = unit_corners.vector @ self._surf_normal.vector - surf_dist
        total_dist = math.sum(abs(corner_sdf), dual)
        neg_dist = math.sum(math.minimum(0, corner_sdf), dual)
        occ_near_surf = -neg_dist / total_dist
        occ_away = self._sdf &lt;= 0
        return math.where(abs(self._sdf) &lt; .5*math.vec_length(self.dx), occ_near_surf, occ_away)

    def approximate_fraction_inside(self, other_geometry: &#39;Geometry&#39;, balance: Union[Tensor, Number] = 0.5) -&gt; Tensor:
        if other_geometry == self.grid and math.always_close(balance, .5):
            return self.approximate_occupancy()
        else:
            return Geometry.approximate_fraction_inside(self, other_geometry, balance)

    def downsample2x(self):
        s, g, t, n, i = [math.downsample2x(v) for v in (self._sdf, self._grad, self._to_surface, self._surf_normal, self._surf_index)]
        return SDFGrid(s, self._bounds, self._approximate_outside, g, t, n, i, self._center, self._volume, self._bounding_radius)</code></pre>
</details>
<div class="desc"><p>Grid-based signed distance field.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sdf</code></strong></dt>
<dd>Signed distance values. <code>Tensor</code> with spatial dimensions corresponding to the physical space.
Each value samples the SDF value at the center of a virtual cell.</dd>
<dt><strong><code>bounds</code></strong></dt>
<dd>Grid limits. The bounds fully enclose all virtual cells.</dd>
<dt><strong><code>approximate_outside</code></strong></dt>
<dd>Whether queries outside the SDF grid should return approximate values. This requires additional computations.</dd>
<dt><strong><code>gradient</code></strong></dt>
<dd>(Optional) Pre-computed gradient grid. Will be computed otherwise.</dd>
<dt><strong><code>center</code></strong></dt>
<dd>(Optional) Geometry center point. Will be computed otherwise.</dd>
<dt><strong><code>volume</code></strong></dt>
<dd>(Optional) Geometry volume. Will be computed otherwise.</dd>
<dt><strong><code>bounding_radius</code></strong></dt>
<dd>(Optional) Geometry bounding radius around center. Will be computed otherwise.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.geom._geom.Geometry</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="phi.geom.SDFGrid.boundary_elements"><code class="name">prop <span class="ident">boundary_elements</span> : Dict[Any, Dict[str, slice]]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def boundary_elements(self) -&gt; Dict[Any, Dict[str, slice]]:
    return {}</code></pre>
</details>
<div class="desc"><p>Slices on the primal dimensions to mark boundary elements.
Grids and meshes have no boundary elements and return <code>{}</code>.
Dynamic graphs can define boundary elements for obstacles and walls.</p>
<h2 id="returns">Returns</h2>
<p>Map from <code>name</code> to slicing <code>dict</code>.</p></div>
</dd>
<dt id="phi.geom.SDFGrid.boundary_faces"><code class="name">prop <span class="ident">boundary_faces</span> : Dict[Any, Dict[str, slice]]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def boundary_faces(self) -&gt; Dict[Any, Dict[str, slice]]:
    return {}</code></pre>
</details>
<div class="desc"><p>Slices on the dual dimensions to mark boundary faces.</p>
<p>Regular grids use the keys (dim, is_upper) to identify boundaries.
Unstructured meshes use string identifiers for the boundaries.
Dynamic graphs return slices along the dual dimensions.</p>
<h2 id="returns">Returns</h2>
<p>Map from <code>name</code> to slicing <code>dict</code>.</p></div>
</dd>
<dt id="phi.geom.SDFGrid.bounds"><code class="name">prop <span class="ident">bounds</span> : phi.geom._box.Box</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bounds(self) -&gt; Box:
    return self._bounds</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.SDFGrid.center"><code class="name">prop <span class="ident">center</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def center(self) -&gt; Tensor:
    return self._center</code></pre>
</details>
<div class="desc"><p>Center location in single channel dimension.</p></div>
</dd>
<dt id="phi.geom.SDFGrid.corners"><code class="name">prop <span class="ident">corners</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def corners(self) -&gt; Tensor:
    raise NotImplementedError(f&#34;SDF does not support corners&#34;)</code></pre>
</details>
<div class="desc"><h2 id="returns">Returns</h2>
<p>Corner locations as <code>phiml.math.Tensor</code>.
Corners belonging to one object or cell are listed along dual dimensions.
If the object has no corners, a size-0 tensor with the correct vector and instance dims is returned.</p></div>
</dd>
<dt id="phi.geom.SDFGrid.dx"><code class="name">prop <span class="ident">dx</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def dx(self) -&gt; Tensor:
    return self._bounds.size / spatial(self._sdf)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.SDFGrid.face_areas"><code class="name">prop <span class="ident">face_areas</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_areas(self) -&gt; Tensor:
    raise NotImplementedError(f&#34;SDF does not support faces&#34;)</code></pre>
</details>
<div class="desc"><p>Area of face connecting a pair of cells. Shape <code>(elements, ~)</code>.
Returns 0 for unconnected cells.</p></div>
</dd>
<dt id="phi.geom.SDFGrid.face_centers"><code class="name">prop <span class="ident">face_centers</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_centers(self) -&gt; Tensor:
    raise NotImplementedError(f&#34;SDF does not support faces&#34;)</code></pre>
</details>
<div class="desc"><p>Center of face connecting a pair of cells. Shape <code>(elements, ~, vector)</code>.
Here, <code>~</code> represents arbitrary internal dual dimensions, such as <code>~staggered_direction</code> or <code>~elements</code>.
Returns 0-vectors for unconnected cells.</p></div>
</dd>
<dt id="phi.geom.SDFGrid.face_normals"><code class="name">prop <span class="ident">face_normals</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_normals(self) -&gt; Tensor:
    raise NotImplementedError(f&#34;SDF does not support faces&#34;)</code></pre>
</details>
<div class="desc"><p>Normal vectors of cell faces, including boundary faces. Shape <code>(elements, ~, vector)</code>.
For meshes, The vectors point out of the primal cells and into the dual cells.</p>
<p>Instance/spatial dimensions along which the normal does not vary may not be included in the result tensor's shape.</p></div>
</dd>
<dt id="phi.geom.SDFGrid.face_shape"><code class="name">prop <span class="ident">face_shape</span> : phiml.math._shape.Shape</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_shape(self) -&gt; Shape:
    return math.EMPTY_SHAPE</code></pre>
</details>
<div class="desc"><h2 id="returns">Returns</h2>
<p>Full Shape to identify each face of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>, including instance/spatial dimensions for the elements and dual dimensions listing the faces per element.
If this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> has no faces, returns an empty <code>Shape</code>.</p></div>
</dd>
<dt id="phi.geom.SDFGrid.faces"><code class="name">prop <span class="ident">faces</span> : <a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def faces(self) -&gt; &#39;Geometry&#39;:
    raise NotImplementedError(f&#34;SDF does not support faces&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.SDFGrid.grid"><code class="name">prop <span class="ident">grid</span> : phi.geom._grid.UniformGrid</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def grid(self) -&gt; UniformGrid:
    return UniformGrid(spatial(self._sdf), self._bounds)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.SDFGrid.points"><code class="name">prop <span class="ident">points</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def points(self) -&gt; Tensor:
    return UniformGrid(spatial(self._sdf), self._bounds).center</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.SDFGrid.resolution"><code class="name">prop <span class="ident">resolution</span> : phiml.math._shape.Shape</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def resolution(self) -&gt; Shape:
    return spatial(self._sdf)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.SDFGrid.shape"><code class="name">prop <span class="ident">shape</span> : phiml.math._shape.Shape</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape(self) -&gt; Shape:
    return non_spatial(self._sdf) &amp; channel(vector=spatial(self._sdf))</code></pre>
</details>
<div class="desc"><p>The <code>shape</code> of a <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> consists of the following dimensions:</p>
<ul>
<li>A single <em>channel</em> dimension called <code>'vector'</code> specifying the physical space</li>
<li>Instance dimensions denote that this geometry consists of multiple copies in the same space</li>
<li>Spatial dimensions denote a crystal (repeating structure) of this geometric primitive in space</li>
<li>Batch dimensions indicate non-interacting versions of this geometry for parallelization only.</li>
</ul></div>
</dd>
<dt id="phi.geom.SDFGrid.size"><code class="name">prop <span class="ident">size</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; Tensor:
    return self._bounds.size</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.SDFGrid.values"><code class="name">prop <span class="ident">values</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def values(self):
    &#34;&#34;&#34;Signed distance grid.&#34;&#34;&#34;
    return self._sdf</code></pre>
</details>
<div class="desc"><p>Signed distance grid.</p></div>
</dd>
<dt id="phi.geom.SDFGrid.volume"><code class="name">prop <span class="ident">volume</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def volume(self) -&gt; Tensor:
    return self._volume</code></pre>
</details>
<div class="desc"><p><code>phi.math.Tensor</code> representing the volume of each element.
The result retains batch, spatial and instance dimensions.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phi.geom.SDFGrid.approximate_closest_surface"><code class="name flex">
<span>def <span class="ident">approximate_closest_surface</span></span>(<span>self, location: phiml.math._tensors.Tensor) ‑> Tuple[phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def approximate_closest_surface(self, location: Tensor) -&gt; Tuple[Tensor, Tensor, Tensor, Tensor, Tensor]:
    if self._approximate_outside:
        location = self._bounds.push(location, outward=False)
    float_idx = (location - self._bounds.lower) / self.size * self.resolution
    sgn_dist = math.grid_sample(self._sdf, float_idx - .5, math.extrapolation.ZERO_GRADIENT)
    if self._to_surface is not None:
        to_surf = math.grid_sample(self._to_surface, float_idx - .5, math.extrapolation.ZERO_GRADIENT)
    else:
        sdf_grad = math.grid_sample(self._grad, float_idx - 1, math.extrapolation.ZERO_GRADIENT)
        sdf_grad = math.vec_normalize(sdf_grad)  # theoretically not necessary
        to_surf = sgn_dist * -sdf_grad
    surface_pos = location + to_surf
    if self._surf_normal is not None:
        normal = math.grid_sample(self._surf_normal, float_idx - .5, math.extrapolation.ZERO_GRADIENT)
        int_index = clip(math.to_int32(float_idx), 0, wrap(spatial(self._surf_index), &#39;(x,y,z)&#39;)-1)
        face_index = self._surf_index[int_index]
    else:
        surf_float_idx = (surface_pos - self._bounds.lower) / self.size * self.resolution
        normal = math.grid_sample(self._grad, surf_float_idx - 1, math.extrapolation.ZERO_GRADIENT)
        # normal = math.where(self._bounds.lies_inside(surface_pos), normal, sdf_grad)  # use current normal if surface point is outside SDF grid
        normal = math.vec_normalize(normal)
        face_index = None
    offset = normal.vector @ surface_pos.vector
    return sgn_dist, to_surf, normal, offset, face_index</code></pre>
</details>
<div class="desc"><p>Find the closest surface face of this geometry given a point that can be outside or inside the geometry.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd><code>Tensor</code> with a single channel dimension called vector. Can have arbitrary other dimensions.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>signed_distance</code></dt>
<dd>Scalar signed distance from <code>location</code>
to the closest point on the surface.
Positive values indicate the point lies outside the geometry, negative values indicate the point lies inside the geometry.</dd>
<dt><code>delta</code></dt>
<dd>Vector-valued distance vector from <code>location</code> to the closest point on the surface.</dd>
<dt><code>normal</code></dt>
<dd>Closest surface normal vector.</dd>
<dt><code>offset</code></dt>
<dd>Min distance of a surface-tangential plane from 0 as a scalar.</dd>
<dt><code>face_index</code></dt>
<dd>(Optional) An index vector pointing at the closest face.</dd>
</dl></div>
</dd>
<dt id="phi.geom.SDFGrid.approximate_fraction_inside"><code class="name flex">
<span>def <span class="ident">approximate_fraction_inside</span></span>(<span>self,<br>other_geometry: <a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a>,<br>balance: phiml.math._tensors.Tensor | numbers.Number = 0.5) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def approximate_fraction_inside(self, other_geometry: &#39;Geometry&#39;, balance: Union[Tensor, Number] = 0.5) -&gt; Tensor:
    if other_geometry == self.grid and math.always_close(balance, .5):
        return self.approximate_occupancy()
    else:
        return Geometry.approximate_fraction_inside(self, other_geometry, balance)</code></pre>
</details>
<div class="desc"><p>Computes the approximate overlap between the geometry and a small other geometry.
Returns 1.0 if <code>other_geometry</code> is fully enclosed in this geometry and 0.0 if there is no overlap.
Close to the surface of this geometry, the fraction filled is differentiable w.r.t. the location and size of <code>other_geometry</code>.</p>
<p>To call this method on batches of geometries of same shape, pass a batched Geometry instance.
The result tensor will match the batch shape of <code>other_geometry</code>.</p>
<p>The result may only be accurate in special cases.
The given geometries may be approximated as spheres or boxes using <code>bounding_radius()</code> and <code>bounding_half_extent()</code>.</p>
<p>The default implementation of this method approximates other_geometry as a Sphere and computes the fraction using <code>approximate_signed_distance()</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>other_geometry</code></strong></dt>
<dd><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> or geometry batch for which to compute the overlap with <code>self</code>.</dd>
<dt><strong><code>balance</code></strong></dt>
<dd>Mid-level between 0 and 1, default 0.5.
This value is returned when exactly half of <code>other_geometry</code> lies inside <code>self</code>.
<code>0.5 &lt; balance &lt;= 1</code> makes <code>self</code> seem larger while <code>0 &lt;= balance &lt; 0.5</code>makes <code>self</code> seem smaller.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>fraction of cell volume lying inside the geometry. float tensor of shape (other_geometry.batch_shape, 1).</p></div>
</dd>
<dt id="phi.geom.SDFGrid.approximate_occupancy"><code class="name flex">
<span>def <span class="ident">approximate_occupancy</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def approximate_occupancy(self):
    assert self._surf_normal is not None
    unit_corners = Cuboid(half_size=.5*self.dx).corners
    surf_dist = self._surf_normal.vector @ self._to_surface.vector
    corner_sdf = unit_corners.vector @ self._surf_normal.vector - surf_dist
    total_dist = math.sum(abs(corner_sdf), dual)
    neg_dist = math.sum(math.minimum(0, corner_sdf), dual)
    occ_near_surf = -neg_dist / total_dist
    occ_away = self._sdf &lt;= 0
    return math.where(abs(self._sdf) &lt; .5*math.vec_length(self.dx), occ_near_surf, occ_away)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.SDFGrid.approximate_signed_distance"><code class="name flex">
<span>def <span class="ident">approximate_signed_distance</span></span>(<span>self, location: phiml.math._tensors.Tensor) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def approximate_signed_distance(self, location: Tensor) -&gt; Tensor:
    float_idx = (location - self._bounds.lower) / self.size * self.resolution
    sdf_val = math.grid_sample(self._sdf, float_idx - .5, math.extrapolation.ZERO_GRADIENT)
    if self._approximate_outside:
        within_bounds = self._bounds.lies_inside(location)
        dist_from_center = math.vec_length(location - self._center) - self._bounding_radius
        return math.where(within_bounds, sdf_val, dist_from_center)
    else:
        return sdf_val</code></pre>
</details>
<div class="desc"><p>Computes the approximate distance from location to the surface of the geometry.
Locations outside return positive values, inside negative values and zero exactly at the boundary.</p>
<p>The exact distance metric used depends on the geometry.
The approximation holds close to the surface and the distance grows to infinity as the location is moved infinitely far from the geometry.
The distance metric is differentiable and its gradients are bounded at every point in space.</p>
<p>When dealing with unions or collections of geometries (instance dimensions), the shortest distance to any instance is returned.
This also holds for negative distances.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd><code>Tensor</code> with one channel dim <code>vector</code> matching the geometry's <code>vector</code> dim.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Float <code>Tensor</code></p></div>
</dd>
<dt id="phi.geom.SDFGrid.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>self, center: phiml.math._tensors.Tensor) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def at(self, center: Tensor) -&gt; &#39;Geometry&#39;:
    return self.shifted(center - self._center)</code></pre>
</details>
<div class="desc"><p>Returns a copy of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> with the center at <code>center</code>.
This is equal to calling <code>self @ center</code>.</p>
<p>See Also:
<code><a title="phi.geom.Geometry.shifted" href="#phi.geom.Geometry.shifted">Geometry.shifted()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>center</code></strong></dt>
<dd>New center as <code>Tensor</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.</p></div>
</dd>
<dt id="phi.geom.SDFGrid.bounding_half_extent"><code class="name flex">
<span>def <span class="ident">bounding_half_extent</span></span>(<span>self) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bounding_half_extent(self) -&gt; Tensor:
    return self._bounds.half_size  # this could be too small if the center is not in the middle of the bounds</code></pre>
</details>
<div class="desc"><p>The bounding half-extent sets a limit on the outer-most point for each coordinate axis.
Each component is non-negative.</p>
<p>Let the bounding half-extent have value <code>e</code> in dimension <code>d</code> (<code>extent[...,d] = e</code>).
Then, no point of the geometry lies further away from its center point than <code>e</code> along <code>d</code> (in both axis directions).</p>
<p>If this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.
If these dims are not present on the result, all parts are assumed to have the same bounds.</p></div>
</dd>
<dt id="phi.geom.SDFGrid.bounding_radius"><code class="name flex">
<span>def <span class="ident">bounding_radius</span></span>(<span>self) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bounding_radius(self) -&gt; Tensor:
    return self._bounding_radius</code></pre>
</details>
<div class="desc"><p>Returns the radius of a Sphere object that fully encloses this geometry.
The sphere is centered at the center of this geometry.</p>
<p>If this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.
If these dims are not present on the result, all parts are assumed to have the same bounds.</p></div>
</dd>
<dt id="phi.geom.SDFGrid.downsample2x"><code class="name flex">
<span>def <span class="ident">downsample2x</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def downsample2x(self):
    s, g, t, n, i = [math.downsample2x(v) for v in (self._sdf, self._grad, self._to_surface, self._surf_normal, self._surf_index)]
    return SDFGrid(s, self._bounds, self._approximate_outside, g, t, n, i, self._center, self._volume, self._bounding_radius)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.SDFGrid.lies_inside"><code class="name flex">
<span>def <span class="ident">lies_inside</span></span>(<span>self, location: phiml.math._tensors.Tensor) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lies_inside(self, location: Tensor) -&gt; Tensor:
    float_idx = (location - self._bounds.lower) / self.size * self.resolution
    sdf_val = math.grid_sample(self._sdf, float_idx - .5, math.extrapolation.ZERO_GRADIENT)
    if self._approximate_outside:
        within_bounds = self._bounds.lies_inside(location)
        return within_bounds &amp; (sdf_val &lt;= 0)
    else:
        return sdf_val &lt;= 0</code></pre>
</details>
<div class="desc"><p>Tests whether the given location lies inside or outside of the geometry. Locations on the surface count as inside.</p>
<p>When dealing with unions or collections of geometries (instance dimensions), a point lies inside the geometry if it lies inside any instance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd>float tensor of shape (batch_size, &hellip;, rank)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>bool tensor of shape (*location.shape[:-1], 1).</p></div>
</dd>
<dt id="phi.geom.SDFGrid.rotated"><code class="name flex">
<span>def <span class="ident">rotated</span></span>(<span>self, angle: phiml.math._tensors.Tensor | float) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotated(self, angle: Union[float, Tensor]) -&gt; &#39;Geometry&#39;:
    raise NotImplementedError(&#34;SDF does not yet support rotation&#34;)</code></pre>
</details>
<div class="desc"><p>Returns a rotated version of this geometry.
The geometry is rotated about its center point.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>angle</code></strong></dt>
<dd>
<p>Delta rotation.
Either</p>
<ul>
<li>Angle(s): scalar angle in 2d or euler angles along <code>vector</code> in 3D or higher.</li>
<li>Matrix: d⨯d rotation matrix</li>
</ul>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Rotated <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></p></div>
</dd>
<dt id="phi.geom.SDFGrid.sample_uniform"><code class="name flex">
<span>def <span class="ident">sample_uniform</span></span>(<span>self, *shape: phiml.math._shape.Shape) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_uniform(self, *shape: math.Shape) -&gt; Tensor:
    raise NotImplementedError</code></pre>
</details>
<div class="desc"><p>Samples uniformly distributed random points inside this volume.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*shape</code></strong></dt>
<dd>How many points to sample per individual geometry.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>Tensor</code> containing all dimensions from <code><a title="phi.geom.Geometry.shape" href="#phi.geom.Geometry.shape">Geometry.shape</a></code>, <code>shape</code> as well as a <code>channel</code> dimension <code>vector</code> matching the dimensionality of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.</p></div>
</dd>
<dt id="phi.geom.SDFGrid.scaled"><code class="name flex">
<span>def <span class="ident">scaled</span></span>(<span>self, factor: phiml.math._tensors.Tensor | float) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scaled(self, factor: Union[float, Tensor]) -&gt; &#39;Geometry&#39;:
    off_center = self._center - self._bounds.center
    volume = self._volume * factor ** self.spatial_rank
    bounds = self._bounds.scaled(factor).shifted(off_center * (factor - 1)).corner_representation()
    return SDFGrid(self._sdf, bounds, self._approximate_outside, self._grad, self._to_surface, self._surf_normal, self._surf_index, self._center, volume, self._bounding_radius * factor)</code></pre>
</details>
<div class="desc"><p>Scales each individual geometry by <code>factor</code>.
The individual <code>center</code> points act as pivots for the operation.</p>
<h2 id="args">Args</h2>
<p>factor:
Returns:</p></div>
</dd>
<dt id="phi.geom.SDFGrid.shifted"><code class="name flex">
<span>def <span class="ident">shifted</span></span>(<span>self, delta: phiml.math._tensors.Tensor) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shifted(self, delta: Tensor) -&gt; &#39;Geometry&#39;:
    return SDFGrid(self._sdf, self._bounds.shifted(delta), self._approximate_outside, self._grad, self._to_surface, self._surf_normal, self._surf_index, self._center + delta, self._volume, self._bounding_radius)</code></pre>
</details>
<div class="desc"><p>Returns a translated version of this geometry.</p>
<p>See Also:
<code><a title="phi.geom.Geometry.at" href="#phi.geom.Geometry.at">Geometry.at()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>delta</code></strong></dt>
<dd>direction vector</dd>
<dt><strong><code>delta</code></strong></dt>
<dd>Tensor:</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></dt>
<dd>shifted geometry</dd>
</dl></div>
</dd>
<dt id="phi.geom.SDFGrid.with_values"><code class="name flex">
<span>def <span class="ident">with_values</span></span>(<span>self, values: phiml.math._tensors.Tensor)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_values(self, values: Tensor):
    values = expand(values, spatial(self._sdf) - spatial(values))
    return SDFGrid(values, self._bounds, self._approximate_outside, self._grad, self._to_surface, self._surf_normal, self._surf_index, self._center, self._volume, self._bounding_radius)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="phi.geom.Sphere"><code class="flex name class">
<span>class <span class="ident">Sphere</span></span>
<span>(</span><span>pos: phiml.math._tensors.Tensor,<br>radius: phiml.math._tensors.Tensor,<br>variable_attrs: Tuple[str, ...] = ('pos', 'radius'))</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@sliceable(keepdims=&#39;vector&#39;)
@dataclass(frozen=True, eq=False)
class Sphere(Geometry, metaclass=SphereType):
    &#34;&#34;&#34;
    N-dimensional sphere.
    Defined through center position and radius.
    &#34;&#34;&#34;
    
    pos: Tensor
    radius: Tensor
    
    variable_attrs: Tuple[str, ...] = (&#39;pos&#39;, &#39;radius&#39;)
    
    def __post_init__(self):
        assert &#39;vector&#39; in self.pos.shape
        assert &#39;vector&#39; not in self.radius.shape, f&#34;Sphere radius must not vary along vector but got {self.radius}&#34;

    @cached_property
    def shape(self):
        return self.pos.shape &amp; self.radius.shape

    @property
    def center(self):
        return self.pos

    @cached_property
    def volume(self) -&gt; math.Tensor:
        return Sphere.volume_from_radius(self.radius, self.spatial_rank)

    @staticmethod
    def volume_from_radius(radius: Union[float, Tensor], spatial_rank: int):
        if spatial_rank == 1:
            return 2 * radius
        elif spatial_rank == 2:
            return PI * radius ** 2
        elif spatial_rank == 3:
            return 4/3 * PI * radius ** 3
        else:
            raise NotImplementedError(f&#34;spatial_rank&gt;3 not supported, got {spatial_rank}&#34;)
            # n = self.spatial_rank
            # return math.pi ** (n // 2) / math.faculty(math.ceil(n / 2)) * self.radius ** n

    @staticmethod
    def radius_from_volume(volume: Union[float, Tensor], spatial_rank: int):
        if spatial_rank == 1:
            return volume / 2
        elif spatial_rank == 2:
            return math.sqrt(volume / PI)
        elif spatial_rank == 3:
            return (.75 / PI * volume) ** (1/3)
        else:
            raise NotImplementedError(f&#34;spatial_rank&gt;3 not supported, got {spatial_rank}&#34;)

    @staticmethod
    def area_from_radius(radius: Union[float, Tensor], spatial_rank: int):
        if spatial_rank == 1:
            return 0
        elif spatial_rank == 2:
            return 2*PI * radius
        elif spatial_rank == 3:
            return 4*PI * radius**2
        else:
            raise NotImplementedError(f&#34;spatial_rank&gt;3 not supported, got {spatial_rank}&#34;)

    def lies_inside(self, location):
        distance_squared = math.sum((location - self.center) ** 2, dim=&#39;vector&#39;)
        return math.any(distance_squared &lt;= self.radius ** 2, self.shape.instance)  # union for instance dimensions

    def approximate_signed_distance(self, location: Union[Tensor, tuple]):
        &#34;&#34;&#34;
        Computes the exact distance from location to the closest point on the sphere.
        Very close to the sphere center, the distance takes a constant value.

        Args:
          location: float tensor of shape (batch_size, ..., rank)

        Returns:
          float tensor of shape (*location.shape[:-1], 1).

        &#34;&#34;&#34;
        distance = vec_length(location - self.pos, eps=1e-3)
        return math.min(distance - self.radius, self.shape.instance)  # union for instance dimensions

    def approximate_closest_surface(self, location: Tensor) -&gt; Tuple[Tensor, Tensor, Tensor, Tensor, Tensor]:
        self_center = self.center
        self_radius = self.radius
        center_delta = location - self_center
        center_dist = vec_length(center_delta)
        sgn_dist = center_dist - self_radius
        if instance(self):
            self_center, self_radius, sgn_dist, center_delta, center_dist = math.at_min((self.center, self.radius, sgn_dist, center_delta, center_dist), key=abs(sgn_dist), dim=instance(self))
        normal = math.safe_div(center_delta, center_dist)
        default_normal = wrap([1] + [0] * (self.spatial_rank-1), self.shape[&#39;vector&#39;])
        normal = math.where(center_dist == 0, default_normal, normal)
        surface_pos = self_center + self_radius * normal
        delta = surface_pos - location
        face_index = expand(0, non_channel(location))
        offset = normal.vector @ surface_pos.vector
        return sgn_dist, delta, normal, offset, face_index

    def sample_uniform(self, *shape: math.Shape):
        # --- Choose a distance from the center of the sphere, equally weighted by mass ---
        uniform = math.random_uniform(self.shape.non_singleton.without(&#39;vector&#39;), *shape)
        if self.spatial_rank == 1:
            r = self.radius * uniform
        else:
            r = self.radius * (uniform ** (1 / self.spatial_rank))
        # --- Uniformly sample a unit vector for direction over the surface of the sphere (Muller 1959, Marsaglia 1972) ---
        unit_vector = math.random_normal(self.shape.non_singleton.without(&#39;vector&#39;), *shape, self.shape[&#39;vector&#39;])
        unit_vector /= vec_length(unit_vector)
        return self.center + r * unit_vector

    def bounding_radius(self):
        return self.radius

    def bounding_half_extent(self):
        return expand(self.radius, self.pos.shape.only(&#39;vector&#39;))

    def at(self, center: Tensor) -&gt; &#39;Geometry&#39;:
        return replace(self, pos=center)

    def rotated(self, angle):
        return self

    def scaled(self, factor: Union[float, Tensor]) -&gt; &#39;Geometry&#39;:
        return replace(self, radius=self.radius * factor)

    @property
    def faces(self) -&gt; &#39;Geometry&#39;:
        raise NotImplementedError(f&#34;Sphere.faces not implemented.&#34;)

    @property
    def face_centers(self) -&gt; Tensor:
        return math.zeros(self.shape &amp; dual(shell=0))

    @property
    def face_areas(self) -&gt; Tensor:
        return expand(Sphere.area_from_radius(self.radius, self.spatial_rank), instance(self) + dual(shell=1))

    @property
    def face_normals(self) -&gt; Tensor:
        return math.zeros(self.shape &amp; dual(shell=0))

    @property
    def boundary_elements(self) -&gt; Dict[str, Tuple[Dict[str, slice], Dict[str, slice]]]:
        return {}

    @property
    def boundary_faces(self) -&gt; Dict[str, Tuple[Dict[str, slice], Dict[str, slice]]]:
        return {}

    @property
    def face_shape(self) -&gt; Shape:
        return self.shape.without(&#39;vector&#39;) &amp; dual(shell=1)

    @property
    def corners(self) -&gt; Tensor:
        return math.zeros(self.shape &amp; dual(corners=0))</code></pre>
</details>
<div class="desc"><p>N-dimensional sphere.
Defined through center position and radius.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.geom._geom.Geometry</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="phi.geom.Sphere.area_from_radius"><code class="name flex">
<span>def <span class="ident">area_from_radius</span></span>(<span>radius: phiml.math._tensors.Tensor | float, spatial_rank: int)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def area_from_radius(radius: Union[float, Tensor], spatial_rank: int):
    if spatial_rank == 1:
        return 0
    elif spatial_rank == 2:
        return 2*PI * radius
    elif spatial_rank == 3:
        return 4*PI * radius**2
    else:
        raise NotImplementedError(f&#34;spatial_rank&gt;3 not supported, got {spatial_rank}&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Sphere.radius_from_volume"><code class="name flex">
<span>def <span class="ident">radius_from_volume</span></span>(<span>volume: phiml.math._tensors.Tensor | float, spatial_rank: int)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def radius_from_volume(volume: Union[float, Tensor], spatial_rank: int):
    if spatial_rank == 1:
        return volume / 2
    elif spatial_rank == 2:
        return math.sqrt(volume / PI)
    elif spatial_rank == 3:
        return (.75 / PI * volume) ** (1/3)
    else:
        raise NotImplementedError(f&#34;spatial_rank&gt;3 not supported, got {spatial_rank}&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Sphere.volume_from_radius"><code class="name flex">
<span>def <span class="ident">volume_from_radius</span></span>(<span>radius: phiml.math._tensors.Tensor | float, spatial_rank: int)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def volume_from_radius(radius: Union[float, Tensor], spatial_rank: int):
    if spatial_rank == 1:
        return 2 * radius
    elif spatial_rank == 2:
        return PI * radius ** 2
    elif spatial_rank == 3:
        return 4/3 * PI * radius ** 3
    else:
        raise NotImplementedError(f&#34;spatial_rank&gt;3 not supported, got {spatial_rank}&#34;)
        # n = self.spatial_rank
        # return math.pi ** (n // 2) / math.faculty(math.ceil(n / 2)) * self.radius ** n</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="phi.geom.Sphere.Tc"><code class="name">prop <span class="ident">Tc</span></code></dt>
<dd>
<div class="desc"><p>partial(func, <em>args, </em>*keywords) - new function with partial application
of the given arguments and keywords.</p></div>
</dd>
<dt id="phi.geom.Sphere.Ti"><code class="name">prop <span class="ident">Ti</span></code></dt>
<dd>
<div class="desc"><p>partial(func, <em>args, </em>*keywords) - new function with partial application
of the given arguments and keywords.</p></div>
</dd>
<dt id="phi.geom.Sphere.Ts"><code class="name">prop <span class="ident">Ts</span></code></dt>
<dd>
<div class="desc"><p>partial(func, <em>args, </em>*keywords) - new function with partial application
of the given arguments and keywords.</p></div>
</dd>
<dt id="phi.geom.Sphere.boundary_elements"><code class="name">prop <span class="ident">boundary_elements</span> : Dict[str, Tuple[Dict[str, slice], Dict[str, slice]]]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def boundary_elements(self) -&gt; Dict[str, Tuple[Dict[str, slice], Dict[str, slice]]]:
    return {}</code></pre>
</details>
<div class="desc"><p>Slices on the primal dimensions to mark boundary elements.
Grids and meshes have no boundary elements and return <code>{}</code>.
Dynamic graphs can define boundary elements for obstacles and walls.</p>
<h2 id="returns">Returns</h2>
<p>Map from <code>name</code> to slicing <code>dict</code>.</p></div>
</dd>
<dt id="phi.geom.Sphere.boundary_faces"><code class="name">prop <span class="ident">boundary_faces</span> : Dict[str, Tuple[Dict[str, slice], Dict[str, slice]]]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def boundary_faces(self) -&gt; Dict[str, Tuple[Dict[str, slice], Dict[str, slice]]]:
    return {}</code></pre>
</details>
<div class="desc"><p>Slices on the dual dimensions to mark boundary faces.</p>
<p>Regular grids use the keys (dim, is_upper) to identify boundaries.
Unstructured meshes use string identifiers for the boundaries.
Dynamic graphs return slices along the dual dimensions.</p>
<h2 id="returns">Returns</h2>
<p>Map from <code>name</code> to slicing <code>dict</code>.</p></div>
</dd>
<dt id="phi.geom.Sphere.center"><code class="name">prop <span class="ident">center</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def center(self):
    return self.pos</code></pre>
</details>
<div class="desc"><p>Center location in single channel dimension.</p></div>
</dd>
<dt id="phi.geom.Sphere.corners"><code class="name">prop <span class="ident">corners</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def corners(self) -&gt; Tensor:
    return math.zeros(self.shape &amp; dual(corners=0))</code></pre>
</details>
<div class="desc"><h2 id="returns">Returns</h2>
<p>Corner locations as <code>phiml.math.Tensor</code>.
Corners belonging to one object or cell are listed along dual dimensions.
If the object has no corners, a size-0 tensor with the correct vector and instance dims is returned.</p></div>
</dd>
<dt id="phi.geom.Sphere.face_areas"><code class="name">prop <span class="ident">face_areas</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_areas(self) -&gt; Tensor:
    return expand(Sphere.area_from_radius(self.radius, self.spatial_rank), instance(self) + dual(shell=1))</code></pre>
</details>
<div class="desc"><p>Area of face connecting a pair of cells. Shape <code>(elements, ~)</code>.
Returns 0 for unconnected cells.</p></div>
</dd>
<dt id="phi.geom.Sphere.face_centers"><code class="name">prop <span class="ident">face_centers</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_centers(self) -&gt; Tensor:
    return math.zeros(self.shape &amp; dual(shell=0))</code></pre>
</details>
<div class="desc"><p>Center of face connecting a pair of cells. Shape <code>(elements, ~, vector)</code>.
Here, <code>~</code> represents arbitrary internal dual dimensions, such as <code>~staggered_direction</code> or <code>~elements</code>.
Returns 0-vectors for unconnected cells.</p></div>
</dd>
<dt id="phi.geom.Sphere.face_normals"><code class="name">prop <span class="ident">face_normals</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_normals(self) -&gt; Tensor:
    return math.zeros(self.shape &amp; dual(shell=0))</code></pre>
</details>
<div class="desc"><p>Normal vectors of cell faces, including boundary faces. Shape <code>(elements, ~, vector)</code>.
For meshes, The vectors point out of the primal cells and into the dual cells.</p>
<p>Instance/spatial dimensions along which the normal does not vary may not be included in the result tensor's shape.</p></div>
</dd>
<dt id="phi.geom.Sphere.face_shape"><code class="name">prop <span class="ident">face_shape</span> : phiml.math._shape.Shape</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_shape(self) -&gt; Shape:
    return self.shape.without(&#39;vector&#39;) &amp; dual(shell=1)</code></pre>
</details>
<div class="desc"><h2 id="returns">Returns</h2>
<p>Full Shape to identify each face of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>, including instance/spatial dimensions for the elements and dual dimensions listing the faces per element.
If this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> has no faces, returns an empty <code>Shape</code>.</p></div>
</dd>
<dt id="phi.geom.Sphere.faces"><code class="name">prop <span class="ident">faces</span> : <a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def faces(self) -&gt; &#39;Geometry&#39;:
    raise NotImplementedError(f&#34;Sphere.faces not implemented.&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Sphere.pos"><code class="name">var <span class="ident">pos</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Sphere.radius"><code class="name">var <span class="ident">radius</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Sphere.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def shape(self):
    return self.pos.shape &amp; self.radius.shape</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Sphere.variable_attrs"><code class="name">var <span class="ident">variable_attrs</span> : Tuple[str, ...]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="phi.geom.Sphere.volume"><code class="name">var <span class="ident">volume</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def volume(self) -&gt; math.Tensor:
    return Sphere.volume_from_radius(self.radius, self.spatial_rank)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phi.geom.Sphere.approximate_closest_surface"><code class="name flex">
<span>def <span class="ident">approximate_closest_surface</span></span>(<span>self, location: phiml.math._tensors.Tensor) ‑> Tuple[phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def approximate_closest_surface(self, location: Tensor) -&gt; Tuple[Tensor, Tensor, Tensor, Tensor, Tensor]:
    self_center = self.center
    self_radius = self.radius
    center_delta = location - self_center
    center_dist = vec_length(center_delta)
    sgn_dist = center_dist - self_radius
    if instance(self):
        self_center, self_radius, sgn_dist, center_delta, center_dist = math.at_min((self.center, self.radius, sgn_dist, center_delta, center_dist), key=abs(sgn_dist), dim=instance(self))
    normal = math.safe_div(center_delta, center_dist)
    default_normal = wrap([1] + [0] * (self.spatial_rank-1), self.shape[&#39;vector&#39;])
    normal = math.where(center_dist == 0, default_normal, normal)
    surface_pos = self_center + self_radius * normal
    delta = surface_pos - location
    face_index = expand(0, non_channel(location))
    offset = normal.vector @ surface_pos.vector
    return sgn_dist, delta, normal, offset, face_index</code></pre>
</details>
<div class="desc"><p>Find the closest surface face of this geometry given a point that can be outside or inside the geometry.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd><code>Tensor</code> with a single channel dimension called vector. Can have arbitrary other dimensions.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>signed_distance</code></dt>
<dd>Scalar signed distance from <code>location</code>
to the closest point on the surface.
Positive values indicate the point lies outside the geometry, negative values indicate the point lies inside the geometry.</dd>
<dt><code>delta</code></dt>
<dd>Vector-valued distance vector from <code>location</code> to the closest point on the surface.</dd>
<dt><code>normal</code></dt>
<dd>Closest surface normal vector.</dd>
<dt><code>offset</code></dt>
<dd>Min distance of a surface-tangential plane from 0 as a scalar.</dd>
<dt><code>face_index</code></dt>
<dd>(Optional) An index vector pointing at the closest face.</dd>
</dl></div>
</dd>
<dt id="phi.geom.Sphere.approximate_signed_distance"><code class="name flex">
<span>def <span class="ident">approximate_signed_distance</span></span>(<span>self, location: phiml.math._tensors.Tensor | tuple)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def approximate_signed_distance(self, location: Union[Tensor, tuple]):
    &#34;&#34;&#34;
    Computes the exact distance from location to the closest point on the sphere.
    Very close to the sphere center, the distance takes a constant value.

    Args:
      location: float tensor of shape (batch_size, ..., rank)

    Returns:
      float tensor of shape (*location.shape[:-1], 1).

    &#34;&#34;&#34;
    distance = vec_length(location - self.pos, eps=1e-3)
    return math.min(distance - self.radius, self.shape.instance)  # union for instance dimensions</code></pre>
</details>
<div class="desc"><p>Computes the exact distance from location to the closest point on the sphere.
Very close to the sphere center, the distance takes a constant value.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd>float tensor of shape (batch_size, &hellip;, rank)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>float tensor of shape (*location.shape[:-1], 1).</p></div>
</dd>
<dt id="phi.geom.Sphere.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>self, center: phiml.math._tensors.Tensor) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def at(self, center: Tensor) -&gt; &#39;Geometry&#39;:
    return replace(self, pos=center)</code></pre>
</details>
<div class="desc"><p>Returns a copy of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> with the center at <code>center</code>.
This is equal to calling <code>self @ center</code>.</p>
<p>See Also:
<code><a title="phi.geom.Geometry.shifted" href="#phi.geom.Geometry.shifted">Geometry.shifted()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>center</code></strong></dt>
<dd>New center as <code>Tensor</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.</p></div>
</dd>
<dt id="phi.geom.Sphere.bounding_half_extent"><code class="name flex">
<span>def <span class="ident">bounding_half_extent</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bounding_half_extent(self):
    return expand(self.radius, self.pos.shape.only(&#39;vector&#39;))</code></pre>
</details>
<div class="desc"><p>The bounding half-extent sets a limit on the outer-most point for each coordinate axis.
Each component is non-negative.</p>
<p>Let the bounding half-extent have value <code>e</code> in dimension <code>d</code> (<code>extent[...,d] = e</code>).
Then, no point of the geometry lies further away from its center point than <code>e</code> along <code>d</code> (in both axis directions).</p>
<p>If this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.
If these dims are not present on the result, all parts are assumed to have the same bounds.</p></div>
</dd>
<dt id="phi.geom.Sphere.bounding_radius"><code class="name flex">
<span>def <span class="ident">bounding_radius</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bounding_radius(self):
    return self.radius</code></pre>
</details>
<div class="desc"><p>Returns the radius of a Sphere object that fully encloses this geometry.
The sphere is centered at the center of this geometry.</p>
<p>If this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.
If these dims are not present on the result, all parts are assumed to have the same bounds.</p></div>
</dd>
<dt id="phi.geom.Sphere.lies_inside"><code class="name flex">
<span>def <span class="ident">lies_inside</span></span>(<span>self, location)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lies_inside(self, location):
    distance_squared = math.sum((location - self.center) ** 2, dim=&#39;vector&#39;)
    return math.any(distance_squared &lt;= self.radius ** 2, self.shape.instance)  # union for instance dimensions</code></pre>
</details>
<div class="desc"><p>Tests whether the given location lies inside or outside of the geometry. Locations on the surface count as inside.</p>
<p>When dealing with unions or collections of geometries (instance dimensions), a point lies inside the geometry if it lies inside any instance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd>float tensor of shape (batch_size, &hellip;, rank)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>bool tensor of shape (*location.shape[:-1], 1).</p></div>
</dd>
<dt id="phi.geom.Sphere.rotated"><code class="name flex">
<span>def <span class="ident">rotated</span></span>(<span>self, angle)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotated(self, angle):
    return self</code></pre>
</details>
<div class="desc"><p>Returns a rotated version of this geometry.
The geometry is rotated about its center point.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>angle</code></strong></dt>
<dd>
<p>Delta rotation.
Either</p>
<ul>
<li>Angle(s): scalar angle in 2d or euler angles along <code>vector</code> in 3D or higher.</li>
<li>Matrix: d⨯d rotation matrix</li>
</ul>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Rotated <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></p></div>
</dd>
<dt id="phi.geom.Sphere.sample_uniform"><code class="name flex">
<span>def <span class="ident">sample_uniform</span></span>(<span>self, *shape: phiml.math._shape.Shape)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_uniform(self, *shape: math.Shape):
    # --- Choose a distance from the center of the sphere, equally weighted by mass ---
    uniform = math.random_uniform(self.shape.non_singleton.without(&#39;vector&#39;), *shape)
    if self.spatial_rank == 1:
        r = self.radius * uniform
    else:
        r = self.radius * (uniform ** (1 / self.spatial_rank))
    # --- Uniformly sample a unit vector for direction over the surface of the sphere (Muller 1959, Marsaglia 1972) ---
    unit_vector = math.random_normal(self.shape.non_singleton.without(&#39;vector&#39;), *shape, self.shape[&#39;vector&#39;])
    unit_vector /= vec_length(unit_vector)
    return self.center + r * unit_vector</code></pre>
</details>
<div class="desc"><p>Samples uniformly distributed random points inside this volume.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*shape</code></strong></dt>
<dd>How many points to sample per individual geometry.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>Tensor</code> containing all dimensions from <code><a title="phi.geom.Geometry.shape" href="#phi.geom.Geometry.shape">Geometry.shape</a></code>, <code>shape</code> as well as a <code>channel</code> dimension <code>vector</code> matching the dimensionality of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.</p></div>
</dd>
<dt id="phi.geom.Sphere.scaled"><code class="name flex">
<span>def <span class="ident">scaled</span></span>(<span>self, factor: phiml.math._tensors.Tensor | float) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scaled(self, factor: Union[float, Tensor]) -&gt; &#39;Geometry&#39;:
    return replace(self, radius=self.radius * factor)</code></pre>
</details>
<div class="desc"><p>Scales each individual geometry by <code>factor</code>.
The individual <code>center</code> points act as pivots for the operation.</p>
<h2 id="args">Args</h2>
<p>factor:
Returns:</p></div>
</dd>
</dl>
</dd>
<dt id="phi.geom.UniformGrid"><code class="flex name class">
<span>class <span class="ident">UniformGrid</span></span>
<span>(</span><span>resolution: phiml.math._shape.Shape, bounds: phi.geom._box.Box)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@sliceable(keepdims=&#39;vector&#39;)
@dataclass(frozen=True, eq=False)
class UniformGrid(Geometry, metaclass=UniformGridType):
    &#34;&#34;&#34;
    An instance of UniformGrid represents all cells of a regular grid as a batch of boxes.
    &#34;&#34;&#34;
    resolution: Shape
    bounds: Box
    
    def __post_init__(self):
        assert set(self.bounds.vector.labels) == set(self.resolution.names)

    @property
    def spatial_rank(self) -&gt; int:
        return self.resolution.spatial_rank
    
    @cached_property
    def shape(self):
        return self.resolution &amp; non_spatial(self.bounds)

    @cached_property
    def center(self):
        local_coords = math.meshgrid(**{dim.name: math.linspace(0.5 / dim.size, 1 - 0.5 / dim.size, dim) for dim in self.resolution})
        points = self.bounds.local_to_global(local_coords)
        return points

    def position_of(self, voxel_index: Tensor):
        voxel_index = rename_dims(voxel_index, channel, &#39;vector&#39;)
        return self.bounds.lower + (voxel_index+.5) / self.resolution * self.bounds.size

    def voxel_at(self, location: Tensor, clamp=True):
        float_idx = (location - self.bounds.lower) / self.bounds.size * self.resolution
        index = math.to_int32(float_idx)
        if clamp:
            index = math.clip(index, 0, wrap(self.resolution, channel(&#39;vector&#39;))-1)
        return index

    @property
    def boundary_elements(self) -&gt; Dict[Any, Dict[str, slice]]:
        return {}

    @property
    def boundary_faces(self) -&gt; Dict[Any, Dict[str, slice]]:
        result = {}
        for dim in self.vector.labels:
            result[dim+&#39;-&#39;] = {&#39;~vector&#39;: dim, dim: slice(1)}
            result[dim+&#39;+&#39;] = {&#39;~vector&#39;: dim, dim: slice(-1, None)}
        return result

    @property
    def face_centers(self) -&gt; Tensor:
        centers = [self.stagger(dim, True, True).center for dim in self.vector.labels]
        return stack(centers, dual(vector=self.vector.labels))

    @property
    def faces(self) -&gt; Geometry:
        slices = [self.stagger(d, True, True) for d in self.resolution.names]
        return stack(slices, dual(vector=self.vector.labels))

    @property
    def face_normals(self) -&gt; Tensor:
        normals = [vec(**{d: float(d == dim) for d in self.vector.labels}) for dim in self.vector.labels]
        return stack(normals, dual(vector=self.vector.labels))

    @property
    def face_areas(self) -&gt; Tensor:
        areas = [math.prod(self.dx.vector[[d for d in self.vector.labels if d != dim]], &#39;vector&#39;) for dim in self.vector.labels]
        return stack(areas, dual(vector=self.vector.labels))

    @cached_property
    def face_shape(self) -&gt; Shape:
        staggered_shapes = [self.shape.spatial.with_dim_size(dim, self.shape.get_size(dim) + 1) for dim in self.vector.labels]
        return shape_stack(dual(vector=self.vector.labels), *staggered_shapes)

    def interior(self) -&gt; &#39;Geometry&#39;:
        raise GeometryException(&#34;Regular grid does not have an interior&#34;)

    @property
    def grid_size(self):
        return self.bounds.size

    @cached_property
    def dx(self):
        return self.bounds.size / self.resolution

    @property
    def size(self):
        return self.dx

    @property
    def volume(self) -&gt; Tensor:
        return math.prod(self.dx, &#39;vector&#39;)

    @property
    def lower(self):
        return self.center - self.half_size

    @property
    def upper(self):
        return self.center + self.half_size

    @property
    def half_size(self):
        return self.bounds.size / self.resolution.sizes / 2

    @property
    def _rot_or_none(self) -&gt; Optional[Tensor]:
        return None

    def corner_representation(self) -&gt; &#39;Box&#39;:
        return Box(self.lower, self.upper)

    box = corner_representation

    def center_representation(self, size_variable=True) -&gt; &#39;Cuboid&#39;:
        return Cuboid(self.center, self.half_size, size_variable=size_variable)

    cuboid = center_representation

    def with_scaled_resolution(self, scale: float):
        return UniformGrid(self.resolution.with_sizes([s*scale for s in self.resolution.sizes]), self.bounds)

    def __getitem__(self, item):
        item = slicing_dict(self, item)
        resolution = self.resolution.after_gather(item)
        bounds = self.bounds[{d: s for d, s in item.items() if d != &#39;vector&#39;}]
        if &#39;vector&#39; in item:
            resolution = resolution.only(item[&#39;vector&#39;], reorder=True)
            bounds = bounds.vector[item[&#39;vector&#39;]]
        bounds = bounds.vector[resolution.name_list]
        for dim, selection in item.items():
            if dim in resolution:
                if isinstance(selection, slice):
                    start = selection.start or 0
                    if start &lt; 0:
                        start += self.resolution.get_size(dim)
                    stop = selection.stop or self.resolution.get_size(dim)
                    if stop &lt; 0:
                        stop += self.resolution.get_size(dim)
                    assert selection.step is None or selection.step == 1
                else:  # int slices are not contained in resolution anymore
                    raise ValueError(f&#34;Illegal selection: {item}&#34;)
                dim_mask = math.wrap(self.resolution.mask(dim))
                lower = bounds.lower + start * dim_mask * self.dx
                upper = bounds.upper + (stop - self.resolution.get_size(dim)) * dim_mask * self.dx
                bounds = Box(lower, upper)
        return UniformGrid(resolution, bounds)

    def __pack_dims__(self, dims: Tuple[str, ...], packed_dim: Shape, pos: Optional[int], **kwargs) -&gt; &#39;Box&#39;:
        return math.pack_dims(self.center_representation(size_variable=False), dims, packed_dim, pos, **kwargs)

    @staticmethod
    def __stack__(values: tuple, dim: Shape, **kwargs) -&gt; &#39;Geometry&#39;:
        from ._geom_ops import GeometryStack
        set_op = kwargs.get(&#39;set_op&#39;)
        return GeometryStack(math.layout(values, dim), set_op)

    def __replace_dims__(self, dims: Tuple[str, ...], new_dims: Shape, **kwargs) -&gt; &#39;UniformGrid&#39;:
        resolution = math.rename_dims(self.resolution, dims, new_dims).spatial
        bounds = math.rename_dims(self.bounds, dims, new_dims, **kwargs)[resolution.name_list]
        return UniformGrid(resolution, bounds)

    def list_cells(self, dim_name):
        center = math.pack_dims(self.center, self.shape.spatial.names, dim_name)
        return Cuboid(center, self.half_size, size_variable=False)

    def stagger(self, dim: str, lower: bool, upper: bool):
        dim_mask = np.array(self.resolution.mask(dim))
        unit = self.bounds.size / self.resolution * dim_mask
        bounds = Box(self.bounds.lower + unit * (-0.5 if lower else 0.5), self.bounds.upper + unit * (0.5 if upper else -0.5))
        ext_res = self.resolution.sizes + dim_mask * (int(lower) + int(upper) - 1)
        return UniformGrid(self.resolution.with_sizes(ext_res), bounds)

    def staggered_cells(self, boundaries: Extrapolation) -&gt; Dict[str, &#39;UniformGrid&#39;]:
        grids = {}
        for dim in self.vector.labels:
            grids[dim] = self.stagger(dim, *boundaries.valid_outer_faces(dim))
        return grids

    def padded(self, widths: dict):
        resolution, bounds = self.resolution, self.bounds
        for dim, (lower, upper) in widths.items():
            masked_dx = self.dx * math.dim_mask(self.resolution, dim)
            resolution = resolution.with_dim_size(dim, self.resolution.get_size(dim) + lower + upper)
            bounds = Box(bounds.lower - masked_dx * lower, bounds.upper + masked_dx * upper)
        return UniformGrid(resolution, bounds)

    def shifted(self, delta: Tensor, **delta_by_dim):
        # delta += math.padded_stack()
        if delta.shape.spatial_rank == 0:
            return UniformGrid(self.resolution, self.bounds.shifted(delta))
        else:
            center = self.center + delta
            return Cuboid(center, self.half_size, size_variable=False)

    def rotated(self, angle) -&gt; Geometry:
        raise NotImplementedError(&#34;Grids cannot be rotated. Use center_representation() to convert it to Cuboids first.&#34;)

    def shallow_equals(self, other):
        return self == other

    def __repr__(self):
        return f&#34;{self.resolution}, bounds={self.bounds}&#34;

    def __eq__(self, other):
        if not isinstance(other, UniformGrid):
            return False
        return self.resolution == other.resolution and self.bounds == other.bounds

    def __hash__(self):
        return hash(self.resolution) + hash(self.bounds)

    @property
    def _center(self):
        return self.center

    @property
    def _half_size(self):
        return self.half_size

    @property
    def normal(self) -&gt; Tensor:
        raise GeometryException(&#34;UniformGrid does not have normals&#34;)

    def bounding_half_extent(self) -&gt; Tensor:
        return self.half_size

    def bounding_radius(self) -&gt; Tensor:
        return vec_length(self.half_size)</code></pre>
</details>
<div class="desc"><p>An instance of UniformGrid represents all cells of a regular grid as a batch of boxes.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.geom._geom.Geometry</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="phi.geom.UniformGrid.Tc"><code class="name">prop <span class="ident">Tc</span></code></dt>
<dd>
<div class="desc"><p>partial(func, <em>args, </em>*keywords) - new function with partial application
of the given arguments and keywords.</p></div>
</dd>
<dt id="phi.geom.UniformGrid.Ti"><code class="name">prop <span class="ident">Ti</span></code></dt>
<dd>
<div class="desc"><p>partial(func, <em>args, </em>*keywords) - new function with partial application
of the given arguments and keywords.</p></div>
</dd>
<dt id="phi.geom.UniformGrid.Ts"><code class="name">prop <span class="ident">Ts</span></code></dt>
<dd>
<div class="desc"><p>partial(func, <em>args, </em>*keywords) - new function with partial application
of the given arguments and keywords.</p></div>
</dd>
<dt id="phi.geom.UniformGrid.boundary_elements"><code class="name">prop <span class="ident">boundary_elements</span> : Dict[Any, Dict[str, slice]]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def boundary_elements(self) -&gt; Dict[Any, Dict[str, slice]]:
    return {}</code></pre>
</details>
<div class="desc"><p>Slices on the primal dimensions to mark boundary elements.
Grids and meshes have no boundary elements and return <code>{}</code>.
Dynamic graphs can define boundary elements for obstacles and walls.</p>
<h2 id="returns">Returns</h2>
<p>Map from <code>name</code> to slicing <code>dict</code>.</p></div>
</dd>
<dt id="phi.geom.UniformGrid.boundary_faces"><code class="name">prop <span class="ident">boundary_faces</span> : Dict[Any, Dict[str, slice]]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def boundary_faces(self) -&gt; Dict[Any, Dict[str, slice]]:
    result = {}
    for dim in self.vector.labels:
        result[dim+&#39;-&#39;] = {&#39;~vector&#39;: dim, dim: slice(1)}
        result[dim+&#39;+&#39;] = {&#39;~vector&#39;: dim, dim: slice(-1, None)}
    return result</code></pre>
</details>
<div class="desc"><p>Slices on the dual dimensions to mark boundary faces.</p>
<p>Regular grids use the keys (dim, is_upper) to identify boundaries.
Unstructured meshes use string identifiers for the boundaries.
Dynamic graphs return slices along the dual dimensions.</p>
<h2 id="returns">Returns</h2>
<p>Map from <code>name</code> to slicing <code>dict</code>.</p></div>
</dd>
<dt id="phi.geom.UniformGrid.bounds"><code class="name">var <span class="ident">bounds</span> : phi.geom._box.Box</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="phi.geom.UniformGrid.center"><code class="name">var <span class="ident">center</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def center(self):
    local_coords = math.meshgrid(**{dim.name: math.linspace(0.5 / dim.size, 1 - 0.5 / dim.size, dim) for dim in self.resolution})
    points = self.bounds.local_to_global(local_coords)
    return points</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.UniformGrid.dx"><code class="name">var <span class="ident">dx</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def dx(self):
    return self.bounds.size / self.resolution</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.UniformGrid.face_areas"><code class="name">prop <span class="ident">face_areas</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_areas(self) -&gt; Tensor:
    areas = [math.prod(self.dx.vector[[d for d in self.vector.labels if d != dim]], &#39;vector&#39;) for dim in self.vector.labels]
    return stack(areas, dual(vector=self.vector.labels))</code></pre>
</details>
<div class="desc"><p>Area of face connecting a pair of cells. Shape <code>(elements, ~)</code>.
Returns 0 for unconnected cells.</p></div>
</dd>
<dt id="phi.geom.UniformGrid.face_centers"><code class="name">prop <span class="ident">face_centers</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_centers(self) -&gt; Tensor:
    centers = [self.stagger(dim, True, True).center for dim in self.vector.labels]
    return stack(centers, dual(vector=self.vector.labels))</code></pre>
</details>
<div class="desc"><p>Center of face connecting a pair of cells. Shape <code>(elements, ~, vector)</code>.
Here, <code>~</code> represents arbitrary internal dual dimensions, such as <code>~staggered_direction</code> or <code>~elements</code>.
Returns 0-vectors for unconnected cells.</p></div>
</dd>
<dt id="phi.geom.UniformGrid.face_normals"><code class="name">prop <span class="ident">face_normals</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def face_normals(self) -&gt; Tensor:
    normals = [vec(**{d: float(d == dim) for d in self.vector.labels}) for dim in self.vector.labels]
    return stack(normals, dual(vector=self.vector.labels))</code></pre>
</details>
<div class="desc"><p>Normal vectors of cell faces, including boundary faces. Shape <code>(elements, ~, vector)</code>.
For meshes, The vectors point out of the primal cells and into the dual cells.</p>
<p>Instance/spatial dimensions along which the normal does not vary may not be included in the result tensor's shape.</p></div>
</dd>
<dt id="phi.geom.UniformGrid.face_shape"><code class="name">var <span class="ident">face_shape</span> : phiml.math._shape.Shape</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def face_shape(self) -&gt; Shape:
    staggered_shapes = [self.shape.spatial.with_dim_size(dim, self.shape.get_size(dim) + 1) for dim in self.vector.labels]
    return shape_stack(dual(vector=self.vector.labels), *staggered_shapes)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.UniformGrid.faces"><code class="name">prop <span class="ident">faces</span> : phi.geom._geom.Geometry</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def faces(self) -&gt; Geometry:
    slices = [self.stagger(d, True, True) for d in self.resolution.names]
    return stack(slices, dual(vector=self.vector.labels))</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.UniformGrid.grid_size"><code class="name">prop <span class="ident">grid_size</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def grid_size(self):
    return self.bounds.size</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.UniformGrid.half_size"><code class="name">prop <span class="ident">half_size</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def half_size(self):
    return self.bounds.size / self.resolution.sizes / 2</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.UniformGrid.lower"><code class="name">prop <span class="ident">lower</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def lower(self):
    return self.center - self.half_size</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.UniformGrid.normal"><code class="name">prop <span class="ident">normal</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def normal(self) -&gt; Tensor:
    raise GeometryException(&#34;UniformGrid does not have normals&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.UniformGrid.resolution"><code class="name">var <span class="ident">resolution</span> : phiml.math._shape.Shape</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="phi.geom.UniformGrid.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_property
def shape(self):
    return self.resolution &amp; non_spatial(self.bounds)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.UniformGrid.size"><code class="name">prop <span class="ident">size</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self):
    return self.dx</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.UniformGrid.spatial_rank"><code class="name">prop <span class="ident">spatial_rank</span> : int</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def spatial_rank(self) -&gt; int:
    return self.resolution.spatial_rank</code></pre>
</details>
<div class="desc"><p>Number of spatial dimensions of the geometry, 1 = 1D, 2 = 2D, 3 = 3D, etc.</p></div>
</dd>
<dt id="phi.geom.UniformGrid.upper"><code class="name">prop <span class="ident">upper</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def upper(self):
    return self.center + self.half_size</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.UniformGrid.volume"><code class="name">prop <span class="ident">volume</span> : phiml.math._tensors.Tensor</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def volume(self) -&gt; Tensor:
    return math.prod(self.dx, &#39;vector&#39;)</code></pre>
</details>
<div class="desc"><p><code>phi.math.Tensor</code> representing the volume of each element.
The result retains batch, spatial and instance dimensions.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phi.geom.UniformGrid.bounding_half_extent"><code class="name flex">
<span>def <span class="ident">bounding_half_extent</span></span>(<span>self) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bounding_half_extent(self) -&gt; Tensor:
    return self.half_size</code></pre>
</details>
<div class="desc"><p>The bounding half-extent sets a limit on the outer-most point for each coordinate axis.
Each component is non-negative.</p>
<p>Let the bounding half-extent have value <code>e</code> in dimension <code>d</code> (<code>extent[...,d] = e</code>).
Then, no point of the geometry lies further away from its center point than <code>e</code> along <code>d</code> (in both axis directions).</p>
<p>If this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.
If these dims are not present on the result, all parts are assumed to have the same bounds.</p></div>
</dd>
<dt id="phi.geom.UniformGrid.bounding_radius"><code class="name flex">
<span>def <span class="ident">bounding_radius</span></span>(<span>self) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bounding_radius(self) -&gt; Tensor:
    return vec_length(self.half_size)</code></pre>
</details>
<div class="desc"><p>Returns the radius of a Sphere object that fully encloses this geometry.
The sphere is centered at the center of this geometry.</p>
<p>If this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.
If these dims are not present on the result, all parts are assumed to have the same bounds.</p></div>
</dd>
<dt id="phi.geom.UniformGrid.box"><code class="name flex">
<span>def <span class="ident">box</span></span>(<span>self) ‑> phi.geom._box.Box</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def corner_representation(self) -&gt; &#39;Box&#39;:
    return Box(self.lower, self.upper)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.UniformGrid.center_representation"><code class="name flex">
<span>def <span class="ident">center_representation</span></span>(<span>self, size_variable=True) ‑> <function <a title="phi.geom.Cuboid" href="#phi.geom.Cuboid">Cuboid()</a> at 0x7f8596084ea0></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def center_representation(self, size_variable=True) -&gt; &#39;Cuboid&#39;:
    return Cuboid(self.center, self.half_size, size_variable=size_variable)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.UniformGrid.corner_representation"><code class="name flex">
<span>def <span class="ident">corner_representation</span></span>(<span>self) ‑> phi.geom._box.Box</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def corner_representation(self) -&gt; &#39;Box&#39;:
    return Box(self.lower, self.upper)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.UniformGrid.cuboid"><code class="name flex">
<span>def <span class="ident">cuboid</span></span>(<span>self, size_variable=True) ‑> <function <a title="phi.geom.Cuboid" href="#phi.geom.Cuboid">Cuboid()</a> at 0x7f8596084ea0></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def center_representation(self, size_variable=True) -&gt; &#39;Cuboid&#39;:
    return Cuboid(self.center, self.half_size, size_variable=size_variable)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.UniformGrid.interior"><code class="name flex">
<span>def <span class="ident">interior</span></span>(<span>self) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interior(self) -&gt; &#39;Geometry&#39;:
    raise GeometryException(&#34;Regular grid does not have an interior&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.UniformGrid.list_cells"><code class="name flex">
<span>def <span class="ident">list_cells</span></span>(<span>self, dim_name)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_cells(self, dim_name):
    center = math.pack_dims(self.center, self.shape.spatial.names, dim_name)
    return Cuboid(center, self.half_size, size_variable=False)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.UniformGrid.padded"><code class="name flex">
<span>def <span class="ident">padded</span></span>(<span>self, widths: dict)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def padded(self, widths: dict):
    resolution, bounds = self.resolution, self.bounds
    for dim, (lower, upper) in widths.items():
        masked_dx = self.dx * math.dim_mask(self.resolution, dim)
        resolution = resolution.with_dim_size(dim, self.resolution.get_size(dim) + lower + upper)
        bounds = Box(bounds.lower - masked_dx * lower, bounds.upper + masked_dx * upper)
    return UniformGrid(resolution, bounds)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.UniformGrid.position_of"><code class="name flex">
<span>def <span class="ident">position_of</span></span>(<span>self, voxel_index: phiml.math._tensors.Tensor)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def position_of(self, voxel_index: Tensor):
    voxel_index = rename_dims(voxel_index, channel, &#39;vector&#39;)
    return self.bounds.lower + (voxel_index+.5) / self.resolution * self.bounds.size</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.UniformGrid.rotated"><code class="name flex">
<span>def <span class="ident">rotated</span></span>(<span>self, angle) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotated(self, angle) -&gt; Geometry:
    raise NotImplementedError(&#34;Grids cannot be rotated. Use center_representation() to convert it to Cuboids first.&#34;)</code></pre>
</details>
<div class="desc"><p>Returns a rotated version of this geometry.
The geometry is rotated about its center point.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>angle</code></strong></dt>
<dd>
<p>Delta rotation.
Either</p>
<ul>
<li>Angle(s): scalar angle in 2d or euler angles along <code>vector</code> in 3D or higher.</li>
<li>Matrix: d⨯d rotation matrix</li>
</ul>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Rotated <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></p></div>
</dd>
<dt id="phi.geom.UniformGrid.shallow_equals"><code class="name flex">
<span>def <span class="ident">shallow_equals</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shallow_equals(self, other):
    return self == other</code></pre>
</details>
<div class="desc"><p>Quick equality check.
May return <code>False</code> even if <code>other == self</code>.
However, if <code>True</code> is returned, the geometries are guaranteed to be equal.</p>
<p>The <code>shallow_equals()</code> check does not compare all tensor elements but merely checks whether the same tensors are referenced.</p></div>
</dd>
<dt id="phi.geom.UniformGrid.shifted"><code class="name flex">
<span>def <span class="ident">shifted</span></span>(<span>self, delta: phiml.math._tensors.Tensor, **delta_by_dim)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shifted(self, delta: Tensor, **delta_by_dim):
    # delta += math.padded_stack()
    if delta.shape.spatial_rank == 0:
        return UniformGrid(self.resolution, self.bounds.shifted(delta))
    else:
        center = self.center + delta
        return Cuboid(center, self.half_size, size_variable=False)</code></pre>
</details>
<div class="desc"><p>Returns a translated version of this geometry.</p>
<p>See Also:
<code><a title="phi.geom.Geometry.at" href="#phi.geom.Geometry.at">Geometry.at()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>delta</code></strong></dt>
<dd>direction vector</dd>
<dt><strong><code>delta</code></strong></dt>
<dd>Tensor:</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></dt>
<dd>shifted geometry</dd>
</dl></div>
</dd>
<dt id="phi.geom.UniformGrid.stagger"><code class="name flex">
<span>def <span class="ident">stagger</span></span>(<span>self, dim: str, lower: bool, upper: bool)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stagger(self, dim: str, lower: bool, upper: bool):
    dim_mask = np.array(self.resolution.mask(dim))
    unit = self.bounds.size / self.resolution * dim_mask
    bounds = Box(self.bounds.lower + unit * (-0.5 if lower else 0.5), self.bounds.upper + unit * (0.5 if upper else -0.5))
    ext_res = self.resolution.sizes + dim_mask * (int(lower) + int(upper) - 1)
    return UniformGrid(self.resolution.with_sizes(ext_res), bounds)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.UniformGrid.staggered_cells"><code class="name flex">
<span>def <span class="ident">staggered_cells</span></span>(<span>self, boundaries: phiml.math.extrapolation.Extrapolation) ‑> Dict[str, phi.geom._grid.UniformGrid]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def staggered_cells(self, boundaries: Extrapolation) -&gt; Dict[str, &#39;UniformGrid&#39;]:
    grids = {}
    for dim in self.vector.labels:
        grids[dim] = self.stagger(dim, *boundaries.valid_outer_faces(dim))
    return grids</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.UniformGrid.voxel_at"><code class="name flex">
<span>def <span class="ident">voxel_at</span></span>(<span>self, location: phiml.math._tensors.Tensor, clamp=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def voxel_at(self, location: Tensor, clamp=True):
    float_idx = (location - self.bounds.lower) / self.bounds.size * self.resolution
    index = math.to_int32(float_idx)
    if clamp:
        index = math.clip(index, 0, wrap(self.resolution, channel(&#39;vector&#39;))-1)
    return index</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="phi.geom.UniformGrid.with_scaled_resolution"><code class="name flex">
<span>def <span class="ident">with_scaled_resolution</span></span>(<span>self, scale: float)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_scaled_resolution(self, scale: float):
    return UniformGrid(self.resolution.with_sizes([s*scale for s in self.resolution.sizes]), self.bounds)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="phi" href="../index.html">phi</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="phi.geom.Cuboid" href="#phi.geom.Cuboid">Cuboid</a></code></li>
<li><code><a title="phi.geom.as_sdf" href="#phi.geom.as_sdf">as_sdf</a></code></li>
<li><code><a title="phi.geom.assert_same_rank" href="#phi.geom.assert_same_rank">assert_same_rank</a></code></li>
<li><code><a title="phi.geom.bounding_box" href="#phi.geom.bounding_box">bounding_box</a></code></li>
<li><code><a title="phi.geom.build_mesh" href="#phi.geom.build_mesh">build_mesh</a></code></li>
<li><code><a title="phi.geom.clip_length" href="#phi.geom.clip_length">clip_length</a></code></li>
<li><code><a title="phi.geom.concat" href="#phi.geom.concat">concat</a></code></li>
<li><code><a title="phi.geom.cross" href="#phi.geom.cross">cross</a></code></li>
<li><code><a title="phi.geom.cylinder" href="#phi.geom.cylinder">cylinder</a></code></li>
<li><code><a title="phi.geom.embed" href="#phi.geom.embed">embed</a></code></li>
<li><code><a title="phi.geom.enclosing_grid" href="#phi.geom.enclosing_grid">enclosing_grid</a></code></li>
<li><code><a title="phi.geom.farthest_points" href="#phi.geom.farthest_points">farthest_points</a></code></li>
<li><code><a title="phi.geom.graph" href="#phi.geom.graph">graph</a></code></li>
<li><code><a title="phi.geom.infinite_cylinder" href="#phi.geom.infinite_cylinder">infinite_cylinder</a></code></li>
<li><code><a title="phi.geom.intersection" href="#phi.geom.intersection">intersection</a></code></li>
<li><code><a title="phi.geom.invert" href="#phi.geom.invert">invert</a></code></li>
<li><code><a title="phi.geom.join_meshes" href="#phi.geom.join_meshes">join_meshes</a></code></li>
<li><code><a title="phi.geom.length" href="#phi.geom.length">length</a></code></li>
<li><code><a title="phi.geom.line_trace" href="#phi.geom.line_trace">line_trace</a></code></li>
<li><code><a title="phi.geom.load_gmsh" href="#phi.geom.load_gmsh">load_gmsh</a></code></li>
<li><code><a title="phi.geom.load_stl" href="#phi.geom.load_stl">load_stl</a></code></li>
<li><code><a title="phi.geom.load_su2" href="#phi.geom.load_su2">load_su2</a></code></li>
<li><code><a title="phi.geom.mesh" href="#phi.geom.mesh">mesh</a></code></li>
<li><code><a title="phi.geom.mesh_from_numpy" href="#phi.geom.mesh_from_numpy">mesh_from_numpy</a></code></li>
<li><code><a title="phi.geom.normal_from_slope" href="#phi.geom.normal_from_slope">normal_from_slope</a></code></li>
<li><code><a title="phi.geom.normalize" href="#phi.geom.normalize">normalize</a></code></li>
<li><code><a title="phi.geom.numpy_sdf" href="#phi.geom.numpy_sdf">numpy_sdf</a></code></li>
<li><code><a title="phi.geom.pack_dims" href="#phi.geom.pack_dims">pack_dims</a></code></li>
<li><code><a title="phi.geom.rotate" href="#phi.geom.rotate">rotate</a></code></li>
<li><code><a title="phi.geom.rotation_angles" href="#phi.geom.rotation_angles">rotation_angles</a></code></li>
<li><code><a title="phi.geom.rotation_matrix" href="#phi.geom.rotation_matrix">rotation_matrix</a></code></li>
<li><code><a title="phi.geom.rotation_matrix_from_axis_and_angle" href="#phi.geom.rotation_matrix_from_axis_and_angle">rotation_matrix_from_axis_and_angle</a></code></li>
<li><code><a title="phi.geom.rotation_matrix_from_directions" href="#phi.geom.rotation_matrix_from_directions">rotation_matrix_from_directions</a></code></li>
<li><code><a title="phi.geom.sample_function" href="#phi.geom.sample_function">sample_function</a></code></li>
<li><code><a title="phi.geom.sample_sdf" href="#phi.geom.sample_sdf">sample_sdf</a></code></li>
<li><code><a title="phi.geom.scale" href="#phi.geom.scale">scale</a></code></li>
<li><code><a title="phi.geom.squared_length" href="#phi.geom.squared_length">squared_length</a></code></li>
<li><code><a title="phi.geom.stack" href="#phi.geom.stack">stack</a></code></li>
<li><code><a title="phi.geom.surface_mesh" href="#phi.geom.surface_mesh">surface_mesh</a></code></li>
<li><code><a title="phi.geom.union" href="#phi.geom.union">union</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="phi.geom.Box" href="#phi.geom.Box">Box</a></code></h4>
<ul class="">
<li><code><a title="phi.geom.Box.Tc" href="#phi.geom.Box.Tc">Tc</a></code></li>
<li><code><a title="phi.geom.Box.Ti" href="#phi.geom.Box.Ti">Ti</a></code></li>
<li><code><a title="phi.geom.Box.Ts" href="#phi.geom.Box.Ts">Ts</a></code></li>
<li><code><a title="phi.geom.Box.approximate_closest_surface" href="#phi.geom.Box.approximate_closest_surface">approximate_closest_surface</a></code></li>
<li><code><a title="phi.geom.Box.approximate_signed_distance" href="#phi.geom.Box.approximate_signed_distance">approximate_signed_distance</a></code></li>
<li><code><a title="phi.geom.Box.at" href="#phi.geom.Box.at">at</a></code></li>
<li><code><a title="phi.geom.Box.boundary_elements" href="#phi.geom.Box.boundary_elements">boundary_elements</a></code></li>
<li><code><a title="phi.geom.Box.boundary_faces" href="#phi.geom.Box.boundary_faces">boundary_faces</a></code></li>
<li><code><a title="phi.geom.Box.bounding_half_extent" href="#phi.geom.Box.bounding_half_extent">bounding_half_extent</a></code></li>
<li><code><a title="phi.geom.Box.bounding_radius" href="#phi.geom.Box.bounding_radius">bounding_radius</a></code></li>
<li><code><a title="phi.geom.Box.box" href="#phi.geom.Box.box">box</a></code></li>
<li><code><a title="phi.geom.Box.center" href="#phi.geom.Box.center">center</a></code></li>
<li><code><a title="phi.geom.Box.center_representation" href="#phi.geom.Box.center_representation">center_representation</a></code></li>
<li><code><a title="phi.geom.Box.contains" href="#phi.geom.Box.contains">contains</a></code></li>
<li><code><a title="phi.geom.Box.corner_representation" href="#phi.geom.Box.corner_representation">corner_representation</a></code></li>
<li><code><a title="phi.geom.Box.corners" href="#phi.geom.Box.corners">corners</a></code></li>
<li><code><a title="phi.geom.Box.cuboid" href="#phi.geom.Box.cuboid">cuboid</a></code></li>
<li><code><a title="phi.geom.Box.face_areas" href="#phi.geom.Box.face_areas">face_areas</a></code></li>
<li><code><a title="phi.geom.Box.face_centers" href="#phi.geom.Box.face_centers">face_centers</a></code></li>
<li><code><a title="phi.geom.Box.face_normals" href="#phi.geom.Box.face_normals">face_normals</a></code></li>
<li><code><a title="phi.geom.Box.face_shape" href="#phi.geom.Box.face_shape">face_shape</a></code></li>
<li><code><a title="phi.geom.Box.faces" href="#phi.geom.Box.faces">faces</a></code></li>
<li><code><a title="phi.geom.Box.global_to_local" href="#phi.geom.Box.global_to_local">global_to_local</a></code></li>
<li><code><a title="phi.geom.Box.half_size" href="#phi.geom.Box.half_size">half_size</a></code></li>
<li><code><a title="phi.geom.Box.is_axis_aligned" href="#phi.geom.Box.is_axis_aligned">is_axis_aligned</a></code></li>
<li><code><a title="phi.geom.Box.is_finite" href="#phi.geom.Box.is_finite">is_finite</a></code></li>
<li><code><a title="phi.geom.Box.is_open" href="#phi.geom.Box.is_open">is_open</a></code></li>
<li><code><a title="phi.geom.Box.is_size_variable" href="#phi.geom.Box.is_size_variable">is_size_variable</a></code></li>
<li><code><a title="phi.geom.Box.largest" href="#phi.geom.Box.largest">largest</a></code></li>
<li><code><a title="phi.geom.Box.lies_inside" href="#phi.geom.Box.lies_inside">lies_inside</a></code></li>
<li><code><a title="phi.geom.Box.local_to_global" href="#phi.geom.Box.local_to_global">local_to_global</a></code></li>
<li><code><a title="phi.geom.Box.lower" href="#phi.geom.Box.lower">lower</a></code></li>
<li><code><a title="phi.geom.Box.pos" href="#phi.geom.Box.pos">pos</a></code></li>
<li><code><a title="phi.geom.Box.project" href="#phi.geom.Box.project">project</a></code></li>
<li><code><a title="phi.geom.Box.push" href="#phi.geom.Box.push">push</a></code></li>
<li><code><a title="phi.geom.Box.rot" href="#phi.geom.Box.rot">rot</a></code></li>
<li><code><a title="phi.geom.Box.rotated" href="#phi.geom.Box.rotated">rotated</a></code></li>
<li><code><a title="phi.geom.Box.rotation_matrix" href="#phi.geom.Box.rotation_matrix">rotation_matrix</a></code></li>
<li><code><a title="phi.geom.Box.sample_uniform" href="#phi.geom.Box.sample_uniform">sample_uniform</a></code></li>
<li><code><a title="phi.geom.Box.sample_uniform_surface" href="#phi.geom.Box.sample_uniform_surface">sample_uniform_surface</a></code></li>
<li><code><a title="phi.geom.Box.scaled" href="#phi.geom.Box.scaled">scaled</a></code></li>
<li><code><a title="phi.geom.Box.shape" href="#phi.geom.Box.shape">shape</a></code></li>
<li><code><a title="phi.geom.Box.size" href="#phi.geom.Box.size">size</a></code></li>
<li><code><a title="phi.geom.Box.smallest" href="#phi.geom.Box.smallest">smallest</a></code></li>
<li><code><a title="phi.geom.Box.upper" href="#phi.geom.Box.upper">upper</a></code></li>
<li><code><a title="phi.geom.Box.variable_attrs" href="#phi.geom.Box.variable_attrs">variable_attrs</a></code></li>
<li><code><a title="phi.geom.Box.volume" href="#phi.geom.Box.volume">volume</a></code></li>
<li><code><a title="phi.geom.Box.without" href="#phi.geom.Box.without">without</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.geom.Box" href="#phi.geom.Box">Box</a></code></h4>
<ul class="">
<li><code><a title="phi.geom.Box.Tc" href="#phi.geom.Box.Tc">Tc</a></code></li>
<li><code><a title="phi.geom.Box.Ti" href="#phi.geom.Box.Ti">Ti</a></code></li>
<li><code><a title="phi.geom.Box.Ts" href="#phi.geom.Box.Ts">Ts</a></code></li>
<li><code><a title="phi.geom.Box.approximate_closest_surface" href="#phi.geom.Box.approximate_closest_surface">approximate_closest_surface</a></code></li>
<li><code><a title="phi.geom.Box.approximate_signed_distance" href="#phi.geom.Box.approximate_signed_distance">approximate_signed_distance</a></code></li>
<li><code><a title="phi.geom.Box.at" href="#phi.geom.Box.at">at</a></code></li>
<li><code><a title="phi.geom.Box.boundary_elements" href="#phi.geom.Box.boundary_elements">boundary_elements</a></code></li>
<li><code><a title="phi.geom.Box.boundary_faces" href="#phi.geom.Box.boundary_faces">boundary_faces</a></code></li>
<li><code><a title="phi.geom.Box.bounding_half_extent" href="#phi.geom.Box.bounding_half_extent">bounding_half_extent</a></code></li>
<li><code><a title="phi.geom.Box.bounding_radius" href="#phi.geom.Box.bounding_radius">bounding_radius</a></code></li>
<li><code><a title="phi.geom.Box.box" href="#phi.geom.Box.box">box</a></code></li>
<li><code><a title="phi.geom.Box.center" href="#phi.geom.Box.center">center</a></code></li>
<li><code><a title="phi.geom.Box.center_representation" href="#phi.geom.Box.center_representation">center_representation</a></code></li>
<li><code><a title="phi.geom.Box.contains" href="#phi.geom.Box.contains">contains</a></code></li>
<li><code><a title="phi.geom.Box.corner_representation" href="#phi.geom.Box.corner_representation">corner_representation</a></code></li>
<li><code><a title="phi.geom.Box.corners" href="#phi.geom.Box.corners">corners</a></code></li>
<li><code><a title="phi.geom.Box.cuboid" href="#phi.geom.Box.cuboid">cuboid</a></code></li>
<li><code><a title="phi.geom.Box.face_areas" href="#phi.geom.Box.face_areas">face_areas</a></code></li>
<li><code><a title="phi.geom.Box.face_centers" href="#phi.geom.Box.face_centers">face_centers</a></code></li>
<li><code><a title="phi.geom.Box.face_normals" href="#phi.geom.Box.face_normals">face_normals</a></code></li>
<li><code><a title="phi.geom.Box.face_shape" href="#phi.geom.Box.face_shape">face_shape</a></code></li>
<li><code><a title="phi.geom.Box.faces" href="#phi.geom.Box.faces">faces</a></code></li>
<li><code><a title="phi.geom.Box.global_to_local" href="#phi.geom.Box.global_to_local">global_to_local</a></code></li>
<li><code><a title="phi.geom.Box.half_size" href="#phi.geom.Box.half_size">half_size</a></code></li>
<li><code><a title="phi.geom.Box.is_axis_aligned" href="#phi.geom.Box.is_axis_aligned">is_axis_aligned</a></code></li>
<li><code><a title="phi.geom.Box.is_finite" href="#phi.geom.Box.is_finite">is_finite</a></code></li>
<li><code><a title="phi.geom.Box.is_open" href="#phi.geom.Box.is_open">is_open</a></code></li>
<li><code><a title="phi.geom.Box.is_size_variable" href="#phi.geom.Box.is_size_variable">is_size_variable</a></code></li>
<li><code><a title="phi.geom.Box.largest" href="#phi.geom.Box.largest">largest</a></code></li>
<li><code><a title="phi.geom.Box.lies_inside" href="#phi.geom.Box.lies_inside">lies_inside</a></code></li>
<li><code><a title="phi.geom.Box.local_to_global" href="#phi.geom.Box.local_to_global">local_to_global</a></code></li>
<li><code><a title="phi.geom.Box.lower" href="#phi.geom.Box.lower">lower</a></code></li>
<li><code><a title="phi.geom.Box.pos" href="#phi.geom.Box.pos">pos</a></code></li>
<li><code><a title="phi.geom.Box.project" href="#phi.geom.Box.project">project</a></code></li>
<li><code><a title="phi.geom.Box.push" href="#phi.geom.Box.push">push</a></code></li>
<li><code><a title="phi.geom.Box.rot" href="#phi.geom.Box.rot">rot</a></code></li>
<li><code><a title="phi.geom.Box.rotated" href="#phi.geom.Box.rotated">rotated</a></code></li>
<li><code><a title="phi.geom.Box.rotation_matrix" href="#phi.geom.Box.rotation_matrix">rotation_matrix</a></code></li>
<li><code><a title="phi.geom.Box.sample_uniform" href="#phi.geom.Box.sample_uniform">sample_uniform</a></code></li>
<li><code><a title="phi.geom.Box.sample_uniform_surface" href="#phi.geom.Box.sample_uniform_surface">sample_uniform_surface</a></code></li>
<li><code><a title="phi.geom.Box.scaled" href="#phi.geom.Box.scaled">scaled</a></code></li>
<li><code><a title="phi.geom.Box.shape" href="#phi.geom.Box.shape">shape</a></code></li>
<li><code><a title="phi.geom.Box.size" href="#phi.geom.Box.size">size</a></code></li>
<li><code><a title="phi.geom.Box.smallest" href="#phi.geom.Box.smallest">smallest</a></code></li>
<li><code><a title="phi.geom.Box.upper" href="#phi.geom.Box.upper">upper</a></code></li>
<li><code><a title="phi.geom.Box.variable_attrs" href="#phi.geom.Box.variable_attrs">variable_attrs</a></code></li>
<li><code><a title="phi.geom.Box.volume" href="#phi.geom.Box.volume">volume</a></code></li>
<li><code><a title="phi.geom.Box.without" href="#phi.geom.Box.without">without</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.geom.Cylinder" href="#phi.geom.Cylinder">Cylinder</a></code></h4>
<ul class="">
<li><code><a title="phi.geom.Cylinder.Tc" href="#phi.geom.Cylinder.Tc">Tc</a></code></li>
<li><code><a title="phi.geom.Cylinder.Ti" href="#phi.geom.Cylinder.Ti">Ti</a></code></li>
<li><code><a title="phi.geom.Cylinder.Ts" href="#phi.geom.Cylinder.Ts">Ts</a></code></li>
<li><code><a title="phi.geom.Cylinder.approximate_closest_surface" href="#phi.geom.Cylinder.approximate_closest_surface">approximate_closest_surface</a></code></li>
<li><code><a title="phi.geom.Cylinder.approximate_signed_distance" href="#phi.geom.Cylinder.approximate_signed_distance">approximate_signed_distance</a></code></li>
<li><code><a title="phi.geom.Cylinder.at" href="#phi.geom.Cylinder.at">at</a></code></li>
<li><code><a title="phi.geom.Cylinder.axis" href="#phi.geom.Cylinder.axis">axis</a></code></li>
<li><code><a title="phi.geom.Cylinder.boundary_elements" href="#phi.geom.Cylinder.boundary_elements">boundary_elements</a></code></li>
<li><code><a title="phi.geom.Cylinder.boundary_faces" href="#phi.geom.Cylinder.boundary_faces">boundary_faces</a></code></li>
<li><code><a title="phi.geom.Cylinder.bounding_half_extent" href="#phi.geom.Cylinder.bounding_half_extent">bounding_half_extent</a></code></li>
<li><code><a title="phi.geom.Cylinder.bounding_radius" href="#phi.geom.Cylinder.bounding_radius">bounding_radius</a></code></li>
<li><code><a title="phi.geom.Cylinder.center" href="#phi.geom.Cylinder.center">center</a></code></li>
<li><code><a title="phi.geom.Cylinder.corners" href="#phi.geom.Cylinder.corners">corners</a></code></li>
<li><code><a title="phi.geom.Cylinder.depth" href="#phi.geom.Cylinder.depth">depth</a></code></li>
<li><code><a title="phi.geom.Cylinder.face_areas" href="#phi.geom.Cylinder.face_areas">face_areas</a></code></li>
<li><code><a title="phi.geom.Cylinder.face_centers" href="#phi.geom.Cylinder.face_centers">face_centers</a></code></li>
<li><code><a title="phi.geom.Cylinder.face_normals" href="#phi.geom.Cylinder.face_normals">face_normals</a></code></li>
<li><code><a title="phi.geom.Cylinder.face_shape" href="#phi.geom.Cylinder.face_shape">face_shape</a></code></li>
<li><code><a title="phi.geom.Cylinder.faces" href="#phi.geom.Cylinder.faces">faces</a></code></li>
<li><code><a title="phi.geom.Cylinder.lies_inside" href="#phi.geom.Cylinder.lies_inside">lies_inside</a></code></li>
<li><code><a title="phi.geom.Cylinder.radial_axes" href="#phi.geom.Cylinder.radial_axes">radial_axes</a></code></li>
<li><code><a title="phi.geom.Cylinder.radius" href="#phi.geom.Cylinder.radius">radius</a></code></li>
<li><code><a title="phi.geom.Cylinder.rotated" href="#phi.geom.Cylinder.rotated">rotated</a></code></li>
<li><code><a title="phi.geom.Cylinder.rotation" href="#phi.geom.Cylinder.rotation">rotation</a></code></li>
<li><code><a title="phi.geom.Cylinder.rotation_matrix" href="#phi.geom.Cylinder.rotation_matrix">rotation_matrix</a></code></li>
<li><code><a title="phi.geom.Cylinder.sample_uniform" href="#phi.geom.Cylinder.sample_uniform">sample_uniform</a></code></li>
<li><code><a title="phi.geom.Cylinder.scaled" href="#phi.geom.Cylinder.scaled">scaled</a></code></li>
<li><code><a title="phi.geom.Cylinder.shape" href="#phi.geom.Cylinder.shape">shape</a></code></li>
<li><code><a title="phi.geom.Cylinder.up" href="#phi.geom.Cylinder.up">up</a></code></li>
<li><code><a title="phi.geom.Cylinder.value_attrs" href="#phi.geom.Cylinder.value_attrs">value_attrs</a></code></li>
<li><code><a title="phi.geom.Cylinder.variable_attrs" href="#phi.geom.Cylinder.variable_attrs">variable_attrs</a></code></li>
<li><code><a title="phi.geom.Cylinder.vertex_rings" href="#phi.geom.Cylinder.vertex_rings">vertex_rings</a></code></li>
<li><code><a title="phi.geom.Cylinder.volume" href="#phi.geom.Cylinder.volume">volume</a></code></li>
<li><code><a title="phi.geom.Cylinder.with_depth" href="#phi.geom.Cylinder.with_depth">with_depth</a></code></li>
<li><code><a title="phi.geom.Cylinder.with_radius" href="#phi.geom.Cylinder.with_radius">with_radius</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></h4>
<ul class="">
<li><code><a title="phi.geom.Geometry.approximate_closest_surface" href="#phi.geom.Geometry.approximate_closest_surface">approximate_closest_surface</a></code></li>
<li><code><a title="phi.geom.Geometry.approximate_fraction_inside" href="#phi.geom.Geometry.approximate_fraction_inside">approximate_fraction_inside</a></code></li>
<li><code><a title="phi.geom.Geometry.approximate_signed_distance" href="#phi.geom.Geometry.approximate_signed_distance">approximate_signed_distance</a></code></li>
<li><code><a title="phi.geom.Geometry.at" href="#phi.geom.Geometry.at">at</a></code></li>
<li><code><a title="phi.geom.Geometry.boundary_elements" href="#phi.geom.Geometry.boundary_elements">boundary_elements</a></code></li>
<li><code><a title="phi.geom.Geometry.boundary_faces" href="#phi.geom.Geometry.boundary_faces">boundary_faces</a></code></li>
<li><code><a title="phi.geom.Geometry.bounding_box" href="#phi.geom.Geometry.bounding_box">bounding_box</a></code></li>
<li><code><a title="phi.geom.Geometry.bounding_half_extent" href="#phi.geom.Geometry.bounding_half_extent">bounding_half_extent</a></code></li>
<li><code><a title="phi.geom.Geometry.bounding_radius" href="#phi.geom.Geometry.bounding_radius">bounding_radius</a></code></li>
<li><code><a title="phi.geom.Geometry.bounding_sphere" href="#phi.geom.Geometry.bounding_sphere">bounding_sphere</a></code></li>
<li><code><a title="phi.geom.Geometry.center" href="#phi.geom.Geometry.center">center</a></code></li>
<li><code><a title="phi.geom.Geometry.corners" href="#phi.geom.Geometry.corners">corners</a></code></li>
<li><code><a title="phi.geom.Geometry.face_areas" href="#phi.geom.Geometry.face_areas">face_areas</a></code></li>
<li><code><a title="phi.geom.Geometry.face_centers" href="#phi.geom.Geometry.face_centers">face_centers</a></code></li>
<li><code><a title="phi.geom.Geometry.face_normals" href="#phi.geom.Geometry.face_normals">face_normals</a></code></li>
<li><code><a title="phi.geom.Geometry.face_shape" href="#phi.geom.Geometry.face_shape">face_shape</a></code></li>
<li><code><a title="phi.geom.Geometry.faces" href="#phi.geom.Geometry.faces">faces</a></code></li>
<li><code><a title="phi.geom.Geometry.get_boundary" href="#phi.geom.Geometry.get_boundary">get_boundary</a></code></li>
<li><code><a title="phi.geom.Geometry.get_points" href="#phi.geom.Geometry.get_points">get_points</a></code></li>
<li><code><a title="phi.geom.Geometry.integrate_flux" href="#phi.geom.Geometry.integrate_flux">integrate_flux</a></code></li>
<li><code><a title="phi.geom.Geometry.integrate_surface" href="#phi.geom.Geometry.integrate_surface">integrate_surface</a></code></li>
<li><code><a title="phi.geom.Geometry.lies_inside" href="#phi.geom.Geometry.lies_inside">lies_inside</a></code></li>
<li><code><a title="phi.geom.Geometry.push" href="#phi.geom.Geometry.push">push</a></code></li>
<li><code><a title="phi.geom.Geometry.rotated" href="#phi.geom.Geometry.rotated">rotated</a></code></li>
<li><code><a title="phi.geom.Geometry.sample_uniform" href="#phi.geom.Geometry.sample_uniform">sample_uniform</a></code></li>
<li><code><a title="phi.geom.Geometry.scaled" href="#phi.geom.Geometry.scaled">scaled</a></code></li>
<li><code><a title="phi.geom.Geometry.sets" href="#phi.geom.Geometry.sets">sets</a></code></li>
<li><code><a title="phi.geom.Geometry.shallow_equals" href="#phi.geom.Geometry.shallow_equals">shallow_equals</a></code></li>
<li><code><a title="phi.geom.Geometry.shape" href="#phi.geom.Geometry.shape">shape</a></code></li>
<li><code><a title="phi.geom.Geometry.shifted" href="#phi.geom.Geometry.shifted">shifted</a></code></li>
<li><code><a title="phi.geom.Geometry.spatial_rank" href="#phi.geom.Geometry.spatial_rank">spatial_rank</a></code></li>
<li><code><a title="phi.geom.Geometry.unstack" href="#phi.geom.Geometry.unstack">unstack</a></code></li>
<li><code><a title="phi.geom.Geometry.volume" href="#phi.geom.Geometry.volume">volume</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.geom.GeometryException" href="#phi.geom.GeometryException">GeometryException</a></code></h4>
</li>
<li>
<h4><code><a title="phi.geom.Graph" href="#phi.geom.Graph">Graph</a></code></h4>
<ul class="">
<li><code><a title="phi.geom.Graph.Tc" href="#phi.geom.Graph.Tc">Tc</a></code></li>
<li><code><a title="phi.geom.Graph.Ti" href="#phi.geom.Graph.Ti">Ti</a></code></li>
<li><code><a title="phi.geom.Graph.Ts" href="#phi.geom.Graph.Ts">Ts</a></code></li>
<li><code><a title="phi.geom.Graph.approximate_closest_surface" href="#phi.geom.Graph.approximate_closest_surface">approximate_closest_surface</a></code></li>
<li><code><a title="phi.geom.Graph.approximate_signed_distance" href="#phi.geom.Graph.approximate_signed_distance">approximate_signed_distance</a></code></li>
<li><code><a title="phi.geom.Graph.as_points" href="#phi.geom.Graph.as_points">as_points</a></code></li>
<li><code><a title="phi.geom.Graph.at" href="#phi.geom.Graph.at">at</a></code></li>
<li><code><a title="phi.geom.Graph.boundary" href="#phi.geom.Graph.boundary">boundary</a></code></li>
<li><code><a title="phi.geom.Graph.boundary_elements" href="#phi.geom.Graph.boundary_elements">boundary_elements</a></code></li>
<li><code><a title="phi.geom.Graph.boundary_faces" href="#phi.geom.Graph.boundary_faces">boundary_faces</a></code></li>
<li><code><a title="phi.geom.Graph.bounding_distance" href="#phi.geom.Graph.bounding_distance">bounding_distance</a></code></li>
<li><code><a title="phi.geom.Graph.bounding_half_extent" href="#phi.geom.Graph.bounding_half_extent">bounding_half_extent</a></code></li>
<li><code><a title="phi.geom.Graph.bounding_radius" href="#phi.geom.Graph.bounding_radius">bounding_radius</a></code></li>
<li><code><a title="phi.geom.Graph.center" href="#phi.geom.Graph.center">center</a></code></li>
<li><code><a title="phi.geom.Graph.connectivity" href="#phi.geom.Graph.connectivity">connectivity</a></code></li>
<li><code><a title="phi.geom.Graph.deltas" href="#phi.geom.Graph.deltas">deltas</a></code></li>
<li><code><a title="phi.geom.Graph.distances" href="#phi.geom.Graph.distances">distances</a></code></li>
<li><code><a title="phi.geom.Graph.edges" href="#phi.geom.Graph.edges">edges</a></code></li>
<li><code><a title="phi.geom.Graph.face_areas" href="#phi.geom.Graph.face_areas">face_areas</a></code></li>
<li><code><a title="phi.geom.Graph.face_centers" href="#phi.geom.Graph.face_centers">face_centers</a></code></li>
<li><code><a title="phi.geom.Graph.face_normals" href="#phi.geom.Graph.face_normals">face_normals</a></code></li>
<li><code><a title="phi.geom.Graph.face_shape" href="#phi.geom.Graph.face_shape">face_shape</a></code></li>
<li><code><a title="phi.geom.Graph.faces" href="#phi.geom.Graph.faces">faces</a></code></li>
<li><code><a title="phi.geom.Graph.lies_inside" href="#phi.geom.Graph.lies_inside">lies_inside</a></code></li>
<li><code><a title="phi.geom.Graph.nodes" href="#phi.geom.Graph.nodes">nodes</a></code></li>
<li><code><a title="phi.geom.Graph.rotated" href="#phi.geom.Graph.rotated">rotated</a></code></li>
<li><code><a title="phi.geom.Graph.sample_uniform" href="#phi.geom.Graph.sample_uniform">sample_uniform</a></code></li>
<li><code><a title="phi.geom.Graph.scaled" href="#phi.geom.Graph.scaled">scaled</a></code></li>
<li><code><a title="phi.geom.Graph.shape" href="#phi.geom.Graph.shape">shape</a></code></li>
<li><code><a title="phi.geom.Graph.shifted" href="#phi.geom.Graph.shifted">shifted</a></code></li>
<li><code><a title="phi.geom.Graph.unit_deltas" href="#phi.geom.Graph.unit_deltas">unit_deltas</a></code></li>
<li><code><a title="phi.geom.Graph.variable_attrs" href="#phi.geom.Graph.variable_attrs">variable_attrs</a></code></li>
<li><code><a title="phi.geom.Graph.volume" href="#phi.geom.Graph.volume">volume</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.geom.Heightmap" href="#phi.geom.Heightmap">Heightmap</a></code></h4>
<ul class="">
<li><code><a title="phi.geom.Heightmap.approximate_closest_surface" href="#phi.geom.Heightmap.approximate_closest_surface">approximate_closest_surface</a></code></li>
<li><code><a title="phi.geom.Heightmap.approximate_signed_distance" href="#phi.geom.Heightmap.approximate_signed_distance">approximate_signed_distance</a></code></li>
<li><code><a title="phi.geom.Heightmap.at" href="#phi.geom.Heightmap.at">at</a></code></li>
<li><code><a title="phi.geom.Heightmap.boundary_elements" href="#phi.geom.Heightmap.boundary_elements">boundary_elements</a></code></li>
<li><code><a title="phi.geom.Heightmap.boundary_faces" href="#phi.geom.Heightmap.boundary_faces">boundary_faces</a></code></li>
<li><code><a title="phi.geom.Heightmap.bounding_half_extent" href="#phi.geom.Heightmap.bounding_half_extent">bounding_half_extent</a></code></li>
<li><code><a title="phi.geom.Heightmap.bounding_radius" href="#phi.geom.Heightmap.bounding_radius">bounding_radius</a></code></li>
<li><code><a title="phi.geom.Heightmap.bounds" href="#phi.geom.Heightmap.bounds">bounds</a></code></li>
<li><code><a title="phi.geom.Heightmap.center" href="#phi.geom.Heightmap.center">center</a></code></li>
<li><code><a title="phi.geom.Heightmap.dx" href="#phi.geom.Heightmap.dx">dx</a></code></li>
<li><code><a title="phi.geom.Heightmap.extrapolation" href="#phi.geom.Heightmap.extrapolation">extrapolation</a></code></li>
<li><code><a title="phi.geom.Heightmap.face_areas" href="#phi.geom.Heightmap.face_areas">face_areas</a></code></li>
<li><code><a title="phi.geom.Heightmap.face_centers" href="#phi.geom.Heightmap.face_centers">face_centers</a></code></li>
<li><code><a title="phi.geom.Heightmap.face_normals" href="#phi.geom.Heightmap.face_normals">face_normals</a></code></li>
<li><code><a title="phi.geom.Heightmap.face_shape" href="#phi.geom.Heightmap.face_shape">face_shape</a></code></li>
<li><code><a title="phi.geom.Heightmap.faces" href="#phi.geom.Heightmap.faces">faces</a></code></li>
<li><code><a title="phi.geom.Heightmap.fill_below" href="#phi.geom.Heightmap.fill_below">fill_below</a></code></li>
<li><code><a title="phi.geom.Heightmap.grid_bounds" href="#phi.geom.Heightmap.grid_bounds">grid_bounds</a></code></li>
<li><code><a title="phi.geom.Heightmap.height" href="#phi.geom.Heightmap.height">height</a></code></li>
<li><code><a title="phi.geom.Heightmap.lies_inside" href="#phi.geom.Heightmap.lies_inside">lies_inside</a></code></li>
<li><code><a title="phi.geom.Heightmap.max_dist" href="#phi.geom.Heightmap.max_dist">max_dist</a></code></li>
<li><code><a title="phi.geom.Heightmap.resolution" href="#phi.geom.Heightmap.resolution">resolution</a></code></li>
<li><code><a title="phi.geom.Heightmap.rotated" href="#phi.geom.Heightmap.rotated">rotated</a></code></li>
<li><code><a title="phi.geom.Heightmap.sample_uniform" href="#phi.geom.Heightmap.sample_uniform">sample_uniform</a></code></li>
<li><code><a title="phi.geom.Heightmap.scaled" href="#phi.geom.Heightmap.scaled">scaled</a></code></li>
<li><code><a title="phi.geom.Heightmap.shallow_equals" href="#phi.geom.Heightmap.shallow_equals">shallow_equals</a></code></li>
<li><code><a title="phi.geom.Heightmap.shape" href="#phi.geom.Heightmap.shape">shape</a></code></li>
<li><code><a title="phi.geom.Heightmap.up" href="#phi.geom.Heightmap.up">up</a></code></li>
<li><code><a title="phi.geom.Heightmap.vertices" href="#phi.geom.Heightmap.vertices">vertices</a></code></li>
<li><code><a title="phi.geom.Heightmap.volume" href="#phi.geom.Heightmap.volume">volume</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.geom.Mesh" href="#phi.geom.Mesh">Mesh</a></code></h4>
<ul class="">
<li><code><a title="phi.geom.Mesh.all_boundary_faces" href="#phi.geom.Mesh.all_boundary_faces">all_boundary_faces</a></code></li>
<li><code><a title="phi.geom.Mesh.approximate_closest_surface" href="#phi.geom.Mesh.approximate_closest_surface">approximate_closest_surface</a></code></li>
<li><code><a title="phi.geom.Mesh.approximate_signed_distance" href="#phi.geom.Mesh.approximate_signed_distance">approximate_signed_distance</a></code></li>
<li><code><a title="phi.geom.Mesh.at" href="#phi.geom.Mesh.at">at</a></code></li>
<li><code><a title="phi.geom.Mesh.boundaries" href="#phi.geom.Mesh.boundaries">boundaries</a></code></li>
<li><code><a title="phi.geom.Mesh.boundary_connectivity" href="#phi.geom.Mesh.boundary_connectivity">boundary_connectivity</a></code></li>
<li><code><a title="phi.geom.Mesh.boundary_elements" href="#phi.geom.Mesh.boundary_elements">boundary_elements</a></code></li>
<li><code><a title="phi.geom.Mesh.boundary_faces" href="#phi.geom.Mesh.boundary_faces">boundary_faces</a></code></li>
<li><code><a title="phi.geom.Mesh.bounding_box" href="#phi.geom.Mesh.bounding_box">bounding_box</a></code></li>
<li><code><a title="phi.geom.Mesh.bounding_half_extent" href="#phi.geom.Mesh.bounding_half_extent">bounding_half_extent</a></code></li>
<li><code><a title="phi.geom.Mesh.bounding_radius" href="#phi.geom.Mesh.bounding_radius">bounding_radius</a></code></li>
<li><code><a title="phi.geom.Mesh.bounds" href="#phi.geom.Mesh.bounds">bounds</a></code></li>
<li><code><a title="phi.geom.Mesh.cell_connectivity" href="#phi.geom.Mesh.cell_connectivity">cell_connectivity</a></code></li>
<li><code><a title="phi.geom.Mesh.cell_count" href="#phi.geom.Mesh.cell_count">cell_count</a></code></li>
<li><code><a title="phi.geom.Mesh.cell_walk_towards" href="#phi.geom.Mesh.cell_walk_towards">cell_walk_towards</a></code></li>
<li><code><a title="phi.geom.Mesh.center" href="#phi.geom.Mesh.center">center</a></code></li>
<li><code><a title="phi.geom.Mesh.closest_vertex" href="#phi.geom.Mesh.closest_vertex">closest_vertex</a></code></li>
<li><code><a title="phi.geom.Mesh.connectivity" href="#phi.geom.Mesh.connectivity">connectivity</a></code></li>
<li><code><a title="phi.geom.Mesh.distance_matrix" href="#phi.geom.Mesh.distance_matrix">distance_matrix</a></code></li>
<li><code><a title="phi.geom.Mesh.element_connectivity" href="#phi.geom.Mesh.element_connectivity">element_connectivity</a></code></li>
<li><code><a title="phi.geom.Mesh.element_rank" href="#phi.geom.Mesh.element_rank">element_rank</a></code></li>
<li><code><a title="phi.geom.Mesh.elements" href="#phi.geom.Mesh.elements">elements</a></code></li>
<li><code><a title="phi.geom.Mesh.face_areas" href="#phi.geom.Mesh.face_areas">face_areas</a></code></li>
<li><code><a title="phi.geom.Mesh.face_centers" href="#phi.geom.Mesh.face_centers">face_centers</a></code></li>
<li><code><a title="phi.geom.Mesh.face_format" href="#phi.geom.Mesh.face_format">face_format</a></code></li>
<li><code><a title="phi.geom.Mesh.face_normals" href="#phi.geom.Mesh.face_normals">face_normals</a></code></li>
<li><code><a title="phi.geom.Mesh.face_shape" href="#phi.geom.Mesh.face_shape">face_shape</a></code></li>
<li><code><a title="phi.geom.Mesh.faces" href="#phi.geom.Mesh.faces">faces</a></code></li>
<li><code><a title="phi.geom.Mesh.faces_to_vertices" href="#phi.geom.Mesh.faces_to_vertices">faces_to_vertices</a></code></li>
<li><code><a title="phi.geom.Mesh.filter_unused_vertices" href="#phi.geom.Mesh.filter_unused_vertices">filter_unused_vertices</a></code></li>
<li><code><a title="phi.geom.Mesh.get_boundary" href="#phi.geom.Mesh.get_boundary">get_boundary</a></code></li>
<li><code><a title="phi.geom.Mesh.get_points" href="#phi.geom.Mesh.get_points">get_points</a></code></li>
<li><code><a title="phi.geom.Mesh.interior_faces" href="#phi.geom.Mesh.interior_faces">interior_faces</a></code></li>
<li><code><a title="phi.geom.Mesh.lies_inside" href="#phi.geom.Mesh.lies_inside">lies_inside</a></code></li>
<li><code><a title="phi.geom.Mesh.max_cell_walk" href="#phi.geom.Mesh.max_cell_walk">max_cell_walk</a></code></li>
<li><code><a title="phi.geom.Mesh.neighbor_distances" href="#phi.geom.Mesh.neighbor_distances">neighbor_distances</a></code></li>
<li><code><a title="phi.geom.Mesh.neighbor_offsets" href="#phi.geom.Mesh.neighbor_offsets">neighbor_offsets</a></code></li>
<li><code><a title="phi.geom.Mesh.normals" href="#phi.geom.Mesh.normals">normals</a></code></li>
<li><code><a title="phi.geom.Mesh.pad_boundary" href="#phi.geom.Mesh.pad_boundary">pad_boundary</a></code></li>
<li><code><a title="phi.geom.Mesh.periodic" href="#phi.geom.Mesh.periodic">periodic</a></code></li>
<li><code><a title="phi.geom.Mesh.relative_face_distance" href="#phi.geom.Mesh.relative_face_distance">relative_face_distance</a></code></li>
<li><code><a title="phi.geom.Mesh.rotated" href="#phi.geom.Mesh.rotated">rotated</a></code></li>
<li><code><a title="phi.geom.Mesh.sample_uniform" href="#phi.geom.Mesh.sample_uniform">sample_uniform</a></code></li>
<li><code><a title="phi.geom.Mesh.scaled" href="#phi.geom.Mesh.scaled">scaled</a></code></li>
<li><code><a title="phi.geom.Mesh.sets" href="#phi.geom.Mesh.sets">sets</a></code></li>
<li><code><a title="phi.geom.Mesh.shape" href="#phi.geom.Mesh.shape">shape</a></code></li>
<li><code><a title="phi.geom.Mesh.shifted" href="#phi.geom.Mesh.shifted">shifted</a></code></li>
<li><code><a title="phi.geom.Mesh.value_attrs" href="#phi.geom.Mesh.value_attrs">value_attrs</a></code></li>
<li><code><a title="phi.geom.Mesh.variable_attrs" href="#phi.geom.Mesh.variable_attrs">variable_attrs</a></code></li>
<li><code><a title="phi.geom.Mesh.vertex_connectivity" href="#phi.geom.Mesh.vertex_connectivity">vertex_connectivity</a></code></li>
<li><code><a title="phi.geom.Mesh.vertex_graph" href="#phi.geom.Mesh.vertex_graph">vertex_graph</a></code></li>
<li><code><a title="phi.geom.Mesh.vertex_normals" href="#phi.geom.Mesh.vertex_normals">vertex_normals</a></code></li>
<li><code><a title="phi.geom.Mesh.vertex_positions" href="#phi.geom.Mesh.vertex_positions">vertex_positions</a></code></li>
<li><code><a title="phi.geom.Mesh.vertices" href="#phi.geom.Mesh.vertices">vertices</a></code></li>
<li><code><a title="phi.geom.Mesh.volume" href="#phi.geom.Mesh.volume">volume</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.geom.Point" href="#phi.geom.Point">Point</a></code></h4>
<ul class="">
<li><code><a title="phi.geom.Point.Tc" href="#phi.geom.Point.Tc">Tc</a></code></li>
<li><code><a title="phi.geom.Point.Ti" href="#phi.geom.Point.Ti">Ti</a></code></li>
<li><code><a title="phi.geom.Point.Ts" href="#phi.geom.Point.Ts">Ts</a></code></li>
<li><code><a title="phi.geom.Point.approximate_signed_distance" href="#phi.geom.Point.approximate_signed_distance">approximate_signed_distance</a></code></li>
<li><code><a title="phi.geom.Point.at" href="#phi.geom.Point.at">at</a></code></li>
<li><code><a title="phi.geom.Point.boundary_elements" href="#phi.geom.Point.boundary_elements">boundary_elements</a></code></li>
<li><code><a title="phi.geom.Point.boundary_faces" href="#phi.geom.Point.boundary_faces">boundary_faces</a></code></li>
<li><code><a title="phi.geom.Point.bounding_half_extent" href="#phi.geom.Point.bounding_half_extent">bounding_half_extent</a></code></li>
<li><code><a title="phi.geom.Point.bounding_radius" href="#phi.geom.Point.bounding_radius">bounding_radius</a></code></li>
<li><code><a title="phi.geom.Point.center" href="#phi.geom.Point.center">center</a></code></li>
<li><code><a title="phi.geom.Point.corners" href="#phi.geom.Point.corners">corners</a></code></li>
<li><code><a title="phi.geom.Point.face_areas" href="#phi.geom.Point.face_areas">face_areas</a></code></li>
<li><code><a title="phi.geom.Point.face_centers" href="#phi.geom.Point.face_centers">face_centers</a></code></li>
<li><code><a title="phi.geom.Point.face_normals" href="#phi.geom.Point.face_normals">face_normals</a></code></li>
<li><code><a title="phi.geom.Point.face_shape" href="#phi.geom.Point.face_shape">face_shape</a></code></li>
<li><code><a title="phi.geom.Point.faces" href="#phi.geom.Point.faces">faces</a></code></li>
<li><code><a title="phi.geom.Point.lies_inside" href="#phi.geom.Point.lies_inside">lies_inside</a></code></li>
<li><code><a title="phi.geom.Point.location" href="#phi.geom.Point.location">location</a></code></li>
<li><code><a title="phi.geom.Point.rotated" href="#phi.geom.Point.rotated">rotated</a></code></li>
<li><code><a title="phi.geom.Point.sample_uniform" href="#phi.geom.Point.sample_uniform">sample_uniform</a></code></li>
<li><code><a title="phi.geom.Point.scaled" href="#phi.geom.Point.scaled">scaled</a></code></li>
<li><code><a title="phi.geom.Point.shape" href="#phi.geom.Point.shape">shape</a></code></li>
<li><code><a title="phi.geom.Point.unstack" href="#phi.geom.Point.unstack">unstack</a></code></li>
<li><code><a title="phi.geom.Point.value_attrs" href="#phi.geom.Point.value_attrs">value_attrs</a></code></li>
<li><code><a title="phi.geom.Point.variable_attrs" href="#phi.geom.Point.variable_attrs">variable_attrs</a></code></li>
<li><code><a title="phi.geom.Point.volume" href="#phi.geom.Point.volume">volume</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.geom.SDF" href="#phi.geom.SDF">SDF</a></code></h4>
<ul class="">
<li><code><a title="phi.geom.SDF.approximate_closest_surface" href="#phi.geom.SDF.approximate_closest_surface">approximate_closest_surface</a></code></li>
<li><code><a title="phi.geom.SDF.approximate_signed_distance" href="#phi.geom.SDF.approximate_signed_distance">approximate_signed_distance</a></code></li>
<li><code><a title="phi.geom.SDF.at" href="#phi.geom.SDF.at">at</a></code></li>
<li><code><a title="phi.geom.SDF.boundary_elements" href="#phi.geom.SDF.boundary_elements">boundary_elements</a></code></li>
<li><code><a title="phi.geom.SDF.boundary_faces" href="#phi.geom.SDF.boundary_faces">boundary_faces</a></code></li>
<li><code><a title="phi.geom.SDF.bounding_box" href="#phi.geom.SDF.bounding_box">bounding_box</a></code></li>
<li><code><a title="phi.geom.SDF.bounding_half_extent" href="#phi.geom.SDF.bounding_half_extent">bounding_half_extent</a></code></li>
<li><code><a title="phi.geom.SDF.bounding_radius" href="#phi.geom.SDF.bounding_radius">bounding_radius</a></code></li>
<li><code><a title="phi.geom.SDF.bounds" href="#phi.geom.SDF.bounds">bounds</a></code></li>
<li><code><a title="phi.geom.SDF.center" href="#phi.geom.SDF.center">center</a></code></li>
<li><code><a title="phi.geom.SDF.corners" href="#phi.geom.SDF.corners">corners</a></code></li>
<li><code><a title="phi.geom.SDF.face_areas" href="#phi.geom.SDF.face_areas">face_areas</a></code></li>
<li><code><a title="phi.geom.SDF.face_centers" href="#phi.geom.SDF.face_centers">face_centers</a></code></li>
<li><code><a title="phi.geom.SDF.face_normals" href="#phi.geom.SDF.face_normals">face_normals</a></code></li>
<li><code><a title="phi.geom.SDF.face_shape" href="#phi.geom.SDF.face_shape">face_shape</a></code></li>
<li><code><a title="phi.geom.SDF.faces" href="#phi.geom.SDF.faces">faces</a></code></li>
<li><code><a title="phi.geom.SDF.lies_inside" href="#phi.geom.SDF.lies_inside">lies_inside</a></code></li>
<li><code><a title="phi.geom.SDF.rotated" href="#phi.geom.SDF.rotated">rotated</a></code></li>
<li><code><a title="phi.geom.SDF.sample_uniform" href="#phi.geom.SDF.sample_uniform">sample_uniform</a></code></li>
<li><code><a title="phi.geom.SDF.scaled" href="#phi.geom.SDF.scaled">scaled</a></code></li>
<li><code><a title="phi.geom.SDF.sdf_and_gradient" href="#phi.geom.SDF.sdf_and_gradient">sdf_and_gradient</a></code></li>
<li><code><a title="phi.geom.SDF.shape" href="#phi.geom.SDF.shape">shape</a></code></li>
<li><code><a title="phi.geom.SDF.shifted" href="#phi.geom.SDF.shifted">shifted</a></code></li>
<li><code><a title="phi.geom.SDF.size" href="#phi.geom.SDF.size">size</a></code></li>
<li><code><a title="phi.geom.SDF.volume" href="#phi.geom.SDF.volume">volume</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.geom.SDFGrid" href="#phi.geom.SDFGrid">SDFGrid</a></code></h4>
<ul class="">
<li><code><a title="phi.geom.SDFGrid.approximate_closest_surface" href="#phi.geom.SDFGrid.approximate_closest_surface">approximate_closest_surface</a></code></li>
<li><code><a title="phi.geom.SDFGrid.approximate_fraction_inside" href="#phi.geom.SDFGrid.approximate_fraction_inside">approximate_fraction_inside</a></code></li>
<li><code><a title="phi.geom.SDFGrid.approximate_occupancy" href="#phi.geom.SDFGrid.approximate_occupancy">approximate_occupancy</a></code></li>
<li><code><a title="phi.geom.SDFGrid.approximate_signed_distance" href="#phi.geom.SDFGrid.approximate_signed_distance">approximate_signed_distance</a></code></li>
<li><code><a title="phi.geom.SDFGrid.at" href="#phi.geom.SDFGrid.at">at</a></code></li>
<li><code><a title="phi.geom.SDFGrid.boundary_elements" href="#phi.geom.SDFGrid.boundary_elements">boundary_elements</a></code></li>
<li><code><a title="phi.geom.SDFGrid.boundary_faces" href="#phi.geom.SDFGrid.boundary_faces">boundary_faces</a></code></li>
<li><code><a title="phi.geom.SDFGrid.bounding_half_extent" href="#phi.geom.SDFGrid.bounding_half_extent">bounding_half_extent</a></code></li>
<li><code><a title="phi.geom.SDFGrid.bounding_radius" href="#phi.geom.SDFGrid.bounding_radius">bounding_radius</a></code></li>
<li><code><a title="phi.geom.SDFGrid.bounds" href="#phi.geom.SDFGrid.bounds">bounds</a></code></li>
<li><code><a title="phi.geom.SDFGrid.center" href="#phi.geom.SDFGrid.center">center</a></code></li>
<li><code><a title="phi.geom.SDFGrid.corners" href="#phi.geom.SDFGrid.corners">corners</a></code></li>
<li><code><a title="phi.geom.SDFGrid.downsample2x" href="#phi.geom.SDFGrid.downsample2x">downsample2x</a></code></li>
<li><code><a title="phi.geom.SDFGrid.dx" href="#phi.geom.SDFGrid.dx">dx</a></code></li>
<li><code><a title="phi.geom.SDFGrid.face_areas" href="#phi.geom.SDFGrid.face_areas">face_areas</a></code></li>
<li><code><a title="phi.geom.SDFGrid.face_centers" href="#phi.geom.SDFGrid.face_centers">face_centers</a></code></li>
<li><code><a title="phi.geom.SDFGrid.face_normals" href="#phi.geom.SDFGrid.face_normals">face_normals</a></code></li>
<li><code><a title="phi.geom.SDFGrid.face_shape" href="#phi.geom.SDFGrid.face_shape">face_shape</a></code></li>
<li><code><a title="phi.geom.SDFGrid.faces" href="#phi.geom.SDFGrid.faces">faces</a></code></li>
<li><code><a title="phi.geom.SDFGrid.grid" href="#phi.geom.SDFGrid.grid">grid</a></code></li>
<li><code><a title="phi.geom.SDFGrid.lies_inside" href="#phi.geom.SDFGrid.lies_inside">lies_inside</a></code></li>
<li><code><a title="phi.geom.SDFGrid.points" href="#phi.geom.SDFGrid.points">points</a></code></li>
<li><code><a title="phi.geom.SDFGrid.resolution" href="#phi.geom.SDFGrid.resolution">resolution</a></code></li>
<li><code><a title="phi.geom.SDFGrid.rotated" href="#phi.geom.SDFGrid.rotated">rotated</a></code></li>
<li><code><a title="phi.geom.SDFGrid.sample_uniform" href="#phi.geom.SDFGrid.sample_uniform">sample_uniform</a></code></li>
<li><code><a title="phi.geom.SDFGrid.scaled" href="#phi.geom.SDFGrid.scaled">scaled</a></code></li>
<li><code><a title="phi.geom.SDFGrid.shape" href="#phi.geom.SDFGrid.shape">shape</a></code></li>
<li><code><a title="phi.geom.SDFGrid.shifted" href="#phi.geom.SDFGrid.shifted">shifted</a></code></li>
<li><code><a title="phi.geom.SDFGrid.size" href="#phi.geom.SDFGrid.size">size</a></code></li>
<li><code><a title="phi.geom.SDFGrid.values" href="#phi.geom.SDFGrid.values">values</a></code></li>
<li><code><a title="phi.geom.SDFGrid.volume" href="#phi.geom.SDFGrid.volume">volume</a></code></li>
<li><code><a title="phi.geom.SDFGrid.with_values" href="#phi.geom.SDFGrid.with_values">with_values</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.geom.Sphere" href="#phi.geom.Sphere">Sphere</a></code></h4>
<ul class="">
<li><code><a title="phi.geom.Sphere.Tc" href="#phi.geom.Sphere.Tc">Tc</a></code></li>
<li><code><a title="phi.geom.Sphere.Ti" href="#phi.geom.Sphere.Ti">Ti</a></code></li>
<li><code><a title="phi.geom.Sphere.Ts" href="#phi.geom.Sphere.Ts">Ts</a></code></li>
<li><code><a title="phi.geom.Sphere.approximate_closest_surface" href="#phi.geom.Sphere.approximate_closest_surface">approximate_closest_surface</a></code></li>
<li><code><a title="phi.geom.Sphere.approximate_signed_distance" href="#phi.geom.Sphere.approximate_signed_distance">approximate_signed_distance</a></code></li>
<li><code><a title="phi.geom.Sphere.area_from_radius" href="#phi.geom.Sphere.area_from_radius">area_from_radius</a></code></li>
<li><code><a title="phi.geom.Sphere.at" href="#phi.geom.Sphere.at">at</a></code></li>
<li><code><a title="phi.geom.Sphere.boundary_elements" href="#phi.geom.Sphere.boundary_elements">boundary_elements</a></code></li>
<li><code><a title="phi.geom.Sphere.boundary_faces" href="#phi.geom.Sphere.boundary_faces">boundary_faces</a></code></li>
<li><code><a title="phi.geom.Sphere.bounding_half_extent" href="#phi.geom.Sphere.bounding_half_extent">bounding_half_extent</a></code></li>
<li><code><a title="phi.geom.Sphere.bounding_radius" href="#phi.geom.Sphere.bounding_radius">bounding_radius</a></code></li>
<li><code><a title="phi.geom.Sphere.center" href="#phi.geom.Sphere.center">center</a></code></li>
<li><code><a title="phi.geom.Sphere.corners" href="#phi.geom.Sphere.corners">corners</a></code></li>
<li><code><a title="phi.geom.Sphere.face_areas" href="#phi.geom.Sphere.face_areas">face_areas</a></code></li>
<li><code><a title="phi.geom.Sphere.face_centers" href="#phi.geom.Sphere.face_centers">face_centers</a></code></li>
<li><code><a title="phi.geom.Sphere.face_normals" href="#phi.geom.Sphere.face_normals">face_normals</a></code></li>
<li><code><a title="phi.geom.Sphere.face_shape" href="#phi.geom.Sphere.face_shape">face_shape</a></code></li>
<li><code><a title="phi.geom.Sphere.faces" href="#phi.geom.Sphere.faces">faces</a></code></li>
<li><code><a title="phi.geom.Sphere.lies_inside" href="#phi.geom.Sphere.lies_inside">lies_inside</a></code></li>
<li><code><a title="phi.geom.Sphere.pos" href="#phi.geom.Sphere.pos">pos</a></code></li>
<li><code><a title="phi.geom.Sphere.radius" href="#phi.geom.Sphere.radius">radius</a></code></li>
<li><code><a title="phi.geom.Sphere.radius_from_volume" href="#phi.geom.Sphere.radius_from_volume">radius_from_volume</a></code></li>
<li><code><a title="phi.geom.Sphere.rotated" href="#phi.geom.Sphere.rotated">rotated</a></code></li>
<li><code><a title="phi.geom.Sphere.sample_uniform" href="#phi.geom.Sphere.sample_uniform">sample_uniform</a></code></li>
<li><code><a title="phi.geom.Sphere.scaled" href="#phi.geom.Sphere.scaled">scaled</a></code></li>
<li><code><a title="phi.geom.Sphere.shape" href="#phi.geom.Sphere.shape">shape</a></code></li>
<li><code><a title="phi.geom.Sphere.variable_attrs" href="#phi.geom.Sphere.variable_attrs">variable_attrs</a></code></li>
<li><code><a title="phi.geom.Sphere.volume" href="#phi.geom.Sphere.volume">volume</a></code></li>
<li><code><a title="phi.geom.Sphere.volume_from_radius" href="#phi.geom.Sphere.volume_from_radius">volume_from_radius</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.geom.UniformGrid" href="#phi.geom.UniformGrid">UniformGrid</a></code></h4>
<ul class="">
<li><code><a title="phi.geom.UniformGrid.Tc" href="#phi.geom.UniformGrid.Tc">Tc</a></code></li>
<li><code><a title="phi.geom.UniformGrid.Ti" href="#phi.geom.UniformGrid.Ti">Ti</a></code></li>
<li><code><a title="phi.geom.UniformGrid.Ts" href="#phi.geom.UniformGrid.Ts">Ts</a></code></li>
<li><code><a title="phi.geom.UniformGrid.boundary_elements" href="#phi.geom.UniformGrid.boundary_elements">boundary_elements</a></code></li>
<li><code><a title="phi.geom.UniformGrid.boundary_faces" href="#phi.geom.UniformGrid.boundary_faces">boundary_faces</a></code></li>
<li><code><a title="phi.geom.UniformGrid.bounding_half_extent" href="#phi.geom.UniformGrid.bounding_half_extent">bounding_half_extent</a></code></li>
<li><code><a title="phi.geom.UniformGrid.bounding_radius" href="#phi.geom.UniformGrid.bounding_radius">bounding_radius</a></code></li>
<li><code><a title="phi.geom.UniformGrid.bounds" href="#phi.geom.UniformGrid.bounds">bounds</a></code></li>
<li><code><a title="phi.geom.UniformGrid.box" href="#phi.geom.UniformGrid.box">box</a></code></li>
<li><code><a title="phi.geom.UniformGrid.center" href="#phi.geom.UniformGrid.center">center</a></code></li>
<li><code><a title="phi.geom.UniformGrid.center_representation" href="#phi.geom.UniformGrid.center_representation">center_representation</a></code></li>
<li><code><a title="phi.geom.UniformGrid.corner_representation" href="#phi.geom.UniformGrid.corner_representation">corner_representation</a></code></li>
<li><code><a title="phi.geom.UniformGrid.cuboid" href="#phi.geom.UniformGrid.cuboid">cuboid</a></code></li>
<li><code><a title="phi.geom.UniformGrid.dx" href="#phi.geom.UniformGrid.dx">dx</a></code></li>
<li><code><a title="phi.geom.UniformGrid.face_areas" href="#phi.geom.UniformGrid.face_areas">face_areas</a></code></li>
<li><code><a title="phi.geom.UniformGrid.face_centers" href="#phi.geom.UniformGrid.face_centers">face_centers</a></code></li>
<li><code><a title="phi.geom.UniformGrid.face_normals" href="#phi.geom.UniformGrid.face_normals">face_normals</a></code></li>
<li><code><a title="phi.geom.UniformGrid.face_shape" href="#phi.geom.UniformGrid.face_shape">face_shape</a></code></li>
<li><code><a title="phi.geom.UniformGrid.faces" href="#phi.geom.UniformGrid.faces">faces</a></code></li>
<li><code><a title="phi.geom.UniformGrid.grid_size" href="#phi.geom.UniformGrid.grid_size">grid_size</a></code></li>
<li><code><a title="phi.geom.UniformGrid.half_size" href="#phi.geom.UniformGrid.half_size">half_size</a></code></li>
<li><code><a title="phi.geom.UniformGrid.interior" href="#phi.geom.UniformGrid.interior">interior</a></code></li>
<li><code><a title="phi.geom.UniformGrid.list_cells" href="#phi.geom.UniformGrid.list_cells">list_cells</a></code></li>
<li><code><a title="phi.geom.UniformGrid.lower" href="#phi.geom.UniformGrid.lower">lower</a></code></li>
<li><code><a title="phi.geom.UniformGrid.normal" href="#phi.geom.UniformGrid.normal">normal</a></code></li>
<li><code><a title="phi.geom.UniformGrid.padded" href="#phi.geom.UniformGrid.padded">padded</a></code></li>
<li><code><a title="phi.geom.UniformGrid.position_of" href="#phi.geom.UniformGrid.position_of">position_of</a></code></li>
<li><code><a title="phi.geom.UniformGrid.resolution" href="#phi.geom.UniformGrid.resolution">resolution</a></code></li>
<li><code><a title="phi.geom.UniformGrid.rotated" href="#phi.geom.UniformGrid.rotated">rotated</a></code></li>
<li><code><a title="phi.geom.UniformGrid.shallow_equals" href="#phi.geom.UniformGrid.shallow_equals">shallow_equals</a></code></li>
<li><code><a title="phi.geom.UniformGrid.shape" href="#phi.geom.UniformGrid.shape">shape</a></code></li>
<li><code><a title="phi.geom.UniformGrid.shifted" href="#phi.geom.UniformGrid.shifted">shifted</a></code></li>
<li><code><a title="phi.geom.UniformGrid.size" href="#phi.geom.UniformGrid.size">size</a></code></li>
<li><code><a title="phi.geom.UniformGrid.spatial_rank" href="#phi.geom.UniformGrid.spatial_rank">spatial_rank</a></code></li>
<li><code><a title="phi.geom.UniformGrid.stagger" href="#phi.geom.UniformGrid.stagger">stagger</a></code></li>
<li><code><a title="phi.geom.UniformGrid.staggered_cells" href="#phi.geom.UniformGrid.staggered_cells">staggered_cells</a></code></li>
<li><code><a title="phi.geom.UniformGrid.upper" href="#phi.geom.UniformGrid.upper">upper</a></code></li>
<li><code><a title="phi.geom.UniformGrid.volume" href="#phi.geom.UniformGrid.volume">volume</a></code></li>
<li><code><a title="phi.geom.UniformGrid.voxel_at" href="#phi.geom.UniformGrid.voxel_at">voxel_at</a></code></li>
<li><code><a title="phi.geom.UniformGrid.with_scaled_resolution" href="#phi.geom.UniformGrid.with_scaled_resolution">with_scaled_resolution</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
