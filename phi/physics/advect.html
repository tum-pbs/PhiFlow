<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>phi.physics.advect API documentation</title>
<meta name="description" content="Container for different advection schemes for grids and particles …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>phi.physics.advect</code></h1>
</header>
<section id="section-intro">
<p>Container for different advection schemes for grids and particles.</p>
<p>Examples:</p>
<ul>
<li>semi_lagrangian (grid)</li>
<li>mac_cormack (grid)</li>
<li>runge_kutta_4 (particle)</li>
</ul>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="phi.physics.advect.advect"><code class="name flex">
<span>def <span class="ident">advect</span></span>(<span>field: phi.field._field.Field,<br>velocity: phi.field._field.Field,<br>dt: float,<br>integrator=&lt;function euler&gt;) ‑> phi.field._field.Field</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def advect(field: Field,
           velocity: Field,
           dt: float or math.Tensor,
           integrator=euler) -&gt; Field:
    &#34;&#34;&#34;
    Advect `field` along the `velocity` vectors using the specified integrator.

    The behavior depends on the type of `field`:

    * `phi.field.PointCloud`: Points are advected forward, see `points`.
    * `phi.field.Grid`: Sample points are traced backward, see `semi_lagrangian`.

    Args:
        field: Field to be advected as `phi.field.Field`.
        velocity: Any `phi.field.Field` that can be sampled in the elements of `field`.
        dt: Time increment
        integrator: ODE integrator for solving the movement.

    Returns:
        Advected field of same type as `field`
    &#34;&#34;&#34;
    if field.is_point_cloud:
        return points(field, velocity, dt=dt, integrator=integrator)
    elif field.is_grid:
        return semi_lagrangian(field, velocity, dt=dt, integrator=integrator)
    raise NotImplementedError(field)</code></pre>
</details>
<div class="desc"><p>Advect <code>field</code> along the <code>velocity</code> vectors using the specified integrator.</p>
<p>The behavior depends on the type of <code>field</code>:</p>
<ul>
<li><code><a title="phi.field.PointCloud" href="../field/index.html#phi.field.PointCloud">PointCloud()</a></code>: Points are advected forward, see <code><a title="phi.physics.advect.points" href="#phi.physics.advect.points">points()</a></code>.</li>
<li><code>phi.field.Grid</code>: Sample points are traced backward, see <code><a title="phi.physics.advect.semi_lagrangian" href="#phi.physics.advect.semi_lagrangian">semi_lagrangian()</a></code>.</li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>field</code></strong></dt>
<dd>Field to be advected as <code><a title="phi.field.Field" href="../field/index.html#phi.field.Field">Field</a></code>.</dd>
<dt><strong><code>velocity</code></strong></dt>
<dd>Any <code><a title="phi.field.Field" href="../field/index.html#phi.field.Field">Field</a></code> that can be sampled in the elements of <code>field</code>.</dd>
<dt><strong><code>dt</code></strong></dt>
<dd>Time increment</dd>
<dt><strong><code>integrator</code></strong></dt>
<dd>ODE integrator for solving the movement.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Advected field of same type as <code>field</code></p></div>
</dd>
<dt id="phi.physics.advect.differential"><code class="name flex">
<span>def <span class="ident">differential</span></span>(<span>u: phi.field._field.Field,<br>velocity: phi.field._field.Field,<br>density: float = 1.0,<br>order=2,<br>implicit: phiml.math._optimize.Solve = None,<br>upwind=True) ‑> phi.field._field.Field</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def differential(u: Field,
                 velocity: Field,
                 density: float = 1.,
                 order=2,
                 implicit: Solve = None,
                 upwind=True) -&gt; Field:
    &#34;&#34;&#34;
    Computes the differential advection term using the differentiation Scheme indicated by `order`, ´implicit´ and `upwind`.

    For a velocity field u, the advection term as it appears on the right-hand-side of a PDE is -u·∇u, including the negative sign.

    For unstructured meshes, computes -1/V ∑_f (n·u_prev) u ρ A

    Args:
        u: Scalar or vector-valued `Field` sampled on a `CenteredGrid`, `StaggeredGrid` or `Mesh`.
        velocity: `Field` that can be sampled at the elements of `u`.
            For FVM, the advection term is typically linearized by setting `velocity = previous_velocity`.
            Passing `velocity=u` yields non-linear terms which cannot be traced inside linear functions.
        order: Spatial order of accuracy.
            Higher orders entail larger stencils and more computation time but result in more accurate results assuming a large enough resolution.
            Supported for grids: 2 explicit, 4 explicit, 6 implicit (inherited from `phi.field.spatial_gradient()` and resampling).
            Passing order=4 currently uses 2nd-order resampling. This is work-in-progress.
            For FVM, the order is used when interpolating centroid values to faces if needed.
        implicit: When a `Solve` object is passed, performs an implicit operation with the specified solver and tolerances.
            Otherwise, an explicit stencil is used.
        upwind: Whether to use upwind interpolation. Only supported for FVM at the moment.

    Returns:
        Differential convection term as `Field` on the same geometry.
    &#34;&#34;&#34;
    if u.is_grid and u.is_staggered:
        grad_list = [spatial_gradient(field_component, stack_dim=channel(&#39;grad_dim&#39;), order=order, implicit=implicit) for field_component in u.vector]
        grad_grid = u.with_values(math.stack([component.values for component in grad_list], channel(velocity).as_dual()))
        if order == 4:
            amounts = [grad * vel.at(grad, order=2) for grad, vel in zip(grad_grid.grad_dim, velocity.vector)]  # ToDo resampling does not yet support order=4
        else:
            amounts = [grad * vel.at(grad, order=order, implicit=implicit) for grad, vel in zip(grad_grid.grad_dim, velocity.vector)]
        amount = sum(amounts)
        return u.with_values(- amount)
    elif u.is_grid and u.is_centered:
        grad_tensor = math.stack(
            [spatial_gradient(component, stack_dim=channel(&#39;gradient&#39;), order=order, implicit=implicit).values for
             component in u.vector], dim=channel(&#39;vector&#39;))
        velocity_tensor = math.stack(math.unstack(velocity.values, dim=&#39;vector&#39;), dim=channel(&#39;gradient&#39;))
        amounts = velocity_tensor * grad_tensor
        amount = sum(amounts.gradient)
        return velocity.with_values(- amount)
    elif u.is_mesh:
        u = u.at_faces(boundary=NONE, order=order, upwind=velocity if upwind is True else upwind)
        velocity = velocity.at_faces(boundary=NONE, order=order, upwind=velocity if upwind is True else upwind)
        conv = density * u.mesh.integrate_surface(u.values * (velocity.values.vector @ velocity.face_normals.vector)) / u.mesh.volume
        return Field(u.geometry, -conv, 0)
    raise NotImplementedError(u)</code></pre>
</details>
<div class="desc"><p>Computes the differential advection term using the differentiation Scheme indicated by <code>order</code>, ´implicit´ and <code>upwind</code>.</p>
<p>For a velocity field u, the advection term as it appears on the right-hand-side of a PDE is -u·∇u, including the negative sign.</p>
<p>For unstructured meshes, computes -1/V ∑_f (n·u_prev) u ρ A</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>u</code></strong></dt>
<dd>Scalar or vector-valued <code>Field</code> sampled on a <code>CenteredGrid</code>, <code>StaggeredGrid</code> or <code>Mesh</code>.</dd>
<dt><strong><code>velocity</code></strong></dt>
<dd><code>Field</code> that can be sampled at the elements of <code>u</code>.
For FVM, the advection term is typically linearized by setting <code>velocity = previous_velocity</code>.
Passing <code>velocity=u</code> yields non-linear terms which cannot be traced inside linear functions.</dd>
<dt><strong><code>order</code></strong></dt>
<dd>Spatial order of accuracy.
Higher orders entail larger stencils and more computation time but result in more accurate results assuming a large enough resolution.
Supported for grids: 2 explicit, 4 explicit, 6 implicit (inherited from <code><a title="phi.field.spatial_gradient" href="../field/index.html#phi.field.spatial_gradient">spatial_gradient()</a></code> and resampling).
Passing order=4 currently uses 2nd-order resampling. This is work-in-progress.
For FVM, the order is used when interpolating centroid values to faces if needed.</dd>
<dt><strong><code>implicit</code></strong></dt>
<dd>When a <code>Solve</code> object is passed, performs an implicit operation with the specified solver and tolerances.
Otherwise, an explicit stencil is used.</dd>
<dt><strong><code>upwind</code></strong></dt>
<dd>Whether to use upwind interpolation. Only supported for FVM at the moment.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Differential convection term as <code>Field</code> on the same geometry.</p></div>
</dd>
<dt id="phi.physics.advect.euler"><code class="name flex">
<span>def <span class="ident">euler</span></span>(<span>data: phi.field._field.Field,<br>velocity: phi.field._field.Field,<br>dt: float,<br>v0: phiml.math._tensors.Tensor = None) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def euler(data: Field, velocity: Field, dt: float, v0: Tensor = None) -&gt; Tensor:
    &#34;&#34;&#34; Euler integrator. &#34;&#34;&#34;
    if v0 is None:
        v0 = sample(velocity, data.geometry, at=data.sampled_at, boundary=data.boundary)
    return data.points + v0 * dt</code></pre>
</details>
<div class="desc"><p>Euler integrator.</p></div>
</dd>
<dt id="phi.physics.advect.finite_difference"><code class="name flex">
<span>def <span class="ident">finite_difference</span></span>(<span>u: phi.field._field.Field,<br>velocity: phi.field._field.Field,<br>density: float = 1.0,<br>order=2,<br>implicit: phiml.math._optimize.Solve = None,<br>upwind=True) ‑> phi.field._field.Field</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def differential(u: Field,
                 velocity: Field,
                 density: float = 1.,
                 order=2,
                 implicit: Solve = None,
                 upwind=True) -&gt; Field:
    &#34;&#34;&#34;
    Computes the differential advection term using the differentiation Scheme indicated by `order`, ´implicit´ and `upwind`.

    For a velocity field u, the advection term as it appears on the right-hand-side of a PDE is -u·∇u, including the negative sign.

    For unstructured meshes, computes -1/V ∑_f (n·u_prev) u ρ A

    Args:
        u: Scalar or vector-valued `Field` sampled on a `CenteredGrid`, `StaggeredGrid` or `Mesh`.
        velocity: `Field` that can be sampled at the elements of `u`.
            For FVM, the advection term is typically linearized by setting `velocity = previous_velocity`.
            Passing `velocity=u` yields non-linear terms which cannot be traced inside linear functions.
        order: Spatial order of accuracy.
            Higher orders entail larger stencils and more computation time but result in more accurate results assuming a large enough resolution.
            Supported for grids: 2 explicit, 4 explicit, 6 implicit (inherited from `phi.field.spatial_gradient()` and resampling).
            Passing order=4 currently uses 2nd-order resampling. This is work-in-progress.
            For FVM, the order is used when interpolating centroid values to faces if needed.
        implicit: When a `Solve` object is passed, performs an implicit operation with the specified solver and tolerances.
            Otherwise, an explicit stencil is used.
        upwind: Whether to use upwind interpolation. Only supported for FVM at the moment.

    Returns:
        Differential convection term as `Field` on the same geometry.
    &#34;&#34;&#34;
    if u.is_grid and u.is_staggered:
        grad_list = [spatial_gradient(field_component, stack_dim=channel(&#39;grad_dim&#39;), order=order, implicit=implicit) for field_component in u.vector]
        grad_grid = u.with_values(math.stack([component.values for component in grad_list], channel(velocity).as_dual()))
        if order == 4:
            amounts = [grad * vel.at(grad, order=2) for grad, vel in zip(grad_grid.grad_dim, velocity.vector)]  # ToDo resampling does not yet support order=4
        else:
            amounts = [grad * vel.at(grad, order=order, implicit=implicit) for grad, vel in zip(grad_grid.grad_dim, velocity.vector)]
        amount = sum(amounts)
        return u.with_values(- amount)
    elif u.is_grid and u.is_centered:
        grad_tensor = math.stack(
            [spatial_gradient(component, stack_dim=channel(&#39;gradient&#39;), order=order, implicit=implicit).values for
             component in u.vector], dim=channel(&#39;vector&#39;))
        velocity_tensor = math.stack(math.unstack(velocity.values, dim=&#39;vector&#39;), dim=channel(&#39;gradient&#39;))
        amounts = velocity_tensor * grad_tensor
        amount = sum(amounts.gradient)
        return velocity.with_values(- amount)
    elif u.is_mesh:
        u = u.at_faces(boundary=NONE, order=order, upwind=velocity if upwind is True else upwind)
        velocity = velocity.at_faces(boundary=NONE, order=order, upwind=velocity if upwind is True else upwind)
        conv = density * u.mesh.integrate_surface(u.values * (velocity.values.vector @ velocity.face_normals.vector)) / u.mesh.volume
        return Field(u.geometry, -conv, 0)
    raise NotImplementedError(u)</code></pre>
</details>
<div class="desc"><p>Computes the differential advection term using the differentiation Scheme indicated by <code>order</code>, ´implicit´ and <code>upwind</code>.</p>
<p>For a velocity field u, the advection term as it appears on the right-hand-side of a PDE is -u·∇u, including the negative sign.</p>
<p>For unstructured meshes, computes -1/V ∑_f (n·u_prev) u ρ A</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>u</code></strong></dt>
<dd>Scalar or vector-valued <code>Field</code> sampled on a <code>CenteredGrid</code>, <code>StaggeredGrid</code> or <code>Mesh</code>.</dd>
<dt><strong><code>velocity</code></strong></dt>
<dd><code>Field</code> that can be sampled at the elements of <code>u</code>.
For FVM, the advection term is typically linearized by setting <code>velocity = previous_velocity</code>.
Passing <code>velocity=u</code> yields non-linear terms which cannot be traced inside linear functions.</dd>
<dt><strong><code>order</code></strong></dt>
<dd>Spatial order of accuracy.
Higher orders entail larger stencils and more computation time but result in more accurate results assuming a large enough resolution.
Supported for grids: 2 explicit, 4 explicit, 6 implicit (inherited from <code><a title="phi.field.spatial_gradient" href="../field/index.html#phi.field.spatial_gradient">spatial_gradient()</a></code> and resampling).
Passing order=4 currently uses 2nd-order resampling. This is work-in-progress.
For FVM, the order is used when interpolating centroid values to faces if needed.</dd>
<dt><strong><code>implicit</code></strong></dt>
<dd>When a <code>Solve</code> object is passed, performs an implicit operation with the specified solver and tolerances.
Otherwise, an explicit stencil is used.</dd>
<dt><strong><code>upwind</code></strong></dt>
<dd>Whether to use upwind interpolation. Only supported for FVM at the moment.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Differential convection term as <code>Field</code> on the same geometry.</p></div>
</dd>
<dt id="phi.physics.advect.finite_rk4"><code class="name flex">
<span>def <span class="ident">finite_rk4</span></span>(<span>data: phi.field._field.Field,<br>velocity: phi.field._field.Field,<br>dt: float,<br>v0: phiml.math._tensors.Tensor = None) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def finite_rk4(data: Field, velocity: Grid, dt: float, v0: math.Tensor = None) -&gt; Tensor:
    &#34;&#34;&#34; Runge-Kutta-4 integrator with Euler fallback where velocity values are NaN. &#34;&#34;&#34;
    if v0 is None:
        v0 = sample(velocity, data.geometry, at=data.sampled_at, boundary=data.boundary)
    v_half = sample(velocity, data.points + 0.5 * dt * v0, at=data.sampled_at, boundary=data.boundary)
    v_half2 = sample(velocity, data.points + 0.5 * dt * v_half, at=data.sampled_at, boundary=data.boundary)
    v_full = sample(velocity, data.points + dt * v_half2, at=data.sampled_at, boundary=data.boundary)
    v_rk4 = (1 / 6.) * (v0 + 2 * (v_half + v_half2) + v_full)
    v_nan = math.where(math.is_finite(v_rk4), v_rk4, v0)
    return data.points + dt * v_nan</code></pre>
</details>
<div class="desc"><p>Runge-Kutta-4 integrator with Euler fallback where velocity values are NaN.</p></div>
</dd>
<dt id="phi.physics.advect.mac_cormack"><code class="name flex">
<span>def <span class="ident">mac_cormack</span></span>(<span>field: phi.field._field.Field,<br>velocity: phi.field._field.Field,<br>dt: float,<br>correction_strength=1.0,<br>integrator=&lt;function euler&gt;) ‑> phi.field._field.Field</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mac_cormack(field: Field,
                velocity: Field,
                dt: float,
                correction_strength=1.0,
                integrator=euler) -&gt; Field:
    &#34;&#34;&#34;
    MacCormack advection uses a forward and backward lookup to determine the first-order error of semi-Lagrangian advection.
    It then uses that error estimate to correct the field values.
    To avoid overshoots, the resulting value is bounded by the neighbouring grid cells of the backward lookup.

    Args:
        field: Field to be advected, one of `(CenteredGrid, StaggeredGrid)`
        velocity: Vector field, need not be sampled at same locations as `field`.
        dt: Time increment
        correction_strength: The estimated error is multiplied by this factor before being applied.
            The case correction_strength=0 equals semi-lagrangian advection. Set lower than 1.0 to avoid oscillations.
        integrator: ODE integrator for solving the movement.

    Returns:
        Advected field of type `type(field)`
    &#34;&#34;&#34;
    v0 = sample(velocity, field.geometry, at=field.sampled_at, boundary=field.boundary)
    points_bwd = integrator(field, velocity, -dt, v0=v0)
    points_fwd = integrator(field, velocity, dt, v0=v0)
    # --- forward+backward semi-Lagrangian advection ---
    fwd_adv = field.with_values(reduce_sample(field, points_bwd))
    bwd_adv = field.with_values(reduce_sample(fwd_adv, points_fwd))
    new_field = fwd_adv + correction_strength * 0.5 * (field - bwd_adv)
    # --- Clamp overshoots ---
    limits = field.closest_values(points_bwd)
    lower_limit = math.min(limits, [f&#39;closest_{dim}&#39; for dim in field.shape.spatial.names])
    upper_limit = math.max(limits, [f&#39;closest_{dim}&#39; for dim in field.shape.spatial.names])
    values_clamped = math.clip(new_field.values, lower_limit, upper_limit)
    return new_field.with_values(values_clamped)</code></pre>
</details>
<div class="desc"><p>MacCormack advection uses a forward and backward lookup to determine the first-order error of semi-Lagrangian advection.
It then uses that error estimate to correct the field values.
To avoid overshoots, the resulting value is bounded by the neighbouring grid cells of the backward lookup.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>field</code></strong></dt>
<dd>Field to be advected, one of <code>(CenteredGrid, StaggeredGrid)</code></dd>
<dt><strong><code>velocity</code></strong></dt>
<dd>Vector field, need not be sampled at same locations as <code>field</code>.</dd>
<dt><strong><code>dt</code></strong></dt>
<dd>Time increment</dd>
<dt><strong><code>correction_strength</code></strong></dt>
<dd>The estimated error is multiplied by this factor before being applied.
The case correction_strength=0 equals semi-lagrangian advection. Set lower than 1.0 to avoid oscillations.</dd>
<dt><strong><code>integrator</code></strong></dt>
<dd>ODE integrator for solving the movement.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Advected field of type <code>type(field)</code></p></div>
</dd>
<dt id="phi.physics.advect.points"><code class="name flex">
<span>def <span class="ident">points</span></span>(<span>points: phi.field._field.Field | phi.geom._geom.Geometry | phiml.math._tensors.Tensor,<br>velocity: phi.field._field.Field,<br>dt: float,<br>integrator=&lt;function euler&gt;)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def points(points: Union[Field, Geometry, Tensor], velocity: Field, dt: float, integrator=euler):
    &#34;&#34;&#34;
    Advects the sample points of a point cloud using a simple Euler step.
    Each point moves by an amount equal to the local velocity times `dt`.

    Args:
        points: Points to be advected. Can be provided as position `Tensor`, `Geometry` or `Field`.
        velocity: velocity sampled at the same points as the point cloud
        dt: Euler step time increment
        integrator: ODE integrator for solving the movement.

    Returns:
        Advected points, same type as `points`.
    &#34;&#34;&#34;
    field = points if isinstance(points, Field) else PointCloud(points)
    new_elements = field.geometry.at(integrator(field, velocity, dt))
    result = field.with_elements(new_elements)
    return result if isinstance(points, Field) else (result.geometry if isinstance(points, Geometry) else result.center)</code></pre>
</details>
<div class="desc"><p>Advects the sample points of a point cloud using a simple Euler step.
Each point moves by an amount equal to the local velocity times <code>dt</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>points</code></strong></dt>
<dd>Points to be advected. Can be provided as position <code>Tensor</code>, <code>Geometry</code> or <code>Field</code>.</dd>
<dt><strong><code>velocity</code></strong></dt>
<dd>velocity sampled at the same points as the point cloud</dd>
<dt><strong><code>dt</code></strong></dt>
<dd>Euler step time increment</dd>
<dt><strong><code>integrator</code></strong></dt>
<dd>ODE integrator for solving the movement.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Advected points, same type as <code><a title="phi.physics.advect.points" href="#phi.physics.advect.points">points()</a></code>.</p></div>
</dd>
<dt id="phi.physics.advect.rk4"><code class="name flex">
<span>def <span class="ident">rk4</span></span>(<span>data: phi.field._field.Field,<br>velocity: phi.field._field.Field,<br>dt: float,<br>v0: phiml.math._tensors.Tensor = None) ‑> phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rk4(data: Field, velocity: Field, dt: float, v0: Tensor = None) -&gt; Tensor:
    &#34;&#34;&#34; Runge-Kutta-4 integrator. &#34;&#34;&#34;
    if v0 is None:
        v0 = sample(velocity, data.geometry, at=data.sampled_at, boundary=data.boundary)
    v_half = sample(velocity, data.points + 0.5 * dt * v0, at=data.sampled_at, boundary=data.boundary)
    v_half2 = sample(velocity, data.points + 0.5 * dt * v_half, at=data.sampled_at, boundary=data.boundary)
    v_full = sample(velocity, data.points + dt * v_half2, at=data.sampled_at, boundary=data.boundary)
    v_rk4 = (1 / 6.) * (v0 + 2 * (v_half + v_half2) + v_full)
    return data.points + dt * v_rk4</code></pre>
</details>
<div class="desc"><p>Runge-Kutta-4 integrator.</p></div>
</dd>
<dt id="phi.physics.advect.semi_lagrangian"><code class="name flex">
<span>def <span class="ident">semi_lagrangian</span></span>(<span>field: phi.field._field.Field,<br>velocity: phi.field._field.Field,<br>dt: float,<br>integrator=&lt;function euler&gt;) ‑> phi.field._field.Field</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def semi_lagrangian(field: Field,
                    velocity: Field,
                    dt: float,
                    integrator=euler) -&gt; Field:
    &#34;&#34;&#34;
    Semi-Lagrangian advection with simple backward lookup.
    
    This method samples the `velocity` at the grid points of `field`
    to determine the lookup location for each grid point by walking backwards along the velocity vectors.
    The new values are then determined by sampling `field` at these lookup locations.

    Args:
        field: quantity to be advected, stored on a grid (CenteredGrid or StaggeredGrid)
        velocity: vector field, need not be compatible with with `field`.
        dt: time increment
        integrator: ODE integrator for solving the movement.

    Returns:
        Field with same sample points as `field`

    &#34;&#34;&#34;
    lookup = integrator(field, velocity, -dt)
    interpolated = reduce_sample(field, lookup)
    return field.with_values(interpolated)</code></pre>
</details>
<div class="desc"><p>Semi-Lagrangian advection with simple backward lookup.</p>
<p>This method samples the <code>velocity</code> at the grid points of <code>field</code>
to determine the lookup location for each grid point by walking backwards along the velocity vectors.
The new values are then determined by sampling <code>field</code> at these lookup locations.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>field</code></strong></dt>
<dd>quantity to be advected, stored on a grid (CenteredGrid or StaggeredGrid)</dd>
<dt><strong><code>velocity</code></strong></dt>
<dd>vector field, need not be compatible with with <code>field</code>.</dd>
<dt><strong><code>dt</code></strong></dt>
<dd>time increment</dd>
<dt><strong><code>integrator</code></strong></dt>
<dd>ODE integrator for solving the movement.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Field with same sample points as <code>field</code></p></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="phi.physics" href="index.html">phi.physics</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="phi.physics.advect.advect" href="#phi.physics.advect.advect">advect</a></code></li>
<li><code><a title="phi.physics.advect.differential" href="#phi.physics.advect.differential">differential</a></code></li>
<li><code><a title="phi.physics.advect.euler" href="#phi.physics.advect.euler">euler</a></code></li>
<li><code><a title="phi.physics.advect.finite_difference" href="#phi.physics.advect.finite_difference">finite_difference</a></code></li>
<li><code><a title="phi.physics.advect.finite_rk4" href="#phi.physics.advect.finite_rk4">finite_rk4</a></code></li>
<li><code><a title="phi.physics.advect.mac_cormack" href="#phi.physics.advect.mac_cormack">mac_cormack</a></code></li>
<li><code><a title="phi.physics.advect.points" href="#phi.physics.advect.points">points</a></code></li>
<li><code><a title="phi.physics.advect.rk4" href="#phi.physics.advect.rk4">rk4</a></code></li>
<li><code><a title="phi.physics.advect.semi_lagrangian" href="#phi.physics.advect.semi_lagrangian">semi_lagrangian</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
